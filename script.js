// gemini如果是多个密钥, 那么随机获取一个
    function getRandomValue(str) {
        // 检查字符串是否包含逗号
        if (str.includes(',')) {
            // 用逗号分隔字符串并移除多余空格
            const arr = str.split(',').map(item => item.trim());
            // 生成随机索引 (0 到 arr.length-1)
            const randomIndex = Math.floor(Math.random() * arr.length);
            // 返回随机元素
            return arr[randomIndex];
        }
        // 没有逗号则直接返回原字符串
        return str;
    }

    // ===== PWA Service Worker 注册 =====
    if ('serviceWorker' in navigator) {
        // 检查是否在支持的协议下（http/https）
        const isValidProtocol = window.location.protocol === 'http:' || window.location.protocol === 'https:';
        
        if (isValidProtocol) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js', { scope: './' })
                    .then(registration => {
                        console.log('✅ Service Worker 注册成功:', registration.scope);
                        
                        // 监听 Service Worker 更新
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            console.log('🔄 检测到新版本 Service Worker');
                            
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'activated') {
                                    console.log('✅ 新版本已激活');
                                    // 如果有旧的 Service Worker 在控制页面，提示刷新
                                    if (navigator.serviceWorker.controller) {
                                        console.log('🔄 准备刷新页面以应用更新...');
                                        // 延迟1秒后刷新，给用户一点反应时间
                                        setTimeout(() => {
                                            window.location.reload();
                                        }, 1000);
                                    }
                                }
                            });
                        });
                        
                        // 定期检查更新（每30秒）
                        setInterval(() => {
                            registration.update();
                        }, 30000);
                        
                        // 立即检查一次更新
                        registration.update();
                    })
                    .catch(error => {
                        console.log('❌ Service Worker 注册失败:', error);
                    });
            });
            
            // 监听来自 Service Worker 的消息
            navigator.serviceWorker.addEventListener('message', event => {
                if (event.data && event.data.type === 'SW_UPDATED') {
                    console.log(`🎉 Service Worker 已更新到版本 ${event.data.version}`);
                    // 可以在这里显示一个提示，告诉用户应用已更新
                }
            });
            
            // 监听 Service Worker 控制器变化
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                console.log('🔄 Service Worker 控制器已更改，刷新页面...');
                window.location.reload();
            });
        } else {
            console.log('ℹ️ Service Worker 仅在 http/https 协议下工作（当前: ' + window.location.protocol + '）');
            console.log('ℹ️ 部署到服务器后将自动启用 PWA 功能');
        }
    }

    // ===== PWA 安装提示 =====
    let deferredPrompt;
    const pwaInstallPrompt = document.getElementById('pwa-install-prompt');
    const pwaInstallBtn = document.getElementById('pwa-install-btn');
    const pwaDismissBtn = document.getElementById('pwa-dismiss-btn');

    // 监听beforeinstallprompt事件
    window.addEventListener('beforeinstallprompt', (e) => {
        // 阻止默认的安装提示
        e.preventDefault();
        deferredPrompt = e;
        
        // 检查用户是否之前关闭过提示
        const dismissed = localStorage.getItem('pwa-install-dismissed');
        const dismissedTime = localStorage.getItem('pwa-install-dismissed-time');
        
        // 如果用户关闭过，且距离上次关闭不到7天，则不显示
        if (dismissed && dismissedTime) {
            const daysSinceDismissed = (Date.now() - parseInt(dismissedTime)) / (1000 * 60 * 60 * 24);
            if (daysSinceDismissed < 7) {
                return;
            }
        }
        
        // 延迟3秒后显示安装提示
        setTimeout(() => {
            if (pwaInstallPrompt) {
                pwaInstallPrompt.style.display = 'block';
            }
        }, 3000);
    });

    // 点击安装按钮
    if (pwaInstallBtn) {
        pwaInstallBtn.addEventListener('click', async () => {
            if (!deferredPrompt) {
                // 如果是iOS设备，显示手动安装提示
                if (/iPhone|iPad|iPod/.test(navigator.userAgent)) {
                    alert('📱 iOS安装步骤：\n\n1. 点击底部的"分享"按钮 📤\n2. 选择"添加到主屏幕" ➕\n3. 点击"添加"完成安装 ✅');
                } else {
                    alert('请使用浏览器菜单中的"添加到主屏幕"或"安装应用"选项');
                }
                return;
            }
            
            // 显示安装提示
            deferredPrompt.prompt();
            
            // 等待用户响应
            const { outcome } = await deferredPrompt.userChoice;
            console.log(`用户选择: ${outcome}`);
            
            // 清除deferredPrompt
            deferredPrompt = null;
            
            // 隐藏安装提示
            if (pwaInstallPrompt) {
                pwaInstallPrompt.style.display = 'none';
            }
        });
    }

    // 点击稍后按钮
    if (pwaDismissBtn) {
        pwaDismissBtn.addEventListener('click', () => {
            if (pwaInstallPrompt) {
                pwaInstallPrompt.style.display = 'none';
            }
            // 记录关闭时间
            localStorage.setItem('pwa-install-dismissed', 'true');
            localStorage.setItem('pwa-install-dismissed-time', Date.now().toString());
        });
    }

    // 监听应用安装成功事件
    window.addEventListener('appinstalled', () => {
        console.log('✅ PWA 安装成功！');
        if (pwaInstallPrompt) {
            pwaInstallPrompt.style.display = 'none';
        }
        // 清除关闭记录
        localStorage.removeItem('pwa-install-dismissed');
        localStorage.removeItem('pwa-install-dismissed-time');
    });

    document.addEventListener('DOMContentLoaded', () => {
        // 修复侧边栏定位：把侧边栏移到.phone-screen里面
        const phoneScreenEl = document.querySelector('.phone-screen');
        const chatSettingsSidebarEl = document.getElementById('chat-settings-sidebar');
        const groupSettingsSidebarEl = document.getElementById('group-settings-sidebar');
        
        if (phoneScreenEl && chatSettingsSidebarEl) {
            phoneScreenEl.appendChild(chatSettingsSidebarEl);
        }
        
        if (phoneScreenEl && groupSettingsSidebarEl) {
            phoneScreenEl.appendChild(groupSettingsSidebarEl);
        }
        
        // 图片压缩函数 - 优化版，防止内存溢出
        async function compressImage(file, options = {}) {
            const {
                quality = 0.7,  // 降低默认质量
                maxWidth = 600,  // 降低最大宽度
                maxHeight = 600,  // 降低最大高度
                maxSizeKB = 200  // 新增：最大文件大小限制（KB）
            } = options;

            // 如果文件是GIF动图
            if (file.type === 'image/gif') {
                // 检查GIF大小，如果太大则拒绝
                if (file.size > maxSizeKB * 1024 * 2) {  // GIF允许2倍大小
                    throw new Error(`GIF文件过大（${(file.size / 1024).toFixed(0)}KB），请选择小于${maxSizeKB * 2}KB的文件`);
                }
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            }

            // 对其他静态图片进行压缩
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onerror = reject;
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onerror = reject;
                    img.onload = () => {
                        let width = img.width;
                        let height = img.height;

                        // 计算缩放比例
                        if (width > height) {
                            if (width > maxWidth) {
                                height = Math.round(height * (maxWidth / width));
                                width = maxWidth;
                            }
                        } else {
                            if (height > maxHeight) {
                                width = Math.round(width * (maxHeight / height));
                                height = maxHeight;
                            }
                        }

                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');

                        // PNG图片填充白色背景
                        if (file.type === 'image/png') {
                            ctx.fillStyle = '#FFFFFF';
                            ctx.fillRect(0, 0, width, height);
                        }

                        ctx.drawImage(img, 0, 0, width, height);

                        // 转换为JPEG格式，多次尝试压缩直到满足大小要求
                        let currentQuality = quality;
                        let compressedDataUrl = canvas.toDataURL('image/jpeg', currentQuality);
                        
                        // 如果压缩后仍然太大，继续降低质量
                        while (compressedDataUrl.length > maxSizeKB * 1024 * 1.37 && currentQuality > 0.3) {
                            currentQuality -= 0.1;
                            compressedDataUrl = canvas.toDataURL('image/jpeg', currentQuality);
                        }
                        
                        // 最终检查
                        if (compressedDataUrl.length > maxSizeKB * 1024 * 1.37) {
                            console.warn(`图片压缩后仍然较大: ${(compressedDataUrl.length / 1024).toFixed(0)}KB`);
                        }
                        
                        resolve(compressedDataUrl);
                    };
                };
            });
        }

        // Base64 图片压缩函数
        async function compressBase64Image(base64Data, quality = 0.7) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    try {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);

                        // 转换为 JPEG 格式并压缩
                        const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                        resolve(compressedDataUrl);
                    } catch (error) {
                        reject(error);
                    }
                };
                img.onerror = () => reject(new Error('图片加载失败'));
                img.src = base64Data;
            });
        }

        // --- Initial HTML Injection ---
        document.getElementById('api-settings-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">API 设置</h1></div><div class="placeholder"></div></header><main class="content"><form id="api-form"><div class="form-group"><label for="api-provider">API 服务商</label><select id="api-provider" name="provider"><option value="newapi">NewAPI (自定义)</option><option value="deepseek">DeepSeek</option><option value="claude">Claude</option><option value="gemini">Gemini</option></select></div><div class="form-group"><label for="api-url">API 地址（后缀不用添加/v1）</label><input type="url" id="api-url" name="url" placeholder="选择服务商可自动填写" required></div><div class="form-group"><label for="api-key">密钥 (Key)</label><input type="password" id="api-key" name="key" placeholder="请输入你的API密钥" required></div><button type="button" class="btn btn-secondary" id="fetch-models-btn"><span class="btn-text">点击拉取模型</span><div class="spinner"></div></button><button type="button" class="btn btn-secondary" id="test-connection-btn" style="margin-top: 10px;"><span class="btn-text">测试连通性</span><div class="spinner"></div></button><div class="form-group"><label for="api-model">选择模型</label><select id="api-model" name="model" required><option value="">请先拉取模型列表</option></select></div><button type="submit" class="btn btn-primary" id="save-btn"><span class="btn-text">保 存</span><div class="spinner"></div></button></form><hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"><div style="padding: 0 20px;"><h3 style="font-size: 16px; margin-bottom: 15px; color: #333;">副API设置</h3><p style="font-size: 14px; color: #666; background-color: #fff3cd; padding: 10px; border-radius: 8px; margin-bottom: 15px;">副API用于聊天总结等功能。如果留空，则默认使用主API。</p><div class="form-group"><label for="secondary-api-provider">副API 服务商</label><select id="secondary-api-provider" name="provider"><option value="">-- 不使用副API --</option><option value="newapi">NewAPI (自定义)</option><option value="deepseek">DeepSeek</option><option value="claude">Claude</option><option value="gemini">Gemini</option></select></div><div class="form-group"><label for="secondary-api-url">副API 地址</label><input type="url" id="secondary-api-url" name="url" placeholder="选择服务商可自动填写"></div><div class="form-group"><label for="secondary-api-key">副API 密钥</label><input type="password" id="secondary-api-key" name="key" placeholder="请输入副API密钥"></div><button type="button" class="btn btn-secondary" id="fetch-secondary-models-btn"><span class="btn-text">拉取副API模型</span><div class="spinner"></div></button><div class="form-group" style="margin-top: 10px;"><label for="secondary-api-model">副API 模型</label><select id="secondary-api-model" name="model"><option value="">请先拉取模型列表</option></select></div><button type="button" class="btn btn-primary" id="save-secondary-api-btn" style="margin-bottom: 20px;">保存副API设置</button></div><hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"><div style="padding: 0 20px;"><h3 style="font-size: 16px; margin-bottom: 15px; color: #333;">副API 预设</h3><div class="form-group"><label for="secondary-api-preset-select">选择副API预设</label><select id="secondary-api-preset-select" style="margin-bottom: 10px;"><option value="">-- 选择一个预设 --</option></select></div><div style="display: flex; gap: 10px; margin-bottom: 15px;"><button type="button" class="btn btn-primary" id="save-secondary-preset-btn" style="flex: 1;">保存副API预设</button><button type="button" class="btn btn-danger" id="delete-secondary-preset-btn" style="flex: 1;">删除副API预设</button></div><div id="secondary-preset-list-container" style="max-height: 200px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px; display: none;"><div style="margin-bottom: 10px; display: flex; align-items: center; gap: 10px;"><input type="checkbox" id="select-all-secondary-presets" style="cursor: pointer;"><label for="select-all-secondary-presets" style="cursor: pointer; margin: 0;">全选</label></div><div id="secondary-preset-checkboxes"></div></div></div><hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"><div style="padding: 0 20px;"><h3 style="font-size: 16px; margin-bottom: 15px; color: #333;">Minimax 语音 (TTS) 设置</h3><p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px; margin-bottom: 15px;">用于AI发送语音消息时的真实语音播放</p><div class="form-group"><label for="minimax-group-id">Minimax Group ID</label><input type="text" id="minimax-group-id" placeholder="输入你的 Minimax Group ID"></div><div class="form-group"><label for="minimax-api-key">Minimax API Key</label><input type="password" id="minimax-api-key" placeholder="输入你的 Minimax API Key"></div><div class="form-group"><label for="minimax-voice-id">语音 ID (Voice ID)</label><input type="text" id="minimax-voice-id" placeholder="例如: male-qn-qingse" value="male-qn-qingse"></div><div class="form-group"><label for="minimax-speech-model">语音模型</label><select id="minimax-speech-model"><option value="speech-01">speech-01</option><option value="speech-02">speech-02</option></select></div><button type="button" class="btn btn-primary" id="save-minimax-btn" style="margin-bottom: 20px;">保存 Minimax 设置</button></div><hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"><div style="padding: 0 20px;"><h3 style="font-size: 16px; margin-bottom: 15px; color: #333;">API 预设</h3><div class="form-group"><label for="api-preset-select">选择预设</label><select id="api-preset-select" style="margin-bottom: 10px;"><option value="">-- 选择一个预设 --</option></select></div><div style="display: flex; gap: 10px; margin-bottom: 15px;"><button type="button" class="btn btn-primary" id="save-preset-btn" style="flex: 1;">保存预设</button><button type="button" class="btn btn-danger" id="delete-preset-btn" style="flex: 1;">删除预设</button></div><div id="preset-list-container" style="max-height: 200px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px; display: none;"><div style="margin-bottom: 10px; display: flex; align-items: center; gap: 10px;"><input type="checkbox" id="select-all-presets" style="cursor: pointer;"><label for="select-all-presets" style="cursor: pointer; margin: 0;">全选</label></div><div id="preset-checkboxes"></div></div></div></main>`;
        document.getElementById('wallpaper-screen').innerHTML = `
            <header class="app-header">
                <button class="back-btn" data-target="home-screen">‹</button>
                <div class="title-container"><h1 class="title">更换壁纸</h1></div>
                <div class="placeholder"></div>
            </header>
            <main class="content">
                <!-- 主屏幕壁纸 -->
                <h3 style="font-size: 16px; margin-bottom: 15px; color: #333;">主屏幕壁纸</h3>
                <div class="wallpaper-preview" id="wallpaper-preview"><span>当前壁纸预览</span></div>
                <input type="file" id="wallpaper-upload" accept="image/*" style="display: none;">
                <label for="wallpaper-upload" class="btn btn-primary">从相册选择新壁纸</label>
                <button type="button" class="btn btn-danger" id="reset-wallpaper-btn" style="margin-top: 10px; width: 100%;">重置壁纸</button>
                <div class="form-group" style="margin-top: 20px;">
                    <label for="wallpaper-url-input">或通过URL上传</label>
                    <input type="url" id="wallpaper-url-input" placeholder="输入壁纸图片URL" style="margin-bottom: 10px;">
                    <button type="button" class="btn btn-secondary" id="wallpaper-url-btn">通过URL上传壁纸</button>
                </div>
                
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                
                <!-- 锁屏壁纸 -->
                <h3 style="font-size: 16px; margin-bottom: 15px; color: #333;">锁屏壁纸</h3>
                <div class="wallpaper-preview" id="lock-wallpaper-preview"><span>锁屏壁纸预览</span></div>
                <input type="file" id="lock-wallpaper-upload" accept="image/*" style="display: none;">
                <label for="lock-wallpaper-upload" class="btn btn-primary">从相册选择锁屏壁纸</label>
                <button type="button" class="btn btn-danger" id="reset-lock-wallpaper-btn" style="margin-top: 10px; width: 100%;">重置锁屏壁纸</button>
                <div class="form-group" style="margin-top: 20px;">
                    <label for="lock-wallpaper-url-input">或通过URL上传</label>
                    <input type="url" id="lock-wallpaper-url-input" placeholder="输入锁屏壁纸图片URL" style="margin-bottom: 10px;">
                    <button type="button" class="btn btn-secondary" id="lock-wallpaper-url-btn">通过URL上传锁屏壁纸</button>
                </div>
                
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                
                <!-- 全局聊天背景 -->
                <h3 style="font-size: 16px; margin-bottom: 15px; color: #333;">全局聊天背景</h3>
                <p style="font-size: 14px; color: #666; background-color: #fff3cd; padding: 10px; border-radius: 8px; margin-bottom: 15px;">设置后将应用于所有角色和群聊的聊天背景，无需逐个更换</p>
                <div class="wallpaper-preview" id="global-chat-bg-preview"><span>全局聊天背景预览</span></div>
                <input type="file" id="global-chat-bg-upload" accept="image/*" style="display: none;">
                <label for="global-chat-bg-upload" class="btn btn-primary">从相册选择聊天背景</label>
                <button type="button" class="btn btn-danger" id="reset-global-chat-bg-btn" style="margin-top: 10px; width: 100%;">重置聊天背景</button>
                <div class="form-group" style="margin-top: 20px;">
                    <label for="global-chat-bg-url-input">或通过URL上传</label>
                    <input type="url" id="global-chat-bg-url-input" placeholder="输入聊天背景图片URL" style="margin-bottom: 10px;">
                    <button type="button" class="btn btn-secondary" id="global-chat-bg-url-btn">通过URL上传聊天背景</button>
                </div>
                
                <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                
                <!-- 壁纸库 -->
                <div style="padding: 0 20px;">
                    <h3 style="font-size: 16px; margin-bottom: 15px; color: #333;">壁纸库</h3>
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <button type="button" class="btn btn-primary" id="add-to-library-btn" style="flex: 1;">添加到壁纸库</button>
                        <button type="button" class="btn btn-danger" id="manage-library-btn" style="flex: 1;">管理壁纸库</button>
                    </div>
                    <div id="wallpaper-library-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 15px;"></div>
                    <div id="wallpaper-library-manage" style="display: none;">
                        <div style="margin-bottom: 10px; display: flex; align-items: center; gap: 10px;">
                            <input type="checkbox" id="select-all-wallpapers" style="cursor: pointer;">
                            <label for="select-all-wallpapers" style="cursor: pointer; margin: 0;">全选</label>
                        </div>
                        <div id="wallpaper-library-checkboxes"></div>
                        <button type="button" class="btn btn-danger" id="delete-wallpapers-btn" style="margin-top: 10px; width: 100%;">删除选中的壁纸</button>
                    </div>
                </div>
            </main>
        `;
        document.getElementById('font-settings-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">字体设置</h1></div><div class="placeholder"></div></header><main class="content"><form id="font-settings-form"><div class="form-group"><label for="font-url">字体链接 (ttf, woff, woff2)</label><input type="url" id="font-url" placeholder="https://.../font.ttf"></div><p style="font-size:12px; color:#888; text-align:center;">示例: https://lf3-static.bytednsdoc.com/obj/eden-cn/jplptk/ljhwZthlaukjlkulzlp/portal/fonts/HarmonyOS_Sans_SC_Regular.woff2</p><button type="submit" class="btn btn-primary">应用字体链接</button><hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"><div class="form-group"><label>本地上传字体</label><input type="file" id="font-file-upload" accept=".ttf,.otf,.woff,.woff2" style="display:none;"><label for="font-file-upload" class="btn btn-secondary" style="width: 100%; margin-top: 10px;">从本地选择字体文件</label><p id="font-file-name" style="font-size:12px; color:#888; text-align:center; margin-top:10px; min-height:18px;"></p></div><button type="button" class="btn btn-neutral" id="restore-default-font-btn" style="margin-top: 15px;">恢复默认字体</button></form><hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"><div style="padding: 0 20px;"><h3 style="font-size: 16px; margin-bottom: 15px; color: #333;">字体大小</h3><div class="form-group" style="margin-bottom: 20px;"><label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;"><span>调整字体大小</span><div style="display: flex; align-items: center; gap: 10px;"><span id="font-size-value" style="color: var(--primary-color); font-weight: 600;">16px</span><button type="button" id="reset-font-size-btn" style="background: var(--secondary-color); color: white; border: none; padding: 4px 12px; border-radius: 5px; cursor: pointer; font-size: 12px;">重置</button></div></label><input type="range" id="font-size-slider" min="12" max="24" value="16" step="1" style="width: 100%; cursor: pointer;"></div></div><hr style="border:none; border-top:1px solid #eee; margin: 20px 0;"><div style="padding: 0 20px;"><h3 style="font-size: 16px; margin-bottom: 15px; color: #333;">字体库</h3><div style="display: flex; gap: 10px; margin-bottom: 15px;"><input type="file" id="font-batch-upload" accept=".ttf,.otf,.woff,.woff2" multiple style="display:none;"><label for="font-batch-upload" class="btn btn-primary" style="flex: 1;">批量导入字体</label><button type="button" class="btn btn-danger" id="manage-font-library-btn" style="flex: 1;">管理字体库</button></div><div id="font-library-grid" style="display: grid; grid-template-columns: repeat(1, 1fr); gap: 10px; margin-bottom: 15px;"></div><div id="font-library-manage" style="display: none;"><div style="margin-bottom: 10px; display: flex; align-items: center; gap: 10px;"><input type="checkbox" id="select-all-fonts" style="cursor: pointer;"><label for="select-all-fonts" style="cursor: pointer; margin: 0;">全选</label></div><div id="font-library-checkboxes"></div><button type="button" class="btn btn-danger" id="delete-fonts-btn" style="margin-top: 10px; width: 100%;">删除选中的字体</button></div></div></main>`;
        document.getElementById('customize-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">主屏幕自定义</h1></div><div class="placeholder"></div></header><main class="content"><form id="customize-form"></form></main>`;
        document.getElementById('tutorial-screen').innerHTML = `<header class="app-header"><button class="back-btn" data-target="home-screen">‹</button><div class="title-container"><h1 class="title">教程</h1></div><div class="placeholder"></div></header><main class="content" id="tutorial-content-area"></main>`;

        // --- Global Variables and Constants ---
        const colorThemes = {
            'white_pink': {
                name: '白/粉',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(255,204,204,0.9)', text: '#A56767'}
            },
            'white_blue': {
                name: '白/蓝',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(173,216,230,0.9)', text: '#4A6F8A'}
            },
            'white_yellow': {
                name: '白/黄',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(249,237,105,0.9)', text: '#8B7E4B'}
            },
            'white_green': {
                name: '白/绿',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(188,238,188,0.9)', text: '#4F784F'}
            },
            'white_purple': {
                name: '白/紫',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(185,190,240,0.9)', text: '#6C5B7B'}
            },
            'black_red': {
                name: '黑/红',
                received: {bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0'},
                sent: {bg: 'rgb(226,62,87,0.9)', text: '#fff'}
            },
            'black_green': {
                name: '黑/绿',
                received: {bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0'},
                sent: {bg: 'rgba(119,221,119,0.9)', text: '#2E5C2E'}
            },
            'black_white': {
                name: '黑/白',
                received: {bg: 'rgba(30,30,30,0.85)', text: '#E0E0E0'},
                sent: {bg: 'rgba(245,245,245,0.9)', text: '#333'}
            },
            'white_black': {
                name: '白/黑',
                received: {bg: 'rgba(255,255,255,0.9)', text: '#6D6D6D'},
                sent: {bg: 'rgba(50,50,50,0.85)', text: '#F5F5F5'}
            },
            'yellow_purple': {
                name: '黄/紫',
                received: {bg: 'rgba(255,250,205,0.9)', text: '#8B7E4B'},
                sent: {bg: 'rgba(185,190,240,0.9)', text: '#6C5B7B'}
            },
            'pink_blue': {
                name: '粉/蓝',
                received: {bg: 'rgba(255,231,240,0.9)', text: '#7C6770'},
                sent: {bg: 'rgba(173,216,230,0.9)', text: '#4A6F8A'}
            },
        };
        const defaultIcons = {
            'chat-list-screen': {name: '404', url: 'https://i.postimg.cc/VvQB8dQT/chan-143.png'},
            'api-settings-screen': {name: 'api', url: 'https://i.postimg.cc/50FqT8GL/chan-125.png'},
            'wallpaper-screen': {name: '壁纸', url: 'https://i.postimg.cc/3wqFttL3/chan-90.png'},
            'world-book-screen': {name: '世界书', url: 'https://i.postimg.cc/prCWkrKT/chan-74.png'},
            'customize-screen': {name: '自定义', url: 'https://i.postimg.cc/vZVdC7gt/chan-133.png'},
            'font-settings-screen': {name: '字体', url: 'https://i.postimg.cc/FzVtC0x4/chan-21.png'},
            'tutorial-screen': {name: '教程', url: 'https://i.postimg.cc/6QgNzCFf/chan-118.png'},
            'day-mode-btn': {name: '', url: 'https://i.postimg.cc/Jz0tYqnT/chan-145.png'},
            'night-mode-btn': {name: '', url: 'https://i.postimg.cc/htYvkdQK/chan-146.png'}
        };

        // 头像框数据（完整版）
        const avatarFrames = [{ id: 'none', url: '', name: '无' }, { id: 'frame_1', url: 'https://i.postimg.cc/fLDnz5Pn/IMG-5574.gif', name: '1' }, { id: 'frame_2', url: 'https://i.postimg.cc/HxH3cNHz/IMG-6871.gif', name: '2' }, { id: 'frame_3', url: 'https://i.postimg.cc/jCVK0fGL/IMG-6890.gif', name: '3' }, { id: 'frame_4', url: 'https://i.postimg.cc/85Zsyjwn/IMG-6895.gif', name: '4' }, { id: 'frame_5', url: 'https://i.postimg.cc/cJtpZCB3/IMG-6894.gif', name: '5' }, { id: 'frame_6', url: 'https://i.postimg.cc/63sDQKMm/IMG-6893.gif', name: '6' }, { id: 'frame_7', url: 'https://i.postimg.cc/cHQPgzj4/IMG-6888.gif', name: '7' }, { id: 'frame_8', url: 'https://i.postimg.cc/dVLXm3Xf/IMG-6885.gif', name: '8' }, { id: 'frame_9', url: 'https://i.postimg.cc/kGsZwbq0/IMG-6886.gif', name: '9' }, { id: 'frame_10', url: 'https://i.postimg.cc/63NmX03s/IMG-4366.gif', name: '10' }, { id: 'frame_11', url: 'https://i.postimg.cc/zvz2LGK0/IMG-4367.gif', name: '11' }, { id: 'frame_12', url: 'https://i.postimg.cc/prsGKMBx/IMG-4370.gif', name: '12' }, { id: 'frame_13', url: 'https://i.postimg.cc/gk0BmrY0/IMG-4371.gif', name: '13' }, { id: 'frame_14', url: 'https://i.postimg.cc/fRt2SFSn/IMG-4368.gif', name: '14' }, { id: 'frame_15', url: 'https://i.postimg.cc/kGgwJhPH/IMG-4374.gif', name: '15' }, { id: 'frame_16', url: 'https://i.postimg.cc/PrcKH436/IMG-4376.gif', name: '16' }, { id: 'frame_17', url: 'https://i.postimg.cc/fRV86FMq/IMG-4381.gif', name: '17' }, { id: 'frame_18', url: 'https://i.postimg.cc/HsyqMVyk/IMG-4385.gif', name: '18' }, { id: 'frame_19', url: 'https://i.postimg.cc/qBbKK7dS/IMG-4386.gif', name: '19' }, { id: 'frame_20', url: 'https://i.postimg.cc/05wnd389/IMG-4388.gif', name: '20' }, { id: 'frame_21', url: 'https://i.postimg.cc/RZNLhbbr/IMG-4389.gif', name: '21' }, { id: 'frame_22', url: 'https://i.postimg.cc/fLTc42dg/IMG-4391.gif', name: '22' }, { id: 'frame_23', url: 'https://i.postimg.cc/FzbGNdRT/IMG-4392.gif', name: '23' }, { id: 'frame_24', url: 'https://i.postimg.cc/XY63sTS3/IMG-4393.gif', name: '24' }, { id: 'frame_25', url: 'https://i.postimg.cc/Cx9vCVWH/IMG-4395.gif', name: '25' }, { id: 'frame_26', url: 'https://i.postimg.cc/kMfPQBwQ/IMG-4396.gif', name: '26' }, { id: 'frame_27', url: 'https://i.postimg.cc/CLrZQMMD/IMG-4398.gif', name: '27' }, { id: 'frame_28', url: 'https://i.postimg.cc/L4zwDhTC/IMG-4399.gif', name: '28' }, { id: 'frame_29', url: 'https://i.postimg.cc/yN3s8szM/IMG-4400.gif', name: '29' }, { id: 'frame_30', url: 'https://i.postimg.cc/59Cn1tkB/IMG-4401.gif', name: '30' }, { id: 'frame_31', url: 'https://i.postimg.cc/g0s1V0PX/IMG-4402.gif', name: '31' }, { id: 'frame_32', url: 'https://i.postimg.cc/Jn1DFPgY/IMG-4403.gif', name: '32' }, { id: 'frame_33', url: 'https://i.postimg.cc/q7cQnDy1/IMG-4404.gif', name: '33' }, { id: 'frame_34', url: 'https://i.postimg.cc/RFK3q2t0/IMG-4407.gif', name: '34' }, { id: 'frame_35', url: 'https://i.postimg.cc/gcV0VR2t/IMG-4408.gif', name: '35' }, { id: 'frame_36', url: 'https://i.postimg.cc/W1CjLb4J/IMG-4409.gif', name: '36' }, { id: 'frame_37', url: 'https://i.postimg.cc/Ss7pM6fW/IMG-4410.gif', name: '37' }, { id: 'frame_38', url: 'https://i.postimg.cc/nrFfYX3N/IMG-4412.gif', name: '38' }, { id: 'frame_39', url: 'https://i.postimg.cc/cHWp0KG6/IMG-4413.gif', name: '39' }, { id: 'frame_40', url: 'https://i.postimg.cc/4yNjHrdg/IMG-4414.gif', name: '40' }, { id: 'frame_41', url: 'https://i.postimg.cc/hPX5F8Qp/IMG-4415.gif', name: '41' }, { id: 'frame_42', url: 'https://i.postimg.cc/vHCSG1WM/IMG-4416.gif', name: '42' }, { id: 'frame_43', url: 'https://i.postimg.cc/x1Hp80Rm/IMG-4417.gif', name: '43' }, { id: 'frame_44', url: 'https://i.postimg.cc/FHRcCGfH/IMG-4418.gif', name: '44' }, { id: 'frame_45', url: 'https://i.postimg.cc/13hhJ77p/IMG-4419.gif', name: '45' }, { id: 'frame_46', url: 'https://i.postimg.cc/J4WCQd2j/IMG-4420.gif', name: '46' }, { id: 'frame_47', url: 'https://i.postimg.cc/Dydkpd9H/IMG-4421.gif', name: '47' }, { id: 'frame_48', url: 'https://i.postimg.cc/mrkvDxPW/IMG-4422.gif', name: '48' }, { id: 'frame_49', url: 'https://i.postimg.cc/76Tj3g1B/IMG-4425.gif', name: '49' }, { id: 'frame_50', url: 'https://i.postimg.cc/3N5Vndn3/IMG-4426.gif', name: '50' }, { id: 'frame_51', url: 'https://i.postimg.cc/05DLr0yj/IMG-4427.gif', name: '51' }, { id: 'frame_52', url: 'https://i.postimg.cc/GhR6DT4Q/IMG-4428.gif', name: '52' }, { id: 'frame_53', url: 'https://i.postimg.cc/fRTF24jS/IMG-4430.gif', name: '53' }, { id: 'frame_54', url: 'https://i.postimg.cc/R0WYmcYM/IMG-4431.gif', name: '54' }, { id: 'frame_55', url: 'https://i.postimg.cc/nrJSqNhz/IMG-4432.gif', name: '55' }, { id: 'frame_56', url: 'https://i.postimg.cc/tC9mJ0cv/IMG-4438.gif', name: '56' }, { id: 'frame_57', url: 'https://i.postimg.cc/XNkQTHvf/IMG-5561.gif', name: '57' }, { id: 'frame_58', url: 'https://i.postimg.cc/Mpv5fzm5/IMG-4439.gif', name: '58' }, { id: 'frame_59', url: 'https://i.postimg.cc/T1tjhsyB/IMG-4720.gif', name: '59' }, { id: 'frame_60', url: 'https://i.postimg.cc/c4JMPd2W/IMG-4724.gif', name: '60' }, { id: 'frame_61', url: 'https://i.postimg.cc/g2XykNGB/IMG-4727.gif', name: '61' }, { id: 'frame_62', url: 'https://i.postimg.cc/y8MmJcd6/IMG-4728.gif', name: '62' }, { id: 'frame_63', url: 'https://i.postimg.cc/Lsjzj5Yt/IMG-4729.gif', name: '63' }, { id: 'frame_64', url: 'https://i.postimg.cc/bNdk33SN/IMG-4893.gif', name: '64' }, { id: 'frame_65', url: 'https://i.postimg.cc/4x9tTy1D/IMG-5563.gif', name: '65' }, { id: 'frame_66', url: 'https://i.postimg.cc/DZshzKv6/IMG-5576.gif', name: '66' }, { id: 'frame_67', url: 'https://i.postimg.cc/Fsvr71JL/IMG-5573.gif', name: '67' }, { id: 'frame_68', url: 'https://i.postimg.cc/Fz3HwLk9/IMG-5569.gif', name: '68' }, { id: 'frame_69', url: 'https://i.postimg.cc/wjH180kn/IMG-5566.gif', name: '69' }, { id: 'frame_70', url: 'https://i.postimg.cc/MG6qtLYK/IMG-5565.gif', name: '70' }, { id: 'frame_71', url: 'https://i.postimg.cc/CKgDNYVb/IMG-5577.gif', name: '71' }, { id: 'frame_72', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '72' }, { id: 'frame_73', url: 'https://i.postimg.cc/C5XnfpNB/IMG-5579.gif', name: '73' }, { id: 'frame_74', url: 'https://i.postimg.cc/4y7mGFgJ/IMG-5716.gif', name: '74' }, { id: 'frame_75', url: 'https://i.postimg.cc/FzM1Hgr0/IMG-5717.gif', name: '75' }, { id: 'frame_76', url: 'https://i.postimg.cc/rF4KYbjj/IMG-5720.gif', name: '76' }, { id: 'frame_77', url: 'https://i.postimg.cc/6pLTBvDG/IMG-5721.gif', name: '77' }, { id: 'frame_78', url: 'https://i.postimg.cc/VNK6Ccsf/IMG-5722.gif', name: '78' }, { id: 'frame_79', url: 'https://i.postimg.cc/wx72fhr2/IMG-5968.gif', name: '79' }, { id: 'frame_80', url: 'https://i.postimg.cc/QdrqdvdY/IMG-5969.gif', name: '80' }, { id: 'frame_81', url: 'https://i.postimg.cc/0yd0MZ6k/IMG-5971.gif', name: '81' }, { id: 'frame_82', url: 'https://i.postimg.cc/1zmcp66p/IMG-5973.gif', name: '82' }, { id: 'frame_83', url: 'https://i.postimg.cc/wBw5Fvcn/IMG-5974.gif', name: '83' }, { id: 'frame_84', url: 'https://i.postimg.cc/R0pfKYvB/IMG-5976.gif', name: '84' }, { id: 'frame_85', url: 'https://i.postimg.cc/9fQZ425b/IMG-5975.gif', name: '85' }, { id: 'frame_86', url: 'https://i.postimg.cc/v8V9xXjJ/IMG-6137.gif', name: '86' }, { id: 'frame_87', url: 'https://i.postimg.cc/WbmkXzsS/IMG-6138.gif', name: '87' }, { id: 'frame_88', url: 'https://i.postimg.cc/Dw2bDhZh/IMG-6140.gif', name: '88' }, { id: 'frame_89', url: 'https://i.postimg.cc/ZqQBCyLY/IMG-6144.gif', name: '89' }, { id: 'frame_90', url: 'https://i.postimg.cc/qRCtnMms/IMG-6145.gif', name: '90' }, { id: 'frame_91', url: 'https://i.postimg.cc/1Rwn3XVP/IMG-6146.gif', name: '91' }, { id: 'frame_92', url: 'https://i.postimg.cc/Kv51tW5H/IMG-6147.gif', name: '92' }, { id: 'frame_93', url: 'https://i.postimg.cc/nhcC21Rc/IMG-6148.gif', name: '93' }, { id: 'frame_94', url: 'https://i.postimg.cc/fTWzQRx8/IMG-6149.gif', name: '94' }, { id: 'frame_95', url: 'https://i.postimg.cc/LXyyqDbY/IMG-6294.gif', name: '95' }, { id: 'frame_96', url: 'https://i.postimg.cc/7Zgm1wRy/IMG-6295.gif', name: '96' }, { id: 'frame_97', url: 'https://i.postimg.cc/5tbpnDcQ/IMG-6296.gif', name: '97' }, { id: 'frame_98', url: 'https://i.postimg.cc/YSRRV8kn/IMG-6297.gif', name: '98' }, { id: 'frame_99', url: 'https://i.postimg.cc/k45sd8gn/IMG-6375.gif', name: '99' }, { id: 'frame_100', url: 'https://i.postimg.cc/50k390X8/IMG-6376.gif', name: '100' }];

        let db = {
            characters: [],
            groups: [],
            apiSettings: {},
            apiPresets: [],
            minimaxConfig: {
                groupId: '',
                apiKey: '',
                voiceId: 'male-qn-qingse',
                speechModel: 'speech-01'
            },
            minimaxPresets: [],
            novelaiConfig: {
                enabled: false,
                model: 'nai-diffusion-4-5-full',
                apiKey: '',
                resolution: '1024x1024',
                steps: 28,
                cfgScale: 5,
                sampler: 'k_euler_ancestral',
                seed: -1,
                ucPreset: 1,
                qualityToggle: true,
                smea: true,
                smeaDyn: false,
                defaultPositive: 'masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style',
                defaultNegative: 'lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry'
            },
            wallpaper: 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg',
            wallpaperLibrary: [],
            homeScreenBg: '', // 主屏幕背景（如果设置了，会覆盖wallpaper）
            lockScreenBg: '', // 锁屏壁纸
            globalChatBg: '', // 全局聊天背景（应用于所有角色和群聊）
            enableLockScreen: false, // 是否启用锁屏
            lockScreenPassword: { // 锁屏密码设置
                type: 'none', // 'none', 'pin', 'gesture'
                pin: '', // 数字密码
                gesture: [] // 手势密码路径
            },
            myStickers: [],
            stickerCategories: [],
            avatarLibrary: [],
            myAvatarLibrary: [],
            avatarBindings: [], // 情头绑定数据：[{id, charAvatarId, myAvatarId, remark, createdAt}]
            homeScreenMode: 'night',
            worldBooks: [],
            worldBookGroups: [],
            fontUrl: '',
            fontLibrary: [],
            fontSize: 16,
            simplePromptMode: false, // 简洁模式开关，默认关闭
            simplePromptFeatures: { // 简洁模式下启用的功能模块
                innerThought: true,
                music: true,
                avatar: true,
                npc: true,
                offlineMode: true,
                mountChat: true,
                recognizeAvatar: true,
                timeAwareness: true
            },
            messageCountMin: 1, // 最少消息数量，默认1条
            messageCountMax: 20, // 最多消息数量，默认20条
            customIcons: {},
            customIconNames: {},
            homeScreenPresets: [],
            showDockAppNames: false,
            showStatusBar: false,
            themePresets: [],
            bubbleStylePresets: [],
            personaPresets: [],
            deletedCharacterIds: [],
            deletedGroupIds: [],
            pageEffects: {
                masterEnabled: false,
                snowEnabled: false,
                snowAutoTrigger: false,
                snowDuration: 30,
                snowSpeed: 3,
                snowColor: '#ffffff',
                customEffect: '',
                customAutoTrigger: false,
                customDuration: 30,
                customSpeed: 3
            },
            effectPresets: [],
            musicPlaylist: [],
            showSecondsInTime: false,
            customTimeFormat: '{HH}:{MM}:{SS}',
            floatingLyricsSettings: {
                activeFontSize: 18,
                otherFontSize: 13,
                linesCount: 3,
                activeColor: '#ff80ab',
                previousColor: '#787878',
                upcomingColor: '#787878',
                lineGap: 8
            }
        };
        let currentChatId = null, currentChatType = null, isGenerating = false, currentAbortController = null, longPressTimer = null,
            isInMultiSelectMode = false, editingMessageId = null, currentPage = 1, currentTransferMessageId = null,
            currentEditingWorldBookId = null, currentStickerActionTarget = null,
            currentGroupAction = {type: null, recipients: []},
            isStickerManageMode = false, selectedStickerIds = new Set(),
            currentWbGroupFilter = '';
        let selectedMessageIds = new Set();
        let activeMessageId = null;
        let currentReplyContext = null;
        const MESSAGES_PER_PAGE = 20; // 【性能优化】从50减少到20，避免一次性渲染过多消息导致闪退
        let waimaiTimers = {}; // 用于存储外卖倒计时
        let simulationIntervalId = null; // 后台活动定时器ID
        
        // 音乐播放器状态
        let musicState = {
            isActive: false,
            activeChatId: null,
            isPlaying: false,
            playlist: [],
            currentIndex: -1,
            playMode: 'order',
            totalElapsedTime: 0,
            timerId: null,
            parsedLyrics: [],
            currentLyricIndex: -1,
            timeDisplayUnit: 'hours' // 'hours' 或 'minutes'
        };
        const audioPlayer = document.getElementById('audio-player');

        // --- DOM Element Cache ---
        const screens = document.querySelectorAll('.screen'),
            toastElement = document.getElementById('toast-notification'),
            homeScreen = document.getElementById('home-screen'),
            chatListContainer = document.getElementById('chat-list-container'),
            noChatsPlaceholder = document.getElementById('no-chats-placeholder'),
            addChatBtn = document.getElementById('add-chat-btn'),
            addCharModal = document.getElementById('add-char-modal'),
            addCharForm = document.getElementById('add-char-form'),
            chatRoomScreen = document.getElementById('chat-room-screen'),
            chatRoomHeaderDefault = document.getElementById('chat-room-header-default'),
            chatRoomHeaderSelect = document.getElementById('chat-room-header-select'),
            cancelMultiSelectBtn = document.getElementById('cancel-multi-select-btn'),
            multiSelectTitle = document.getElementById('multi-select-title'),
            chatRoomTitle = document.getElementById('chat-room-title'),
            chatRoomStatusText = document.getElementById('chat-room-status-text'),
            messageArea = document.getElementById('message-area'),
            messageInputDefault = document.getElementById('message-input-default'),
            messageInput = document.getElementById('message-input'),
            sendMessageBtn = document.getElementById('send-message-btn'),
            getReplyBtn = document.getElementById('get-reply-btn'),
            typingIndicator = document.getElementById('typing-indicator'),
            chatSettingsBtn = document.getElementById('chat-settings-btn'),
            settingsSidebar = document.getElementById('chat-settings-sidebar'),
            settingsForm = document.getElementById('chat-settings-form'),
            multiSelectBar = document.getElementById('multi-select-bar'),
            selectCount = document.getElementById('select-count'),
            deleteSelectedBtn = document.getElementById('delete-selected-btn');
        const stickerToggleBtn = document.getElementById('sticker-toggle-btn'),
            stickerModal = document.getElementById('sticker-modal'),
            stickerGridContainer = document.getElementById('sticker-grid-container'),
            addNewStickerBtn = document.getElementById('add-new-sticker-btn'),
            addStickerModal = document.getElementById('add-sticker-modal'),
            addStickerModalTitle = document.getElementById('add-sticker-modal-title'),
            addStickerForm = document.getElementById('add-sticker-form'),
            stickerEditIdInput = document.getElementById('sticker-edit-id'),
            stickerPreview = document.getElementById('sticker-preview'),
            stickerNameInput = document.getElementById('sticker-name'),
            stickerUrlInput = document.getElementById('sticker-url-input'),
            stickerFileUpload = document.getElementById('sticker-file-upload'),
            stickerCategorySelect = document.getElementById('sticker-category-select'),
            currentStickerCategory = document.getElementById('current-sticker-category');
        const stickerActionSheet = document.getElementById('sticker-actionsheet'),
            editStickerBtn = document.getElementById('edit-sticker-btn'),
            deleteStickerBtn = document.getElementById('delete-sticker-btn');
        const stickerCategoryBtn = document.getElementById('sticker-category-btn'),
            stickerCategoryModal = document.getElementById('sticker-category-modal'),
            newCategoryNameInput = document.getElementById('new-category-name'),
            createCategoryBtn = document.getElementById('create-category-btn'),
            categoryList = document.getElementById('category-list'),
            closeCategoryModalBtn = document.getElementById('close-category-modal-btn');
        const categoryDetailModal = document.getElementById('category-detail-modal'),
            categoryDetailTitle = document.getElementById('category-detail-title'),
            categoryDetailGrid = document.getElementById('category-detail-grid'),
            deleteCategoryBtn = document.getElementById('delete-category-btn'),
            closeCategoryDetailBtn = document.getElementById('close-category-detail-btn');
        const batchStickerCategorySelect = document.getElementById('batch-sticker-category-select'),
            batchStickerCategorySelectLocal = document.getElementById('batch-sticker-category-select-local');
        const voiceMessageBtn = document.getElementById('voice-message-btn'),
            sendVoiceModal = document.getElementById('send-voice-modal'),
            sendVoiceForm = document.getElementById('send-voice-form'),
            voiceTextInput = document.getElementById('voice-text-input'),
            voiceDurationPreview = document.getElementById('voice-duration-preview');
        const photoVideoBtn = document.getElementById('photo-video-btn'),
            sendPvModal = document.getElementById('send-pv-modal'),
            sendPvForm = document.getElementById('send-pv-form'),
            pvTextInput = document.getElementById('pv-text-input');
        const imageRecognitionBtn = document.getElementById('image-recognition-btn'),
            imageUploadInput = document.getElementById('image-upload-input'),
            cameraCaptureBtn = document.getElementById('camera-capture-btn'),
            cameraCaptureInput = document.getElementById('camera-capture-input');
        const walletBtn = document.getElementById('wallet-btn'),
            sendTransferModal = document.getElementById('send-transfer-modal'),
            sendTransferForm = document.getElementById('send-transfer-form'),
            transferAmountInput = document.getElementById('transfer-amount-input'),
            transferRemarkInput = document.getElementById('transfer-remark-input');
        const receiveTransferActionSheet = document.getElementById('receive-transfer-actionsheet'),
            acceptTransferBtn = document.getElementById('accept-transfer-btn'),
            returnTransferBtn = document.getElementById('return-transfer-btn'),
            viewTransferRemarkBtn = document.getElementById('view-transfer-remark-btn');
        const giftBtn = document.getElementById('gift-btn'), sendGiftModal = document.getElementById('send-gift-modal'),
            sendGiftForm = document.getElementById('send-gift-form'),
            giftDescriptionInput = document.getElementById('gift-description-input');
        const waimaiBtn = document.getElementById('waimai-btn'), sendWaimaiModal = document.getElementById('send-waimai-modal'),
            sendWaimaiForm = document.getElementById('send-waimai-form'),
            waimaiProductInput = document.getElementById('waimai-product-input'),
            waimaiAmountInput = document.getElementById('waimai-amount-input');
        const regenerateResponseBtn = document.getElementById('regenerate-response-btn');
        const stopGenerationBtn = document.getElementById('stop-generation-btn');
        const timeSkipBtn = document.getElementById('time-skip-btn'),
            timeSkipModal = document.getElementById('time-skip-modal'),
            timeSkipForm = document.getElementById('time-skip-form'),
            timeSkipInput = document.getElementById('time-skip-input');
        const editStatusModal = document.getElementById('edit-status-modal'),
            editStatusForm = document.getElementById('edit-status-form'),
            statusInput = document.getElementById('status-input');
        const clearChatHistoryBtn = document.getElementById('clear-chat-history-btn');
        const exportChatHistoryBtn = document.getElementById('export-chat-history-btn');
        const importChatHistoryBtn = document.getElementById('import-chat-history-btn');
        const importChatHistoryInput = document.getElementById('import-chat-history-input');
        const exportGroupChatHistoryBtn = document.getElementById('export-group-chat-history-btn');
        const importGroupChatHistoryBtn = document.getElementById('import-group-chat-history-btn');
        const importGroupChatHistoryInput = document.getElementById('import-group-chat-history-input');
        const worldBookListContainer = document.getElementById('world-book-list-container'),
            noWorldBooksPlaceholder = document.getElementById('no-world-books-placeholder'),
            addWorldBookBtn = document.getElementById('add-world-book-btn'),
            editWorldBookScreen = document.getElementById('edit-world-book-screen'),
            editWorldBookForm = document.getElementById('edit-world-book-form'),
            worldBookIdInput = document.getElementById('world-book-id'),
            worldBookNameInput = document.getElementById('world-book-name'),
            worldBookContentInput = document.getElementById('world-book-content'),
            worldBookIsGlobalInput = document.getElementById('world-book-is-global'),
            worldBookGroupInput = document.getElementById('world-book-group'),
            wbGroupFilter = document.getElementById('wb-group-filter');
        const linkWorldBookBtn = document.getElementById('link-world-book-btn'),
            worldBookSelectionModal = document.getElementById('world-book-selection-modal'),
            worldBookSelectionList = document.getElementById('world-book-selection-list'),
            saveWorldBookSelectionBtn = document.getElementById('save-world-book-selection-btn');
        const fontSettingsForm = document.getElementById('font-settings-form'),
            fontUrlInput = document.getElementById('font-url'),
            restoreDefaultFontBtn = document.getElementById('restore-default-font-btn');
        const createGroupBtn = document.getElementById('create-group-btn'),
            groupTypeSelectionModal = document.getElementById('group-type-selection-modal'),
            normalGroupBtn = document.getElementById('normal-group-btn'),
            observerGroupBtn = document.getElementById('observer-group-btn'),
            cancelGroupTypeBtn = document.getElementById('cancel-group-type-btn'),
            createGroupModal = document.getElementById('create-group-modal'),
            createGroupForm = document.getElementById('create-group-form'),
            createObserverGroupModal = document.getElementById('create-observer-group-modal'),
            createObserverGroupForm = document.getElementById('create-observer-group-form'),
            observerMemberSelectionList = document.getElementById('observer-member-selection-list'),
            observerGroupNameInput = document.getElementById('observer-group-name-input'),
            membersKnowEachOtherToggle = document.getElementById('members-know-each-other-toggle'),
            knowEachOtherSelection = document.getElementById('know-each-other-selection'),
            knowEachOtherPairs = document.getElementById('know-each-other-pairs'),
            memoryHasUserToggle = document.getElementById('memory-has-user-toggle'),
            memoryHasUserSelection = document.getElementById('memory-has-user-selection'),
            memoryHasUserList = document.getElementById('memory-has-user-list'),
            memberSelectionList = document.getElementById('member-selection-list'),
            groupNameInput = document.getElementById('group-name-input'),
            groupSettingsSidebar = document.getElementById('group-settings-sidebar'),
            groupSettingsForm = document.getElementById('group-settings-form'),
            groupMembersListContainer = document.getElementById('group-members-list-container'),
            editGroupMemberModal = document.getElementById('edit-group-member-modal'),
            editGroupMemberForm = document.getElementById('edit-group-member-form');
        const addMemberActionSheet = document.getElementById('add-member-actionsheet'),
            inviteExistingMemberBtn = document.getElementById('invite-existing-member-btn'),
            createNewMemberBtn = document.getElementById('create-new-member-btn'),
            inviteMemberModal = document.getElementById('invite-member-modal'),
            inviteMemberSelectionList = document.getElementById('invite-member-selection-list'),
            confirmInviteBtn = document.getElementById('confirm-invite-btn'),
            createMemberForGroupModal = document.getElementById('create-member-for-group-modal'),
            createMemberForGroupForm = document.getElementById('create-member-for-group-form');
        const customizeForm = document.getElementById('customize-form'),
            tutorialContentArea = document.getElementById('tutorial-content-area');
        const groupRecipientSelectionModal = document.getElementById('group-recipient-selection-modal'),
            groupRecipientSelectionList = document.getElementById('group-recipient-selection-list'),
            confirmGroupRecipientBtn = document.getElementById('confirm-group-recipient-btn'),
            groupRecipientSelectionTitle = document.getElementById('group-recipient-selection-title');
        const linkGroupWorldBookBtn = document.getElementById('link-group-world-book-btn');
        const resetIconModal = document.getElementById('reset-icon-modal'),
            resetIconImageBtn = document.getElementById('reset-icon-image-btn'),
            resetIconNameBtn = document.getElementById('reset-icon-name-btn'),
            resetIconBothBtn = document.getElementById('reset-icon-both-btn'),
            resetIconCancelBtn = document.getElementById('reset-icon-cancel-btn');
        let currentResetIconId = null;

        // --- 优化的数据存储系统 (OPFS) ---
        class OptimizedDataStorage {
            constructor() {
                // 创建 Dexie 数据库用于记忆快照等功能
                this.db = new Dexie('章鱼喷墨机DB_V2');
                
                // 定义数据库结构
                this.db.version(4).stores({
                    // 基础数据存储
                    storage: 'key, value, timestamp',
                    // 消息分块存储
                    messageChunks: 'id, chatId, chatType, chunkIndex, messages, timestamp',
                    // 元数据存储
                    metadata: 'key, value, timestamp',
                    // 自动总结记忆存储
                    memorySummaries: 'id, chatId, chatType, name, content, messageCount, timestamp',
                    // 记忆快照存储
                    memorySnapshots: 'id, chatId, chatType, name, data, timestamp',
                    // 本机数据快照存储
                    localSnapshots: '++id, name, data, timestamp',
                    // 图片Blob存储（消息中的图片）
                    imageBlobs: 'id, data, mimeType, timestamp',
                    // 通用资源Blob存储（头像、图标、壁纸、表情等）
                    assetBlobs: 'id, data, mimeType, category, timestamp'
                }).upgrade(trans => {
                    console.log('数据库升级到版本3，添加通用资源Blob存储');
                });

                // 使用 OPFS (Origin Private File System)
                this.rootHandle = null;
                this.initialized = false;

                // LRU缓存配置
                this.cache = new Map();
                this.maxCacheSize = 50; // 最大缓存50个数据块
                this.chunkSize = 100; // 每个数据块100条消息

                // 性能监控
                this.performanceMetrics = {
                    cacheHits: 0,
                    cacheMisses: 0,
                    operationTimes: [],
                    memoryUsage: 0
                };

                // 初始化 OPFS
                this.init();
            }

            // 初始化 OPFS
            async init() {
                try {
                    if (!navigator.storage || !navigator.storage.getDirectory) {
                        throw new Error('OPFS 不支持，浏览器版本过低');
                    }
                    this.rootHandle = await navigator.storage.getDirectory();
                    this.initialized = true;
                    console.log('✅ OPFS 初始化成功');
                } catch (error) {
                    console.error('❌ OPFS 初始化失败:', error);
                    // 降级到 localStorage
                    console.warn('⚠️ 降级使用 localStorage');
                    this.initialized = false;
                }
            }

            // 确保初始化完成
            async ensureInitialized() {
                if (!this.initialized) {
                    await this.init();
                }
                if (!this.initialized) {
                    throw new Error('存储系统未初始化');
                }
            }

            // 获取或创建目录（支持嵌套路径）
            async getOrCreateDirectory(dirPath) {
                await this.ensureInitialized();
                
                // 分割路径
                const parts = dirPath.split('/').filter(p => p);
                let currentHandle = this.rootHandle;
                
                // 逐级创建目录
                for (const part of parts) {
                    currentHandle = await currentHandle.getDirectoryHandle(part, { create: true });
                }
                
                return currentHandle;
            }

            // 写入文件
            async writeFile(dirName, fileName, data) {
                try {
                    const dirHandle = await this.getOrCreateDirectory(dirName);
                    const fileHandle = await dirHandle.getFileHandle(fileName, { create: true });
                    const writable = await fileHandle.createWritable();
                    await writable.write(JSON.stringify(data));
                    await writable.close();
                    return true;
                } catch (error) {
                    console.error(`写入文件失败 ${dirName}/${fileName}:`, error);
                    return false;
                }
            }

            // 读取文件
            async readFile(dirName, fileName) {
                try {
                    const dirHandle = await this.getOrCreateDirectory(dirName);
                    const fileHandle = await dirHandle.getFileHandle(fileName);
                    const file = await fileHandle.getFile();
                    const text = await file.text();
                    return JSON.parse(text);
                } catch (error) {
                    if (error.name !== 'NotFoundError') {
                        console.error(`读取文件失败 ${dirName}/${fileName}:`, error);
                    }
                    return null;
                }
            }

            // 删除文件
            async deleteFile(dirName, fileName) {
                try {
                    const dirHandle = await this.getOrCreateDirectory(dirName);
                    await dirHandle.removeEntry(fileName);
                    return true;
                } catch (error) {
                    if (error.name !== 'NotFoundError') {
                        console.error(`删除文件失败 ${dirName}/${fileName}:`, error);
                    }
                    return false;
                }
            }

            // 列出目录中的所有文件
            async listFiles(dirName) {
                try {
                    const dirHandle = await this.getOrCreateDirectory(dirName);
                    const files = [];
                    for await (const entry of dirHandle.values()) {
                        if (entry.kind === 'file') {
                            files.push(entry.name);
                        }
                    }
                    return files;
                } catch (error) {
                    console.error(`列出文件失败 ${dirName}:`, error);
                    return [];
                }
            }



            // LRU缓存管理
            updateCache(key, value) {
                if (this.cache.has(key)) {
                    this.cache.delete(key);
                }
                this.cache.set(key, value);

                if (this.cache.size > this.maxCacheSize) {
                    const firstKey = this.cache.keys().next().value;
                    this.cache.delete(firstKey);
                }

                // 更新内存使用量估算
                this.performanceMetrics.memoryUsage = JSON.stringify([...this.cache.values()]).length;
            }

            // 从缓存获取数据
            getFromCache(key) {
                if (this.cache.has(key)) {
                    const value = this.cache.get(key);
                    // 移到最后（最近使用）
                    this.cache.delete(key);
                    this.cache.set(key, value);
                    this.performanceMetrics.cacheHits++;
                    return value;
                }
                this.performanceMetrics.cacheMisses++;
                return null;
            }

            // 保存基础数据（非消息数据）
            async saveData(key, data) {
                const startTime = Date.now();
                try {
                    // 保存到 OPFS: storage/key.json
                    await this.writeFile('storage', `${key}.json`, {
                        key: key,
                        value: data,
                        timestamp: Date.now()
                    });

                    this.updateCache(key, data);
                    console.log(`数据已保存: ${key}`);
                    return true;
                } catch (error) {
                    console.error('保存数据失败:', error);
                    return false;
                }
            }

            // 获取基础数据
            async getData(key) {
                const startTime = Date.now();
                try {
                    // 先检查缓存
                    const cached = this.getFromCache(key);
                    if (cached !== null) {
                        return cached;
                    }

                    // 从 OPFS 读取: storage/key.json
                    const item = await this.readFile('storage', `${key}.json`);
                    if (item && item.value) {
                        this.updateCache(key, item.value);
                        return item.value;
                    } else {
                        console.log(`未找到数据: ${key}`);
                        return null;
                    }
                } catch (error) {
                    console.error('获取数据失败:', error);
                    return null;
                }
            }

            // 处理消息中的图片数据（转换为Blob引用）
            async processMessageImages(msg) {
                // 简化版本：直接返回消息，不做图片处理
                // 如果需要图片优化，可以在这里添加逻辑
                return msg;
            }

            // 恢复消息中的图片数据
            async restoreMessageImages(msg) {
                // 简化版本：直接返回消息，不做图片处理
                return msg;
            }

            // 保存聊天消息（分块存储）
            async saveChatMessages(chatId, chatType, messages) {
                const startTime = Date.now();
                try {
                    // 处理消息中的图片数据（转换为Blob引用）
                    const processedMessages = await Promise.all(
                        messages.map(msg => this.processMessageImages(msg))
                    );

                    // 将消息分块存储到 OPFS: messages/chatType_chatId/chunk_0.json
                    const dirName = `messages/${chatType}_${chatId}`;
                    
                    // 先删除旧的分块文件
                    const oldFiles = await this.listFiles(dirName);
                    for (const file of oldFiles) {
                        await this.deleteFile(dirName, file);
                    }

                    // 将消息分块存储
                    const chunks = [];
                    for (let i = 0; i < processedMessages.length; i += this.chunkSize) {
                        const chunkMessages = processedMessages.slice(i, i + this.chunkSize);
                        const chunkIndex = Math.floor(i / this.chunkSize);
                        const fileName = `chunk_${chunkIndex}.json`;

                        await this.writeFile(dirName, fileName, {
                            id: `${chatId}_${chatType}_${chunkIndex}`,
                            chatId: chatId,
                            chatType: chatType,
                            chunkIndex: chunkIndex,
                            messages: chunkMessages,
                            timestamp: Date.now()
                        });

                        chunks.push(fileName);
                    }

                    // 更新缓存（缓存原始消息，不是处理后的）
                    const cacheKey = `messages_${chatId}_${chatType}`;
                    this.updateCache(cacheKey, messages);

                    console.log(`消息已分块保存: ${chatId} (${chunks.length}个分块)`);
                    return true;
                } catch (error) {
                    console.error('保存消息失败:', error);
                    return false;
                }
            }

            // 获取聊天消息（按需加载）
            async getChatMessages(chatId, chatType, limit = null, offset = 0) {
                const startTime = Date.now();
                try {
                    const cacheKey = `messages_${chatId}_${chatType}`;

                    // 如果没有限制，先检查缓存
                    if (!limit) {
                        const cached = this.getFromCache(cacheKey);
                        if (cached !== null) {
                            return cached;
                        }
                    }

                    // 从 OPFS 获取分块: messages/chatType_chatId/chunk_*.json
                    const dirName = `messages/${chatType}_${chatId}`;
                    const files = await this.listFiles(dirName);
                    
                    if (files.length === 0) {
                        return [];
                    }

                    // 按文件名排序（chunk_0, chunk_1, ...）
                    files.sort((a, b) => {
                        const aIndex = parseInt(a.match(/chunk_(\d+)/)?.[1] || '0');
                        const bIndex = parseInt(b.match(/chunk_(\d+)/)?.[1] || '0');
                        return aIndex - bIndex;
                    });

                    // 读取所有分块
                    const chunks = [];
                    for (const file of files) {
                        const chunk = await this.readFile(dirName, file);
                        if (chunk) {
                            chunks.push(chunk);
                        }
                    }

                    // 合并所有消息
                    let allMessages = [];
                    chunks.forEach(chunk => {
                        allMessages = allMessages.concat(chunk.messages);
                    });

                    // 恢复消息中的图片数据
                    const restoredMessages = await Promise.all(
                        allMessages.map(msg => this.restoreMessageImages(msg))
                    );

                    // 如果没有限制，更新缓存
                    if (!limit) {
                        this.updateCache(cacheKey, restoredMessages);
                    }

                    // 应用分页
                    if (limit) {
                        const result = restoredMessages.slice(offset, offset + limit);
                        return result;
                    }

                    return restoredMessages;
                } catch (error) {
                    console.error('获取消息失败:', error);
                    return [];
                }
            }

            // 添加单条消息（增量更新）
            async addMessage(chatId, chatType, message) {
                const startTime = Date.now();
                try {
                    // 获取当前消息
                    const currentMessages = await this.getChatMessages(chatId, chatType);
                    currentMessages.push(message);

                    // 重新保存（会自动分块）
                    await this.saveChatMessages(chatId, chatType, currentMessages);

                    return true;
                } catch (error) {
                    console.error('添加消息失败:', error);
                    return false;
                }
            }

            // 删除消息
            async deleteMessage(chatId, chatType, messageId) {
                const startTime = Date.now();
                try {
                    const currentMessages = await this.getChatMessages(chatId, chatType);
                    const filteredMessages = currentMessages.filter(msg => msg.id !== messageId);

                    await this.saveChatMessages(chatId, chatType, filteredMessages);

                    return true;
                } catch (error) {
                    console.error('删除消息失败:', error);

                    return false;
                }
            }

            // 更新消息
            async updateMessage(chatId, chatType, messageId, updatedMessage) {
                const startTime = Date.now();
                try {
                    const currentMessages = await this.getChatMessages(chatId, chatType);
                    const messageIndex = currentMessages.findIndex(msg => msg.id === messageId);

                    if (messageIndex !== -1) {
                        currentMessages[messageIndex] = { ...currentMessages[messageIndex], ...updatedMessage };
                        await this.saveChatMessages(chatId, chatType, currentMessages);

                        return true;
                    }

                    return false;
                } catch (error) {
                    console.error('更新消息失败:', error);

                    return false;
                }
            }

            // 清空聊天记录
            async clearChatMessages(chatId, chatType) {
                const startTime = Date.now();
                try {
                    // 删除 OPFS 中的消息目录
                    const dirName = `messages/${chatType}_${chatId}`;
                    const files = await this.listFiles(dirName);
                    
                    for (const file of files) {
                        await this.deleteFile(dirName, file);
                    }

                    // 清除缓存
                    const cacheKey = `messages_${chatId}_${chatType}`;
                    this.cache.delete(cacheKey);

                    return true;
                } catch (error) {
                    console.error('清空消息失败:', error);

                    return false;
                }
            }

            // 删除数据
            async removeData(key) {
                const startTime = Date.now();
                try {
                    await this.deleteFile('storage', `${key}.json`);
                    this.cache.delete(key);
                    console.log(`数据已删除: ${key}`);

                    return true;
                } catch (error) {
                    console.error('删除数据失败:', error);

                    return false;
                }
            }

            // 清空所有数据
            async clearAll() {
                const startTime = Date.now();
                try {
                    await this.ensureInitialized();
                    
                    // 删除所有目录
                    const directories = ['storage', 'messages', 'metadata', 'images', 'assets'];
                    
                    for (const dirName of directories) {
                        try {
                            const dirHandle = await this.rootHandle.getDirectoryHandle(dirName);
                            // 删除目录中的所有文件
                            for await (const entry of dirHandle.values()) {
                                await dirHandle.removeEntry(entry.name, { recursive: true });
                            }
                        } catch (error) {
                            // 目录不存在，跳过
                        }
                    }
                    
                    this.cache.clear();
                    console.log('所有数据已清空');

                    return true;
                } catch (error) {
                    console.error('清空数据失败:', error);

                    return false;
                }
            }

            // 获取所有存储的键
            async getAllKeys() {
                try {
                    const files = await this.listFiles('storage');
                    return files.map(file => file.replace('.json', ''));
                } catch (error) {
                    console.error('获取所有键失败:', error);
                    return [];
                }
            }

            // 获取存储信息
            async getStorageInfo() {
                const startTime = Date.now();
                try {
                    // 获取所有存储文件
                    const storageFiles = await this.listFiles('storage');
                    
                    // 计算存储大小
                    let storageSize = 0;
                    for (const file of storageFiles) {
                        const data = await this.readFile('storage', file);
                        if (data) {
                            storageSize += JSON.stringify(data).length;
                        }
                    }

                    // 获取消息目录
                    let messageSize = 0;
                    let chunkCount = 0;
                    try {
                        const messagesDir = await this.rootHandle.getDirectoryHandle('messages');
                        for await (const chatDir of messagesDir.values()) {
                            if (chatDir.kind === 'directory') {
                                for await (const file of chatDir.values()) {
                                    if (file.kind === 'file') {
                                        const fileHandle = await chatDir.getFileHandle(file.name);
                                        const fileObj = await fileHandle.getFile();
                                        messageSize += fileObj.size;
                                        chunkCount++;
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        // messages 目录不存在
                    }

                    const totalSize = storageSize + messageSize;

                    const info = {
                        itemCount: storageFiles.length,
                        chunkCount: chunkCount,
                        imageBlobCount: 0,
                        assetBlobCount: 0,
                        totalSize: totalSize,
                        storageSize: storageSize,
                        messageSize: messageSize,
                        imageBlobSize: 0,
                        assetBlobSize: 0,
                        cacheSize: this.cache.size,
                        items: storageFiles.map(file => ({
                            key: file.replace('.json', ''),
                            size: 0, // 需要读取文件才能知道大小
                            timestamp: new Date().toLocaleString()
                        }))
                    };

                    // 更新显示
                    this.updateStorageDisplay(info);

                    return info;
                } catch (error) {
                    console.error('获取存储信息失败:', error);

                    return null;
                }
            }

            // 更新存储信息显示
            updateStorageDisplay(info) {
                const monitor = document.getElementById('performance-monitor');
                if (!monitor) return;

                document.getElementById('storage-size').textContent = `${(info.totalSize / 1024 / 1024).toFixed(2)} MB`;
                document.getElementById('chunk-count').textContent = info.chunkCount.toString();

                // 设置存储大小颜色指示器
                const sizeElement = document.getElementById('storage-size');
                const sizeMB = info.totalSize / 1024 / 1024;
                if (sizeMB < 10) sizeElement.className = 'metric-value good';
                else if (sizeMB < 50) sizeElement.className = 'metric-value warning';
                else sizeElement.className = 'metric-value error';
            }

            // 清除缓存（清除已删除角色的残留数据）
            async clearCache() {
                const startTime = Date.now();
                let deletedCount = 0;
                let deletedSize = 0;
                
                try {
                    console.log('开始清理无效缓存...');
                    
                    // 获取所有存储的键
                    const allKeys = await this.getAllKeys();
                    
                    // 获取当前活跃的角色和群组ID列表
                    // 注意：这里的db是全局变量，可以直接访问
                    const activeCharacterIds = new Set(db.characters.map(c => c.id));
                    const activeGroupIds = new Set(db.groups.map(g => g.id));
                    
                    // 1. 清理残留的角色和群组数据
                    for (const key of allKeys) {
                        if (key.startsWith('character_')) {
                            const id = key.replace('character_', '');
                            if (!activeCharacterIds.has(id)) {
                                const item = await this.getData(key);
                                if (item) {
                                    deletedSize += JSON.stringify(item).length;
                                    await this.removeData(key);
                                    // 同时清理对应的消息记录
                                    await this.clearChatMessages(id, 'private');
                                    deletedCount++;
                                    console.log(`清理残留角色: ${id}`);
                                }
                            }
                        } else if (key.startsWith('group_')) {
                            const id = key.replace('group_', '');
                            if (!activeGroupIds.has(id)) {
                                const item = await this.getData(key);
                                if (item) {
                                    deletedSize += JSON.stringify(item).length;
                                    await this.removeData(key);
                                    // 同时清理对应的消息记录
                                    await this.clearChatMessages(id, 'group');
                                    deletedCount++;
                                    console.log(`清理残留群组: ${id}`);
                                }
                            }
                        }
                    }
                    
                    // 2. 清理孤立的消息分块
                    try {
                        const messagesDir = await this.rootHandle.getDirectoryHandle('messages');
                        for await (const chatDir of messagesDir.values()) {
                            if (chatDir.kind === 'directory') {
                                const dirName = chatDir.name;
                                const parts = dirName.split('_');
                                if (parts.length >= 2) {
                                    const chatType = parts[0];
                                    const chatId = parts.slice(1).join('_');
                                    
                                    let isOrphan = false;
                                    if (chatType === 'private' && !activeCharacterIds.has(chatId)) {
                                        isOrphan = true;
                                    } else if (chatType === 'group' && !activeGroupIds.has(chatId)) {
                                        isOrphan = true;
                                    }
                                    
                                    if (isOrphan) {
                                        // 删除整个目录
                                        for await (const file of chatDir.values()) {
                                            await chatDir.removeEntry(file.name);
                                            deletedCount++;
                                        }
                                        await messagesDir.removeEntry(dirName);
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        // messages 目录不存在
                    }

                    // 3. 清理孤立的缓存对象
                    for (const key of this.cache.keys()) {
                        if (key.startsWith('messages_')) {
                             const parts = key.split('_');
                             if (parts.length >= 3) {
                                 const chatId = parts[1];
                                 const chatType = parts[2];
                                 
                                 if (chatType === 'private' && !activeCharacterIds.has(chatId)) {
                                     this.cache.delete(key);
                                 } else if (chatType === 'group' && !activeGroupIds.has(chatId)) {
                                     this.cache.delete(key);
                                 }
                             }
                        }
                    }
                    
                    console.log(`清理完成: 删除 ${deletedCount} 个项目, 释放 ${(deletedSize / 1024).toFixed(2)} KB`);
                    
                    return { count: deletedCount, size: deletedSize };
                } catch (error) {
                    console.error('清理缓存失败:', error);
                    throw error;
                }
            }

            // 数据迁移方法（从旧版本 IndexedDB 迁移到 OPFS）
            async migrateFromOldStorage() {
                const startTime = Date.now();
                let migrationSuccess = false;

                try {
                    // 检查是否支持 Dexie（用于迁移）
                    if (typeof Dexie === 'undefined') {
                        console.log('Dexie 未加载，跳过迁移');
                        return false;
                    }

                    // 尝试从旧数据库获取数据
                    const oldDb = new Dexie('章鱼喷墨机DB');
                    oldDb.version(1).stores({
                        storage: 'key, value, timestamp'
                    });

                    // 检查旧数据库是否存在数据
                    const oldData = await oldDb.storage.get('章鱼喷墨机');
                    if (oldData) {
                        console.log('检测到旧 IndexedDB 数据库，开始迁移到 OPFS...');
                        const data = JSON.parse(oldData.value);

                        // 迁移基础数据
                        const { characters, groups, ...baseData } = data;
                        await this.saveData('章鱼喷墨机', baseData);

                        let migratedCharacters = 0;
                        let migratedGroups = 0;
                        let migratedImages = 0;

                        // 迁移角色消息
                        if (characters) {
                            for (const char of characters) {
                                if (char.history && char.history.length > 0) {
                                    // 统计图片数量
                                    char.history.forEach(msg => {
                                        if (msg.imageUrl && msg.imageUrl.startsWith('data:')) migratedImages++;
                                        if (msg.parts) {
                                            migratedImages += msg.parts.filter(p => p.type === 'image' && p.data && p.data.startsWith('data:')).length;
                                        }
                                    });
                                    await this.saveChatMessages(char.id, 'private', char.history);
                                }
                                // 保存角色信息（不包含history）
                                const { history, ...charData } = char;
                                charData.history = []; // 保持兼容性
                                await this.saveData(`character_${char.id}`, charData);
                                migratedCharacters++;
                            }
                        }

                        // 迁移群组消息
                        if (groups) {
                            for (const group of groups) {
                                if (group.history && group.history.length > 0) {
                                    // 统计图片数量
                                    group.history.forEach(msg => {
                                        if (msg.imageUrl && msg.imageUrl.startsWith('data:')) migratedImages++;
                                        if (msg.parts) {
                                            migratedImages += msg.parts.filter(p => p.type === 'image' && p.data && p.data.startsWith('data:')).length;
                                        }
                                    });
                                    await this.saveChatMessages(group.id, 'group', group.history);
                                }
                                // 保存群组信息（不包含history）
                                const { history, ...groupData } = group;
                                groupData.history = []; // 保持兼容性
                                await this.saveData(`group_${group.id}`, groupData);
                                migratedGroups++;
                            }
                        }

                        migrationSuccess = true;
                        console.log(`✅ 数据迁移完成: ${migratedCharacters}个角色, ${migratedGroups}个群组, ${migratedImages}张图片`);

                        // 迁移成功后删除旧数据库
                        try {
                            console.log('开始删除旧 IndexedDB 数据库...');
                            if (oldDb.isOpen()) {
                                oldDb.close();
                            }
                            await oldDb.delete();
                            console.log('✅ 旧数据库删除成功');
                        } catch (deleteError) {
                            console.error('删除旧数据库失败:', deleteError);
                        }

                        return true;
                    } else {
                        console.log('未发现旧数据库数据');
                        return false;
                    }
                } catch (error) {
                    console.error('数据迁移失败:', error);
                    return false;
                } finally {
                    const duration = Date.now() - startTime;
                    console.log(`数据迁移操作完成，耗时: ${duration}ms, 成功: ${migrationSuccess}`);
                }
            }
        }

        const dataStorage = new OptimizedDataStorage();

        // ===== 存储监控系统（只监控，不删除数据）=====
        class StorageMonitor {
            constructor(dataStorage) {
                this.dataStorage = dataStorage;
            }

            // 计算当前存储大小
            async calculateStorageSize() {
                try {
                    const estimate = await navigator.storage.estimate();
                    const usage = estimate.usage || 0;
                    const quota = estimate.quota || 0;
                    
                    console.log(`📊 存储使用: ${(usage / 1024 / 1024).toFixed(2)}MB / ${(quota / 1024 / 1024).toFixed(2)}MB (${(usage / quota * 100).toFixed(1)}%)`);
                    
                    return { usage, quota, percentage: usage / quota };
                } catch (error) {
                    console.warn('无法获取存储信息:', error);
                    return { usage: 0, quota: 0, percentage: 0 };
                }
            }

            // 统计各类数据的大小
            async analyzeStorage() {
                try {
                    console.log('📊 开始分析存储使用情况...');
                    
                    // 统计图片（OPFS 版本）
                    let imageTotalSize = 0;
                    let imageCount = 0;
                    try {
                        const imagesDir = await this.dataStorage.rootHandle.getDirectoryHandle('images');
                        for await (const file of imagesDir.values()) {
                            if (file.kind === 'file') {
                                const fileHandle = await imagesDir.getFileHandle(file.name);
                                const fileObj = await fileHandle.getFile();
                                imageTotalSize += fileObj.size;
                                imageCount++;
                            }
                        }
                    } catch (error) {
                        // images 目录不存在
                    }
                    
                    // 统计消息数量
                    const baseData = await this.dataStorage.getData('章鱼喷墨机');
                    let totalMessages = 0;
                    let totalCharacters = 0;
                    let totalGroups = 0;
                    
                    if (baseData) {
                        if (baseData.characters) {
                            totalCharacters = baseData.characters.length;
                            for (const char of baseData.characters) {
                                const messages = await this.dataStorage.getChatMessages(char.id, 'private');
                                totalMessages += messages.length;
                            }
                        }
                        
                        if (baseData.groups) {
                            totalGroups = baseData.groups.length;
                            for (const group of baseData.groups) {
                                const messages = await this.dataStorage.getChatMessages(group.id, 'group');
                                totalMessages += messages.length;
                            }
                        }
                    }
                    
                    console.log('📊 存储分析结果:');
                    console.log(`   - 图片数量: ${imageCount} 张`);
                    console.log(`   - 图片大小: ${(imageTotalSize / 1024 / 1024).toFixed(2)}MB`);
                    console.log(`   - 角色数量: ${totalCharacters} 个`);
                    console.log(`   - 群组数量: ${totalGroups} 个`);
                    console.log(`   - 消息总数: ${totalMessages} 条`);
                    
                    return {
                        imageCount: imageCount,
                        imageSize: imageTotalSize,
                        characterCount: totalCharacters,
                        groupCount: totalGroups,
                        messageCount: totalMessages
                    };
                } catch (error) {
                    console.error('分析存储时出错:', error);
                    return null;
                }
            }
        }

        // 初始化存储监控（只监控，不自动清理）
        const storageMonitor = new StorageMonitor(dataStorage);

        // 启动时显示存储信息
        setTimeout(() => {
            storageMonitor.calculateStorageSize().catch(err => console.error('存储检查失败:', err));
            storageMonitor.analyzeStorage().catch(err => console.error('存储分析失败:', err));
        }, 3000);

        // 兼容性适配器 - 保持原有API接口
        const saveData = async (data) => {
            const dbData = data ? data : db;

            // 分离消息数据和基础数据
            const { characters, groups, ...baseData } = dbData;

            console.log(`💾 saveData 被调用，角色数量: ${characters ? characters.length : 0}, 群组数量: ${groups ? groups.length : 0}`);

            // 保存基础数据
            await dataStorage.saveData('章鱼喷墨机', baseData);

            // 分别保存角色和群组数据（包含消息）
            if (characters) {
                for (const char of characters) {
                    // 保存消息到分块存储
                    if (char.history && char.history.length > 0) {
                        console.log(`💾 保存角色 ${char.remarkName || char.name} 的 ${char.history.length} 条消息`);
                        await dataStorage.saveChatMessages(char.id, 'private', char.history);
                    } else {
                        console.log(`⚠️ 角色 ${char.remarkName || char.name} 没有消息历史`);
                    }
                    // 保存角色基础信息（不包含history）
                    const { history, ...charData } = char;
                    charData.history = []; // 保持兼容性
                    await dataStorage.saveData(`character_${char.id}`, charData);
                }
            }

            if (groups) {
                for (const group of groups) {
                    // 保存消息到分块存储
                    if (group.history && group.history.length > 0) {
                        console.log(`💾 保存群组 ${group.name} 的 ${group.history.length} 条消息`);
                        await dataStorage.saveChatMessages(group.id, 'group', group.history);
                    } else {
                        console.log(`⚠️ 群组 ${group.name} 没有消息历史`);
                    }
                    // 保存群组基础信息（不包含history）
                    const { history, ...groupData} = group;
                    groupData.history = []; // 保持兼容性
                    await dataStorage.saveData(`group_${group.id}`, groupData);
                }
            }

            if(dbData.apiSettings){
                await dataStorage.saveData('apiSettings', dbData.apiSettings);
            }
            if(dbData.customIcons){
                await dataStorage.saveData('customIcons', dbData.customIcons);
            }
            if(dbData.fontUrl){
                await dataStorage.saveData('fontUrl', dbData.fontUrl);
            }
            if(dbData.homeScreenMode){
                await dataStorage.saveData('homeScreenMode', dbData.homeScreenMode);
            }
            if(dbData.wallpaper){
                await dataStorage.saveData('wallpaper', dbData.wallpaper);
            }
            return Promise.resolve();
        };

        // 添加系统消息的全局辅助函数
        async function addSystemMessage(chatId, content) {
            const chat = db.groups.find(g => g.id === chatId);
            if (!chat) return;
            
            const systemMessage = {
                id: `msg_${Date.now()}_${Math.random()}`,
                role: 'system',
                content: `[system-display:${content}]`,
                timestamp: Date.now()
            };
            
            chat.history.push(systemMessage);
            await saveData();
            
            // 如果当前正在查看这个群聊，刷新消息显示
            if (currentChatType === 'group' && currentChatId === chatId) {
                await addMessageBubble(systemMessage);
            }
        }

        const loadData = async () => {
            // 首先尝试数据迁移
            await dataStorage.migrateFromOldStorage();

            // 检查localStorage中的旧数据
            const oldData = localStorage.getItem('gemini-chat-app-db');
            if (oldData) {
                console.log('检测到localStorage中的旧数据，开始迁移...');
                await saveData(JSON.parse(oldData));
                localStorage.removeItem('gemini-chat-app-db');
                console.log('localStorage旧数据迁移完成并已清理');
            }

            // 额外的安全检查：确保旧数据库完全清理
            try {
                if (typeof Dexie !== 'undefined') {
                    const safetyCheckDb = new Dexie('章鱼喷墨机DB');
                    safetyCheckDb.version(1).stores({
                        storage: 'key, value, timestamp'
                    });

                    const residualData = await safetyCheckDb.storage.get('章鱼喷墨机');
                    if (residualData) {
                        console.warn('发现残留的旧数据库数据，执行强制清理...');
                        await safetyCheckDb.storage.clear();
                        safetyCheckDb.close();
                        await safetyCheckDb.delete();
                        console.log('残留旧数据库已强制清理');
                    } else {
                        safetyCheckDb.close();
                    }
                }
            } catch (safetyError) {
                // 如果无法访问旧数据库，说明已经被正确删除
                console.log('旧数据库安全检查完成（数据库不存在或 Dexie 未加载）');
            }

            // 加载基础数据
            let data = await dataStorage.getData('章鱼喷墨机');
            if (data) {
                db = { ...db, ...data };
            }

            // 初始化默认值
            if (!db.apiSettings) db.apiSettings = {};
            if (!db.wallpaper) db.wallpaper = 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg';
            if (!db.myStickers) db.myStickers = [];
            if (!db.homeScreenMode) db.homeScreenMode = 'night';
            if (!db.worldBooks) db.worldBooks = [];
            if (!db.fontUrl) db.fontUrl = '';
            if (!db.customIcons) db.customIcons = {};
            if (db.enableLanguageSwitch === undefined) db.enableLanguageSwitch = false;
            if (!db.appLanguage) db.appLanguage = 'zh-CN';
            if (!db.timeDividerSettings) {
                db.timeDividerSettings = {
                    bgColor: 'rgba(200, 200, 200, 0.5)',
                    textColor: '#666666',
                    language: 'zh',
                    bgOpacity: 50,
                    textOpacity: 100,
                    borderRadius: 10
                };
            }

            // 重建characters和groups列表
            // 由于saveData时这两个字段被排除，需要从存储中重新构建
            db.characters = [];
            db.groups = [];

            // 获取所有存储的键，找出角色和群组数据
            const allKeys = await dataStorage.getAllKeys();
            const characterKeys = allKeys.filter(key => key.startsWith('character_'));
            const groupKeys = allKeys.filter(key => key.startsWith('group_'));

            console.log(`发现 ${characterKeys.length} 个角色数据, ${groupKeys.length} 个群组数据`);

            // 加载角色数据
            const characterPromises = characterKeys.map(async (key) => {
                const charId = key.replace('character_', '');
                const charData = await dataStorage.getData(key);
                if (charData) {
                    // 按需加载消息历史
                    charData.history = await dataStorage.getChatMessages(charId, 'private');

                    // 设置默认值
                    if (charData.isPinned === undefined) charData.isPinned = false;
                    if (charData.status === undefined) charData.status = '在线';
                    if (!charData.worldBookIds) charData.worldBookIds = [];
                    if (charData.customBubbleCss === undefined) charData.customBubbleCss = '';
                    if (charData.useCustomBubbleCss === undefined) charData.useCustomBubbleCss = false;

                    return charData;
                }
                return null;
            });

            // 加载群组数据
            const groupPromises = groupKeys.map(async (key) => {
                const groupId = key.replace('group_', '');
                const groupData = await dataStorage.getData(key);
                if (groupData) {
                    // 按需加载消息历史
                    groupData.history = await dataStorage.getChatMessages(groupId, 'group');

                    // 设置默认值
                    if (groupData.isPinned === undefined) groupData.isPinned = false;
                    if (!groupData.worldBookIds) groupData.worldBookIds = [];
                    if (groupData.customBubbleCss === undefined) groupData.customBubbleCss = '';
                    if (groupData.useCustomBubbleCss === undefined) groupData.useCustomBubbleCss = false;

                    return groupData;
                }
                return null;
            });

            // 等待所有数据加载完成
            const [loadedCharacters, loadedGroups] = await Promise.all([
                Promise.all(characterPromises),
                Promise.all(groupPromises)
            ]);

            // 过滤掉null值并赋值给db
            db.characters = loadedCharacters.filter(char => char !== null);
            db.groups = loadedGroups.filter(group => group !== null);

            console.log(`成功加载 ${db.characters.length} 个角色, ${db.groups.length} 个群组`);
            console.log('完整数据库对象:', db);
        };
        const showToast = (message) => {
            toastElement.textContent = message;
            toastElement.classList.add('show');
            setTimeout(() => toastElement.classList.remove('show'), 3000);
        };
        const switchScreen = (targetId) => {
            // 检查是否从外卖界面离开
            const currentScreen = document.querySelector('.screen.active');
            if (currentScreen && currentScreen.id === 'waimai-screen' && targetId !== 'waimai-screen') {
                // 如果没有开启保存功能，清空店铺数据
                const waimaiShopList = document.getElementById('waimai-shop-list');
                if (window.waimaiSettings && !window.waimaiSettings.saveShops && waimaiShopList) {
                    waimaiShopList.innerHTML = '<div class="placeholder-text">点击右上角刷新按钮加载外卖店铺</div>';
                    if (window.waimaiSavedShops !== undefined) {
                        window.waimaiSavedShops = null;
                    }
                }
            }
            
            screens.forEach(screen => screen.classList.remove('active'));
            document.getElementById(targetId)?.classList.add('active');
            // Close all overlays and sidebars
            const overlays = document.querySelectorAll('.modal-overlay, .action-sheet-overlay, .settings-sidebar');
            overlays.forEach(o => o.classList.remove('visible', 'open'));
        };
        const pad = (num) => num.toString().padStart(2, '0');

        // 弹窗通知计时器
        let notificationTimeout = null;

        /**
         * 显示弹窗通知
         * @param {string} chatId - 聊天ID
         * @param {string} messageContent - 消息内容
         */
        function showNotification(chatId, messageContent) {
            clearTimeout(notificationTimeout);
            
            // 查找角色或群组
            const character = db.characters.find(c => c.id === chatId);
            const group = db.groups.find(g => g.id === chatId);
            const chat = character || group;
            
            if (!chat) return;
            
            const bar = document.getElementById('notification-bar');
            const notifAvatar = document.getElementById('notification-avatar');
            const notifName = document.getElementById('notification-content').querySelector('.name');
            const notifMessage = document.getElementById('notification-content').querySelector('.message');
            
            // 设置通知内容
            notifAvatar.src = chat.avatar;
            notifName.textContent = character ? chat.remarkName : chat.name;
            notifMessage.textContent = messageContent;
            
            // 克隆并替换节点以重新触发动画
            const newBar = bar.cloneNode(true);
            bar.parentNode.replaceChild(newBar, bar);
            
            // 添加点击事件
            newBar.addEventListener('click', () => {
                currentChatId = chatId;
                currentChatType = character ? 'private' : 'group';
                openChatRoom(chatId, currentChatType);
                newBar.classList.remove('visible');
            });
            
            // 显示通知
            newBar.classList.add('visible');
            
            // 4秒后自动隐藏
            notificationTimeout = setTimeout(() => {
                newBar.classList.remove('visible');
            }, 4000);
        }

        /**
         * 格式化系统时间戳显示
         * @param {number} timestamp - 消息的时间戳
         * @returns {string} - 格式化后的时间字符串
         */
        function formatSystemTimestamp(timestamp) {
            if (!timestamp) return '';
            const now = new Date();
            const date = new Date(timestamp);

            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const timeString = `${hours}:${minutes}`;
            
            // 获取语言设置
            const language = db.timeDividerSettings?.language || 'zh';

            // 如果是今天
            if (now.toDateString() === date.toDateString()) {
                return timeString; // 只显示 HH:mm
            }

            // 如果是昨天
            const yesterday = new Date();
            yesterday.setDate(now.getDate() - 1);
            if (yesterday.toDateString() === date.toDateString()) {
                const yesterdayText = {
                    'zh': '昨天',
                    'en': 'Yesterday',
                    'ja': '昨日',
                    'ko': '어제',
                    'es': 'Ayer',
                    'fr': 'Hier',
                    'de': 'Gestern',
                    'it': 'Ieri',
                    'pt': 'Ontem',
                    'ru': 'Вчера'
                };
                return `${yesterdayText[language] || yesterdayText['zh']} ${timeString}`;
            }
            
            // 更早的时间
            const year = date.getFullYear();
            const month = date.getMonth() + 1;
            const day = date.getDate();

            if (now.getFullYear() === year) {
                // 今年的日期
                if (language === 'zh') {
                    return `${month}月${day}日 ${timeString}`;
                } else if (language === 'ja') {
                    return `${month}月${day}日 ${timeString}`;
                } else if (language === 'ko') {
                    return `${month}월 ${day}일 ${timeString}`;
                } else if (language === 'en') {
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    return `${monthNames[month - 1]} ${day} ${timeString}`;
                } else if (language === 'es') {
                    const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
                    return `${day} ${monthNames[month - 1]} ${timeString}`;
                } else if (language === 'fr') {
                    const monthNames = ['Jan', 'Fév', 'Mar', 'Avr', 'Mai', 'Juin', 'Juil', 'Aoû', 'Sep', 'Oct', 'Nov', 'Déc'];
                    return `${day} ${monthNames[month - 1]} ${timeString}`;
                } else if (language === 'de') {
                    const monthNames = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
                    return `${day}. ${monthNames[month - 1]} ${timeString}`;
                } else if (language === 'it') {
                    const monthNames = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
                    return `${day} ${monthNames[month - 1]} ${timeString}`;
                } else if (language === 'pt') {
                    const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
                    return `${day} ${monthNames[month - 1]} ${timeString}`;
                } else if (language === 'ru') {
                    const monthNames = ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн', 'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'];
                    return `${day} ${monthNames[month - 1]} ${timeString}`;
                }
            } else {
                // 更早年份的日期
                if (language === 'zh') {
                    return `${year}年${month}月${day}日 ${timeString}`;
                } else if (language === 'ja') {
                    return `${year}年${month}月${day}日 ${timeString}`;
                } else if (language === 'ko') {
                    return `${year}년 ${month}월 ${day}일 ${timeString}`;
                } else if (language === 'en') {
                    const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    return `${monthNames[month - 1]} ${day}, ${year} ${timeString}`;
                } else if (language === 'es') {
                    const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
                    return `${day} ${monthNames[month - 1]} ${year} ${timeString}`;
                } else if (language === 'fr') {
                    const monthNames = ['Jan', 'Fév', 'Mar', 'Avr', 'Mai', 'Juin', 'Juil', 'Aoû', 'Sep', 'Oct', 'Nov', 'Déc'];
                    return `${day} ${monthNames[month - 1]} ${year} ${timeString}`;
                } else if (language === 'de') {
                    const monthNames = ['Jan', 'Feb', 'Mär', 'Apr', 'Mai', 'Jun', 'Jul', 'Aug', 'Sep', 'Okt', 'Nov', 'Dez'];
                    return `${day}. ${monthNames[month - 1]} ${year} ${timeString}`;
                } else if (language === 'it') {
                    const monthNames = ['Gen', 'Feb', 'Mar', 'Apr', 'Mag', 'Giu', 'Lug', 'Ago', 'Set', 'Ott', 'Nov', 'Dic'];
                    return `${day} ${monthNames[month - 1]} ${year} ${timeString}`;
                } else if (language === 'pt') {
                    const monthNames = ['Jan', 'Fev', 'Mar', 'Abr', 'Mai', 'Jun', 'Jul', 'Ago', 'Set', 'Out', 'Nov', 'Dez'];
                    return `${day} ${monthNames[month - 1]} ${year} ${timeString}`;
                } else if (language === 'ru') {
                    const monthNames = ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн', 'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'];
                    return `${day} ${monthNames[month - 1]} ${year} ${timeString}`;
                }
            }
            
            // 默认返回中文格式
            return `${year}年${month}月${day}日 ${timeString}`;
        }

        /**
         * 【新增】为AI上下文格式化时间戳 - 让AI能理解对话历史中的时间
         * @param {number} timestamp - 消息的时间戳
         * @returns {string} - 格式化后的日期时间字符串，例如 "今天 17:42", "昨天 23:50" 等
         */
        function formatTimestampForAI(timestamp) {
            if (!timestamp) return '';
            
            const now = new Date();
            const date = new Date(timestamp);

            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const timeString = `${hours}:${minutes}`;

            // 如果是今天
            if (now.toDateString() === date.toDateString()) {
                return `今天 ${timeString}`;
            }

            // 如果是昨天
            const yesterday = new Date();
            yesterday.setDate(now.getDate() - 1);
            if (yesterday.toDateString() === date.toDateString()) {
                return `昨天 ${timeString}`;
            }
            
            // 如果是今年
            if (now.getFullYear() === date.getFullYear()) {
                const month = String(date.getMonth() + 1);
                const day = String(date.getDate());
                return `${month}月${day}日 ${timeString}`;
            }
            
            // 更早的时间
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1);
            const day = String(date.getDate());
            return `${year}年${month}月${day}日 ${timeString}`;
        }

        /**
         * 创建系统时间提示的DOM元素
         * @param {number} timestamp - 要显示的时间戳
         * @returns {HTMLElement} - 创建好的DOM元素
         */
        function createSystemTimestampElement(timestamp) {
            const wrapper = document.createElement('div');
            wrapper.className = 'message-wrapper system-notification'; 
            
            const bubble = document.createElement('div');
            bubble.className = 'system-notification-bubble'; 
            bubble.textContent = formatSystemTimestamp(timestamp);
            
            const bgColor = db.timeDividerSettings?.bgColor || 'rgba(200, 200, 200, 0.5)';
            const textColor = db.timeDividerSettings?.textColor || '#666';
            const borderRadius = db.timeDividerSettings?.borderRadius !== undefined ? db.timeDividerSettings.borderRadius : 10;
            
            bubble.style.backgroundColor = bgColor;
            bubble.style.color = textColor;
            bubble.style.borderRadius = borderRadius + 'px';
            
            wrapper.appendChild(bubble);
            return wrapper;
        }

        function createContextMenu(items, x, y) {
            removeContextMenu();
            const menu = document.createElement('div');
            menu.className = 'context-menu';
            menu.style.left = `${x}px`;
            menu.style.top = `${y}px`;
            items.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.className = 'context-menu-item';
                if (item.danger) menuItem.classList.add('danger');
                menuItem.textContent = item.label;
                menuItem.onclick = () => {
                    item.action();
                    removeContextMenu();
                };
                menu.appendChild(menuItem);
            });
            document.body.appendChild(menu);
            document.addEventListener('click', removeContextMenu, {once: true});
        }

        function removeContextMenu() {
            const menu = document.querySelector('.context-menu');
            if (menu) menu.remove();
        }
        
        // Token计算函数 - 使用简化的估算方法
        function estimateTokenCount(text) {
            if (!text) return 0;
            
            // 中文字符约1.5-2个token，英文单词约1-1.5个token
            // 这里使用简化估算：中文字符 * 1.6 + 英文单词数
            const chineseChars = (text.match(/[\u4e00-\u9fa5]/g) || []).length;
            const englishWords = (text.match(/[a-zA-Z]+/g) || []).length;
            const numbers = (text.match(/\d+/g) || []).length;
            const symbols = text.length - chineseChars - text.replace(/[a-zA-Z\d\s]/g, '').length;
            
            return Math.ceil(chineseChars * 1.6 + englishWords * 1.3 + numbers * 0.5 + symbols * 0.3);
        }
        
        // 计算聊天记录的总Token数
        function calculateTotalTokens(history) {
            if (!history || history.length === 0) return 0;
            
            let totalTokens = 0;
            history.forEach(msg => {
                if (msg.content) {
                    totalTokens += estimateTokenCount(msg.content);
                }
            });
            
            return totalTokens;
        }
        
        // 更新Token显示（计算API实际调用的Token：系统提示词 + 记忆轮数内的历史消息）
        async function updateTokenDisplay() {
            if (currentChatType === 'private') {
                const character = db.characters.find(c => c.id === currentChatId);
                if (character) {
                    // 生成系统提示词
                    let memoryLibrary = null;
                    if (character.memoryLibraryEnabled) {
                        memoryLibrary = await getMemoryLibraryContent(currentChatId, 'private');
                    }
                    const systemPrompt = await generatePrivateSystemPrompt(character, memoryLibrary);
                    const systemTokens = estimateTokenCount(systemPrompt);
                    
                    // 计算历史消息Token（根据记忆轮数截取）
                    const maxMemory = parseInt(character.maxMemory) || 10;
                    const historySlice = (character.history || []).slice(-maxMemory);
                    const historyTokens = calculateTotalTokens(historySlice);
                    
                    // API实际调用的Token = 系统提示词 + 历史消息
                    const tokens = systemTokens + historyTokens;
                    
                    const tokenEl = document.getElementById('current-token-count');
                    if (tokenEl) {
                        tokenEl.textContent = tokens.toLocaleString();
                    }
                    
                    // Check token warning
                    checkTokenWarning(character, tokens, 'private');
                    
                    // Check message count warning
                    const messageCount = (character.history || []).length;
                    checkMessageCountWarning(character, messageCount, 'private');
                }
            } else if (currentChatType === 'group') {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    // 生成系统提示词
                    let memoryLibrary = null;
                    if (group.members && group.members.some(m => m.memoryLibraryEnabled)) {
                        memoryLibrary = await getMemoryLibraryContent(currentChatId, 'group');
                    }
                    
                    let systemPrompt;
                    if (group.isObserverMode) {
                        systemPrompt = await generateObserverGroupSystemPrompt(group, memoryLibrary);
                    } else {
                        systemPrompt = await generateGroupSystemPrompt(group, memoryLibrary);
                    }
                    const systemTokens = estimateTokenCount(systemPrompt);
                    
                    // 计算历史消息Token（根据记忆轮数截取）
                    const maxMemory = parseInt(group.maxMemory) || 10;
                    const historySlice = (group.history || []).slice(-maxMemory);
                    const historyTokens = calculateTotalTokens(historySlice);
                    
                    // API实际调用的Token = 系统提示词 + 历史消息
                    const tokens = systemTokens + historyTokens;
                    
                    const tokenEl = document.getElementById('group-current-token-count');
                    if (tokenEl) {
                        tokenEl.textContent = tokens.toLocaleString();
                    }
                    
                    // Check token warning
                    checkTokenWarning(group, tokens, 'group');
                    
                    // Check message count warning
                    const messageCount = (group.history || []).length;
                    checkMessageCountWarning(group, messageCount, 'group');
                }
            }
        }
        
        // 检查Token是否超过阈值并显示警告
        function checkTokenWarning(chat, currentTokens, chatType) {
            const isEnabled = chatType === 'private' ? 
                (chat.tokenWarningEnabled || false) : 
                (chat.tokenWarningEnabled || false);
            
            const threshold = chatType === 'private' ? 
                (chat.tokenWarningThreshold || 0) : 
                (chat.tokenWarningThreshold || 0);
            
            // 检查是否已经为当前阈值提示过
            const lastWarnedThreshold = chat.lastTokenWarningThreshold || 0;
            
            if (isEnabled && threshold > 0 && currentTokens >= threshold) {
                // 只有当阈值改变或者从未提示过时才提示
                if (lastWarnedThreshold !== threshold) {
                    const chatName = chatType === 'private' ? chat.remarkName : chat.name;
                    const message = `Token数量提醒\n\n当前对话"${chatName}"的Token数已达到 ${currentTokens.toLocaleString()}，超过了您设置的阈值 ${threshold.toLocaleString()}。\n\n建议：\n• 使用"自动总结"功能压缩历史对话\n• 清理不重要的消息\n• 开始新的对话`;
                    
                    // 记录已提示的阈值
                    chat.lastTokenWarningThreshold = threshold;
                    saveData();
                    
                    if (confirm(message + '\n\n点击"确定"查看聊天设置，点击"取消"表示已知')) {
                        // 打开设置侧边栏
                        if (chatType === 'private') {
                            document.getElementById('chat-settings-sidebar').classList.add('open');
                        } else {
                            document.getElementById('group-settings-sidebar').classList.add('open');
                        }
                    }
                }
            }
        }
        
        // 检查消息条数是否超过阈值并显示警告
        function checkMessageCountWarning(chat, messageCount, chatType) {
            const isEnabled = chatType === 'private' ? 
                (chat.messageCountWarningEnabled || false) : 
                (chat.messageCountWarningEnabled || false);
            
            const threshold = chatType === 'private' ? 
                (chat.messageCountWarningThreshold || 0) : 
                (chat.messageCountWarningThreshold || 0);
            
            // 检查是否已经为当前阈值提示过
            const lastWarnedThreshold = chat.lastMessageCountWarningThreshold || 0;
            
            if (isEnabled && threshold > 0 && messageCount >= threshold) {
                // 只有当阈值改变或者从未提示过时才提示
                if (lastWarnedThreshold !== threshold) {
                    const chatName = chatType === 'private' ? chat.remarkName : chat.name;
                    const message = `消息条数提醒\n\n当前对话"${chatName}"的消息条数已达到 ${messageCount} 条，超过了您设置的阈值 ${threshold} 条。\n\n建议：\n• 使用"自动总结"功能压缩历史对话\n• 清理不重要的消息\n• 开始新的对话`;
                    
                    // 记录已提示的阈值
                    chat.lastMessageCountWarningThreshold = threshold;
                    saveData();
                    
                    if (confirm(message + '\n\n点击"确定"查看聊天设置，点击"取消"表示已知')) {
                        // 打开设置侧边栏
                        if (chatType === 'private') {
                            document.getElementById('chat-settings-sidebar').classList.add('open');
                        } else {
                            document.getElementById('group-settings-sidebar').classList.add('open');
                        }
                    }
                }
            }
        }
        
        // 显示Token详细信息（提示词各部分）
        async function showTokenDetails(chatType) {
            let chat = null;
            let systemPrompt = '';
            let history = [];
            
            if (chatType === 'private') {
                chat = db.characters.find(c => c.id === currentChatId);
                if (!chat) return;
                
                // 检查是否需要加载记忆库
                let memoryLibrary = null;
                if (chat.memoryLibraryEnabled) {
                    memoryLibrary = await getMemoryLibraryContent(currentChatId, 'private');
                }
                
                systemPrompt = await generatePrivateSystemPrompt(chat, memoryLibrary);
                history = chat.history || [];
            } else if (chatType === 'group') {
                chat = db.groups.find(g => g.id === currentChatId);
                if (!chat) return;
                
                // 检查群组成员是否需要加载记忆库
                let memoryLibrary = null;
                if (chat.members && chat.members.some(m => m.memoryLibraryEnabled)) {
                    memoryLibrary = await getMemoryLibraryContent(currentChatId, 'group');
                }
                
                if (chat.isObserverMode) {
                    systemPrompt = await generateObserverGroupSystemPrompt(chat, memoryLibrary);
                } else {
                    systemPrompt = await generateGroupSystemPrompt(chat, memoryLibrary);
                }
                history = chat.history || [];
            }
            
            // 计算系统提示词的Token
            const systemTokens = estimateTokenCount(systemPrompt);
            
            // 计算历史消息的Token（根据maxMemory截取）
            const maxMemory = parseInt(chat.maxMemory) || 10;
            const historySlice = history.slice(-maxMemory);
            let historyTokens = 0;
            const messageDetails = [];
            
            historySlice.forEach((msg, index) => {
                if (!msg.content) return;
                
                const tokens = estimateTokenCount(msg.content);
                historyTokens += tokens;
                
                // 获取发送者名称
                let senderName = '系统';
                if (msg.sender === 'user') {
                    senderName = '我';
                } else if (msg.sender === 'char') {
                    senderName = chat.remarkName || chat.name;
                } else if (msg.senderId) {
                    if (chatType === 'group') {
                        const member = chat.members?.find(m => m.id === msg.senderId);
                        if (member) {
                            senderName = member.nickname || member.name;
                        }
                    }
                }
                
                messageDetails.push({
                    index: index + 1,
                    sender: senderName,
                    content: msg.content.substring(0, 60) + (msg.content.length > 60 ? '...' : ''),
                    tokens: tokens
                });
            });
            
            const totalTokens = systemTokens + historyTokens;
            
            // 计算系统提示词各部分的Token（粗略估算）
            const systemParts = [];
            
            // 基础规则部分
            const baseRulesMatch = systemPrompt.match(/你正在一个名为"404"的线上聊天软件[\s\S]*?(?=\n\n#|$)/);
            if (baseRulesMatch) {
                const baseTokens = estimateTokenCount(baseRulesMatch[0]);
                systemParts.push({ name: '基础规则', tokens: baseTokens });
            }
            
            // 时间感知部分
            const timeMatch = systemPrompt.match(/# 时间感知[\s\S]*?(?=\n\n#|$)/);
            if (timeMatch) {
                const timeTokens = estimateTokenCount(timeMatch[0]);
                systemParts.push({ name: '时间感知', tokens: timeTokens });
            }
            
            // 音乐情景部分
            const musicMatch = systemPrompt.match(/# 当前音乐情景[\s\S]*?(?=\n\n#|$)/);
            if (musicMatch) {
                const musicTokens = estimateTokenCount(musicMatch[0]);
                systemParts.push({ name: '音乐情景', tokens: musicTokens });
            }
            
            // NPC社交圈部分
            const npcMatch = systemPrompt.match(/# 你的社交圈[\s\S]*?(?=\n\n#|$)/);
            if (npcMatch) {
                const npcTokens = estimateTokenCount(npcMatch[0]);
                systemParts.push({ name: 'NPC社交圈', tokens: npcTokens });
            }
            
            // 可用资源部分
            const resourceMatch = systemPrompt.match(/# 可用资源[\s\S]*?(?=\n\n#|$)/);
            if (resourceMatch) {
                const resourceTokens = estimateTokenCount(resourceMatch[0]);
                systemParts.push({ name: '可用资源', tokens: resourceTokens });
            }
            
            // 线下模式部分
            const offlineMatch = systemPrompt.match(/# 🌍 当前场景：线下真实世界[\s\S]*?(?=\n\n#|$)/);
            if (offlineMatch) {
                const offlineTokens = estimateTokenCount(offlineMatch[0]);
                systemParts.push({ name: '线下模式', tokens: offlineTokens });
            }
            
            // 心声功能部分
            const innerMatch = systemPrompt.match(/# 心声功能[\s\S]*?(?=\n\n#|$)/);
            if (innerMatch) {
                const innerTokens = estimateTokenCount(innerMatch[0]);
                systemParts.push({ name: '心声功能', tokens: innerTokens });
            }
            
            // 挂载聊天记录部分
            const mountMatch = systemPrompt.match(/# 挂载的聊天记录[\s\S]*?(?=\n\n#|$)/);
            if (mountMatch) {
                const mountTokens = estimateTokenCount(mountMatch[0]);
                systemParts.push({ name: '挂载聊天记录', tokens: mountTokens });
            }
            
            // 头像管理能力部分
            const avatarMatch = systemPrompt.match(/# 头像管理能力[\s\S]*?(?=\n\n#|$)/);
            if (avatarMatch) {
                const avatarTokens = estimateTokenCount(avatarMatch[0]);
                systemParts.push({ name: '头像管理', tokens: avatarTokens });
            }
            
            // 更新模态框内容
            document.getElementById('token-detail-total').textContent = totalTokens.toLocaleString();
            document.getElementById('token-detail-chinese').textContent = systemTokens.toLocaleString();
            document.getElementById('token-detail-english').textContent = historyTokens.toLocaleString();
            document.getElementById('token-detail-numbers').textContent = systemParts.length;
            document.getElementById('token-detail-symbols').textContent = messageDetails.length;
            document.getElementById('token-detail-message-count').textContent = `${systemParts.length} 个提示词模块`;
            
            // 渲染提示词模块列表
            const messagesContainer = document.getElementById('token-detail-messages');
            messagesContainer.innerHTML = '';
            
            // 显示系统提示词总计
            const systemSummary = document.createElement('div');
            systemSummary.style.cssText = 'background: #e8e8e8; color: #333; border-radius: 6px; padding: 12px; margin-bottom: 10px; border: 1px solid #ccc;';
            systemSummary.innerHTML = `
                <div style="font-weight: 600; font-size: 14px; margin-bottom: 5px;">系统提示词</div>
                <div style="font-size: 20px; font-weight: bold;">${systemTokens.toLocaleString()} tokens</div>
            `;
            messagesContainer.appendChild(systemSummary);
            
            // 显示系统提示词各模块
            if (systemParts.length > 0) {
                systemParts.forEach(part => {
                    const partItem = document.createElement('div');
                    partItem.style.cssText = 'background: white; border-radius: 6px; padding: 10px; margin-bottom: 8px; border: 1px solid #ddd;';
                    
                    const percentage = ((part.tokens / systemTokens) * 100).toFixed(1);
                    partItem.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="font-weight: 600; color: #333; font-size: 13px;">${part.name}</div>
                            <div style="font-weight: bold; color: #333; font-size: 14px;">${part.tokens.toLocaleString()} tokens (${percentage}%)</div>
                        </div>
                    `;
                    
                    messagesContainer.appendChild(partItem);
                });
            }
            
            // 显示历史消息总计
            const historySummary = document.createElement('div');
            historySummary.style.cssText = 'background: #e8e8e8; color: #333; border-radius: 6px; padding: 12px; margin: 15px 0 10px 0; border: 1px solid #ccc;';
            historySummary.innerHTML = `
                <div style="font-weight: 600; font-size: 14px; margin-bottom: 5px;">历史消息 (最近${maxMemory}轮)</div>
                <div style="font-size: 20px; font-weight: bold;">${historyTokens.toLocaleString()} tokens</div>
            `;
            messagesContainer.appendChild(historySummary);
            
            // 显示每条消息
            if (messageDetails.length === 0) {
                const emptyMsg = document.createElement('div');
                emptyMsg.style.cssText = 'text-align: center; color: #999; padding: 20px; background: white; border-radius: 6px; border: 1px solid #ddd;';
                emptyMsg.textContent = '暂无历史消息';
                messagesContainer.appendChild(emptyMsg);
            } else {
                messageDetails.forEach(msg => {
                    const messageItem = document.createElement('div');
                    messageItem.style.cssText = 'background: white; border-radius: 6px; padding: 10px; margin-bottom: 8px; border: 1px solid #ddd;';
                    
                    const percentage = ((msg.tokens / historyTokens) * 100).toFixed(1);
                    messageItem.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                            <div style="font-weight: 600; color: #333; font-size: 13px;">#${msg.index} ${msg.sender}</div>
                            <div style="font-weight: bold; color: #333; font-size: 14px;">${msg.tokens.toLocaleString()} tokens (${percentage}%)</div>
                        </div>
                        <div style="font-size: 12px; color: #666; line-height: 1.4;">${msg.content}</div>
                    `;
                    
                    messagesContainer.appendChild(messageItem);
                });
            }
            
            // 显示模态框
            document.getElementById('token-details-modal').classList.add('visible');
        }

        function updateCustomBubbleStyle(chatId, css, enabled) {
            const styleId = `custom-bubble-style-for-${chatId}`;
            let styleElement = document.getElementById(styleId);

            if (enabled && css) {
                if (!styleElement) {
                    styleElement = document.createElement('style');
                    styleElement.id = styleId;
                    document.head.appendChild(styleElement);
                }
                const scopedCss = css.replace(/(\.message-bubble(?:\.sent|\.received)?)/g, `#chat-room-screen.chat-active-${chatId} $1`);
                styleElement.innerHTML = scopedCss;
            } else {
                if (styleElement) styleElement.remove();
            }
        }

        function updateBubbleCssPreview(previewContainer, css, useDefault, theme) {
            previewContainer.innerHTML = '';

            const sentBubble = document.createElement('div');
            sentBubble.className = 'message-bubble sent';
            sentBubble.textContent = '这是我方气泡。';
            sentBubble.style.alignSelf = 'flex-end';
            sentBubble.style.borderBottomRightRadius = '5px';

            const receivedBubble = document.createElement('div');
            receivedBubble.className = 'message-bubble received';
            receivedBubble.textContent = '这是对方气泡。';
            receivedBubble.style.alignSelf = 'flex-start';
            receivedBubble.style.borderBottomLeftRadius = '5px';

            [sentBubble, receivedBubble].forEach(bubble => {
                bubble.style.maxWidth = '70%';
                bubble.style.padding = '8px 12px';
                bubble.style.wordWrap = 'break-word';
                bubble.style.lineHeight = '1.4';
            });

            if (useDefault || !css) {
                sentBubble.style.backgroundColor = theme.sent.bg;
                sentBubble.style.color = theme.sent.text;
                sentBubble.style.borderRadius = '18px';
                sentBubble.style.borderBottomRightRadius = '5px';
                receivedBubble.style.backgroundColor = theme.received.bg;
                receivedBubble.style.color = theme.received.text;
                receivedBubble.style.borderRadius = '18px';
                receivedBubble.style.borderBottomLeftRadius = '5px';
            } else {
                const styleTag = document.createElement('style');
                const scopedCss = css.replace(/(\.message-bubble(?:\.sent|\.received)?)/g, `#${previewContainer.id} $1`);
                styleTag.textContent = scopedCss;
                previewContainer.appendChild(styleTag);
            }
            previewContainer.appendChild(receivedBubble);
            previewContainer.appendChild(sentBubble);
        }

        const init = async () => {
            await loadData();
            
            // 图片大图查看器关闭事件
            const imageViewer = document.getElementById('image-viewer');
            if (imageViewer) {
                imageViewer.addEventListener('click', () => {
                    imageViewer.style.display = 'none';
                });
            }
            
            document.body.addEventListener('click', (e) => {
                if (e.target.closest('.context-menu')) {
                    e.stopPropagation();
                    return;
                }
                removeContextMenu();

                const backBtn = e.target.closest('.back-btn');
                if (backBtn) {
                    e.preventDefault();
                    // 如果当前是NPC角色，返回到父角色聊天
                    const currentChar = db.characters.find(c => c.id === currentChatId);
                    if (currentChar && currentChar.isNPC && currentChar.parentCharacterId) {
                        // 先设置currentChatId和currentChatType
                        currentChatId = currentChar.parentCharacterId;
                        currentChatType = 'private';
                        // 然后打开父角色聊天
                        openChatRoom(currentChar.parentCharacterId, 'private');
                        return;
                    }
                    switchScreen(backBtn.getAttribute('data-target'));
                }

                // Consolidated overlay closing logic
                const openOverlay = document.querySelector('.modal-overlay.visible, .action-sheet-overlay.visible');
                if (openOverlay && e.target === openOverlay) {
                    openOverlay.classList.remove('visible');
                }
            });

            // Specific nav links that switch screens
            document.body.addEventListener('click', e => {
                const navLink = e.target.closest('.app-icon[data-target]');
                if (navLink) {
                    e.preventDefault();
                    switchScreen(navLink.getAttribute('data-target'));
                }
            });

            updateClock();
            setInterval(updateClock, 30000);
            applyGlobalFont(db.fontUrl);
            applyGlobalFontSize(db.fontSize);
            initStatusBar(); // 初始化顶部状态栏
            initLockScreen(); // 初始化锁屏页面
            
            // 应用语言设置
            if (db.enableLanguageSwitch && db.appLanguage) {
                applyLanguage(db.appLanguage);
            }
            
            setupHomeScreen();
            setupChatListScreen();
            setupAddCharModal();
            setupChatRoom();
            setupChatSettings();
            setupApiSettingsApp();
            setupWallpaperApp();
            await setupStickerSystem();
            setupVoiceMessageSystem();
            setupPhotoVideoSystem();
            setupImageRecognition();
            setupWalletSystem();
            setupGiftSystem();
            setupWaimaiSystem();
            setupShareLinkSystem();
            setupLocationShareSystem();
            setupWaimaiInterface();
            setupRegenerateResponseSystem();
            setupStopGenerationSystem();
            setupTimeSkipSystem();
            setupWorldBookApp();
            setupFontSettingsApp();
            setupGroupChatSystem();
            setupCustomizeApp();
            setupTutorialApp();
            
            // 应用悬浮歌词样式
            applyFloatingLyricsStyles();
        };

        // ===== 后台发消息功能开始 =====
        
        /**
         * 解析AI返回的响应内容
         * @param {string} content - AI返回的原始字符串
         * @returns {Array} - 标准化的消息对象数组
         */
        function parseAiResponse(content) {
            const trimmedContent = content.trim();

            // 方案1：尝试作为标准JSON数组解析
            if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
                try {
                    const parsed = JSON.parse(trimmedContent);
                    if (Array.isArray(parsed)) {
                        console.log("解析成功：标准JSON数组格式。");
                        return parsed;
                    }
                } catch (e) {
                    console.warn("标准JSON数组解析失败，将尝试强力解析...");
                }
            }

            // 方案2：使用正则表达式提取JSON对象
            const jsonMatches = trimmedContent.match(/{[^{}]*}/g);
            if (jsonMatches) {
                const results = [];
                for (const match of jsonMatches) {
                    try {
                        const parsedObject = JSON.parse(match);
                        results.push(parsedObject);
                    } catch (e) {
                        console.warn("跳过一个无效的JSON片段:", match);
                    }
                }
                if (results.length > 0) {
                    console.log("解析成功：通过强力提取模式。");
                    return results;
                }
            }
            
            // 方案3：返回原始文本
            console.error("所有解析方案均失败！将返回原始文本。");
            return [{ type: 'text', content: content }];
        }
        
        /**
         * 启动后台活动模拟
         */
        function startBackgroundSimulation() {
            if (simulationIntervalId) return;
            
            // 【修复】收集所有可能的检测间隔
            const intervals = [];
            
            // 如果全局启用了后台活动，添加全局间隔
            if (db.enableBackgroundActivity && db.backgroundActivityInterval) {
                intervals.push(db.backgroundActivityInterval);
            }
            
            // 收集所有启用了后台活动的角色的间隔
            const allCharacters = db.characters || [];
            allCharacters.forEach(char => {
                if (char.enableBackgroundActivity && char.backgroundActivityInterval) {
                    intervals.push(char.backgroundActivityInterval);
                }
            });
            
            // 如果没有任何间隔设置，使用默认值60秒
            const minInterval = intervals.length > 0 ? Math.min(...intervals) : 60;
            
            simulationIntervalId = setInterval(runBackgroundSimulationTick, minInterval * 1000);
            console.log(`后台活动已启动，检测间隔: ${minInterval}秒`);
        }

        /**
         * 停止后台活动模拟
         */
        function stopBackgroundSimulation() {
            if (simulationIntervalId) {
                clearInterval(simulationIntervalId);
                simulationIntervalId = null;
                console.log('后台活动已停止');
            }
        }

        /**
         * 后台活动心跳检查
         */
        function runBackgroundSimulationTick() {
            console.log("后台活动心跳 Tick...");
            
            // 获取所有私聊角色
            const allCharacters = db.characters || [];
            if (allCharacters.length === 0) return;

            // 检查是否有任何角色启用了后台活动（全局或角色专属）
            const hasAnyBackgroundActivity = db.enableBackgroundActivity || allCharacters.some(c => c.enableBackgroundActivity);
            if (!hasAnyBackgroundActivity) {
                stopBackgroundSimulation();
                return;
            }

            const now = Date.now();
            allCharacters.forEach(character => {
                // 初始化角色的上次检测时间
                if (!character.lastBackgroundCheck) {
                    character.lastBackgroundCheck = now;
                }
                
                // 获取该角色的检测间隔（角色专属优先，否则使用全局设置）
                const checkInterval = (character.backgroundActivityInterval !== undefined ? 
                                      character.backgroundActivityInterval : 
                                      (db.backgroundActivityInterval || 60)) * 1000;
                
                // 检查是否到了该角色的检测时间
                if (now - character.lastBackgroundCheck < checkInterval) {
                    return; // 还没到检测时间，跳过
                }
                
                // 更新上次检测时间
                character.lastBackgroundCheck = now;
                // 【核心修正】将两种状态检查分离开，逻辑更清晰

                // 检查1：处理【被用户拉黑】的角色
                if (character.relationship?.status === 'blocked_by_user') {
                    const blockedTimestamp = character.relationship.blockedTimestamp;
                    // 安全检查：确保有拉黑时间戳
                    if (!blockedTimestamp) {
                        console.warn(`角色 "${character.remarkName}" 状态为拉黑，但缺少拉黑时间戳，跳过处理。`);
                        return; // 跳过这个角色，继续下一个
                    }

                    const blockedDuration = Date.now() - blockedTimestamp;
                    // 优先使用角色自己的冷静期设置，如果没有则使用全局设置
                    const cooldownHours = character.blockCooldownHours !== undefined ? character.blockCooldownHours : (db.blockCooldownHours || 1);
                    const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;

                    console.log(`检查角色 "${character.remarkName}"：已拉黑 ${Math.round(blockedDuration/1000/60)}分钟，冷静期需 ${cooldownMilliseconds/1000/60}分钟。`);

                    // 【核心修改】移除了随机概率，只要冷静期一过，就触发！
                    if (blockedDuration > cooldownMilliseconds) {
                        console.log(`角色 "${character.remarkName}" 的冷静期已过，触发"反思"并申请好友事件...`);
                        
                        // 【重要】为了防止在AI响应前重复触发，我们在触发后立刻更新状态
                        character.relationship.status = 'pending_system_reflection'; // 设置一个临时的、防止重复触发的状态
                        
                        triggerAiFriendApplication(character.id);
                    }
                }
                // 检查2：处理【好友关系】的正常后台活动
                else if ((!character.relationship || character.relationship.status === 'friend') && character.id !== currentChatId) {
                    // 检查该角色是否启用了后台活动（角色专属优先，否则使用全局设置）
                    const isBackgroundEnabled = character.enableBackgroundActivity === true || 
                                               (character.enableBackgroundActivity !== false && db.enableBackgroundActivity === true);
                    
                    if (!isBackgroundEnabled) {
                        return; // 跳过未启用后台活动的角色
                    }
                    
                    // 优先使用角色专属的唤醒概率，如果没有则使用全局设置
                    const probability = (character.backgroundActivityProbability !== undefined ? 
                                        character.backgroundActivityProbability : 
                                        (db.backgroundActivityProbability || 20)) / 100;
                    
                    // 这里的随机触发逻辑保持不变，因为我们不希望所有好友同时行动
                    if (Math.random() < probability) {
                        const characterName = character.remarkName || character.realName || '未命名角色';
                        console.log(`角色 "${characterName}" 被唤醒（概率: ${(probability * 100).toFixed(0)}%），准备独立行动...`);
                        triggerBackgroundAiAction(character.id);
                    }
                }
                
                // 检查3：处理【CHAR主动拉群】功能
                if (character.enableAutoGroup && (!character.relationship || character.relationship.status === 'friend')) {
                    // 初始化角色的上次拉群检测时间
                    if (!character.lastAutoGroupCheck) {
                        character.lastAutoGroupCheck = now;
                    }
                    
                    // 获取该角色的拉群检测间隔（角色专属优先，否则使用后台活动间隔）
                    const autoGroupCheckInterval = (character.autoGroupInterval !== undefined ? 
                                                    character.autoGroupInterval : 
                                                    (character.backgroundActivityInterval !== undefined ? 
                                                     character.backgroundActivityInterval : 
                                                     (db.backgroundActivityInterval || 60))) * 1000;
                    
                    // 检查是否到了该角色的拉群检测时间
                    if (now - character.lastAutoGroupCheck < autoGroupCheckInterval) {
                        return; // 还没到检测时间，跳过
                    }
                    
                    // 更新上次检测时间
                    character.lastAutoGroupCheck = now;
                    
                    // 计算可用成员数量（NPC + USER）
                    const npcCount = character.npcLibrary ? character.npcLibrary.length : 0;
                    const totalAvailableMembers = npcCount + 1; // +1 是USER
                    
                    // 至少需要2个成员（可以是1个NPC+USER，或者2个NPC，或者没有NPC只有USER也行，由AI决定）
                    if (totalAvailableMembers < 2) {
                        return; // 总成员数不足2个
                    }
                    
                    // 5%的概率触发拉群（避免过于频繁）
                    if (Math.random() < 0.05) {
                        const characterName = character.remarkName || character.realName || '未命名角色';
                        console.log(`角色 "${characterName}" 准备主动拉群...`);
                        triggerAutoGroupCreation(character.id);
                    }
                }
            });
        }

        /**
         * 触发AI角色的后台独立行动
         */
        async function triggerBackgroundAiAction(characterId) {
            const character = db.characters.find(c => c.id === characterId);
            if (!character) {
                console.warn('未找到角色ID:', characterId);
                return;
            }

            // 从db.apiSettings读取API配置
            const apiUrl = db.apiSettings?.url;
            const apiKey = db.apiSettings?.key;
            const model = db.apiSettings?.model;
            
            if (!apiUrl || !apiKey || !model) {
                console.warn('API配置不完整，无法执行后台活动。当前配置:', { apiUrl, apiKey: apiKey ? '已设置' : '未设置', model });
                return;
            }
            
            // 获取角色名称
            const characterName = character.remarkName || character.realName || '未命名角色';
            console.log(`开始为角色 "${characterName}" 执行后台活动...`);

            try {
                const now = new Date();
                const currentTime = now.toLocaleTimeString('zh-CN', { hour: 'numeric', minute: 'numeric', hour12: true });
                const userNickname = character.myName || '用户';

                // 获取最近的对话摘要
                const messages = await dataStorage.getChatMessages(characterId, 'private', 10);
                const lastUserMessage = messages.filter(m => m.role === 'user').slice(-1)[0];
                const lastAiMessage = messages.filter(m => m.role === 'assistant').slice(-1)[0];
                
                let recentContextSummary = "你们最近没有聊过天。";
                let timeAwarenessContext = "";
                
                if (lastUserMessage) {
                    recentContextSummary = `用户 (${userNickname}) 最后对你说："${String(lastUserMessage.content).substring(0, 50)}..."。`;
                }
                if (lastAiMessage) {
                    recentContextSummary += `\n你最后对用户说："${String(lastAiMessage.content).substring(0, 50)}..."。`;
                    
                    // 【新增】计算时间差，增强时间感知
                    const timeDiffHours = (Date.now() - lastAiMessage.timestamp) / (1000 * 60 * 60);
                    if (timeDiffHours > 3) {
                        const diffDays = Math.floor(timeDiffHours / 24);
                        const timeDesc = diffDays > 0 ? `${diffDays}天` : `${Math.floor(timeDiffHours)}小时`;
                        timeAwarenessContext = `\n\n# ⚠️ 时间感知 - 重要提示\n`;
                        timeAwarenessContext += `- 你们已经有**${timeDesc}**没有聊天了！\n`;
                        timeAwarenessContext += `- 你【绝对不能】延续${timeDesc}前的话题或状态！\n`;
                        timeAwarenessContext += `- 如果你${timeDesc}前说自己在喝酒/吃饭/看电影等，现在【绝对不能】还在做同样的事！\n`;
                        timeAwarenessContext += `- 你【必须】根据当前时间（${currentTime}）和你的人设，开启一个全新的、符合当前时间的话题或状态。\n`;
                        timeAwarenessContext += `- 例如：如果现在是早上，你可以说刚起床；如果是晚上，你可以说在准备睡觉等。\n`;
                    }
                }
                
                // 构建系统提示词
                const systemPrompt = `
# 你的任务
你现在扮演一个名为"${characterName}"的角色。你已经有一段时间没有和用户（${userNickname}）互动了，现在你有机会【主动】做点什么，来表现你的个性和独立生活。这是一个秘密的、后台的独立行动。

# 你的可选行动:
1.  **发消息**: 主动给用户发送消息，分享你的想法或问候。你可以一次发送多条消息（1-100条），根据上下文和你的心情决定。

# 指令格式 (你的回复【必须】是包含一个或多个对象的JSON数组):
-   **发送单条消息**: \`[{"type": "text", "content": "你想对用户说的话..."}]\`
-   **发送多条消息**: \`[{"type": "text", "content": "第一条消息"}, {"type": "text", "content": "第二条消息"}, {"type": "text", "content": "第三条消息"}]\`
-   **共享位置**: \`[{"type": "location_share", "content": "位置名称，如：星巴克、学校图书馆、家里等"}]\`
-   **分享链接**: \`[{"type": "share_link", "title": "链接标题", "description": "摘要描述（可选）", "source_name": "来源名称（可选）", "content": "完整内容（可选）"}]\`

# 心声功能
✨重要✨ 在你每次发送消息后，必须添加一段心声。心声是你内心的真实想法，用第一人称"我"的角度，简短地（50-100字）表达你此刻的真实感受、想法或情绪。
格式为：[心声: xxx]。这段心声不会被用户直接看到，但会被记录下来。
心声应该：
- 用第一人称"我"的角度
- 简短精炼，50-100字左右
- 表达真实的内心想法、情绪或感受
- 可以与发送的消息内容有所不同（表里不一也可以）
- ✨重要✨ 心声的语言应该与你的角色性格、国籍、语言习惯保持一致。如果你是英语角色，心声用英语；如果你是日语角色，心声用日语；如果你是中文角色，心声用中文。心声语言要符合你的角色设定。
示例：[心声: 虽然表面上装作不在意，但其实我很开心能主动联系Ta，心里有点小激动...]

# 重要提示:
- 你可以根据情况发送1-100条消息
- 即使最后一条消息是你发的，你也可以继续发送新消息（比如追问、补充说明等）
- 如果用户很久没回复，你可以发送多条消息表达你的想法或关心
- 根据对话上下文和你的人设，自然地表达
- 每次发送消息后都要添加心声
${timeAwarenessContext}

# 供你决策的参考信息：
-   **你的角色设定**: ${character.persona || '无特定设定'}
-   **当前时间**: ${currentTime}
-   **你们最后的对话摘要**: ${recentContextSummary}

请根据你的人设和当前情况，决定要发送几条消息。如果不想发送，请返回空数组 []。`;

                const messagesPayload = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: '[系统指令：请根据你在 system prompt 中读到的规则，开始你的独立行动。]' }
                ];

                console.log("正在为后台活动发送API请求...");

                // 发送API请求
                const isGemini = apiUrl.includes('generativelanguage.googleapis.com');
                let response;
                
                if (isGemini) {
                    // Gemini API格式
                    const geminiBody = {
                        contents: messagesPayload.map(msg => ({
                            role: msg.role === 'assistant' ? 'model' : 'user',
                            parts: [{ text: msg.content }]
                        }))
                    };
                    response = await fetch(`${apiUrl}/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(geminiBody)
                    });
                } else {
                    response = await fetch(`${apiUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: model,
                            messages: messagesPayload,
                            temperature: 0.9,
                        })
                    });
                }

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API请求失败: ${response.status} - ${JSON.stringify(errorData)}`);
                }

                const data = await response.json();
                let responseText;
                
                if (isGemini) {
                    responseText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                } else {
                    responseText = data.choices?.[0]?.message?.content;
                }

                if (!responseText) {
                    console.warn(`API响应为空，角色 "${character.name}" 的本次后台活动跳过。`);
                    return;
                }

                // 提取心声
                let innerThought = null;
                const innerThoughtRegex = /\[心声[:：]\s*([\s\S]+?)\]/;
                const innerThoughtMatch = responseText.match(innerThoughtRegex);
                if (innerThoughtMatch) {
                    innerThought = innerThoughtMatch[1].trim();
                    // 从响应中移除心声部分
                    responseText = responseText.replace(innerThoughtRegex, '').trim();
                }

                // 解析AI返回的指令
                const responseArray = parseAiResponse(responseText);

                // 收集所有要发送的消息
                const messagesToSend = [];
                for (const action of responseArray) {
                    if (!action) continue;
                    if (action.type === 'text' && action.content) {
                        const message = {
                            role: 'assistant',
                            content: String(action.content),
                            timestamp: Date.now()
                        };
                        // 只给第一条消息添加心声
                        if (innerThought && messagesToSend.length === 0) {
                            message.innerThought = innerThought;
                        }
                        messagesToSend.push(message);
                    } else if (action.type === 'location_share' && action.content) {
                        const hardcodedImageUrl = 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756262526935_qdqqd_4uque3.jpeg';
                        const message = {
                            role: 'assistant',
                            type: 'location_share',
                            content: String(action.content),
                            imageUrl: hardcodedImageUrl,
                            timestamp: Date.now()
                        };
                        // 只给第一条消息添加心声
                        if (innerThought && messagesToSend.length === 0) {
                            message.innerThought = innerThought;
                        }
                        messagesToSend.push(message);
                    } else if (action.type === 'share_link' && action.title) {
                        const message = {
                            role: 'assistant',
                            type: 'share_link',
                            content: `[分享了链接：${action.title}]`,
                            title: String(action.title),
                            description: action.description ? String(action.description) : '',
                            source_name: action.source_name ? String(action.source_name) : '链接分享',
                            content: action.content ? String(action.content) : '',
                            timestamp: Date.now()
                        };
                        // 只给第一条消息添加心声
                        if (innerThought && messagesToSend.length === 0) {
                            message.innerThought = innerThought;
                        }
                        messagesToSend.push(message);
                    }
                }

                // 如果有消息要发送
                if (messagesToSend.length > 0) {
                    // 【性能优化】如果当前聊天室已打开且已加载完整历史，直接操作内存
                    if (currentChatId === characterId && currentChatType === 'private' && character._fullHistoryLoaded) {
                        character.history.push(...messagesToSend);
                        await dataStorage.saveChatMessages(characterId, 'private', character.history);
                    } else {
                        // 否则使用增量保存，避免加载完整历史
                        const existingMessages = await dataStorage.getChatMessages(characterId, 'private');
                        existingMessages.push(...messagesToSend);
                        await dataStorage.saveChatMessages(characterId, 'private', existingMessages);
                    }

                    // 更新未读计数
                    character.unreadCount = (character.unreadCount || 0) + messagesToSend.length;
                    await saveData();

                    // 只显示最后一条消息的通知
                    const lastMessage = messagesToSend[messagesToSend.length - 1];
                    const notificationContent = messagesToSend.length > 1 
                        ? `发送了${messagesToSend.length}条消息：${lastMessage.content}` 
                        : lastMessage.content;
                    showNotification(characterId, notificationContent);

                    // 如果当前正在聊天列表页面，刷新列表
                    if (document.getElementById('chat-list-screen').classList.contains('active')) {
                        renderChatList();
                    }

                    const characterName = character.remarkName || character.realName || '未命名角色';
                    console.log(`后台活动: 角色 "${characterName}" 主动发送了${messagesToSend.length}条消息:`);
                    messagesToSend.forEach((msg, index) => {
                        console.log(`  消息${index + 1}: ${msg.content}`);
                    });
                }
            } catch (error) {
                const characterName = character.remarkName || character.realName || '未命名角色';
                console.error(`角色 "${characterName}" 的后台活动失败:`, error);
            }
        }

        // ===== 后台发消息功能结束 =====

        /**
         * 【全新】CHAR主动拉群功能
         */
        async function triggerAutoGroupCreation(characterId) {
            const character = db.characters.find(c => c.id === characterId);
            if (!character) {
                console.warn('未找到角色ID:', characterId);
                return;
            }

            // 检查API配置
            const apiUrl = db.apiSettings?.url;
            const apiKey = db.apiSettings?.key;
            const model = db.apiSettings?.model;
            
            if (!apiUrl || !apiKey || !model) {
                console.warn('API配置不完整，无法执行主动拉群');
                return;
            }

            const characterName = character.remarkName || character.realName || '未命名角色';
            console.log(`开始为角色 "${characterName}" 执行主动拉群...`);

            try {
                const now = new Date();
                const currentTime = now.toLocaleTimeString('zh-CN', { hour: 'numeric', minute: 'numeric', hour12: true });
                const userNickname = character.myName || '用户';

                // 获取最近的对话上下文（使用角色的maxMemory设置）
                const maxMemory = parseInt(character.maxMemory) || 10;
                const messages = await dataStorage.getChatMessages(characterId, 'private', maxMemory);
                
                let recentContextSummary = "你们最近没有聊过天。";
                if (messages && messages.length > 0) {
                    // 构建完整的对话历史
                    const conversationHistory = messages.map(msg => {
                        const speaker = msg.role === 'user' ? userNickname : characterName;
                        return `${speaker}: ${msg.content}`;
                    }).join('\n');
                    recentContextSummary = `你们最近的对话（最近${messages.length}条）：\n${conversationHistory}`;
                }

                // 获取长期记忆（记忆库）
                let memoryLibrary = '';
                if (character.persona && character.persona.includes('char')) {
                    try {
                        const summaries = await dataStorage.db.memorySummaries
                            .where('chatId').equals(characterId)
                            .and(item => item.chatType === 'private')
                            .toArray();
                        
                        if (summaries && summaries.length > 0) {
                            memoryLibrary = '\n\n# 你的长期记忆（记忆库）:\n';
                            memoryLibrary += summaries.map(s => `- ${s.summary}`).join('\n');
                        }
                    } catch (error) {
                        console.warn('获取记忆库失败:', error);
                    }
                }

                // 构建NPC列表信息
                const hasNPCs = character.npcLibrary && character.npcLibrary.length > 0;
                const npcListInfo = hasNPCs 
                    ? character.npcLibrary.map((npc, index) => 
                        `${index + 1}. ${npc.name} - ${npc.persona}`
                      ).join('\n')
                    : '（你目前没有NPC朋友）';

                // 构建系统提示词
                const systemPrompt = `
# 你的任务
你现在扮演"${characterName}"。你想要创建一个群聊。

# 你的朋友圈（NPC库）:
${npcListInfo}

# 决策要求
你需要决定：
1. **群聊名称**: 起一个有趣、符合你性格的群名（5-15字）
2. **选择成员**: ${hasNPCs ? `从上面的NPC列表中选择成员（填写NPC的名字，可以选0-${Math.min(character.npcLibrary.length, 8)}个）` : '你没有NPC朋友'}
3. **是否邀请用户**: 决定是否邀请${userNickname}加入群聊（true/false）
4. **创建理由**: 简短说明为什么要创建这个群（20-50字）

# 决策参考信息
- **你的人设**: ${character.persona || '无特定设定'}
- **当前时间**: ${currentTime}
- **你和${userNickname}的最近对话**: ${recentContextSummary}${memoryLibrary}

# 回复格式（必须是有效的JSON）
{
    "groupName": "群聊名称",
    "selectedNPCs": ["NPC名字1", "NPC名字2"],
    "includeUser": true,
    "reason": "创建理由"
}

# 重要提示
- 群聊总人数（你+NPC+USER）必须≥2人
- 如果没有NPC，你必须邀请${userNickname}
- 如果有NPC，你可以选择邀请或不邀请${userNickname}
- selectedNPCs可以是空数组[]（如果只想和${userNickname}单独聊）
- 群名要有创意，符合你的性格和拉群理由
- 如果不邀请${userNickname}，这将是一个旁观者群聊
- 请只返回JSON，不要有其他文字`;

                const messagesPayload = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: '请根据你的人设和当前情况，决定如何创建群聊。' }
                ];

                console.log("正在请求AI决定拉群方案...");

                // 发送API请求
                const isGemini = apiUrl.includes('generativelanguage.googleapis.com');
                let response;
                
                if (isGemini) {
                    const geminiBody = {
                        contents: messagesPayload.map(msg => ({
                            role: msg.role === 'assistant' ? 'model' : 'user',
                            parts: [{ text: msg.content }]
                        }))
                    };
                    response = await fetch(`${apiUrl}/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(geminiBody)
                    });
                } else {
                    response = await fetch(`${apiUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: model,
                            messages: messagesPayload,
                            temperature: 0.8,
                        })
                    });
                }

                if (!response.ok) {
                    throw new Error(`API请求失败: ${response.status}`);
                }

                const data = await response.json();
                let responseText;
                
                if (isGemini) {
                    responseText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                } else {
                    responseText = data.choices?.[0]?.message?.content || '';
                }

                console.log("AI拉群决策原始回复:", responseText);

                // 解析JSON
                const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                if (!jsonMatch) {
                    throw new Error('AI回复格式错误，未找到JSON');
                }

                const decision = JSON.parse(jsonMatch[0]);
                console.log("AI拉群决策:", decision);

                // 验证决策
                if (!decision.groupName || !decision.selectedNPCs || !Array.isArray(decision.selectedNPCs)) {
                    throw new Error('AI决策格式不完整');
                }

                const includeUser = decision.includeUser === true;

                // 查找选中的NPC
                const selectedNPCs = [];
                if (character.npcLibrary && character.npcLibrary.length > 0) {
                    for (const npcName of decision.selectedNPCs) {
                        const npc = character.npcLibrary.find(n => n.name === npcName);
                        if (npc) {
                            selectedNPCs.push(npc);
                        }
                    }
                }

                // 验证总人数（CHAR + NPC + USER）≥ 2
                const totalMembers = 1 + selectedNPCs.length + (includeUser ? 1 : 0);
                if (totalMembers < 2) {
                    throw new Error('群聊总人数不足2人');
                }

                // 创建群聊
                const groupId = `group_${Date.now()}`;

                // 构建群成员列表
                const members = selectedNPCs.map((npc, index) => ({
                    id: `member_${npc.id}`,
                    originalCharId: null, // NPC没有对应的角色ID
                    realName: npc.name,
                    groupNickname: npc.name,
                    persona: npc.persona,
                    avatar: npc.avatar || 'https://i.postimg.cc/fTLCngk1/image.jpg',
                    isOwner: index === 0, // 第一个NPC是群主（实际上CHAR是创建者）
                    isNPC: true,
                    npcData: npc
                }));

                // 添加CHAR自己作为成员
                members.unshift({
                    id: `member_${character.id}`,
                    originalCharId: character.id,
                    realName: character.realName,
                    groupNickname: character.remarkName,
                    persona: character.persona,
                    avatar: character.avatar,
                    isOwner: true, // CHAR是真正的群主
                    isNPC: false
                });

                const newGroup = {
                    id: groupId,
                    name: decision.groupName,
                    avatar: character.avatar, // 使用CHAR的头像作为群头像
                    me: includeUser ? {
                        nickname: userNickname,
                        persona: character.myPersona || '',
                        avatar: character.myAvatar || 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg',
                        isOwner: false,
                        isAdmin: false
                    } : null,
                    members: members,
                    theme: character.theme || 'white_pink',
                    maxMemory: 10,
                    chatBg: character.chatBg || '',
                    history: [],
                    isPinned: false,
                    useCustomBubbleCss: false,
                    customBubbleCss: '',
                    worldBookIds: character.worldBookIds || getGlobalWorldBookIds(),
                    musicData: { totalTime: 0 },
                    unreadCount: 0,
                    mentionData: {
                        userMentionCount: 0,
                        userMentionDate: new Date().toDateString(),
                        mentions: []
                    },
                    innerThoughtEnabled: false,
                    isAutoCreated: true, // 标记为自动创建的群聊
                    creatorCharId: character.id, // 记录创建者
                    isObserverGroup: !includeUser // 是否为旁观者群聊
                };

                // 保存群聊
                if (!db.groups) db.groups = [];
                db.groups.push(newGroup);

                // 更新角色的拉群计数
                if (!character.autoGroupCreationCount) character.autoGroupCreationCount = 0;
                character.autoGroupCreationCount++;

                await saveData();

                console.log(`群聊"${decision.groupName}"创建成功！`);

                // 生成系统通知消息
                const systemMessage = {
                    id: `msg_${Date.now()}_system`,
                    role: 'system',
                    content: `${characterName}创建了群聊"${decision.groupName}"`,
                    timestamp: Date.now(),
                    type: 'system_notification'
                };

                // 【性能优化】先获取现有消息，追加系统消息，然后调用群组初始化
                // 群组初始化函数会继续追加并一次性保存所有消息
                const existingMessages = await dataStorage.getChatMessages(groupId, 'group');
                existingMessages.push(systemMessage);
                
                // 让CHAR和NPC主动发言（会在内部追加消息并保存）
                await triggerGroupInitialMessages(groupId, character, selectedNPCs, decision.reason, includeUser, existingMessages);

                // 更新未读计数
                newGroup.unreadCount = selectedNPCs.length + 1; // CHAR + 每个NPC至少一条消息
                await saveData();

                // 显示通知
                showNotification(groupId, `${characterName}创建了群聊"${decision.groupName}"并邀请了${selectedNPCs.length}个朋友${includeUser ? '和你' : ''}`);

                // 刷新聊天列表
                if (document.getElementById('chat-list-screen').classList.contains('active')) {
                    renderChatList();
                }

                console.log(`主动拉群完成: "${decision.groupName}"，成员: ${selectedNPCs.map(n => n.name).join(', ')}${includeUser ? `, ${userNickname}` : ''}`);

            } catch (error) {
                console.error(`角色 "${characterName}" 的主动拉群失败:`, error);
            }
        }

        /**
         * 触发群聊初始消息（CHAR和NPC主动发言）
         */
        async function triggerGroupInitialMessages(groupId, character, npcs, reason, includeUser, existingMessages = null) {
            const apiUrl = db.apiSettings?.url;
            const apiKey = db.apiSettings?.key;
            const model = db.apiSettings?.model;
            
            if (!apiUrl || !apiKey || !model) return;

            try {
                const characterName = character.remarkName || character.realName;
                const userNickname = character.myName || '用户';
                const npcNames = npcs.map(n => n.name).join('、');

                // 【性能优化】使用传入的消息数组，如果没有则获取
                let allMessages = existingMessages || await dataStorage.getChatMessages(groupId, 'group');

                // 1. CHAR先发言
                const membersInfo = npcs.length > 0 
                    ? `邀请了${npcNames}${includeUser ? `和${userNickname}` : ''}`
                    : `邀请了${userNickname}`;
                
                const charPrompt = `
你是${characterName}，你刚刚创建了一个群聊，${membersInfo}。
你创建这个群的理由是：${reason}

请根据你的性格和拉群理由，发送1-3条消息。

你的人设：${character.persona}

重要提示：
- 不一定要说"欢迎"，根据你的性格和拉群理由来决定说什么
- 如果是严肃的事，可以直接说正事
- 如果是随意的聚会，可以轻松一点
- 如果是紧急的事，可以直接切入主题
- 自然、口语化，符合你的性格
- 每条消息用换行符分隔

请直接输出消息内容，不要有其他格式。`;

                const charResponse = await callAIAPI(apiUrl, apiKey, model, charPrompt);
                const charMessages = charResponse.split('\n').filter(m => m.trim()).slice(0, 3);

                // 保存CHAR的消息到内存数组
                const charMessageObjects = charMessages.map((content, index) => ({
                    id: `msg_${Date.now()}_${index}`,
                    role: 'assistant',
                    content: content.trim(),
                    timestamp: Date.now() + index * 1000,
                    sender: {
                        id: `member_${character.id}`,
                        name: characterName,
                        avatar: character.avatar
                    }
                }));
                allMessages.push(...charMessageObjects);

                // 2. 让每个NPC依次发言
                for (let i = 0; i < npcs.length; i++) {
                    const npc = npcs[i];
                    
                    // 使用内存中的消息作为上下文
                    const contextSummary = allMessages.slice(-5).map(m => 
                        `${m.sender?.name || '系统'}: ${m.content}`
                    ).join('\n');

                    const npcPrompt = `
你是${npc.name}，你刚被${characterName}拉进了一个群聊。

你的人设：${npc.persona}

群里目前的对话：
${contextSummary}

请发送1-2条消息来回应，要求：
- 符合你的人设
- 自然、口语化
- 可以和其他人互动
- 每条消息用换行符分隔

请直接输出消息内容，不要有其他格式。`;

                    const npcResponse = await callAIAPI(apiUrl, apiKey, model, npcPrompt);
                    const npcMessages = npcResponse.split('\n').filter(m => m.trim()).slice(0, 2);

                    // 保存NPC的消息到内存数组
                    const npcMessageObjects = npcMessages.map((content, index) => ({
                        id: `msg_${Date.now()}_${i}_${index}`,
                        role: 'assistant',
                        content: content.trim(),
                        timestamp: Date.now() + (i + 1) * 3000 + index * 1000,
                        sender: {
                            id: `member_${npc.id}`,
                            name: npc.name,
                            avatar: npc.avatar || 'https://i.postimg.cc/fTLCngk1/image.jpg'
                        }
                    }));
                    allMessages.push(...npcMessageObjects);

                    // 延迟一下，让消息看起来更自然
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                // 【性能优化】一次性保存所有消息
                await dataStorage.saveChatMessages(groupId, 'group', allMessages);

                console.log(`群聊初始消息生成完成`);

            } catch (error) {
                console.error('生成群聊初始消息失败:', error);
            }
        }

        /**
         * 辅助函数：调用AI API
         */
        async function callAIAPI(apiUrl, apiKey, model, prompt) {
            const isGemini = apiUrl.includes('generativelanguage.googleapis.com');
            let response;
            
            if (isGemini) {
                const geminiBody = {
                    contents: [{
                        role: 'user',
                        parts: [{ text: prompt }]
                    }]
                };
                response = await fetch(`${apiUrl}/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(geminiBody)
                });
            } else {
                response = await fetch(`${apiUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [{ role: 'user', content: prompt }],
                        temperature: 0.9,
                    })
                });
            }

            if (!response.ok) {
                throw new Error(`API请求失败: ${response.status}`);
            }

            const data = await response.json();
            
            if (isGemini) {
                return data.candidates?.[0]?.content?.parts?.[0]?.text || '';
            } else {
                return data.choices?.[0]?.message?.content || '';
            }
        }

        // ===== CHAR主动拉群功能结束 =====

        /**
         * 【全新】触发AI角色的好友申请流程（被拉黑后的反思与申请）
         */
        async function triggerAiFriendApplication(characterId) {
            const character = db.characters.find(c => c.id === characterId);
            if (!character) return;

            const apiUrl = db.apiSettings?.url;
            const apiKey = db.apiSettings?.key;
            const model = db.apiSettings?.model;
            
            if (!apiUrl || !apiKey || !model) {
                console.warn('API配置不完整，无法执行好友申请流程');
                return;
            }

            try {
                console.log(`为角色 "${character.remarkName}" 触发好友申请流程...`);

                // 1. 抓取被拉黑前的最后5条聊天记录作为参考
                const allMessages = await dataStorage.getChatMessages(characterId, 'private');
                const contextMessages = allMessages
                    .filter(m => !m.isHidden)
                    .slice(-10, -5) // 获取拉黑前的最后5条消息
                    .map(msg => {
                        const sender = msg.role === 'user' ? '用户' : character.remarkName;
                        return `${sender}: ${msg.content}`;
                    });
                
                const contextSummary = contextMessages.length > 0 
                    ? contextMessages.join('\n') 
                    : '（无有效对话记录）';

                // 2. 获取世界书内容
                let worldBookContent = '';
                if (character.worldBookIds && character.worldBookIds.length > 0) {
                    const linkedContents = character.worldBookIds.map(bookId => {
                        const worldBook = db.worldBooks.find(wb => wb.id === bookId);
                        return worldBook ? `\n\n## 世界书: ${worldBook.name}\n${getWorldBookRealContent(worldBook)}` : '';
                    }).filter(Boolean).join('');
                    if (linkedContents) {
                        worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
                    }
                }

                const systemPrompt = `
# 你的任务
你现在是角色"${character.remarkName}"。你之前被用户（你的聊天对象）拉黑了，你们已经有一段时间没有联系了。
现在，你非常希望能够和好，重新和用户聊天。请你仔细分析下面的"被拉黑前的对话摘要"，理解当时发生了什么，然后思考一个真诚的、符合你人设、并且【针对具体事件】的申请理由。

# 你的角色设定
${character.persona || '无特定设定'}
${worldBookContent}

# 被拉黑前的对话摘要 (这是你被拉黑的关键原因)
${contextSummary}

# 指令格式
你的回复【必须】是一个JSON对象，格式如下：
\`\`\`json
{
    "reason": "你想对用户说的申请理由，要真诚、具体、符合你的人设"
}
\`\`\`

# 重要提示
- 你的申请理由应该针对上面的对话摘要，表现出你对之前发生的事情的理解和反思
- 不要使用空洞的套话，要真诚、具体
- 理由长度建议在50-200字之间
- 如果对话摘要为空，说明你们之前可能没有深入交流，你可以表达想要重新开始的愿望

请开始你的反思和申请。`;

                const messagesPayload = [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: '[系统指令：请根据你在 system prompt 中读到的规则，生成你的好友申请理由。]' }
                ];

                // 发送API请求
                const isGemini = apiUrl.includes('generativelanguage.googleapis.com');
                let response;
                
                if (isGemini) {
                    const geminiBody = {
                        contents: messagesPayload.map(msg => ({
                            role: msg.role === 'assistant' ? 'model' : 'user',
                            parts: [{ text: msg.content }]
                        }))
                    };
                    response = await fetch(`${apiUrl}/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(geminiBody)
                    });
                } else {
                    response = await fetch(`${apiUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: model,
                            messages: messagesPayload,
                            temperature: 0.8,
                        })
                    });
                }

                if (!response.ok) {
                    throw new Error(`API请求失败: ${response.status}`);
                }

                const data = await response.json();
                let responseText;
                
                if (isGemini) {
                    responseText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                } else {
                    responseText = data.choices?.[0]?.message?.content;
                }

                if (!responseText) {
                    throw new Error('API响应为空');
                }

                // 解析AI返回的申请理由
                const reasonObj = parseAiResponse(responseText);
                const applicationReason = reasonObj[0]?.reason || '我想和你重新开始聊天，可以吗？';

                // 3. 更新角色状态为"等待用户审批"
                character.relationship.status = 'pending_user_approval';
                character.relationship.applicationReason = applicationReason;

                // 4. 添加一条隐藏的系统消息
                const hiddenMessage = {
                    id: `msg_${Date.now()}`,
                    role: 'system',
                    content: `[系统提示：你刚刚向用户发送了好友申请，理由是："${applicationReason}"。现在等待对方的回应。]`,
                    parts: [{type: 'text', text: `[系统提示：你刚刚向用户发送了好友申请，理由是："${applicationReason}"。现在等待对方的回应。]`}],
                    timestamp: Date.now(),
                    isHidden: true
                };
                character.history.push(hiddenMessage);

                await saveData();

                // 5. 显示通知
                showNotification(characterId, `${character.remarkName}请求添加你为好友`);

                // 6. 刷新聊天列表
                if (document.getElementById('chat-list-screen').classList.contains('active')) {
                    renderChatList();
                }

                console.log(`角色 "${character.remarkName}" 的好友申请已发送，理由: ${applicationReason}`);

            } catch (error) {
                console.error(`角色 "${character.remarkName}" 的好友申请流程失败:`, error);
                // 如果失败，重置状态为被拉黑，让下次心跳可以重试
                character.relationship.status = 'blocked_by_user';
                await saveData();
            }
        }

        function updateClock() {
            const now = new Date();
            const timeDisplay = document.getElementById('time-display');
            const dateDisplay = document.getElementById('date-display');
            
            const timeText = `${pad(now.getHours())}:${pad(now.getMinutes())}`;
            const dateText = `${now.getFullYear()}年${pad(now.getMonth() + 1)}月${pad(now.getDate())}日`;
            
            if (timeDisplay) timeDisplay.textContent = timeText;
            if (dateDisplay) dateDisplay.textContent = dateText;
        }

        // --- 主屏幕页面滑动功能 ---
        function initHomeScreenSwipe() {
            const container = document.getElementById('home-pages-container');
            if (!container) return;

            let currentPage = 0;
            const totalPages = 2;
            let startX = 0;
            let currentX = 0;
            let isDragging = false;
            let startTime = 0;

            const updatePagePosition = (animate = true) => {
                if (animate) {
                    container.style.transition = 'transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                } else {
                    container.style.transition = 'none';
                }
                container.style.transform = `translateX(-${currentPage * 50}%)`;
            };

            // 移动端触摸事件
            const handleTouchStart = (e) => {
                // 检查是否点击在可交互元素上
                if (e.target.closest('.app-icon') || e.target.closest('.dock')) {
                    return;
                }
                
                startX = e.touches[0].clientX;
                currentX = startX;
                isDragging = true;
                startTime = Date.now();
                container.style.transition = 'none';
            };

            const handleTouchMove = (e) => {
                if (!isDragging) return;
                
                currentX = e.touches[0].clientX;
                const deltaX = currentX - startX;
                const containerWidth = container.offsetWidth / 2; // 单页宽度
                const movePercent = (deltaX / containerWidth) * 50; // 转换为百分比
                
                // 限制滑动范围
                const targetTransform = -currentPage * 50 + movePercent;
                if (targetTransform > 0 || targetTransform < -50) {
                    // 在边界时添加阻尼效果
                    const dampedMove = movePercent * 0.3;
                    container.style.transform = `translateX(${-currentPage * 50 + dampedMove}%)`;
                } else {
                    container.style.transform = `translateX(${targetTransform}%)`;
                }
            };

            const handleTouchEnd = (e) => {
                if (!isDragging) return;
                isDragging = false;

                const deltaX = currentX - startX;
                const deltaTime = Date.now() - startTime;
                const velocity = Math.abs(deltaX) / deltaTime; // 速度
                const containerWidth = container.offsetWidth / 2;

                // 判断是否切换页面
                if (Math.abs(deltaX) > containerWidth * 0.3 || velocity > 0.5) {
                    if (deltaX > 0 && currentPage > 0) {
                        currentPage--;
                    } else if (deltaX < 0 && currentPage < totalPages - 1) {
                        currentPage++;
                    }
                }

                updatePagePosition(true);
            };

            // PC端键盘事件
            const handleKeyDown = (e) => {
                // 只在主屏幕激活时响应
                if (!homeScreen.classList.contains('active')) return;
                
                if (e.key === 'ArrowLeft' && currentPage > 0) {
                    e.preventDefault();
                    currentPage--;
                    updatePagePosition(true);
                } else if (e.key === 'ArrowRight' && currentPage < totalPages - 1) {
                    e.preventDefault();
                    currentPage++;
                    updatePagePosition(true);
                }
            };

            // 添加事件监听
            container.addEventListener('touchstart', handleTouchStart, { passive: true });
            container.addEventListener('touchmove', handleTouchMove, { passive: true });
            container.addEventListener('touchend', handleTouchEnd, { passive: true });
            document.addEventListener('keydown', handleKeyDown);

            // 初始化位置
            updatePagePosition(false);
        }

        // --- 状态栏控制函数 ---
        let timeUpdateInterval = null;

        async function initStatusBar() {
            if (db.showStatusBar) {
                toggleStatusBar(true);
            }
        }

        function toggleStatusBar(show) {
            const statusBar = document.getElementById('status-bar');
            const phoneScreen = document.querySelector('.phone-screen');
            
            if (show) {
                statusBar.style.display = 'flex';
                // 给页面添加padding-top，避免与状态栏重叠
                if (phoneScreen) {
                    phoneScreen.style.paddingTop = '32px';
                }
                startStatusBarUpdates();
            } else {
                statusBar.style.display = 'none';
                // 移除padding-top
                if (phoneScreen) {
                    phoneScreen.style.paddingTop = '0';
                }
                stopStatusBarUpdates();
            }
        }

        function startStatusBarUpdates() {
            // 更新时间
            updateTime();
            if (timeUpdateInterval) clearInterval(timeUpdateInterval);
            timeUpdateInterval = setInterval(updateTime, 1000);

            // 初始化电量显示（只调用一次，后续由事件驱动）
            updateBattery();
        }

        function stopStatusBarUpdates() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
                timeUpdateInterval = null;
            }
        }

        // --- 锁屏功能 ---
        let lockScreenInterval = null;
        let lockScreenHandlers = null; // 保存事件处理器引用

        async function initLockScreen() {
            if (db.enableLockScreen) {
                showLockScreen();
            }
        }

        function showLockScreen() {
            const lockScreen = document.getElementById('lock-screen');
            lockScreen.classList.add('active');
            updateLockScreenTime();
            
            // 应用锁屏壁纸
            if (db.lockScreenWallpaper) {
                if (db.lockScreenWallpaper.startsWith('linear-gradient') || db.lockScreenWallpaper.startsWith('radial-gradient')) {
                    lockScreen.style.background = db.lockScreenWallpaper;
                    lockScreen.style.backgroundImage = '';
                } else {
                    lockScreen.style.backgroundImage = `url(${db.lockScreenWallpaper})`;
                    lockScreen.style.backgroundSize = 'cover';
                    lockScreen.style.backgroundPosition = 'center';
                }
            }
            
            // 开始更新时间
            if (lockScreenInterval) clearInterval(lockScreenInterval);
            lockScreenInterval = setInterval(updateLockScreenTime, 1000);
            
            // 根据密码类型显示对应的解锁界面
            const unlockSwipe = document.getElementById('unlock-swipe');
            const unlockPin = document.getElementById('unlock-pin');
            const unlockGesture = document.getElementById('unlock-gesture');
            const unlockText = document.getElementById('unlock-text');
            
            let passwordType = db.lockScreenPassword?.type || 'none';
            
            // 检查密码是否已设置，如果选择了密码类型但密码为空，降级到无密码模式
            if (passwordType === 'pin' && !db.lockScreenPassword?.pin) {
                passwordType = 'none';
            } else if (passwordType === 'gesture' && (!db.lockScreenPassword?.gesture || db.lockScreenPassword.gesture.length === 0)) {
                passwordType = 'none';
            }
            
            // 初始都隐藏密码输入界面，先显示上滑指示器
            unlockSwipe.style.display = 'flex';
            unlockPin.style.display = 'none';
            unlockPin.style.opacity = '0';
            unlockGesture.style.display = 'none';
            unlockGesture.style.opacity = '0';
            
            // 根据密码类型设置提示文字
            if (passwordType === 'pin') {
                unlockText.textContent = '上滑输入密码 / 按↑键输入密码';
            } else if (passwordType === 'gesture') {
                unlockText.textContent = '上滑绘制手势 / 按↑键绘制手势';
            } else {
                unlockText.textContent = '上滑解锁 / 按↑键解锁';
            }
            
            // 设置上滑解锁（传入密码类型）
            setupSwipeUnlock(passwordType);
        }

        function hideLockScreen() {
            const lockScreen = document.getElementById('lock-screen');
            lockScreen.classList.remove('active');
            
            if (lockScreenInterval) {
                clearInterval(lockScreenInterval);
                lockScreenInterval = null;
            }
            
            // 清理事件监听器
            if (lockScreenHandlers) {
                lockScreen.removeEventListener('touchstart', lockScreenHandlers.handleTouchStart);
                lockScreen.removeEventListener('touchmove', lockScreenHandlers.handleTouchMove);
                lockScreen.removeEventListener('touchend', lockScreenHandlers.handleTouchEnd);
                document.removeEventListener('keydown', lockScreenHandlers.handleKeyDown);
                
                // 清理数字密码输入事件
                if (lockScreenHandlers.pinHandlers) {
                    const pinInput = lockScreenHandlers.pinHandlers.pinInput;
                    if (pinInput) {
                        pinInput.removeEventListener('input', lockScreenHandlers.pinHandlers.handleInput);
                        pinInput.removeEventListener('keypress', lockScreenHandlers.pinHandlers.handleKeyPress);
                        pinInput.value = '';
                    }
                }
                
                // 清理手势密码输入事件
                if (lockScreenHandlers.gestureHandlers) {
                    const canvas = lockScreenHandlers.gestureHandlers.canvas;
                    if (canvas) {
                        canvas.removeEventListener('mousedown', lockScreenHandlers.gestureHandlers.handleStart);
                        canvas.removeEventListener('mousemove', lockScreenHandlers.gestureHandlers.handleMove);
                        canvas.removeEventListener('mouseup', lockScreenHandlers.gestureHandlers.handleEnd);
                        canvas.removeEventListener('touchstart', lockScreenHandlers.gestureHandlers.handleStart);
                        canvas.removeEventListener('touchmove', lockScreenHandlers.gestureHandlers.handleMove);
                        canvas.removeEventListener('touchend', lockScreenHandlers.gestureHandlers.handleEnd);
                    }
                }
                
                lockScreenHandlers = null;
            }
            
            // 重置密码输入界面状态，以便下次显示时从初始状态开始
            const unlockSwipe = document.getElementById('unlock-swipe');
            const unlockPin = document.getElementById('unlock-pin');
            const unlockGesture = document.getElementById('unlock-gesture');
            
            if (unlockSwipe) {
                unlockSwipe.style.display = 'flex';
                unlockSwipe.style.opacity = '1';
            }
            if (unlockPin) {
                unlockPin.style.display = 'none';
                unlockPin.style.opacity = '0';
                // 清空密码输入框
                const pinInput = document.getElementById('pin-password-input');
                if (pinInput) {
                    pinInput.value = '';
                }
                // 清空密码点
                const pinDots = document.querySelectorAll('#unlock-pin .pin-dot');
                pinDots.forEach(dot => dot.classList.remove('filled'));
            }
            if (unlockGesture) {
                unlockGesture.style.display = 'none';
                unlockGesture.style.opacity = '0';
                // 清空手势画布
                const gestureCanvas = document.getElementById('unlock-gesture-canvas');
                if (gestureCanvas) {
                    const ctx = gestureCanvas.getContext('2d');
                    ctx.clearRect(0, 0, gestureCanvas.width, gestureCanvas.height);
                }
            }
        }

        function updateLockScreenTime() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            
            const lockTimeElement = document.getElementById('lock-time');
            if (lockTimeElement) {
                lockTimeElement.textContent = `${hours}:${minutes}`;
            }
            
            // 更新日期
            const month = now.getMonth() + 1;
            const date = now.getDate();
            const weekdays = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
            const weekday = weekdays[now.getDay()];
            
            const lockDateElement = document.getElementById('lock-date');
            if (lockDateElement) {
                lockDateElement.textContent = `${month}月${date}日 ${weekday}`;
            }
        }

        function setupSwipeUnlock(passwordType) {
            const lockScreen = document.getElementById('lock-screen');
            const unlockSwipe = document.getElementById('unlock-swipe');
            const unlockPin = document.getElementById('unlock-pin');
            const unlockGesture = document.getElementById('unlock-gesture');
            let startY = 0;
            let currentY = 0;
            let isDragging = false;

            // 解锁动画函数
            const unlockAnimation = () => {
                lockScreen.style.transform = 'translateY(-100%)';
                lockScreen.style.opacity = '0';
                setTimeout(() => {
                    hideLockScreen();
                    lockScreen.style.transform = '';
                    lockScreen.style.opacity = '';
                }, 300);
            };
            
            // 显示密码输入界面
            const showPasswordInput = () => {
                // 隐藏上滑指示器
                unlockSwipe.style.opacity = '0';
                setTimeout(() => {
                    unlockSwipe.style.display = 'none';
                }, 300);
                
                // 显示对应的密码输入界面
                if (passwordType === 'pin') {
                    unlockPin.style.display = 'block';
                    setTimeout(() => {
                        unlockPin.style.opacity = '1';
                        setupPinUnlock();
                    }, 50);
                } else if (passwordType === 'gesture') {
                    unlockGesture.style.display = 'block';
                    setTimeout(() => {
                        unlockGesture.style.opacity = '1';
                        setupGestureUnlock();
                    }, 50);
                }
            };

            // 移动端触摸事件
            const handleTouchStart = (e) => {
                startY = e.touches[0].clientY;
                isDragging = true;
            };

            const handleTouchMove = (e) => {
                if (!isDragging) return;
                currentY = e.touches[0].clientY;
                const diff = startY - currentY;
                
                // 上滑时，diff > 0
                if (diff > 0) {
                    lockScreen.style.transform = `translateY(-${Math.min(diff, 100)}px)`;
                    lockScreen.style.opacity = `${1 - Math.min(diff, 100) / 100}`;
                }
            };

            const handleTouchEnd = (e) => {
                if (!isDragging) return;
                isDragging = false;
                
                const diff = startY - currentY;
                
                // 如果上滑距离超过100px
                if (diff > 100) {
                    // 恢复位置
                    lockScreen.style.transform = '';
                    lockScreen.style.opacity = '';
                    
                    // 如果有密码，显示密码输入界面；否则直接解锁
                    if (passwordType === 'none') {
                        unlockAnimation();
                    } else {
                        showPasswordInput();
                    }
                } else {
                    // 恢复原位
                    lockScreen.style.transform = '';
                    lockScreen.style.opacity = '';
                }
            };

            // PC端键盘事件
            const handleKeyDown = (e) => {
                // 只有当锁屏界面显示时才响应按键
                if (!lockScreen.classList.contains('active')) return;
                
                // 按下向上箭头键
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    
                    // 如果有密码，显示密码输入界面；否则直接解锁
                    if (passwordType === 'none') {
                        unlockAnimation();
                    } else {
                        showPasswordInput();
                    }
                }
            };

            // 移除旧的事件监听器（如果有）
            if (lockScreenHandlers) {
                lockScreen.removeEventListener('touchstart', lockScreenHandlers.handleTouchStart);
                lockScreen.removeEventListener('touchmove', lockScreenHandlers.handleTouchMove);
                lockScreen.removeEventListener('touchend', lockScreenHandlers.handleTouchEnd);
                document.removeEventListener('keydown', lockScreenHandlers.handleKeyDown);
            }
            
            // 保存handler引用
            lockScreenHandlers = {
                handleTouchStart,
                handleTouchMove,
                handleTouchEnd,
                handleKeyDown
            };
            
            // 添加新的事件监听器
            // 移动端触摸事件
            lockScreen.addEventListener('touchstart', handleTouchStart);
            lockScreen.addEventListener('touchmove', handleTouchMove);
            lockScreen.addEventListener('touchend', handleTouchEnd);
            
            // PC端键盘事件
            document.addEventListener('keydown', handleKeyDown);
        }

        // 数字密码解锁
        function setupPinUnlock() {
            const pinInput = document.getElementById('pin-password-input');
            const pinHint = document.getElementById('pin-hint');
            const pinDots = document.querySelectorAll('.pin-dot');
            
            if (!pinInput) return;
            
            // 清空输入
            pinInput.value = '';
            pinHint.textContent = '请输入密码';
            pinHint.style.color = '#333';
            pinDots.forEach(dot => dot.classList.remove('filled'));
            
            // 监听输入
            const handleInput = () => {
                const value = pinInput.value;
                // 更新密码点
                pinDots.forEach((dot, index) => {
                    if (index < value.length) {
                        dot.classList.add('filled');
                    } else {
                        dot.classList.remove('filled');
                    }
                });
            };
            
            const handleKeyPress = async (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const value = pinInput.value.trim();
                    
                    if (!value) {
                        pinHint.textContent = '请输入密码';
                        pinHint.style.color = '#f44336';
                        return;
                    }
                    
                    // 验证密码
                    if (value === db.lockScreenPassword.pin) {
                        pinHint.textContent = '解锁成功！';
                        pinHint.style.color = '#4CAF50';
                        
                        // 解锁动画
                        const lockScreen = document.getElementById('lock-screen');
                        lockScreen.style.transform = 'translateY(-100%)';
                        lockScreen.style.opacity = '0';
                        setTimeout(() => {
                            hideLockScreen();
                            lockScreen.style.transform = '';
                            lockScreen.style.opacity = '';
                        }, 300);
                    } else {
                        pinHint.textContent = '密码错误，请重试';
                        pinHint.style.color = '#f44336';
                        pinInput.value = '';
                        pinDots.forEach(dot => dot.classList.remove('filled'));
                        
                        // 抖动动画
                        const unlockPin = document.getElementById('unlock-pin');
                        unlockPin.style.animation = 'shake 0.5s';
                        setTimeout(() => {
                            unlockPin.style.animation = '';
                        }, 500);
                    }
                }
            };
            
            pinInput.addEventListener('input', handleInput);
            pinInput.addEventListener('keypress', handleKeyPress);
            
            // 自动聚焦
            setTimeout(() => pinInput.focus(), 100);
            
            // 保存handler引用以便清理
            if (!lockScreenHandlers) lockScreenHandlers = {};
            lockScreenHandlers.pinHandlers = {
                handleInput,
                handleKeyPress,
                pinInput
            };
        }

        // 手势密码解锁
        function setupGestureUnlock() {
            const canvas = document.getElementById('unlock-gesture-canvas');
            const ctx = canvas.getContext('2d');
            const hint = document.getElementById('gesture-hint');
            
            if (!canvas) return;
            
            let currentPattern = [];
            
            // 九宫格配置
            const gridSize = 3;
            const circleRadius = 23;
            const padding = 40;
            const spacing = (canvas.width - padding * 2) / (gridSize - 1);
            
            // 创建九宫格点位
            const dots = [];
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    dots.push({
                        x: padding + col * spacing,
                        y: padding + row * spacing,
                        index: row * gridSize + col,
                        active: false
                    });
                }
            }
            
            // 绘制函数
            function draw(mouseX = null, mouseY = null) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 绘制连线
                if (currentPattern.length > 0) {
                    ctx.strokeStyle = '#FF6B9D';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.beginPath();
                    
                    const firstDot = dots[currentPattern[0]];
                    ctx.moveTo(firstDot.x, firstDot.y);
                    
                    for (let i = 1; i < currentPattern.length; i++) {
                        const dot = dots[currentPattern[i]];
                        ctx.lineTo(dot.x, dot.y);
                    }
                    
                    if (mouseX !== null && mouseY !== null) {
                        ctx.lineTo(mouseX, mouseY);
                    }
                    
                    ctx.stroke();
                }
                
                // 绘制圆点
                dots.forEach(dot => {
                    ctx.beginPath();
                    ctx.arc(dot.x, dot.y, circleRadius, 0, Math.PI * 2);
                    
                    if (currentPattern.includes(dot.index)) {
                        ctx.fillStyle = '#FF6B9D';
                        ctx.fill();
                        ctx.strokeStyle = '#FF6B9D';
                    } else {
                        ctx.fillStyle = 'white';
                        ctx.fill();
                        ctx.strokeStyle = '#e0e0e0';
                    }
                    
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // 中心小圆点
                    ctx.beginPath();
                    ctx.arc(dot.x, dot.y, 5, 0, Math.PI * 2);
                    ctx.fillStyle = currentPattern.includes(dot.index) ? 'white' : '#999';
                    ctx.fill();
                });
            }
            
            // 获取触摸/鼠标位置
            function getEventPos(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            }
            
            // 检查点是否在圆内
            function checkDot(x, y) {
                for (let dot of dots) {
                    const distance = Math.sqrt(Math.pow(x - dot.x, 2) + Math.pow(y - dot.y, 2));
                    if (distance <= circleRadius) {
                        return dot.index;
                    }
                }
                return -1;
            }
            
            // 鼠标/触摸事件
            let isDrawing = false;
            
            function handleStart(e) {
                e.preventDefault();
                isDrawing = true;
                const pos = getEventPos(e);
                const dotIndex = checkDot(pos.x, pos.y);
                if (dotIndex !== -1 && !currentPattern.includes(dotIndex)) {
                    currentPattern.push(dotIndex);
                    draw();
                }
            }
            
            function handleMove(e) {
                if (!isDrawing) return;
                e.preventDefault();
                const pos = getEventPos(e);
                const dotIndex = checkDot(pos.x, pos.y);
                if (dotIndex !== -1 && !currentPattern.includes(dotIndex)) {
                    currentPattern.push(dotIndex);
                }
                draw(pos.x, pos.y);
            }
            
            async function handleEnd(e) {
                if (!isDrawing) return;
                e.preventDefault();
                isDrawing = false;
                draw();
                
                if (currentPattern.length < 4) {
                    hint.textContent = '至少连接4个点，请重试';
                    hint.style.color = '#f44336';
                    setTimeout(() => {
                        currentPattern = [];
                        draw();
                        hint.textContent = '请绘制手势密码';
                        hint.style.color = '#333';
                    }, 1000);
                    return;
                }
                
                // 验证手势密码
                const savedGesture = db.lockScreenPassword.gesture || [];
                if (JSON.stringify(currentPattern) === JSON.stringify(savedGesture)) {
                    hint.textContent = '解锁成功！';
                    hint.style.color = '#4CAF50';
                    
                    // 解锁动画
                    const lockScreen = document.getElementById('lock-screen');
                    lockScreen.style.transform = 'translateY(-100%)';
                    lockScreen.style.opacity = '0';
                    setTimeout(() => {
                        hideLockScreen();
                        lockScreen.style.transform = '';
                        lockScreen.style.opacity = '';
                    }, 300);
                } else {
                    hint.textContent = '手势错误，请重试';
                    hint.style.color = '#f44336';
                    
                    // 显示错误颜色
                    ctx.strokeStyle = '#f44336';
                    ctx.stroke();
                    
                    // 抖动动画
                    const unlockGesture = document.getElementById('unlock-gesture');
                    unlockGesture.style.animation = 'shake 0.5s';
                    
                    setTimeout(() => {
                        currentPattern = [];
                        draw();
                        hint.textContent = '请绘制手势密码';
                        hint.style.color = '#333';
                        unlockGesture.style.animation = '';
                    }, 1000);
                }
            }
            
            // 绑定事件
            canvas.addEventListener('mousedown', handleStart);
            canvas.addEventListener('mousemove', handleMove);
            canvas.addEventListener('mouseup', handleEnd);
            canvas.addEventListener('touchstart', handleStart);
            canvas.addEventListener('touchmove', handleMove);
            canvas.addEventListener('touchend', handleEnd);
            
            // 初始绘制
            draw();
            
            // 保存handler引用以便清理
            if (!lockScreenHandlers) lockScreenHandlers = {};
            lockScreenHandlers.gestureHandlers = {
                handleStart,
                handleMove,
                handleEnd,
                canvas
            };
        }

        function updateTime() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const timeElement = document.getElementById('status-bar-time');
            if (timeElement) {
                timeElement.textContent = `${hours}:${minutes}`;
            }
        }

        async function updateBattery() {
            const batteryElement = document.getElementById('status-bar-battery');
            const batteryLevel = document.getElementById('battery-level');
            const batteryPercentage = document.getElementById('battery-percentage');
            const chargingIcon = document.getElementById('charging-icon');

            // 检查是否已经添加过QWQ，避免重复添加
            const existingQwq = batteryElement.querySelector('.status-bar-fallback');
            if (existingQwq) {
                return; // 已经初始化过，直接返回
            }

            try {
                if ('getBattery' in navigator) {
                    const battery = await navigator.getBattery();
                    
                    // 更新电量显示的函数
                    const refreshBatteryDisplay = () => {
                        const level = battery.level;
                        const charging = battery.charging;

                        // 更新电量百分比文字
                        const percentage = Math.round(level * 100);
                        batteryPercentage.textContent = `${percentage}%`;

                        // 更新电量条宽度（最大宽度22，适配viewBox中width=26的电池，减去左右padding 2*2=4）
                        const levelWidth = level * 22;
                        batteryLevel.setAttribute('width', levelWidth);

                        // 移除所有状态类
                        batteryLevel.classList.remove('low', 'charging');

                        // 根据状态添加类
                        if (charging) {
                            batteryLevel.classList.add('charging');
                            chargingIcon.style.display = 'block';
                        } else {
                            chargingIcon.style.display = 'none';
                            if (level <= 0.2) {
                                batteryLevel.classList.add('low');
                            }
                        }
                    };

                    // 初始显示
                    refreshBatteryDisplay();

                    // 监听电量变化（跟随设备更新）
                    battery.addEventListener('levelchange', refreshBatteryDisplay);
                    battery.addEventListener('chargingchange', refreshBatteryDisplay);
                } else {
                    // 不支持电量API，隐藏百分比并在电池图标左边插入QWQ
                    batteryPercentage.style.display = 'none';
                    const qwqSpan = document.createElement('span');
                    qwqSpan.className = 'status-bar-fallback';
                    qwqSpan.textContent = 'QWQ';
                    batteryElement.insertBefore(qwqSpan, batteryElement.firstChild);
                }
            } catch (error) {
                // 发生错误，隐藏百分比并在电池图标左边插入QWQ
                console.log('Battery API not supported:', error);
                batteryPercentage.style.display = 'none';
                const qwqSpan = document.createElement('span');
                qwqSpan.className = 'status-bar-fallback';
                qwqSpan.textContent = 'QWQ';
                batteryElement.insertBefore(qwqSpan, batteryElement.firstChild);
            }
        }

        // 导入主屏幕配置文件监听器
        document.addEventListener('DOMContentLoaded', () => {
            const importInput = document.getElementById('import-homescreen-config-input');
            if (importInput) {
                importInput.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    try {
                        const text = await file.text();
                        const importData = JSON.parse(text);
                        
                        // 验证数据格式
                        if (!importData.version) {
                            throw new Error('无效的配置文件格式');
                        }
                        
                        // 确认导入
                        if (!confirm('确定要导入此配置吗？这将覆盖当前的主屏幕设置。')) {
                            e.target.value = '';
                            return;
                        }
                        
                        // 导入数据
                        if (importData.customIcons) db.customIcons = importData.customIcons;
                        if (importData.customIconNames) db.customIconNames = importData.customIconNames;
                        if (importData.homeScreenPresets) db.homeScreenPresets = importData.homeScreenPresets;
                        if (importData.homeScreenBg !== undefined) db.homeScreenBg = importData.homeScreenBg;
                        if (importData.lockScreenBg !== undefined) db.lockScreenBg = importData.lockScreenBg;
                        if (importData.showDockAppNames !== undefined) db.showDockAppNames = importData.showDockAppNames;
                        if (importData.showStatusBar !== undefined) db.showStatusBar = importData.showStatusBar;
                        
                        // 保存数据
                        await saveData();
                        
                        // 应用设置
                        setupHomeScreen();
                        renderCustomizeForm();
                        
                        // 应用背景
                        if (db.homeScreenBg) {
                            const homeScreen = document.getElementById('home-screen');
                            if (homeScreen) {
                                homeScreen.style.backgroundImage = `url(${db.homeScreenBg})`;
                            }
                        }
                        
                        // 应用锁屏背景
                        if (db.lockScreenBg) {
                            const lockScreen = document.getElementById('lock-screen');
                            if (lockScreen) {
                                lockScreen.style.backgroundImage = `url(${db.lockScreenBg})`;
                            }
                        }
                        
                        // 应用状态栏设置
                        toggleStatusBar(db.showStatusBar);
                        
                        showToast('主屏幕配置导入成功');
                        e.target.value = '';
                    } catch (error) {
                        console.error('导入配置失败:', error);
                        showToast('导入配置失败：' + error.message);
                        e.target.value = '';
                    }
                });
            }
        });

        // --- App Setup Functions ---
        function setupHomeScreen() {
            const getIcon = (id) => db.customIcons[id] || defaultIcons[id].url;
            const getName = (id) => {
                // 如果用户自定义了名称，使用自定义名称
                if (db.customIconNames[id]) return db.customIconNames[id];
                
                // 如果启用了语言切换，使用翻译
                if (db.enableLanguageSwitch) {
                    const keyMap = {
                        'chat-list-screen': 'chat',
                        'world-book-screen': 'worldBook',
                        'api-settings-screen': 'apiSettings',
                        'wallpaper-screen': 'wallpaper',
                        'font-settings-screen': 'fontSettings',
                        'customize-screen': 'customize',
                        'tutorial-screen': 'tutorial',
                        'day-mode-btn': 'dayMode',
                        'night-mode-btn': 'nightMode'
                    };
                    const key = keyMap[id];
                    if (key) return t(key);
                }
                
                // 否则使用默认名称
                return defaultIcons[id].name;
            };
            const homeScreenHTML = `
            <div class="home-pages-container" id="home-pages-container">
                <!-- 第一页 -->
                <div class="home-page">
                    <div class="time-widget"><div class="time" id="time-display"></div><div class="date" id="date-display"></div></div>
                    <div class="app-grid">
                        <a href="#" class="app-icon" data-target="chat-list-screen"><img src="${getIcon('chat-list-screen')}" alt="404" class="icon-img"><span class="app-name">${getName('chat-list-screen')}</span></a>
                        <a href="#" class="app-icon" data-target="api-settings-screen"><img src="${getIcon('api-settings-screen')}" alt="API" class="icon-img"><span class="app-name">${getName('api-settings-screen')}</span></a>
                        <a href="#" class="app-icon" data-target="wallpaper-screen"><img src="${getIcon('wallpaper-screen')}" alt="Wallpaper" class="icon-img"><span class="app-name">${getName('wallpaper-screen')}</span></a>
                        <a href="#" class="app-icon" data-target="world-book-screen"><img src="${getIcon('world-book-screen')}" alt="World Book" class="icon-img"><span class="app-name">${getName('world-book-screen')}</span></a>
                        <a href="#" class="app-icon" data-target="customize-screen"><img src="${getIcon('customize-screen')}" alt="Customize" class="icon-img"><span class="app-name">${getName('customize-screen')}</span></a>
                        <a href="#" class="app-icon" data-target="tutorial-screen"><img src="${getIcon('tutorial-screen')}" alt="Tutorial" class="icon-img"><span class="app-name">${getName('tutorial-screen')}</span></a>
                    </div>
                    <div class="dock ${db.showDockAppNames ? 'show-names' : ''}">
                        <a href="#" class="app-icon" id="day-mode-btn"><img src="${getIcon('day-mode-btn')}" alt="日间" class="icon-img">${db.showDockAppNames ? `<span class="app-name">${getName('day-mode-btn') || '日间'}</span>` : ''}</a>
                        <a href="#" class="app-icon" id="night-mode-btn"><img src="${getIcon('night-mode-btn')}" alt="夜间" class="icon-img">${db.showDockAppNames ? `<span class="app-name">${getName('night-mode-btn') || '夜间'}</span>` : ''}</a>
                        <a href="#" class="app-icon" data-target="font-settings-screen"><img src="${getIcon('font-settings-screen')}" alt="字体" class="icon-img">${db.showDockAppNames ? `<span class="app-name">${getName('font-settings-screen')}</span>` : ''}</a>
                    </div>
                </div>
                <!-- 第二页 -->
                <div class="home-page">
                    <!-- 左上角游戏图标 -->
                    <a href="#" class="app-icon plugin-icon-top-left" id="game-btn">
                        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='15' fill='white'/%3E%3Ctext x='32' y='44' font-size='36' font-weight='bold' text-anchor='middle' fill='black' font-family='Arial, sans-serif'%3E游%3C/text%3E%3C/svg%3E" alt="游戏" class="icon-img">
                        <span class="app-name">游戏</span>
                    </a>
                    <div style="flex: 1;"></div>
                    <div class="dock ${db.showDockAppNames ? 'show-names' : ''}">
                        <a href="#" class="app-icon" id="day-mode-btn-2"><img src="${getIcon('day-mode-btn')}" alt="日间" class="icon-img">${db.showDockAppNames ? `<span class="app-name">${getName('day-mode-btn') || '日间'}</span>` : ''}</a>
                        <a href="#" class="app-icon" id="night-mode-btn-2"><img src="${getIcon('night-mode-btn')}" alt="夜间" class="icon-img">${db.showDockAppNames ? `<span class="app-name">${getName('night-mode-btn') || '夜间'}</span>` : ''}</a>
                        <a href="#" class="app-icon" data-target="font-settings-screen"><img src="${getIcon('font-settings-screen')}" alt="字体" class="icon-img">${db.showDockAppNames ? `<span class="app-name">${getName('font-settings-screen')}</span>` : ''}</a>
                    </div>
                </div>
            </div>`;
            homeScreen.innerHTML = homeScreenHTML;
            updateClock();
            applyWallpaper(db.wallpaper);
            applyHomeScreenMode(db.homeScreenMode);
            document.getElementById('day-mode-btn')?.addEventListener('click', (e) => {
                e.preventDefault();
                applyHomeScreenMode('day');
            });
            document.getElementById('night-mode-btn')?.addEventListener('click', (e) => {
                e.preventDefault();
                applyHomeScreenMode('night');
            });
            document.getElementById('day-mode-btn-2')?.addEventListener('click', (e) => {
                e.preventDefault();
                applyHomeScreenMode('day');
            });
            document.getElementById('night-mode-btn-2')?.addEventListener('click', (e) => {
                e.preventDefault();
                applyHomeScreenMode('night');
            });
            document.querySelector('[data-target="world-book-screen"]').addEventListener('click', renderWorldBookList);
            document.querySelector('[data-target="customize-screen"]').addEventListener('click', renderCustomizeForm);
            document.querySelector('[data-target="tutorial-screen"]').addEventListener('click', renderTutorialContent);
            
            // 游戏按钮点击事件
            document.getElementById('game-btn')?.addEventListener('click', (e) => {
                e.preventDefault();
                showToast('游戏功能开发中...', 2000);
            });
            
            // 初始化主屏幕页面滑动
            initHomeScreenSwipe();
        }

        function applyWallpaper(url) {
            homeScreen.style.backgroundImage = `url(${url})`;
        }

        async function applyHomeScreenMode(mode) {
            if (mode === 'day') {
                homeScreen.classList.add('day-mode');
            } else {
                homeScreen.classList.remove('day-mode');
            }
            db.homeScreenMode = mode;
            await saveData();
        }

        function setupCustomizeApp() {
            customizeForm.addEventListener('input', async (e) => {
                if (e.target.matches('input[type="url"]')) {
                    const iconId = e.target.dataset.id;
                    const newUrl = e.target.value.trim();
                    const previewImg = document.getElementById(`icon-preview-${iconId}`);
                    if (newUrl) {
                        db.customIcons[iconId] = newUrl;
                        previewImg.src = newUrl;
                        await saveData();
                        setupHomeScreen();
                    }
                }
                if (e.target.matches('.icon-name-input')) {
                    const iconId = e.target.dataset.id;
                    const newName = e.target.value.trim();
                    if (newName) {
                        db.customIconNames[iconId] = newName;
                    } else {
                        delete db.customIconNames[iconId];
                    }
                    await saveData();
                    setupHomeScreen();
                }
            });
            customizeForm.addEventListener('click', async (e) => {
                if (e.target.matches('.reset-icon-btn')) {
                    currentResetIconId = e.target.dataset.id;
                    resetIconModal.classList.add('visible');
                }
            });
            customizeForm.addEventListener('change', async (e) => {
                if (e.target.matches('input[type="file"]')) {
                    const iconId = e.target.dataset.id;
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = async () => {
                            const newUrl = reader.result;
                            db.customIcons[iconId] = newUrl;
                            const previewImg = document.getElementById(`icon-preview-${iconId}`);
                            previewImg.src = newUrl;
                            await saveData();
                            setupHomeScreen();
                        };
                        reader.readAsDataURL(file);
                    }
                }
            });
            // Reset Icon Modal Event Handlers
            resetIconModal.addEventListener('click', (e) => {
                if (e.target === resetIconModal) {
                    resetIconModal.classList.remove('visible');
                    currentResetIconId = null;
                }
            });
            resetIconCancelBtn.addEventListener('click', () => {
                resetIconModal.classList.remove('visible');
                currentResetIconId = null;
            });
            resetIconImageBtn.addEventListener('click', async () => {
                if (currentResetIconId) {
                    delete db.customIcons[currentResetIconId];
                    await saveData();
                    renderCustomizeForm();
                    setupHomeScreen();
                    resetIconModal.classList.remove('visible');
                    showToast('图标图片已重置');
                    currentResetIconId = null;
                }
            });
            resetIconNameBtn.addEventListener('click', async () => {
                if (currentResetIconId) {
                    delete db.customIconNames[currentResetIconId];
                    await saveData();
                    renderCustomizeForm();
                    setupHomeScreen();
                    resetIconModal.classList.remove('visible');
                    showToast('图标名字已重置');
                    currentResetIconId = null;
                }
            });
            resetIconBothBtn.addEventListener('click', async () => {
                if (currentResetIconId) {
                    delete db.customIcons[currentResetIconId];
                    delete db.customIconNames[currentResetIconId];
                    await saveData();
                    renderCustomizeForm();
                    setupHomeScreen();
                    resetIconModal.classList.remove('visible');
                    showToast('图标已完全重置');
                    currentResetIconId = null;
                }
            });

            // 预设管理功能事件监听器
            customizeForm.addEventListener('click', async (e) => {
                // 保存预设
                if (e.target.id === 'save-preset-btn') {
                    const presetNameInput = document.getElementById('preset-name-input');
                    const presetName = presetNameInput.value.trim();
                    if (!presetName) {
                        showToast('请输入预设名称');
                        return;
                    }
                    const preset = {
                        name: presetName,
                        customIcons: JSON.parse(JSON.stringify(db.customIcons)),
                        customIconNames: JSON.parse(JSON.stringify(db.customIconNames)),
                        timestamp: Date.now()
                    };
                    if (!db.homeScreenPresets) {
                        db.homeScreenPresets = [];
                    }
                    db.homeScreenPresets.push(preset);
                    await saveData();
                    showToast(`预设"${presetName}"保存成功`);
                    presetNameInput.value = '';
                    renderCustomizeForm();
                }

                // 应用预设
                if (e.target.id === 'apply-preset-btn') {
                    const presetSelect = document.getElementById('preset-select');
                    const selectedIndex = presetSelect.value;
                    if (selectedIndex === '') {
                        showToast('请先选择一个预设方案');
                        return;
                    }
                    const preset = db.homeScreenPresets[parseInt(selectedIndex)];
                    if (!preset) {
                        showToast('预设不存在');
                        return;
                    }
                    db.customIcons = JSON.parse(JSON.stringify(preset.customIcons));
                    db.customIconNames = JSON.parse(JSON.stringify(preset.customIconNames));
                    await saveData();
                    showToast(`已应用预设"${preset.name}"`);
                    renderCustomizeForm();
                    setupHomeScreen();
                }

                // 导出主屏幕配置
                if (e.target.id === 'export-homescreen-config-btn') {
                    try {
                        const exportData = {
                            version: '1.0',
                            exportTime: new Date().toISOString(),
                            customIcons: db.customIcons || {},
                            customIconNames: db.customIconNames || {},
                            homeScreenPresets: db.homeScreenPresets || [],
                            homeScreenBg: db.homeScreenBg || '',
                            lockScreenBg: db.lockScreenBg || '',
                            showDockAppNames: db.showDockAppNames !== undefined ? db.showDockAppNames : true,
                            showStatusBar: db.showStatusBar !== undefined ? db.showStatusBar : true
                        };
                        
                        const dataStr = JSON.stringify(exportData, null, 2);
                        const blob = new Blob([dataStr], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `主屏幕配置_${new Date().toISOString().slice(0, 10)}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        showToast('主屏幕配置已导出');
                    } catch (error) {
                        console.error('导出配置失败:', error);
                        showToast('导出配置失败，请重试');
                    }
                }

                // 导入主屏幕配置
                if (e.target.id === 'import-homescreen-config-btn') {
                    const fileInput = document.getElementById('import-homescreen-config-input');
                    fileInput.click();
                }

                // 删除选中的预设
                if (e.target.id === 'delete-presets-btn') {
                    const checkboxes = document.querySelectorAll('.preset-checkbox:checked');
                    if (checkboxes.length === 0) {
                        showToast('请先选择要删除的预设');
                        return;
                    }
                    if (!confirm(`确定要删除选中的 ${checkboxes.length} 个预设吗？此操作不可撤销。`)) {
                        return;
                    }
                    const indicesToDelete = Array.from(checkboxes).map(cb => parseInt(cb.dataset.index)).sort((a, b) => b - a);
                    indicesToDelete.forEach(index => {
                        db.homeScreenPresets.splice(index, 1);
                    });
                    await saveData();
                    showToast('预设已删除');
                    renderCustomizeForm();
                }
                
                // 设置数字密码按钮
                if (e.target.id === 'set-pin-btn') {
                    showPinPasswordSetup();
                }
                
                // 设置手势密码按钮
                if (e.target.id === 'set-gesture-btn') {
                    showGesturePasswordSetup();
                }
            });

            // 全选预设复选框和底栏APP名称开关
            customizeForm.addEventListener('change', async (e) => {
                if (e.target.id === 'select-all-presets') {
                    const checkboxes = document.querySelectorAll('.preset-checkbox');
                    checkboxes.forEach(cb => {
                        cb.checked = e.target.checked;
                    });
                }
                
                // 底栏APP显示名字开关
                if (e.target.id === 'show-dock-names-toggle') {
                    db.showDockAppNames = e.target.checked;
                    await saveData();
                    setupHomeScreen();
                    showToast(db.showDockAppNames ? '底栏APP名称已显示' : '底栏APP名称已隐藏');
                }
                
                // 本机语言切换开关
                if (e.target.id === 'enable-language-switch-toggle') {
                    db.enableLanguageSwitch = e.target.checked;
                    const languageSelectContainer = document.getElementById('language-select-container');
                    if (languageSelectContainer) {
                        languageSelectContainer.style.display = e.target.checked ? 'block' : 'none';
                    }
                    await saveData();
                    showToast(e.target.checked ? '语言切换已启用' : '语言切换已关闭');
                }
                
                // 语言选择
                if (e.target.id === 'app-language-select') {
                    db.appLanguage = e.target.value;
                    await saveData();
                    applyLanguage(e.target.value);
                    showToast(t('languageChanged'));
                }
                
                // 顶部状态栏开关
                if (e.target.id === 'show-status-bar-toggle') {
                    db.showStatusBar = e.target.checked;
                    await saveData();
                    toggleStatusBar(e.target.checked);
                    showToast(db.showStatusBar ? '顶部状态栏已显示' : '顶部状态栏已隐藏');
                }
                
                // 锁屏页面开关
                if (e.target.id === 'enable-lock-screen-toggle') {
                    db.enableLockScreen = e.target.checked;
                    await saveData();
                    const passwordSection = document.getElementById('lock-password-section');
                    if (passwordSection) {
                        passwordSection.style.display = e.target.checked ? 'block' : 'none';
                    }
                    showToast(db.enableLockScreen ? '锁屏页面已启用' : '锁屏页面已关闭');
                }
                
                // 重置主页面所有外观设置按钮
                if (e.target.id === 'reset-appearance-btn') {
                    // 双重确认
                    if (!confirm('警告：此操作将重置所有主页面外观设置到默认状态，包括：\n\n• 所有应用图标和名称\n• 主屏幕背景\n• 锁屏壁纸\n• 底栏名称显示\n• 状态栏显示\n\n此操作不可撤销！\n\n确定要继续吗？')) {
                        return;
                    }
                    
                    if (!confirm('最后确认：您真的要重置所有外观设置吗？')) {
                        return;
                    }
                    
                    try {
                        showToast('正在重置外观设置...');
                        
                        // 重置所有外观相关设置
                        db.customIcons = {};
                        db.customIconNames = {};
                        db.showDockAppNames = false;
                        db.showStatusBar = false;
                        db.lockScreenWallpaper = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                        
                        // 重置主屏幕背景（移除内联样式）
                        const homeScreen = document.getElementById('home-screen');
                        if (homeScreen) {
                            homeScreen.style.backgroundImage = '';
                        }
                        
                        // 保存数据
                        await saveData();
                        
                        // 重新渲染界面
                        setupHomeScreen();
                        renderCustomizeForm();
                        
                        // 更新锁屏壁纸
                        const lockScreen = document.getElementById('lock-screen');
                        if (lockScreen) {
                            lockScreen.style.background = db.lockScreenWallpaper;
                            lockScreen.style.backgroundImage = '';
                        }
                        
                        // 更新状态栏显示
                        toggleStatusBar(false);
                        
                        showToast('外观设置已重置为默认状态');
                        
                        // 刷新页面以确保所有设置生效
                        setTimeout(() => {
                            if (confirm('外观设置已重置！是否刷新页面以完全应用更改？')) {
                                window.location.href = window.location.href;
                            }
                        }, 1000);
                        
                    } catch (error) {
                        showToast(`重置失败: ${error.message}`);
                        console.error('重置外观设置错误:', error);
                    }
                }
                
                // 密码类型选择
                if (e.target.id === 'password-type-select') {
                    db.lockScreenPassword.type = e.target.value;
                    await saveData();
                    
                    // 切换显示对应的设置区域
                    const pinSetup = document.getElementById('pin-password-setup');
                    const gestureSetup = document.getElementById('gesture-password-setup');
                    
                    pinSetup.style.display = e.target.value === 'pin' ? 'block' : 'none';
                    gestureSetup.style.display = e.target.value === 'gesture' ? 'block' : 'none';
                    
                    let message = '密码已关闭';
                    if (e.target.value === 'pin') {
                        message = db.lockScreenPassword.pin ? '已切换到数字密码' : '已切换到数字密码，请点击下方按钮设置密码';
                    }
                    if (e.target.value === 'gesture') {
                        message = (db.lockScreenPassword.gesture && db.lockScreenPassword.gesture.length > 0) ? '已切换到手势密码' : '已切换到手势密码，请点击下方按钮设置密码';
                    }
                    showToast(message);
                }
            });
            
            // 悬浮歌词设置事件监听器
            customizeForm.addEventListener('input', async (e) => {
                // 当前歌词字号滑动条
                if (e.target.id === 'floating-lyrics-active-size-slider') {
                    const value = e.target.value;
                    document.getElementById('floating-lyrics-active-size-value').textContent = value + 'px';
                    db.floatingLyricsSettings.activeFontSize = parseInt(value);
                    await saveData();
                    applyFloatingLyricsStyles();
                }
                
                // 其他歌词字号滑动条
                if (e.target.id === 'floating-lyrics-other-size-slider') {
                    const value = e.target.value;
                    document.getElementById('floating-lyrics-other-size-value').textContent = value + 'px';
                    db.floatingLyricsSettings.otherFontSize = parseInt(value);
                    await saveData();
                    applyFloatingLyricsStyles();
                }
                
                // 显示句数滑动条
                if (e.target.id === 'floating-lyrics-lines-slider') {
                    const value = e.target.value;
                    document.getElementById('floating-lyrics-lines-value').textContent = value + '句';
                    db.floatingLyricsSettings.linesCount = parseInt(value);
                    await saveData();
                    updateFloatingLyrics();
                }
                
                // 当前歌词颜色选择器
                if (e.target.id === 'floating-lyrics-active-color') {
                    const value = e.target.value;
                    document.getElementById('floating-lyrics-active-color-text').value = value;
                    db.floatingLyricsSettings.activeColor = value;
                    await saveData();
                    applyFloatingLyricsStyles();
                }
                
                // 当前歌词颜色文本输入
                if (e.target.id === 'floating-lyrics-active-color-text') {
                    const value = e.target.value;
                    if (/^#[0-9A-F]{6}$/i.test(value)) {
                        document.getElementById('floating-lyrics-active-color').value = value;
                        db.floatingLyricsSettings.activeColor = value;
                        await saveData();
                        applyFloatingLyricsStyles();
                    }
                }
                
                // 前一句歌词颜色选择器
                if (e.target.id === 'floating-lyrics-previous-color') {
                    const value = e.target.value;
                    document.getElementById('floating-lyrics-previous-color-text').value = value;
                    db.floatingLyricsSettings.previousColor = value;
                    await saveData();
                    applyFloatingLyricsStyles();
                }
                
                // 前一句歌词颜色文本输入
                if (e.target.id === 'floating-lyrics-previous-color-text') {
                    const value = e.target.value;
                    if (/^#[0-9A-F]{6}$/i.test(value)) {
                        document.getElementById('floating-lyrics-previous-color').value = value;
                        db.floatingLyricsSettings.previousColor = value;
                        await saveData();
                        applyFloatingLyricsStyles();
                    }
                }
                
                // 接下来歌词颜色选择器
                if (e.target.id === 'floating-lyrics-upcoming-color') {
                    const value = e.target.value;
                    document.getElementById('floating-lyrics-upcoming-color-text').value = value;
                    db.floatingLyricsSettings.upcomingColor = value;
                    await saveData();
                    applyFloatingLyricsStyles();
                }
                
                // 接下来歌词颜色文本输入
                if (e.target.id === 'floating-lyrics-upcoming-color-text') {
                    const value = e.target.value;
                    if (/^#[0-9A-F]{6}$/i.test(value)) {
                        document.getElementById('floating-lyrics-upcoming-color').value = value;
                        db.floatingLyricsSettings.upcomingColor = value;
                        await saveData();
                        applyFloatingLyricsStyles();
                    }
                }
                
                // 歌词间隔滑动条
                if (e.target.id === 'floating-lyrics-gap-slider') {
                    const value = e.target.value;
                    document.getElementById('floating-lyrics-gap-value').textContent = value + 'px';
                    db.floatingLyricsSettings.lineGap = parseInt(value);
                    await saveData();
                    applyFloatingLyricsStyles();
                }
            });
            
            // 悬浮歌词重置按钮事件监听器
            customizeForm.addEventListener('click', async (e) => {
                // 重置当前歌词字号
                if (e.target.id === 'reset-floating-lyrics-active-size-btn') {
                    db.floatingLyricsSettings.activeFontSize = 18;
                    document.getElementById('floating-lyrics-active-size-slider').value = 18;
                    document.getElementById('floating-lyrics-active-size-value').textContent = '18px';
                    await saveData();
                    applyFloatingLyricsStyles();
                    showToast('当前歌词字号已重置');
                }
                
                // 重置其他歌词字号
                if (e.target.id === 'reset-floating-lyrics-other-size-btn') {
                    db.floatingLyricsSettings.otherFontSize = 13;
                    document.getElementById('floating-lyrics-other-size-slider').value = 13;
                    document.getElementById('floating-lyrics-other-size-value').textContent = '13px';
                    await saveData();
                    applyFloatingLyricsStyles();
                    showToast('其他歌词字号已重置');
                }
                
                // 重置显示句数
                if (e.target.id === 'reset-floating-lyrics-lines-btn') {
                    db.floatingLyricsSettings.linesCount = 3;
                    document.getElementById('floating-lyrics-lines-slider').value = 3;
                    document.getElementById('floating-lyrics-lines-value').textContent = '3句';
                    await saveData();
                    updateFloatingLyrics();
                    showToast('显示句数已重置');
                }
                
                // 重置当前歌词颜色
                if (e.target.id === 'reset-floating-lyrics-active-color-btn') {
                    db.floatingLyricsSettings.activeColor = '#ff80ab';
                    document.getElementById('floating-lyrics-active-color').value = '#ff80ab';
                    document.getElementById('floating-lyrics-active-color-text').value = '#ff80ab';
                    await saveData();
                    applyFloatingLyricsStyles();
                    showToast('当前歌词颜色已重置');
                }
                
                // 重置前一句歌词颜色
                if (e.target.id === 'reset-floating-lyrics-previous-color-btn') {
                    db.floatingLyricsSettings.previousColor = '#787878';
                    document.getElementById('floating-lyrics-previous-color').value = '#787878';
                    document.getElementById('floating-lyrics-previous-color-text').value = '#787878';
                    await saveData();
                    applyFloatingLyricsStyles();
                    showToast('前一句歌词颜色已重置');
                }
                
                // 重置接下来歌词颜色
                if (e.target.id === 'reset-floating-lyrics-upcoming-color-btn') {
                    db.floatingLyricsSettings.upcomingColor = '#787878';
                    document.getElementById('floating-lyrics-upcoming-color').value = '#787878';
                    document.getElementById('floating-lyrics-upcoming-color-text').value = '#787878';
                    await saveData();
                    applyFloatingLyricsStyles();
                    showToast('接下来歌词颜色已重置');
                }
                
                // 重置歌词间隔
                if (e.target.id === 'reset-floating-lyrics-gap-btn') {
                    db.floatingLyricsSettings.lineGap = 8;
                    document.getElementById('floating-lyrics-gap-slider').value = 8;
                    document.getElementById('floating-lyrics-gap-value').textContent = '8px';
                    await saveData();
                    applyFloatingLyricsStyles();
                    showToast('歌词间隔已重置');
                }
                
                // 重置所有悬浮歌词设置
                if (e.target.id === 'reset-all-floating-lyrics-btn') {
                    if (!confirm('确定要重置所有悬浮歌词设置吗？')) return;
                    
                    db.floatingLyricsSettings = {
                        activeFontSize: 18,
                        otherFontSize: 13,
                        linesCount: 3,
                        activeColor: '#ff80ab',
                        previousColor: '#787878',
                        upcomingColor: '#787878',
                        lineGap: 8
                    };
                    await saveData();
                    renderCustomizeForm();
                    applyFloatingLyricsStyles();
                    updateFloatingLyrics();
                    showToast('所有悬浮歌词设置已重置');
                }
            });
            
            // 时间旁白设置事件监听器
            customizeForm.addEventListener('input', async (e) => {
                // 背景颜色选择器
                if (e.target.id === 'time-divider-bg-color') {
                    const value = e.target.value;
                    const opacity = db.timeDividerSettings.bgOpacity !== undefined ? db.timeDividerSettings.bgOpacity : 50;
                    const rgba = hexToRgba(value, opacity / 100);
                    document.getElementById('time-divider-bg-color-text').value = rgba;
                    db.timeDividerSettings.bgColor = rgba;
                    await saveData();
                    updateTimeDividerPreview();
                }
                
                // 背景颜色文本输入
                if (e.target.id === 'time-divider-bg-color-text') {
                    const value = e.target.value;
                    if (/^#[0-9A-F]{6}$/i.test(value) || /^rgba?\(/.test(value)) {
                        if (value.startsWith('#')) {
                            const opacity = db.timeDividerSettings.bgOpacity !== undefined ? db.timeDividerSettings.bgOpacity : 50;
                            const rgba = hexToRgba(value, opacity / 100);
                            db.timeDividerSettings.bgColor = rgba;
                            document.getElementById('time-divider-bg-color').value = value;
                        } else {
                            db.timeDividerSettings.bgColor = value;
                            const hex = rgbaToHex(value);
                            if (hex) document.getElementById('time-divider-bg-color').value = hex;
                        }
                        await saveData();
                        updateTimeDividerPreview();
                    }
                }
                
                // 背景透明度滑动条
                if (e.target.id === 'time-divider-bg-opacity') {
                    const value = parseInt(e.target.value);
                    document.getElementById('time-divider-bg-opacity-value').textContent = value + '%';
                    db.timeDividerSettings.bgOpacity = value;
                    const colorInput = document.getElementById('time-divider-bg-color');
                    const rgba = hexToRgba(colorInput.value, value / 100);
                    db.timeDividerSettings.bgColor = rgba;
                    document.getElementById('time-divider-bg-color-text').value = rgba;
                    await saveData();
                    updateTimeDividerPreview();
                }
                
                // 文字颜色选择器
                if (e.target.id === 'time-divider-text-color') {
                    const value = e.target.value;
                    const opacity = db.timeDividerSettings.textOpacity !== undefined ? db.timeDividerSettings.textOpacity : 100;
                    const rgba = hexToRgba(value, opacity / 100);
                    document.getElementById('time-divider-text-color-text').value = rgba;
                    db.timeDividerSettings.textColor = rgba;
                    await saveData();
                    updateTimeDividerPreview();
                }
                
                // 文字颜色文本输入
                if (e.target.id === 'time-divider-text-color-text') {
                    const value = e.target.value;
                    if (/^#[0-9A-F]{6}$/i.test(value) || /^rgba?\(/.test(value)) {
                        if (value.startsWith('#')) {
                            const opacity = db.timeDividerSettings.textOpacity !== undefined ? db.timeDividerSettings.textOpacity : 100;
                            const rgba = hexToRgba(value, opacity / 100);
                            db.timeDividerSettings.textColor = rgba;
                            document.getElementById('time-divider-text-color').value = value;
                        } else {
                            db.timeDividerSettings.textColor = value;
                            const hex = rgbaToHex(value);
                            if (hex) document.getElementById('time-divider-text-color').value = hex;
                        }
                        await saveData();
                        updateTimeDividerPreview();
                    }
                }
                
                // 文字透明度滑动条
                if (e.target.id === 'time-divider-text-opacity') {
                    const value = parseInt(e.target.value);
                    document.getElementById('time-divider-text-opacity-value').textContent = value + '%';
                    db.timeDividerSettings.textOpacity = value;
                    const colorInput = document.getElementById('time-divider-text-color');
                    const rgba = hexToRgba(colorInput.value, value / 100);
                    db.timeDividerSettings.textColor = rgba;
                    document.getElementById('time-divider-text-color-text').value = rgba;
                    await saveData();
                    updateTimeDividerPreview();
                }
                
                // 圆角大小滑动条
                if (e.target.id === 'time-divider-radius-slider') {
                    const value = parseInt(e.target.value);
                    document.getElementById('time-divider-radius-value').textContent = value + 'px';
                    db.timeDividerSettings.borderRadius = value;
                    await saveData();
                    updateTimeDividerPreview();
                }
                
                // 语言选择
                if (e.target.id === 'time-divider-language') {
                    const value = e.target.value;
                    db.timeDividerSettings.language = value;
                    await saveData();
                    updateTimeDividerPreview();
                }
            });
            
            // 时间旁白重置按钮事件监听器
            customizeForm.addEventListener('click', async (e) => {
                // 重置背景颜色
                if (e.target.id === 'reset-time-divider-bg-color-btn') {
                    db.timeDividerSettings.bgColor = 'rgba(200, 200, 200, 0.5)';
                    db.timeDividerSettings.bgOpacity = 50;
                    document.getElementById('time-divider-bg-color').value = '#c8c8c8';
                    document.getElementById('time-divider-bg-color-text').value = 'rgba(200, 200, 200, 0.5)';
                    document.getElementById('time-divider-bg-opacity').value = 50;
                    document.getElementById('time-divider-bg-opacity-value').textContent = '50%';
                    await saveData();
                    updateTimeDividerPreview();
                    showToast('旁白背景颜色已重置');
                }
                
                // 重置文字颜色
                if (e.target.id === 'reset-time-divider-text-color-btn') {
                    db.timeDividerSettings.textColor = '#666666';
                    db.timeDividerSettings.textOpacity = 100;
                    document.getElementById('time-divider-text-color').value = '#666666';
                    document.getElementById('time-divider-text-color-text').value = '#666666';
                    document.getElementById('time-divider-text-opacity').value = 100;
                    document.getElementById('time-divider-text-opacity-value').textContent = '100%';
                    await saveData();
                    updateTimeDividerPreview();
                    showToast('旁白文字颜色已重置');
                }
                
                // 重置圆角大小
                if (e.target.id === 'reset-time-divider-radius-btn') {
                    db.timeDividerSettings.borderRadius = 10;
                    document.getElementById('time-divider-radius-slider').value = 10;
                    document.getElementById('time-divider-radius-value').textContent = '10px';
                    await saveData();
                    updateTimeDividerPreview();
                    showToast('圆角大小已重置');
                }
                
                // 重置所有时间旁白设置
                if (e.target.id === 'reset-all-time-divider-btn') {
                    if (!confirm('确定要重置所有时间旁白设置吗？')) return;
                    
                    db.timeDividerSettings = {
                        bgColor: 'rgba(200, 200, 200, 0.5)',
                        textColor: '#666666',
                        language: 'zh',
                        bgOpacity: 50,
                        textOpacity: 100,
                        borderRadius: 10
                    };
                    await saveData();
                    renderCustomizeForm();
                    showToast('所有时间旁白设置已重置');
                }
            });
        }

        // 颜色转换辅助函数
        function hexToRgba(hex, alpha = 1) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function rgbaToHex(rgba) {
            const match = rgba.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
            if (!match) return null;
            const r = parseInt(match[1]).toString(16).padStart(2, '0');
            const g = parseInt(match[2]).toString(16).padStart(2, '0');
            const b = parseInt(match[3]).toString(16).padStart(2, '0');
            return `#${r}${g}${b}`;
        }

        // 语言翻译字典
        const i18n = {
            'zh-CN': {
                // 主屏幕
                'chat': '聊天',
                'worldBook': '世界书',
                'apiSettings': 'API 设置',
                'wallpaper': '更换壁纸',
                'fontSettings': '字体设置',
                'customize': '主屏幕自定义',
                'tutorial': '教程',
                'dayMode': '日间',
                'nightMode': '夜间',
                
                // 通用按钮
                'back': '返回',
                'save': '保存',
                'cancel': '取消',
                'delete': '删除',
                'edit': '编辑',
                'add': '添加',
                'settings': '设置',
                'confirm': '确认',
                'reset': '重置',
                'apply': '应用',
                'close': '关闭',
                'ok': '确定',
                
                // 聊天界面
                'chatList': '聊天列表',
                'newChat': '新建聊天',
                'groupChat': '群聊',
                'sendMessage': '发送消息',
                'inputMessage': '输入消息...',
                'online': '在线',
                'offline': '离线',
                'typing': '正在输入...',
                
                // 设置相关
                'languageSwitch': '本机语言切换',
                'selectLanguage': '选择语言',
                'showDockNames': '底栏APP显示名字',
                'showStatusBar': '显示顶部电量栏和时间',
                'enableLockScreen': '启用锁屏页面',
                'resetAppearance': '重置主页面所有外观设置',
                
                // 提示信息
                'languageChanged': '语言已切换',
                'saved': '已保存',
                'deleted': '已删除',
                'resetSuccess': '重置成功',
                'confirmDelete': '确定要删除吗？',
                'confirmReset': '确定要重置吗？',
                
                // 时间相关
                'today': '今天',
                'yesterday': '昨天',
                'justNow': '刚刚',
                'minutesAgo': '分钟前',
                'hoursAgo': '小时前',
                'daysAgo': '天前'
            },
            'zh-TW': {
                'chat': '聊天',
                'worldBook': '世界書',
                'apiSettings': 'API 設置',
                'wallpaper': '更換壁紙',
                'fontSettings': '字體設置',
                'customize': '主屏幕自定義',
                'tutorial': '教程',
                'dayMode': '日間',
                'nightMode': '夜間',
                'back': '返回',
                'save': '保存',
                'cancel': '取消',
                'delete': '刪除',
                'edit': '編輯',
                'add': '添加',
                'settings': '設置',
                'confirm': '確認',
                'reset': '重置',
                'apply': '應用',
                'close': '關閉',
                'ok': '確定',
                'chatList': '聊天列表',
                'newChat': '新建聊天',
                'groupChat': '群聊',
                'sendMessage': '發送消息',
                'inputMessage': '輸入消息...',
                'online': '在線',
                'offline': '離線',
                'typing': '正在輸入...',
                'languageSwitch': '本機語言切換',
                'selectLanguage': '選擇語言',
                'showDockNames': '底欄APP顯示名字',
                'showStatusBar': '顯示頂部電量欄和時間',
                'enableLockScreen': '啟用鎖屏頁面',
                'resetAppearance': '重置主頁面所有外觀設置',
                'languageChanged': '語言已切換',
                'saved': '已保存',
                'deleted': '已刪除',
                'resetSuccess': '重置成功',
                'confirmDelete': '確定要刪除嗎？',
                'confirmReset': '確定要重置嗎？',
                'today': '今天',
                'yesterday': '昨天',
                'justNow': '剛剛',
                'minutesAgo': '分鐘前',
                'hoursAgo': '小時前',
                'daysAgo': '天前'
            },
            'en': {
                'chat': 'Chat',
                'worldBook': 'World Book',
                'apiSettings': 'API Settings',
                'wallpaper': 'Wallpaper',
                'fontSettings': 'Font Settings',
                'customize': 'Customize',
                'tutorial': 'Tutorial',
                'dayMode': 'Day',
                'nightMode': 'Night',
                'back': 'Back',
                'save': 'Save',
                'cancel': 'Cancel',
                'delete': 'Delete',
                'edit': 'Edit',
                'add': 'Add',
                'settings': 'Settings',
                'confirm': 'Confirm',
                'reset': 'Reset',
                'apply': 'Apply',
                'close': 'Close',
                'ok': 'OK',
                'chatList': 'Chat List',
                'newChat': 'New Chat',
                'groupChat': 'Group Chat',
                'sendMessage': 'Send Message',
                'inputMessage': 'Type a message...',
                'online': 'Online',
                'offline': 'Offline',
                'typing': 'Typing...',
                'languageSwitch': 'Language Switch',
                'selectLanguage': 'Select Language',
                'showDockNames': 'Show Dock App Names',
                'showStatusBar': 'Show Status Bar',
                'enableLockScreen': 'Enable Lock Screen',
                'resetAppearance': 'Reset All Appearance Settings',
                'languageChanged': 'Language Changed',
                'saved': 'Saved',
                'deleted': 'Deleted',
                'resetSuccess': 'Reset Successfully',
                'confirmDelete': 'Are you sure to delete?',
                'confirmReset': 'Are you sure to reset?',
                'today': 'Today',
                'yesterday': 'Yesterday',
                'justNow': 'Just now',
                'minutesAgo': 'minutes ago',
                'hoursAgo': 'hours ago',
                'daysAgo': 'days ago'
            },
            'ja': {
                'chat': 'チャット',
                'worldBook': 'ワールドブック',
                'apiSettings': 'API設定',
                'wallpaper': '壁紙',
                'fontSettings': 'フォント設定',
                'customize': 'カスタマイズ',
                'tutorial': 'チュートリアル',
                'dayMode': '昼',
                'nightMode': '夜',
                'back': '戻る',
                'save': '保存',
                'cancel': 'キャンセル',
                'delete': '削除',
                'edit': '編集',
                'add': '追加',
                'settings': '設定',
                'confirm': '確認',
                'reset': 'リセット',
                'apply': '適用',
                'close': '閉じる',
                'ok': 'OK',
                'chatList': 'チャットリスト',
                'newChat': '新しいチャット',
                'groupChat': 'グループチャット',
                'sendMessage': 'メッセージを送信',
                'inputMessage': 'メッセージを入力...',
                'online': 'オンライン',
                'offline': 'オフライン',
                'typing': '入力中...',
                'languageSwitch': '言語切替',
                'selectLanguage': '言語を選択',
                'showDockNames': 'ドックアプリ名を表示',
                'showStatusBar': 'ステータスバーを表示',
                'enableLockScreen': 'ロック画面を有効化',
                'resetAppearance': 'すべての外観設定をリセット',
                'languageChanged': '言語が変更されました',
                'saved': '保存しました',
                'deleted': '削除しました',
                'resetSuccess': 'リセットしました',
                'confirmDelete': '削除してもよろしいですか？',
                'confirmReset': 'リセットしてもよろしいですか？',
                'today': '今日',
                'yesterday': '昨日',
                'justNow': 'たった今',
                'minutesAgo': '分前',
                'hoursAgo': '時間前',
                'daysAgo': '日前'
            },
            'ko': {
                'chat': '채팅',
                'worldBook': '월드북',
                'apiSettings': 'API 설정',
                'wallpaper': '배경화면',
                'fontSettings': '글꼴 설정',
                'customize': '사용자 지정',
                'tutorial': '튜토리얼',
                'dayMode': '낮',
                'nightMode': '밤',
                'back': '뒤로',
                'save': '저장',
                'cancel': '취소',
                'delete': '삭제',
                'edit': '편집',
                'add': '추가',
                'settings': '설정',
                'confirm': '확인',
                'reset': '재설정',
                'apply': '적용',
                'close': '닫기',
                'ok': '확인',
                'chatList': '채팅 목록',
                'newChat': '새 채팅',
                'groupChat': '그룹 채팅',
                'sendMessage': '메시지 보내기',
                'inputMessage': '메시지 입력...',
                'online': '온라인',
                'offline': '오프라인',
                'typing': '입력 중...',
                'languageSwitch': '언어 전환',
                'selectLanguage': '언어 선택',
                'showDockNames': '독 앱 이름 표시',
                'showStatusBar': '상태 표시줄 표시',
                'enableLockScreen': '잠금 화면 활성화',
                'resetAppearance': '모든 외관 설정 재설정',
                'languageChanged': '언어가 변경되었습니다',
                'saved': '저장됨',
                'deleted': '삭제됨',
                'resetSuccess': '재설정 완료',
                'confirmDelete': '삭제하시겠습니까?',
                'confirmReset': '재설정하시겠습니까?',
                'today': '오늘',
                'yesterday': '어제',
                'justNow': '방금',
                'minutesAgo': '분 전',
                'hoursAgo': '시간 전',
                'daysAgo': '일 전'
            }
        };

        // 获取翻译文本
        function t(key, lang = null) {
            if (!db.enableLanguageSwitch) return key;
            const currentLang = lang || db.appLanguage || 'zh-CN';
            return i18n[currentLang]?.[key] || i18n['zh-CN']?.[key] || key;
        }

        // 应用语言翻译
        function applyLanguage(lang) {
            if (!db.enableLanguageSwitch) return;
            
            document.documentElement.lang = lang;
            
            // 翻译所有带data-i18n属性的元素
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                const text = t(key, lang);
                if (el.tagName === 'INPUT' && (el.type === 'text' || el.type === 'password')) {
                    el.placeholder = text;
                } else {
                    el.textContent = text;
                }
            });
            
            // 重新渲染主屏幕以应用翻译
            setupHomeScreen();
        }

        // 更新时间旁白预览
        function updateTimeDividerPreview() {
            const preview = document.getElementById('time-divider-preview');
            if (!preview) return;
            
            const bgColor = db.timeDividerSettings?.bgColor || 'rgba(200, 200, 200, 0.5)';
            const textColor = db.timeDividerSettings?.textColor || '#666666';
            const borderRadius = db.timeDividerSettings?.borderRadius !== undefined ? db.timeDividerSettings.borderRadius : 10;
            const language = db.timeDividerSettings?.language || 'zh';
            
            preview.style.backgroundColor = bgColor;
            preview.style.color = textColor;
            preview.style.borderRadius = borderRadius + 'px';
            
            const yesterday = new Date();
            yesterday.setDate(yesterday.getDate() - 1);
            preview.textContent = formatSystemTimestamp(yesterday.getTime());
        }

        function renderCustomizeForm() {
            customizeForm.innerHTML = '';
            
            // 确保 lockScreenPassword 对象存在
            if (!db.lockScreenPassword) {
                db.lockScreenPassword = {
                    type: 'none',
                    pin: '',
                    gesture: []
                };
            }
            
            // 确保 enableLockScreen 属性存在
            if (db.enableLockScreen === undefined) {
                db.enableLockScreen = false;
            }
            
            // 确保 floatingLyricsSettings 对象存在
            if (!db.floatingLyricsSettings) {
                db.floatingLyricsSettings = {
                    activeFontSize: 18,
                    otherFontSize: 13,
                    linesCount: 3,
                    activeColor: '#ff80ab',
                    previousColor: '#787878',
                    upcomingColor: '#787878',
                    lineGap: 8
                };
            }
            
            // 确保 timeDividerSettings 对象存在
            if (!db.timeDividerSettings) {
                db.timeDividerSettings = {
                    bgColor: 'rgba(200, 200, 200, 0.5)',
                    textColor: '#666666',
                    language: 'zh',
                    bgOpacity: 50,
                    textOpacity: 100,
                    borderRadius: 10
                };
            }
            
            Object.entries(defaultIcons).forEach(([id, {name, url}]) => {
                const currentIcon = db.customIcons[id] || url;
                const currentName = db.customIconNames[id] || name;
                const itemHTML = `
                <div class="icon-custom-item">
                    <img src="${currentIcon}" alt="${name}" class="icon-preview" id="icon-preview-${id}">
                    <div class="icon-details">
                        <p>${name || '模式切换'}</p>
                        <input type="text" class="form-group icon-name-input" placeholder="自定义图标名称" value="${currentName || ''}" data-id="${id}" style="margin-bottom: 10px;">
                        <input type="url" class="form-group" placeholder="粘贴新的图标URL" value="${db.customIcons[id] || ''}" data-id="${id}">
                        <input type="file" id="icon-upload-${id}" accept="image/*" style="display:none;" data-id="${id}">
                        <label for="icon-upload-${id}" class="btn btn-secondary" style="width: 100%; margin-top: 10px; padding: 8px;">从本地上传</label>
                    </div>
                    <button type="button" class="reset-icon-btn" data-id="${id}">重置</button>
                </div>`;
                customizeForm.insertAdjacentHTML('beforeend', itemHTML);
            });

            // 添加底栏APP显示名字开关
            const dockNamesToggleHTML = `
                <hr style="border:none; border-top:2px solid #f0f0f0; margin: 30px 0 20px 0;">
                
                <!-- 本机语言切换 -->
                <div class="form-group" style="margin-bottom: 20px;">
                    <div style="padding: 15px; background-color: #fff8fa; border-radius: 12px; border: 1px solid #fce4ec;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <label for="enable-language-switch-toggle" style="font-weight: 600; margin: 0; color: var(--text-color); flex-grow: 1;">本机语言切换</label>
                            <label class="toggle-switch">
                                <input type="checkbox" id="enable-language-switch-toggle" ${db.enableLanguageSwitch ? 'checked' : ''}>
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div id="language-select-container" style="display: ${db.enableLanguageSwitch ? 'block' : 'none'}; margin-top: 15px;">
                            <label style="font-weight: 600; margin-bottom: 8px; display: block; font-size: 14px;">选择语言</label>
                            <select id="app-language-select" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px;">
                                <option value="zh-CN" ${!db.appLanguage || db.appLanguage === 'zh-CN' ? 'selected' : ''}>简体中文</option>
                                <option value="zh-TW" ${db.appLanguage === 'zh-TW' ? 'selected' : ''}>繁體中文</option>
                                <option value="en" ${db.appLanguage === 'en' ? 'selected' : ''}>English</option>
                                <option value="ja" ${db.appLanguage === 'ja' ? 'selected' : ''}>日本語</option>
                                <option value="ko" ${db.appLanguage === 'ko' ? 'selected' : ''}>한국어</option>
                                <option value="es" ${db.appLanguage === 'es' ? 'selected' : ''}>Español</option>
                                <option value="fr" ${db.appLanguage === 'fr' ? 'selected' : ''}>Français</option>
                                <option value="de" ${db.appLanguage === 'de' ? 'selected' : ''}>Deutsch</option>
                                <option value="it" ${db.appLanguage === 'it' ? 'selected' : ''}>Italiano</option>
                                <option value="pt" ${db.appLanguage === 'pt' ? 'selected' : ''}>Português</option>
                                <option value="ru" ${db.appLanguage === 'ru' ? 'selected' : ''}>Русский</option>
                                <option value="ar" ${db.appLanguage === 'ar' ? 'selected' : ''}>العربية</option>
                                <option value="hi" ${db.appLanguage === 'hi' ? 'selected' : ''}>हिन्दी</option>
                                <option value="th" ${db.appLanguage === 'th' ? 'selected' : ''}>ไทย</option>
                                <option value="vi" ${db.appLanguage === 'vi' ? 'selected' : ''}>Tiếng Việt</option>
                                <option value="id" ${db.appLanguage === 'id' ? 'selected' : ''}>Bahasa Indonesia</option>
                                <option value="ms" ${db.appLanguage === 'ms' ? 'selected' : ''}>Bahasa Melayu</option>
                                <option value="tr" ${db.appLanguage === 'tr' ? 'selected' : ''}>Türkçe</option>
                                <option value="pl" ${db.appLanguage === 'pl' ? 'selected' : ''}>Polski</option>
                                <option value="nl" ${db.appLanguage === 'nl' ? 'selected' : ''}>Nederlands</option>
                                <option value="sv" ${db.appLanguage === 'sv' ? 'selected' : ''}>Svenska</option>
                                <option value="da" ${db.appLanguage === 'da' ? 'selected' : ''}>Dansk</option>
                                <option value="no" ${db.appLanguage === 'no' ? 'selected' : ''}>Norsk</option>
                                <option value="fi" ${db.appLanguage === 'fi' ? 'selected' : ''}>Suomi</option>
                                <option value="cs" ${db.appLanguage === 'cs' ? 'selected' : ''}>Čeština</option>
                                <option value="el" ${db.appLanguage === 'el' ? 'selected' : ''}>Ελληνικά</option>
                                <option value="he" ${db.appLanguage === 'he' ? 'selected' : ''}>עברית</option>
                                <option value="uk" ${db.appLanguage === 'uk' ? 'selected' : ''}>Українська</option>
                                <option value="ro" ${db.appLanguage === 'ro' ? 'selected' : ''}>Română</option>
                                <option value="hu" ${db.appLanguage === 'hu' ? 'selected' : ''}>Magyar</option>
                            </select>
                            <p style="font-size: 12px; color: #888; margin-top: 8px; margin-bottom: 0;">
                                注意：语言切换功能目前仅影响界面显示，不影响AI对话内容
                            </p>
                        </div>
                    </div>
                </div>
                
                <div class="form-group" style="margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 15px; background-color: #fff8fa; border-radius: 12px; border: 1px solid #fce4ec;">
                        <label for="show-dock-names-toggle" style="font-weight: 600; margin: 0; color: var(--text-color); flex-grow: 1;">底栏APP显示名字</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="show-dock-names-toggle" ${db.showDockAppNames ? 'checked' : ''}>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                
                <div class="form-group" style="margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 15px; background-color: #fff8fa; border-radius: 12px; border: 1px solid #fce4ec;">
                        <label for="show-status-bar-toggle" style="font-weight: 600; margin: 0; color: var(--text-color); flex-grow: 1;">显示顶部电量栏和时间</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="show-status-bar-toggle" ${db.showStatusBar ? 'checked' : ''}>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                
                <div class="form-group" style="margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 15px; background-color: #fff8fa; border-radius: 12px; border: 1px solid #fce4ec;">
                        <label for="enable-lock-screen-toggle" style="font-weight: 600; margin: 0; color: var(--text-color); flex-grow: 1;">启用锁屏页面</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="enable-lock-screen-toggle" ${db.enableLockScreen ? 'checked' : ''}>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
                
                <!-- 重置主页面外观设置按钮 -->
                <div class="form-group" style="margin-bottom: 20px;">
                    <button type="button" class="btn btn-danger" id="reset-appearance-btn" style="width: 100%; padding: 12px; font-size: 16px; font-weight: 600;">
                        重置主页面所有外观设置
                    </button>
                    <p style="font-size: 12px; color: #888; margin-top: 8px; margin-bottom: 0; line-height: 1.5;">
                        此操作将重置：应用图标、图标名称、主屏幕背景、锁屏壁纸、底栏名称显示、状态栏显示等所有外观设置到默认状态
                    </p>
                </div>
                
                <!-- 锁屏密码设置 -->
                <div id="lock-password-section" style="margin-bottom: 20px; display: ${db.enableLockScreen ? 'block' : 'none'};">
                    <h3 style="font-size: 16px; margin-bottom: 15px; color: #333;">锁屏密码</h3>
                    
                    <div class="form-group" style="margin-bottom: 15px;">
                        <label style="font-weight: 600; margin-bottom: 8px; display: block;">密码类型</label>
                        <select id="password-type-select" class="form-group" style="margin-bottom: 10px;">
                            <option value="none" ${db.lockScreenPassword.type === 'none' ? 'selected' : ''}>无密码</option>
                            <option value="pin" ${db.lockScreenPassword.type === 'pin' ? 'selected' : ''}>数字密码</option>
                            <option value="gesture" ${db.lockScreenPassword.type === 'gesture' ? 'selected' : ''}>手势密码</option>
                        </select>
                    </div>
                    
                    <!-- 数字密码设置 -->
                    <div id="pin-password-setup" style="display: ${db.lockScreenPassword.type === 'pin' ? 'block' : 'none'};">
                        <button type="button" class="btn btn-primary" id="set-pin-btn" style="width: 100%; margin-bottom: 10px;">
                            ${db.lockScreenPassword.pin ? '修改数字密码' : '设置数字密码'}
                        </button>
                        ${db.lockScreenPassword.pin ? '<p style="font-size: 14px; color: #4CAF50; margin: 0;">✓ 已设置数字密码</p>' : ''}
                    </div>
                    
                    <!-- 手势密码设置 -->
                    <div id="gesture-password-setup" style="display: ${db.lockScreenPassword.type === 'gesture' ? 'block' : 'none'};">
                        <button type="button" class="btn btn-primary" id="set-gesture-btn" style="width: 100%; margin-bottom: 10px;">
                            ${db.lockScreenPassword.gesture && db.lockScreenPassword.gesture.length > 0 ? '修改手势密码' : '设置手势密码'}
                        </button>
                        ${db.lockScreenPassword.gesture && db.lockScreenPassword.gesture.length > 0 ? '<p style="font-size: 14px; color: #4CAF50; margin: 0;">✓ 已设置手势密码</p>' : ''}
                    </div>
                </div>
            `;
            customizeForm.insertAdjacentHTML('beforeend', dockNamesToggleHTML);

            // 添加主屏幕预设管理区域
            const presetSectionHTML = `
                <hr style="border:none; border-top:1px solid #f0f0f0; margin: 20px 0;">
                <div class="preset-section">
                    <h3 style="font-size: 18px; font-weight: 600; color: var(--primary-color); margin-bottom: 15px;">主屏幕预设</h3>
                    
                    <div class="form-group" style="margin-bottom: 15px;">
                        <label for="preset-name-input" style="font-weight: 600; margin-bottom: 8px; display: block;">预设名称</label>
                        <input type="text" id="preset-name-input" class="form-group" placeholder="输入预设方案名称" style="margin-bottom: 10px;">
                        <button type="button" class="btn btn-primary" id="save-preset-btn" style="width: 100%;">保存当前主屏幕配置</button>
                        <button type="button" class="btn btn-secondary" id="import-homescreen-config-btn" style="width: 100%; margin-top: 10px;">导入主屏幕配置</button>
                        <button type="button" class="btn btn-secondary" id="export-homescreen-config-btn" style="width: 100%; margin-top: 10px;">导出主屏幕配置</button>
                        <input type="file" id="import-homescreen-config-input" accept=".json" style="display: none;">
                    </div>

                    <div class="form-group" style="margin-bottom: 15px;">
                        <label for="preset-select" style="font-weight: 600; margin-bottom: 8px; display: block;">选择预设方案</label>
                        <select id="preset-select" class="form-group" style="margin-bottom: 10px;">
                            <option value="">-- 选择一个预设方案 --</option>
                            ${(db.homeScreenPresets || []).map((preset, index) => 
                                `<option value="${index}">${preset.name}</option>`
                            ).join('')}
                        </select>
                        <button type="button" class="btn btn-secondary" id="apply-preset-btn" style="width: 100%; margin-bottom: 10px;">应用选中的预设</button>
                    </div>

                    <div class="preset-delete-section" style="margin-top: 20px;">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                            <label style="font-weight: 600; margin: 0;">管理预设</label>
                            <label style="font-size: 14px; color: #888;">
                                <input type="checkbox" id="select-all-presets" style="margin-right: 5px;">全选
                            </label>
                        </div>
                        <div id="preset-list" class="preset-list">
                            ${renderPresetList()}
                        </div>
                        <button type="button" class="btn btn-danger" id="delete-presets-btn" style="width: 100%; margin-top: 10px;">删除选中的预设</button>
                    </div>
                </div>
            `;
            customizeForm.insertAdjacentHTML('beforeend', presetSectionHTML);
            
            // 添加时间旁白样式设置区域
            const timeDividerSettingsHTML = `
                <hr style="border:none; border-top:2px solid #f0f0f0; margin: 30px 0 20px 0;">
                <div class="time-divider-settings-section">
                    <h3 style="font-size: 18px; font-weight: 600; color: var(--primary-color); margin-bottom: 15px;">时间旁白样式</h3>
                    
                    <!-- 背景颜色设置 -->
                    <div class="form-group" style="margin-bottom: 15px;">
                        <label style="font-weight: 600; margin-bottom: 8px; display: block;">旁白背景颜色</label>
                        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px;">
                            <input type="color" id="time-divider-bg-color" value="${(db.timeDividerSettings?.bgColor || 'rgba(200, 200, 200, 0.5)').replace(/rgba?\((\d+),\s*(\d+),\s*(\d+).*\)/, (m, r, g, b) => '#' + [r, g, b].map(x => parseInt(x).toString(16).padStart(2, '0')).join(''))}" style="width: 60px; height: 40px; border: none; border-radius: 8px; cursor: pointer;">
                            <input type="text" id="time-divider-bg-color-text" value="${db.timeDividerSettings?.bgColor || 'rgba(200, 200, 200, 0.5)'}" placeholder="rgba(200, 200, 200, 0.5)" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 8px;">
                            <button type="button" id="reset-time-divider-bg-color-btn" style="background: var(--secondary-color); color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px;">重置</button>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <label style="font-size: 12px; color: #666; min-width: 60px;">透明度:</label>
                            <input type="range" id="time-divider-bg-opacity" min="0" max="100" value="${db.timeDividerSettings?.bgOpacity !== undefined ? db.timeDividerSettings.bgOpacity : 50}" style="flex: 1; cursor: pointer;">
                            <span id="time-divider-bg-opacity-value" style="font-size: 12px; color: var(--primary-color); font-weight: 600; min-width: 40px;">${db.timeDividerSettings?.bgOpacity !== undefined ? db.timeDividerSettings.bgOpacity : 50}%</span>
                        </div>
                    </div>
                    
                    <!-- 文字颜色设置 -->
                    <div class="form-group" style="margin-bottom: 15px;">
                        <label style="font-weight: 600; margin-bottom: 8px; display: block;">旁白文字颜色</label>
                        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 8px;">
                            <input type="color" id="time-divider-text-color" value="${(db.timeDividerSettings?.textColor || '#666666').replace(/rgba?\((\d+),\s*(\d+),\s*(\d+).*\)/, (m, r, g, b) => '#' + [r, g, b].map(x => parseInt(x).toString(16).padStart(2, '0')).join(''))}" style="width: 60px; height: 40px; border: none; border-radius: 8px; cursor: pointer;">
                            <input type="text" id="time-divider-text-color-text" value="${db.timeDividerSettings?.textColor || '#666666'}" placeholder="#666666" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 8px;">
                            <button type="button" id="reset-time-divider-text-color-btn" style="background: var(--secondary-color); color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px;">重置</button>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <label style="font-size: 12px; color: #666; min-width: 60px;">透明度:</label>
                            <input type="range" id="time-divider-text-opacity" min="0" max="100" value="${db.timeDividerSettings?.textOpacity !== undefined ? db.timeDividerSettings.textOpacity : 100}" style="flex: 1; cursor: pointer;">
                            <span id="time-divider-text-opacity-value" style="font-size: 12px; color: var(--primary-color); font-weight: 600; min-width: 40px;">${db.timeDividerSettings?.textOpacity !== undefined ? db.timeDividerSettings.textOpacity : 100}%</span>
                        </div>
                    </div>
                    
                    <!-- 圆角大小设置 -->
                    <div class="form-group" style="margin-bottom: 15px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <span style="font-weight: 600;">圆角大小</span>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span id="time-divider-radius-value" style="color: var(--primary-color); font-weight: 600;">${db.timeDividerSettings?.borderRadius !== undefined ? db.timeDividerSettings.borderRadius : 10}px</span>
                                <button type="button" id="reset-time-divider-radius-btn" style="background: var(--secondary-color); color: white; border: none; padding: 4px 12px; border-radius: 5px; cursor: pointer; font-size: 12px;">重置</button>
                            </div>
                        </label>
                        <input type="range" id="time-divider-radius-slider" min="0" max="20" value="${db.timeDividerSettings?.borderRadius !== undefined ? db.timeDividerSettings.borderRadius : 10}" step="1" style="width: 100%; cursor: pointer;">
                    </div>
                    
                    <!-- 语言选择 -->
                    <div class="form-group" style="margin-bottom: 15px;">
                        <label style="font-weight: 600; margin-bottom: 8px; display: block;">时间显示语言</label>
                        <select id="time-divider-language" style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px;">
                            <option value="zh" ${!db.timeDividerSettings?.language || db.timeDividerSettings?.language === 'zh' ? 'selected' : ''}>中文</option>
                            <option value="en" ${db.timeDividerSettings?.language === 'en' ? 'selected' : ''}>English</option>
                            <option value="ja" ${db.timeDividerSettings?.language === 'ja' ? 'selected' : ''}>日本語</option>
                            <option value="ko" ${db.timeDividerSettings?.language === 'ko' ? 'selected' : ''}>한국어</option>
                            <option value="es" ${db.timeDividerSettings?.language === 'es' ? 'selected' : ''}>Español</option>
                            <option value="fr" ${db.timeDividerSettings?.language === 'fr' ? 'selected' : ''}>Français</option>
                            <option value="de" ${db.timeDividerSettings?.language === 'de' ? 'selected' : ''}>Deutsch</option>
                            <option value="it" ${db.timeDividerSettings?.language === 'it' ? 'selected' : ''}>Italiano</option>
                            <option value="pt" ${db.timeDividerSettings?.language === 'pt' ? 'selected' : ''}>Português</option>
                            <option value="ru" ${db.timeDividerSettings?.language === 'ru' ? 'selected' : ''}>Русский</option>
                        </select>
                    </div>
                    
                    <!-- 预览效果 -->
                    <div class="form-group" style="margin-bottom: 15px;">
                        <label style="font-weight: 600; margin-bottom: 8px; display: block;">预览效果</label>
                        <div style="text-align: center; padding: 20px; background: #f5f5f5; border-radius: 8px;">
                            <div id="time-divider-preview" style="display: inline-block; padding: 4px 10px; font-size: 12px; background-color: ${db.timeDividerSettings?.bgColor || 'rgba(200, 200, 200, 0.5)'}; color: ${db.timeDividerSettings?.textColor || '#666666'}; border-radius: ${db.timeDividerSettings?.borderRadius !== undefined ? db.timeDividerSettings.borderRadius : 10}px;">
                                昨天 21:13
                            </div>
                        </div>
                    </div>
                    
                    <!-- 重置按钮 -->
                    <div class="form-group" style="margin-top: 20px;">
                        <button type="button" class="btn btn-danger" id="reset-all-time-divider-btn" style="width: 100%; padding: 12px; font-size: 16px; font-weight: 600;">
                            重置所有时间旁白设置
                        </button>
                    </div>
                </div>
            `;
            customizeForm.insertAdjacentHTML('beforeend', timeDividerSettingsHTML);
            
            // 添加悬浮歌词设置区域
            const floatingLyricsSettingsHTML = `
                <hr style="border:none; border-top:2px solid #f0f0f0; margin: 30px 0 20px 0;">
                <div class="floating-lyrics-settings-section">
                    <h3 style="font-size: 18px; font-weight: 600; color: var(--primary-color); margin-bottom: 15px;">悬浮歌词设置</h3>
                    
                    <!-- 字号设置 -->
                    <div class="form-group" style="margin-bottom: 20px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <span style="font-weight: 600;">当前歌词字号</span>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span id="floating-lyrics-active-size-value" style="color: var(--primary-color); font-weight: 600;">${db.floatingLyricsSettings?.activeFontSize || 18}px</span>
                                <button type="button" id="reset-floating-lyrics-active-size-btn" style="background: var(--secondary-color); color: white; border: none; padding: 4px 12px; border-radius: 5px; cursor: pointer; font-size: 12px;">重置</button>
                            </div>
                        </label>
                        <input type="range" id="floating-lyrics-active-size-slider" min="14" max="32" value="${db.floatingLyricsSettings?.activeFontSize || 18}" step="1" style="width: 100%; cursor: pointer;">
                    </div>
                    
                    <!-- 其他歌词字号设置 -->
                    <div class="form-group" style="margin-bottom: 20px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <span style="font-weight: 600;">其他歌词字号</span>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span id="floating-lyrics-other-size-value" style="color: var(--primary-color); font-weight: 600;">${db.floatingLyricsSettings?.otherFontSize || 13}px</span>
                                <button type="button" id="reset-floating-lyrics-other-size-btn" style="background: var(--secondary-color); color: white; border: none; padding: 4px 12px; border-radius: 5px; cursor: pointer; font-size: 12px;">重置</button>
                            </div>
                        </label>
                        <input type="range" id="floating-lyrics-other-size-slider" min="10" max="24" value="${db.floatingLyricsSettings?.otherFontSize || 13}" step="1" style="width: 100%; cursor: pointer;">
                    </div>
                    
                    <!-- 显示句数设置 -->
                    <div class="form-group" style="margin-bottom: 20px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <span style="font-weight: 600;">显示歌词句数</span>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span id="floating-lyrics-lines-value" style="color: var(--primary-color); font-weight: 600;">${db.floatingLyricsSettings?.linesCount || 3}句</span>
                                <button type="button" id="reset-floating-lyrics-lines-btn" style="background: var(--secondary-color); color: white; border: none; padding: 4px 12px; border-radius: 5px; cursor: pointer; font-size: 12px;">重置</button>
                            </div>
                        </label>
                        <input type="range" id="floating-lyrics-lines-slider" min="1" max="7" value="${db.floatingLyricsSettings?.linesCount || 3}" step="1" style="width: 100%; cursor: pointer;">
                        <p style="font-size: 12px; color: #888; margin-top: 5px;">包括当前句、前一句和接下来的句子</p>
                    </div>
                    
                    <!-- 颜色设置 -->
                    <div class="form-group" style="margin-bottom: 15px;">
                        <label style="font-weight: 600; margin-bottom: 8px; display: block;">当前歌词颜色</label>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="color" id="floating-lyrics-active-color" value="${db.floatingLyricsSettings?.activeColor || '#ff80ab'}" style="width: 60px; height: 40px; border: none; border-radius: 8px; cursor: pointer;">
                            <input type="text" id="floating-lyrics-active-color-text" value="${db.floatingLyricsSettings?.activeColor || '#ff80ab'}" placeholder="#ff80ab" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 8px;">
                            <button type="button" id="reset-floating-lyrics-active-color-btn" style="background: var(--secondary-color); color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px;">重置</button>
                        </div>
                    </div>
                    
                    <div class="form-group" style="margin-bottom: 15px;">
                        <label style="font-weight: 600; margin-bottom: 8px; display: block;">前一句歌词颜色</label>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="color" id="floating-lyrics-previous-color" value="${db.floatingLyricsSettings?.previousColor || '#787878'}" style="width: 60px; height: 40px; border: none; border-radius: 8px; cursor: pointer;">
                            <input type="text" id="floating-lyrics-previous-color-text" value="${db.floatingLyricsSettings?.previousColor || '#787878'}" placeholder="#787878" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 8px;">
                            <button type="button" id="reset-floating-lyrics-previous-color-btn" style="background: var(--secondary-color); color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px;">重置</button>
                        </div>
                    </div>
                    
                    <div class="form-group" style="margin-bottom: 15px;">
                        <label style="font-weight: 600; margin-bottom: 8px; display: block;">接下来歌词颜色</label>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="color" id="floating-lyrics-upcoming-color" value="${db.floatingLyricsSettings?.upcomingColor || '#787878'}" style="width: 60px; height: 40px; border: none; border-radius: 8px; cursor: pointer;">
                            <input type="text" id="floating-lyrics-upcoming-color-text" value="${db.floatingLyricsSettings?.upcomingColor || '#787878'}" placeholder="#787878" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 8px;">
                            <button type="button" id="reset-floating-lyrics-upcoming-color-btn" style="background: var(--secondary-color); color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px;">重置</button>
                        </div>
                    </div>
                    
                    <!-- 歌词间隔设置 -->
                    <div class="form-group" style="margin-bottom: 20px;">
                        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <span style="font-weight: 600;">歌词上下间隔</span>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span id="floating-lyrics-gap-value" style="color: var(--primary-color); font-weight: 600;">${db.floatingLyricsSettings?.lineGap || 8}px</span>
                                <button type="button" id="reset-floating-lyrics-gap-btn" style="background: var(--secondary-color); color: white; border: none; padding: 4px 12px; border-radius: 5px; cursor: pointer; font-size: 12px;">重置</button>
                            </div>
                        </label>
                        <input type="range" id="floating-lyrics-gap-slider" min="0" max="30" value="${db.floatingLyricsSettings?.lineGap || 8}" step="1" style="width: 100%; cursor: pointer;">
                        <p style="font-size: 12px; color: #888; margin-top: 5px;">调整歌词行之间的垂直间距</p>
                    </div>
                    
                    <!-- 重置所有悬浮歌词设置 -->
                    <div class="form-group" style="margin-top: 20px;">
                        <button type="button" class="btn btn-danger" id="reset-all-floating-lyrics-btn" style="width: 100%; padding: 12px; font-size: 16px; font-weight: 600;">
                            重置所有悬浮歌词设置
                        </button>
                        <p style="font-size: 12px; color: #888; margin-top: 8px; margin-bottom: 0;">
                            将所有悬浮歌词设置恢复为默认值
                        </p>
                    </div>
                </div>
            `;
            customizeForm.insertAdjacentHTML('beforeend', floatingLyricsSettingsHTML);
        }

        function renderPresetList() {
            if (!db.homeScreenPresets || db.homeScreenPresets.length === 0) {
                return '<p style="text-align: center; color: #aaa; padding: 20px 0;">暂无保存的预设</p>';
            }
            return db.homeScreenPresets.map((preset, index) => `
                <div class="preset-item">
                    <label style="display: flex; align-items: center; cursor: pointer; padding: 10px; border-bottom: 1px solid #f0f0f0;">
                        <input type="checkbox" class="preset-checkbox" data-index="${index}" style="margin-right: 10px;">
                        <span style="flex-grow: 1;">${preset.name}</span>
                        <span style="font-size: 12px; color: #aaa;">${new Date(preset.timestamp).toLocaleDateString()}</span>
                    </label>
                </div>
            `).join('');
        }

        // 数字密码设置弹窗
        function showPinPasswordSetup() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                border-radius: 16px;
                padding: 20px;
                max-width: 380px;
                width: 90%;
                max-height: 90vh;
                overflow-y: auto;
                box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            `;
            
            content.innerHTML = `
                <h2 style="margin: 0 0 15px 0; color: var(--primary-color); font-size: 20px;">设置数字密码</h2>
                <p style="margin-bottom: 15px; color: #666; font-size: 14px;">请输入4-8位数字密码</p>
                
                <input type="password" id="pin-input-1" placeholder="输入密码" 
                    style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 16px; margin-bottom: 15px; box-sizing: border-box;" 
                    maxlength="8" pattern="[0-9]*" inputmode="numeric">
                
                <input type="password" id="pin-input-2" placeholder="确认密码" 
                    style="width: 100%; padding: 12px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 16px; margin-bottom: 20px; box-sizing: border-box;" 
                    maxlength="8" pattern="[0-9]*" inputmode="numeric">
                
                <div style="display: flex; gap: 10px;">
                    <button id="pin-cancel-btn" class="btn btn-secondary" style="flex: 1;">取消</button>
                    <button id="pin-confirm-btn" class="btn btn-primary" style="flex: 1;">确认</button>
                </div>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            const input1 = content.querySelector('#pin-input-1');
            const input2 = content.querySelector('#pin-input-2');
            const cancelBtn = content.querySelector('#pin-cancel-btn');
            const confirmBtn = content.querySelector('#pin-confirm-btn');
            
            // 取消按钮
            cancelBtn.addEventListener('click', () => {
                modal.remove();
            });
            
            // 点击背景关闭
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
            
            // 确认按钮
            confirmBtn.addEventListener('click', async () => {
                const pin1 = input1.value.trim();
                const pin2 = input2.value.trim();
                
                if (!pin1 || !pin2) {
                    showToast('请输入密码');
                    return;
                }
                
                if (pin1.length < 4 || pin1.length > 8) {
                    showToast('密码长度应为4-8位');
                    return;
                }
                
                if (!/^\d+$/.test(pin1)) {
                    showToast('密码只能包含数字');
                    return;
                }
                
                if (pin1 !== pin2) {
                    showToast('两次密码不一致');
                    return;
                }
                
                // 保存密码
                db.lockScreenPassword.pin = pin1;
                db.lockScreenPassword.type = 'pin';
                await saveData();
                
                showToast('数字密码设置成功！');
                modal.remove();
                
                // 刷新设置页面
                renderCustomizeForm();
            });
            
            // 自动聚焦第一个输入框
            setTimeout(() => input1.focus(), 100);
        }

        // 手势密码设置弹窗
        function showGesturePasswordSetup() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;
            
            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                border-radius: 16px;
                padding: 20px;
                max-width: 380px;
                width: 90%;
                max-height: 90vh;
                overflow-y: auto;
                box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            `;
            
            let currentPattern = [];
            let isConfirming = false;
            let firstPattern = [];
            
            content.innerHTML = `
                <h2 style="margin: 0 0 10px 0; color: var(--primary-color); font-size: 20px;">设置手势密码</h2>
                <p id="gesture-tip" style="margin-bottom: 15px; color: #666; font-size: 14px; text-align: center;">请绘制解锁手势</p>
                
                <canvas id="gesture-canvas" width="280" height="280" 
                    style="display: block; margin: 0 auto 15px auto; border: 2px solid #e0e0e0; border-radius: 12px; touch-action: none;"></canvas>
                
                <div style="display: flex; gap: 10px;">
                    <button id="gesture-cancel-btn" class="btn btn-secondary" style="flex: 1;">取消</button>
                    <button id="gesture-reset-btn" class="btn btn-danger" style="flex: 1;">重置</button>
                </div>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            const canvas = content.querySelector('#gesture-canvas');
            const ctx = canvas.getContext('2d');
            const tip = content.querySelector('#gesture-tip');
            const cancelBtn = content.querySelector('#gesture-cancel-btn');
            const resetBtn = content.querySelector('#gesture-reset-btn');
            
            // 九宫格配置
            const gridSize = 3;
            const circleRadius = 25;
            const padding = 40;
            const spacing = (canvas.width - padding * 2) / (gridSize - 1);
            
            // 创建九宫格点位
            const dots = [];
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    dots.push({
                        x: padding + col * spacing,
                        y: padding + row * spacing,
                        index: row * gridSize + col,
                        active: false
                    });
                }
            }
            
            // 绘制函数
            function draw(mouseX = null, mouseY = null) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // 绘制连线
                if (currentPattern.length > 0) {
                    ctx.strokeStyle = '#FF6B9D';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.beginPath();
                    
                    const firstDot = dots[currentPattern[0]];
                    ctx.moveTo(firstDot.x, firstDot.y);
                    
                    for (let i = 1; i < currentPattern.length; i++) {
                        const dot = dots[currentPattern[i]];
                        ctx.lineTo(dot.x, dot.y);
                    }
                    
                    // 如果正在绘制，连接到鼠标位置
                    if (mouseX !== null && mouseY !== null) {
                        ctx.lineTo(mouseX, mouseY);
                    }
                    
                    ctx.stroke();
                }
                
                // 绘制圆点
                dots.forEach(dot => {
                    ctx.beginPath();
                    ctx.arc(dot.x, dot.y, circleRadius, 0, Math.PI * 2);
                    
                    if (currentPattern.includes(dot.index)) {
                        ctx.fillStyle = '#FF6B9D';
                        ctx.fill();
                        ctx.strokeStyle = '#FF6B9D';
                    } else {
                        ctx.fillStyle = 'white';
                        ctx.fill();
                        ctx.strokeStyle = '#e0e0e0';
                    }
                    
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // 中心小圆点
                    ctx.beginPath();
                    ctx.arc(dot.x, dot.y, 6, 0, Math.PI * 2);
                    ctx.fillStyle = currentPattern.includes(dot.index) ? 'white' : '#999';
                    ctx.fill();
                });
            }
            
            // 获取触摸/鼠标位置
            function getEventPos(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            }
            
            // 检查点是否在圆内
            function checkDot(x, y) {
                for (let dot of dots) {
                    const distance = Math.sqrt(Math.pow(x - dot.x, 2) + Math.pow(y - dot.y, 2));
                    if (distance <= circleRadius) {
                        return dot.index;
                    }
                }
                return -1;
            }
            
            // 鼠标/触摸事件
            let isDrawing = false;
            
            function handleStart(e) {
                e.preventDefault();
                isDrawing = true;
                const pos = getEventPos(e);
                const dotIndex = checkDot(pos.x, pos.y);
                if (dotIndex !== -1 && !currentPattern.includes(dotIndex)) {
                    currentPattern.push(dotIndex);
                    draw();
                }
            }
            
            function handleMove(e) {
                if (!isDrawing) return;
                e.preventDefault();
                const pos = getEventPos(e);
                const dotIndex = checkDot(pos.x, pos.y);
                if (dotIndex !== -1 && !currentPattern.includes(dotIndex)) {
                    currentPattern.push(dotIndex);
                }
                draw(pos.x, pos.y);
            }
            
            async function handleEnd(e) {
                if (!isDrawing) return;
                e.preventDefault();
                isDrawing = false;
                draw();
                
                if (currentPattern.length < 4) {
                    tip.textContent = '至少连接4个点，请重新绘制';
                    tip.style.color = '#f44336';
                    setTimeout(() => {
                        currentPattern = [];
                        draw();
                        tip.textContent = isConfirming ? '请再次绘制手势' : '请绘制解锁手势';
                        tip.style.color = '#666';
                    }, 1000);
                    return;
                }
                
                if (!isConfirming) {
                    // 第一次绘制完成
                    firstPattern = [...currentPattern];
                    isConfirming = true;
                    tip.textContent = '请再次绘制确认';
                    tip.style.color = '#4CAF50';
                    setTimeout(() => {
                        currentPattern = [];
                        draw();
                    }, 500);
                } else {
                    // 第二次绘制完成，验证
                    if (JSON.stringify(firstPattern) === JSON.stringify(currentPattern)) {
                        // 保存手势密码
                        db.lockScreenPassword.gesture = firstPattern;
                        db.lockScreenPassword.type = 'gesture';
                        await saveData();
                        
                        showToast('手势密码设置成功！');
                        modal.remove();
                        
                        // 刷新设置页面
                        renderCustomizeForm();
                    } else {
                        tip.textContent = '两次手势不一致，请重新设置';
                        tip.style.color = '#f44336';
                        setTimeout(() => {
                            currentPattern = [];
                            firstPattern = [];
                            isConfirming = false;
                            draw();
                            tip.textContent = '请绘制解锁手势';
                            tip.style.color = '#666';
                        }, 1000);
                    }
                }
            }
            
            // 绑定事件
            canvas.addEventListener('mousedown', handleStart);
            canvas.addEventListener('mousemove', handleMove);
            canvas.addEventListener('mouseup', handleEnd);
            canvas.addEventListener('touchstart', handleStart);
            canvas.addEventListener('touchmove', handleMove);
            canvas.addEventListener('touchend', handleEnd);
            
            // 重置按钮
            resetBtn.addEventListener('click', () => {
                currentPattern = [];
                firstPattern = [];
                isConfirming = false;
                draw();
                tip.textContent = '请绘制解锁手势';
                tip.style.color = '#666';
            });
            
            // 取消按钮
            cancelBtn.addEventListener('click', () => {
                modal.remove();
            });
            
            // 点击背景关闭
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
            
            // 初始绘制
            draw();
        }

        function setupTutorialApp() {
            tutorialContentArea.addEventListener('click', (e) => {
                const header = e.target.closest('.tutorial-header');
                if (header) {
                    header.parentElement.classList.toggle('open');
                }
            });
        }

        let loadingBtn = false

        function renderTutorialContent() {
            const tutorials = [
                {title: '写在前面', imageUrls: ['https://i.postimg.cc/7PgyMG9S/image.jpg']},
                {
                    title: '二改说明',
                    content: `<div style="padding: 20px; line-height: 1.8; font-size: 15px; color: #333;">
                        <p style="margin-bottom: 15px; text-indent: 2em;">声明一下，这个文件是9.18分享出来的ee老师的原件，然后后面是由DC的呆（yuan）进行二改的。</p>
                        <p style="margin-bottom: 15px; text-indent: 2em;">其中缝合了多位老师的功能，在制作过程中真切体会到了各位老师的伟大。</p>
                        <p style="margin-bottom: 10px; font-weight: 600;">感谢以下老师：</p>
                        <ul style="margin-left: 20px; margin-bottom: 15px;">
                            <li style="margin-bottom: 8px;"><strong>源代码：</strong>ee</li>
                            <li style="margin-bottom: 8px;"><strong>缝合以下二改作者的部分功能代码：</strong></li>
                            <li style="margin-left: 20px; margin-bottom: 5px;">kuku老师</li>
                            <li style="margin-left: 20px; margin-bottom: 5px;">JCY老师</li>
                            <li style="margin-left: 20px; margin-bottom: 5px;">330老师</li>
                            <li style="margin-left: 20px; margin-bottom: 5px;">小兔主义和kitty两位老师</li>
                        </ul>
                        <p style="margin-top: 20px; padding: 15px; background-color: #f0f0f0; border-radius: 8px; text-indent: 2em; color: #555; line-height: 1.8;">
                            为了以防万一遗漏老师们，在这里向所有进行过改版的老师致谢。
                        </p>
                    </div>`,
                    imageUrls: []
                },
                {
                    title: '二传说明',
                    content: `<div style="position: relative; padding: 20px; line-height: 1.8; font-size: 15px; color: #333;">
                        <!-- 锁定遮罩层 -->
                        <div style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: #1a1a1a; backdrop-filter: blur(30px); -webkit-backdrop-filter: blur(30px); z-index: 999; display: flex; flex-direction: column; align-items: center; justify-content: center; border-radius: 8px;">
                            <div style="text-align: center; color: white;">
                                <div style="font-size: 80px; margin-bottom: 20px;">🔒</div>
                                <div style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">目前不允许二传哦！</div>
                                <div style="font-size: 16px; color: #cccccc;">请遵守相关规定</div>
                            </div>
                        </div>
                        <div style="margin-bottom: 20px; padding: 15px; background-color: #8b7ab8; border-radius: 8px; color: white; filter: blur(20px);">
                            <p style="margin: 0; font-size: 17px; font-weight: 600; text-align: center;">
                                粘包狗版本二传许可说明
                            </p>
                        </div>
                        
                        <div style="margin-bottom: 20px; padding: 15px; background-color: #e8f5e9; border-left: 4px solid #4caf50; border-radius: 4px; filter: blur(20px);">
                            <p style="margin: 0 0 10px 0; font-weight: 600; color: #2e7d32;">【允许二传范围】</p>
                            <p style="margin: 0; text-indent: 2em; color: #1b5e20;">
                                这个小手机是允许二传的，<strong>仅限粘包狗改的这个版本</strong>。其他老师改的版本需要你去征求其他老师的意见之后才可以。
                            </p>
                        </div>
                        
                        <div style="margin-bottom: 20px; padding: 15px; background-color: #fff3e0; border-left: 4px solid #ff9800; border-radius: 4px; filter: blur(20px);">
                            <p style="margin: 0 0 10px 0; font-weight: 600; color: #e65100;">【重要前提】</p>
                            <p style="margin: 0; text-indent: 2em; color: #bf360c;">
                                粘包狗版本是在<strong>尊重源代码和各位二改老师</strong>的前提下，暂时允许二传的。如果其中有任何一个老师跟我说不希望二传，那么将<strong>不允许二传</strong>。
                            </p>
                        </div>
                        
                        <div style="margin-bottom: 20px; padding: 15px; background-color: #ffebee; border-left: 4px solid #f44336; border-radius: 4px; filter: blur(20px);">
                            <p style="margin: 0 0 10px 0; font-weight: 600; color: #c62828;">【严格禁止事项】</p>
                            <ul style="margin: 10px 0 0 20px; padding: 0; color: #b71c1c;">
                                <li style="margin-bottom: 8px;"><strong>禁止商用：</strong>不允许任何买卖行为、盈利行为、打包出售等商业化操作</li>
                                <li style="margin-bottom: 8px;"><strong>禁止引流：</strong>不允许发帖四连、三连、评论宣传、用来涨粉等引流行为</li>
                                <li style="margin-bottom: 8px;"><strong>禁止大面积传播：</strong>不要在公开平台大范围宣传链接</li>
                            </ul>
                        </div>
                        
                        <div style="margin-bottom: 20px; padding: 15px; background-color: #e3f2fd; border-left: 4px solid #2196f3; border-radius: 4px; filter: blur(20px);">
                            <p style="margin: 0 0 10px 0; font-weight: 600; color: #0d47a1;">【正确的二传方式】</p>
                            <p style="margin: 0; text-indent: 2em; color: #01579b;">
                                你可以给<strong>没有在尾巴镇的同好或者群友</strong>私下发送这个链接，但请保持低调，<strong>最好不要大面积传播</strong>。
                            </p>
                        </div>
                        
                        <div style="margin-top: 20px; padding: 15px; background-color: #f5f5f5; border-radius: 8px; text-align: center; filter: blur(20px);">
                            <p style="margin: 0; font-size: 14px; color: #666; line-height: 1.6;">
                                感谢你的理解与配合<br>
                                让我们一起维护良好的分享环境
                            </p>
                        </div>
                    </div>`,
                    imageUrls: []
                },
                {
                    title: '软件介绍',
                    imageUrls: ['https://i.postimg.cc/VvsJRh6q/IMG-20250713-162647.jpg', 'https://i.postimg.cc/8P5FfxxD/IMG-20250713-162702.jpg', 'https://i.postimg.cc/3r94R3Sn/IMG-20250713-162712.jpg']
                },
                {
                    title: '404',
                    imageUrls: ['https://i.postimg.cc/x8scFPJW/IMG-20250713-162756.jpg', 'https://i.postimg.cc/pX6mfqtj/IMG-20250713-162809.jpg', 'https://i.postimg.cc/YScjV00q/IMG-20250713-162819.jpg', 'https://i.postimg.cc/13VfJw9j/IMG-20250713-162828.jpg']
                },
                {title: '404-群聊', imageUrls: ['https://i.postimg.cc/X7LSmRTJ/404.jpg']},
                {
                    title: '简洁模式 (Prompt优化)',
                    content: `
                        <div style="line-height: 1.8; color: #333;">
                            <h3 style="color: var(--primary-color); margin-top: 0;">什么是简洁模式？</h3>
                            <p>简洁模式是一个重要的Prompt优化功能，它可以帮助AI更好地扮演角色。</p>
                            
                            <h4 style="color: #666; margin-top: 20px;">为什么需要简洁模式？</h4>
                            <p><strong>问题：</strong>当系统提示词（Prompt）包含太多功能模块时，AI的注意力会被分散。就像一个人同时被要求做10件事情，很难把每件事都做好。</p>
                            
                            <p><strong>举例说明：</strong></p>
                            <ul style="margin-left: 20px;">
                                <li>如果Prompt里同时包含：心声功能、音乐功能、头像管理、NPC社交圈、线下模式、挂载聊天等十几个功能...</li>
                                <li>AI需要同时记住和处理这么多规则，就会导致角色扮演不够专注，回复质量下降</li>
                                <li>AI可能会忘记自己的人设，或者回复变得机械化</li>
                            </ul>
                            
                            <h4 style="color: #666; margin-top: 20px;">简洁模式的作用</h4>
                            <p>开启简洁模式后，你可以<strong>只选择需要的功能模块</strong>，关闭不常用的功能。这样：</p>
                            <ul style="margin-left: 20px;">
                                <li>✅ AI的注意力更集中，能更好地理解和扮演角色</li>
                                <li>✅ 减少Prompt长度，节省Token消耗</li>
                                <li>✅ 提高回复质量和角色一致性</li>
                                <li>✅ 加快AI响应速度</li>
                            </ul>
                            
                            <h4 style="color: #666; margin-top: 20px;">如何使用？</h4>
                            <p>在<strong>全局设置</strong>中找到"简洁模式"开关：</p>
                            <ol style="margin-left: 20px;">
                                <li>开启简洁模式</li>
                                <li>勾选你需要的功能模块（如心声、音乐、NPC等）</li>
                                <li>未勾选的功能将不会出现在系统提示词中</li>
                            </ol>
                            
                            <div style="background: #fff3e0; padding: 15px; border-radius: 8px; margin-top: 20px; border-left: 4px solid #ff9800;">
                                <strong>💡 建议：</strong>如果你只是想简单聊天，建议只保留"心声功能"和"时间感知"，关闭其他复杂功能。这样AI会更专注于角色扮演本身。
                            </div>
                        </div>
                    `
                },
                {
                    title: '消息数量限制说明',
                    content: `
                        <div style="line-height: 1.8; color: #333;">
                            <h3 style="color: var(--primary-color); margin-top: 0;">为什么要限制消息数量？</h3>
                            <p>消息数量限制是指AI每次回复时生成的消息条数范围（例如1-3条）。这个设置对Token消耗和对话质量都有重要影响。</p>
                            
                            <h4 style="color: #666; margin-top: 20px;">Token消耗问题</h4>
                            <p><strong>什么是Token？</strong></p>
                            <p>Token是AI处理文本的基本单位。简单理解：</p>
                            <ul style="margin-left: 20px;">
                                <li>1个中文字 ≈ 1.6个Token</li>
                                <li>1个英文单词 ≈ 1.3个Token</li>
                                <li>每次对话都会消耗Token（包括历史消息和系统提示词）</li>
                            </ul>
                            
                            <p><strong>消息数量如何影响Token？</strong></p>
                            <ul style="margin-left: 20px;">
                                <li>如果设置为1-20条：AI可能一次生成很多条消息，每条消息都会消耗Token</li>
                                <li>如果设置为1-3条：AI只生成少量消息，Token消耗更可控</li>
                                <li>历史消息越多，每次对话消耗的Token就越多</li>
                            </ul>
                            
                            <h4 style="color: #666; margin-top: 20px;">最大记忆轮数的作用</h4>
                            <p><strong>什么是记忆轮数？</strong></p>
                            <p>记忆轮数决定AI能"看到"多少条历史消息。例如设置为10轮，AI只会读取最近10轮对话。</p>
                            
                            <p><strong>为什么要限制记忆轮数？</strong></p>
                            <ul style="margin-left: 20px;">
                                <li>历史消息越多，Token消耗越大</li>
                                <li>如果记忆轮数太大（如100轮），每次对话都要处理大量历史，Token消耗会非常高</li>
                                <li>合理的记忆轮数（10-20轮）既能保持对话连贯性，又能控制Token消耗</li>
                            </ul>
                            
                            <h4 style="color: #666; margin-top: 20px;">实际例子</h4>
                            <div style="background: #e8f5e9; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #4caf50;">
                                <p style="margin: 0;"><strong>场景1：</strong>消息数量1-20条，记忆轮数100轮</p>
                                <p style="margin: 10px 0 0 0;">→ AI可能一次生成15条消息，加上100轮历史，Token消耗可能达到几万</p>
                            </div>
                            
                            <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid #2196f3;">
                                <p style="margin: 0;"><strong>场景2：</strong>消息数量1-3条，记忆轮数10轮</p>
                                <p style="margin: 10px 0 0 0;">→ AI每次生成2-3条消息，只读取最近10轮对话，Token消耗可能只有几千</p>
                            </div>
                            
                            <h4 style="color: #666; margin-top: 20px;">如何设置？</h4>
                            <p>在<strong>全局设置</strong>或<strong>角色设置</strong>中：</p>
                            <ol style="margin-left: 20px;">
                                <li><strong>消息数量限制：</strong>建议设置为1-3条或1-5条</li>
                                <li><strong>最大记忆轮数：</strong>建议设置为10-20轮</li>
                                <li>如果对话很长，可以使用"自动总结"功能压缩历史</li>
                            </ol>
                            
                            <div style="background: #fff3e0; padding: 15px; border-radius: 8px; margin-top: 20px; border-left: 4px solid #ff9800;">
                                <strong>💡 省Token小技巧：</strong>
                                <ul style="margin: 10px 0 0 20px;">
                                    <li>定期使用"自动总结"功能压缩历史对话</li>
                                    <li>开启"Token过大提示"，及时了解Token使用情况</li>
                                    <li>使用"查看Token详细"按钮，查看哪些部分占用了Token</li>
                                    <li>不需要的功能模块可以在简洁模式中关闭</li>
                                </ul>
                            </div>
                        </div>
                    `
                }
            ];
            tutorialContentArea.innerHTML = '';
            tutorials.forEach(tutorial => {
                const item = document.createElement('div');
                item.className = 'tutorial-item';
                let contentHtml = '';
                
                if (tutorial.content) {
                    contentHtml = tutorial.content;
                } else if (tutorial.imageUrls && tutorial.imageUrls.length > 0) {
                    contentHtml = tutorial.imageUrls.map(url => `<img src="${url}" alt="${tutorial.title}教程图片">`).join('');
                }
                
                item.innerHTML = `<div class="tutorial-header">${tutorial.title}</div><div class="tutorial-content">${contentHtml}</div>`;
                tutorialContentArea.appendChild(item);
            });

            const backupDataBtn = document.createElement('button');
            backupDataBtn.className = 'btn btn-primary';
            backupDataBtn.textContent = '备份数据';
            backupDataBtn.disabled = loadingBtn

            backupDataBtn.addEventListener('click', async () => {
                if(loadingBtn){
                    return
                }
                
                // 提示用户输入自定义文件名
                const customName = prompt('请输入备份文件名（留空使用默认名称）：', '');
                
                // 用户点击取消，则不执行备份
                if (customName === null) {
                    return;
                }
                
                loadingBtn = true
                try {
                    showToast('正在准备导出数据...');

                    // 创建完整的数据备份对象
                    const fullBackupData = await createFullBackupData();

                    const jsonString = JSON.stringify(fullBackupData);
                    const dataBlob = new Blob([jsonString]);

                    // Compress the data using Gzip
                    const compressionStream = new CompressionStream('gzip');
                    const compressedStream = dataBlob.stream().pipeThrough(compressionStream);
                    const compressedBlob = await new Response(compressedStream).blob();

                    const url = URL.createObjectURL(compressedBlob);
                    const a = document.createElement('a');
                    
                    // 生成文件名：如果用户输入了自定义名称则使用，否则使用默认格式
                    let fileName;
                    if (customName.trim()) {
                        // 使用自定义名称，自动添加.ee扩展名（如果用户没有输入）
                        fileName = customName.trim().endsWith('.ee') ? customName.trim() : `${customName.trim()}.ee`;
                    } else {
                        // 使用默认格式
                        const now = new Date();
                        const date = now.toISOString().slice(0, 10);
                        const time = now.toTimeString().slice(0, 8).replace(/:/g, '');
                        fileName = `章鱼喷墨_备份数据_${date}_${time}.ee`;
                    }
                    
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    loadingBtn = false
                    showToast('聊天记录导出成功');
                }catch (e){
                    loadingBtn = false
                    showToast(`导出失败, 发生错误: ${e.message}`);
                    console.error('导出错误详情:', e);
                }
            });
            
            // VIA浏览器专属备份按钮
            const viaBackupBtn = document.createElement('button');
            viaBackupBtn.className = 'btn';
            viaBackupBtn.textContent = 'VIA浏览器备份数据';
            viaBackupBtn.style.marginTop = '15px';
            viaBackupBtn.style.display = 'block';
            viaBackupBtn.style.backgroundColor = '#9c27b0'; // 紫色，区别于其他按钮
            viaBackupBtn.style.color = 'white';
            viaBackupBtn.disabled = loadingBtn;
            
            viaBackupBtn.addEventListener('click', async () => {
                if(loadingBtn){
                    return;
                }
                
                // 提示用户输入自定义文件名
                const customName = prompt('请输入备份文件名（留空使用默认名称）：', '');
                
                // 用户点击取消，则不执行备份
                if (customName === null) {
                    return;
                }
                
                loadingBtn = true;
                const originalText = viaBackupBtn.textContent;
                viaBackupBtn.textContent = '正在准备...';
                
                try {
                    showToast('正在为VIA浏览器准备备份数据...');

                    // 创建完整的数据备份对象
                    const fullBackupData = await createFullBackupData();
                    const jsonString = JSON.stringify(fullBackupData);

                    // VIA浏览器特殊处理：使用data URI方式
                    // 因为VIA浏览器不支持Blob下载，需要使用base64编码的data URI
                    const base64Data = btoa(unescape(encodeURIComponent(jsonString)));
                    const dataUri = `data:application/json;charset=utf-8;base64,${base64Data}`;
                    
                    // 生成文件名：如果用户输入了自定义名称则使用，否则使用默认格式
                    let fileName;
                    if (customName.trim()) {
                        // 使用自定义名称，自动添加.json扩展名（如果用户没有输入）
                        fileName = customName.trim().endsWith('.json') ? customName.trim() : `${customName.trim()}.json`;
                    } else {
                        // 使用默认格式
                        const now = new Date();
                        const date = now.toISOString().slice(0, 10);
                        const time = now.toTimeString().slice(0, 8).replace(/:/g, '');
                        fileName = `章鱼喷墨_VIA备份_${date}_${time}.json`;
                    }
                    
                    // 创建一个临时的a标签进行下载
                    const a = document.createElement('a');
                    a.href = dataUri;
                    a.download = fileName;
                    a.style.display = 'none';
                    document.body.appendChild(a);
                    
                    // VIA浏览器需要用户手动触发
                    a.click();
                    
                    // 延迟移除，确保下载开始
                    setTimeout(() => {
                        document.body.removeChild(a);
                    }, 100);
                    
                    showToast('VIA浏览器备份数据已准备好！请在下载管理中查看。');
                    
                    // 额外提示：如果data URI方式也不行，提供复制到剪贴板的备选方案
                    setTimeout(async () => {
                        const userChoice = confirm('如果下载未开始，是否将备份数据复制到剪贴板？\n（复制后可以手动粘贴保存到文本文件）');
                        if (userChoice) {
                            try {
                                await navigator.clipboard.writeText(jsonString);
                                await showCustomAlert('复制成功', '备份数据已复制到剪贴板！\n\n请打开文本编辑器，粘贴并保存为 .json 文件。');
                            } catch (err) {
                                // 如果剪贴板API失败，显示文本框让用户手动复制
                                const textarea = document.createElement('textarea');
                                textarea.value = jsonString;
                                textarea.style.position = 'fixed';
                                textarea.style.top = '0';
                                textarea.style.left = '0';
                                textarea.style.width = '100%';
                                textarea.style.height = '100%';
                                textarea.style.zIndex = '99999';
                                document.body.appendChild(textarea);
                                textarea.select();
                                document.execCommand('copy');
                                document.body.removeChild(textarea);
                                await showCustomAlert('复制成功', '备份数据已复制到剪贴板！\n\n请打开文本编辑器，粘贴并保存为 .json 文件。');
                            }
                        }
                    }, 2000);
                    
                } catch (e) {
                    showToast(`导出失败: ${e.message}`);
                    console.error('VIA备份导出错误:', e);
                } finally {
                    loadingBtn = false;
                    viaBackupBtn.textContent = originalText;
                }
            });
            
            // 大数据流式备份按钮
            const streamBackupBtn = document.createElement('button');
            streamBackupBtn.className = 'btn';
            streamBackupBtn.textContent = '大数据流式备份';
            streamBackupBtn.style.marginTop = '15px';
            streamBackupBtn.style.display = 'block';
            streamBackupBtn.style.backgroundColor = '#ff6f00'; // 橙色，表示高级功能
            streamBackupBtn.style.color = 'white';
            streamBackupBtn.disabled = loadingBtn;
            
            streamBackupBtn.addEventListener('click', async () => {
                if(loadingBtn){
                    return;
                }
                
                // 提示用户输入自定义文件名
                const customName = prompt('请输入备份文件名（留空使用默认名称）：', '');
                
                // 用户点击取消，则不执行备份
                if (customName === null) {
                    return;
                }
                
                loadingBtn = true;
                const originalText = streamBackupBtn.textContent;
                streamBackupBtn.textContent = '正在导出...';
                
                try {
                    showToast('正在使用流式方式导出大数据，请稍候...');
                    
                    // 生成文件名
                    let fileName;
                    if (customName.trim()) {
                        fileName = customName.trim().endsWith('.ee') ? customName.trim() : `${customName.trim()}.ee`;
                    } else {
                        const now = new Date();
                        const date = now.toISOString().slice(0, 10);
                        const time = now.toTimeString().slice(0, 8).replace(/:/g, '');
                        fileName = `章鱼喷墨_流式备份_${date}_${time}.ee`;
                    }
                    
                    // 检查是否支持 File System Access API
                    const supportsFileSystemAccess = 'showSaveFilePicker' in window;
                    
                    let writableStream, fileHandle, compressionStream, compressedWriter, reader, writePromise;
                    let chunks = []; // 用于降级方案收集数据块
                    
                    if (supportsFileSystemAccess) {
                        // 使用流式API创建可写流
                        fileHandle = await window.showSaveFilePicker({
                            suggestedName: fileName,
                            types: [{
                                description: '章鱼喷墨备份文件',
                                accept: {'application/octet-stream': ['.ee']},
                            }],
                        });
                        
                        writableStream = await fileHandle.createWritable();
                        
                        // 创建压缩流
                        compressionStream = new CompressionStream('gzip');
                        compressedWriter = compressionStream.writable.getWriter();
                        
                        // 将压缩后的数据写入文件
                        reader = compressionStream.readable.getReader();
                        writePromise = (async () => {
                            try {
                                while (true) {
                                    const { done, value } = await reader.read();
                                    if (done) break;
                                    await writableStream.write(value);
                                }
                            } finally {
                                await writableStream.close();
                            }
                        })();
                    } else {
                        // 降级方案：使用内存收集数据，最后一次性下载
                        showToast('您的浏览器不支持流式保存，将使用传统方式导出...');
                        compressionStream = new CompressionStream('gzip');
                        compressedWriter = compressionStream.writable.getWriter();
                        
                        // 读取压缩后的数据到内存
                        reader = compressionStream.readable.getReader();
                        writePromise = (async () => {
                            try {
                                while (true) {
                                    const { done, value } = await reader.read();
                                    if (done) break;
                                    chunks.push(value);
                                }
                            } catch (e) {
                                console.error('读取压缩数据错误:', e);
                            }
                        })();
                    }
                    
                    // 流式写入JSON数据
                    const encoder = new TextEncoder();
                    
                    // 开始写入JSON
                    await compressedWriter.write(encoder.encode('{"_exportVersion":"2.0","_exportTimestamp":' + Date.now() + ',"_optimizedStorage":true,"exportTime":"' + new Date().toISOString() + '",'));
                    
                    // 导出基础设置数据
                    showToast('正在导出基础设置...');
                    await compressedWriter.write(encoder.encode('"apiSettings":' + JSON.stringify(db.apiSettings || {}) + ','));
                    await compressedWriter.write(encoder.encode('"wallpaper":"' + (db.wallpaper || 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg') + '",'));
                    await compressedWriter.write(encoder.encode('"myStickers":' + JSON.stringify(db.myStickers || []) + ','));
                    await compressedWriter.write(encoder.encode('"stickerCategories":' + JSON.stringify(db.stickerCategories || []) + ','));
                    await compressedWriter.write(encoder.encode('"homeScreenMode":"' + (db.homeScreenMode || 'night') + '",'));
                    await compressedWriter.write(encoder.encode('"fontUrl":"' + (db.fontUrl || '') + '",'));
                    await compressedWriter.write(encoder.encode('"fontLibrary":' + JSON.stringify(db.fontLibrary || []) + ','));
                    await compressedWriter.write(encoder.encode('"fontSize":' + (db.fontSize || 16) + ','));
                    await compressedWriter.write(encoder.encode('"customIcons":' + JSON.stringify(db.customIcons || {}) + ','));
                    // 修复：导出人设预设
                    await compressedWriter.write(encoder.encode('"personaPresets":' + JSON.stringify(db.personaPresets || []) + ','));
                    
                    // 导出角色数据（包含完整历史）
                    showToast('正在导出角色数据...');
                    const charactersWithHistory = [];
                    for (const char of db.characters) {
                        const fullHistory = await dataStorage.getChatMessages(char.id, 'private');
                        const charData = await dataStorage.getData(`character_${char.id}`) || char;
                        // 修复：确保 worldBookIds 被导出
                        charactersWithHistory.push({
                            ...charData,
                            worldBookIds: charData.worldBookIds || char.worldBookIds || [],
                            history: fullHistory || []
                        });
                    }
                    await compressedWriter.write(encoder.encode('"characters":' + JSON.stringify(charactersWithHistory) + ','));
                    
                    // 导出群组数据（包含完整历史）
                    showToast('正在导出群组数据...');
                    const groupsWithHistory = [];
                    for (const group of db.groups) {
                        const fullHistory = await dataStorage.getChatMessages(group.id, 'group');
                        const groupData = await dataStorage.getData(`group_${group.id}`) || group;
                        // 修复：确保 worldBookIds 被导出
                        groupsWithHistory.push({
                            ...groupData,
                            worldBookIds: groupData.worldBookIds || group.worldBookIds || [],
                            history: fullHistory || []
                        });
                    }
                    await compressedWriter.write(encoder.encode('"groups":' + JSON.stringify(groupsWithHistory) + ','));
                    
                    // 导出世界书数据
                    showToast('正在导出世界书数据...');
                    await compressedWriter.write(encoder.encode('"worldBooks":' + JSON.stringify(db.worldBooks || []) + '}'));
                    
                    // 关闭写入流
                    await compressedWriter.close();
                    await writePromise;
                    
                    // 如果使用降级方案，创建并下载文件
                    if (!supportsFileSystemAccess) {
                        const blob = new Blob(chunks, { type: 'application/octet-stream' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = fileName;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    }
                    
                    showToast('流式备份导出成功！');
                    
                } catch (e) {
                    if (e.name === 'AbortError') {
                        showToast('用户取消了导出操作');
                    } else {
                        showToast(`导出失败: ${e.message}`);
                        console.error('流式备份导出错误:', e);
                    }
                } finally {
                    loadingBtn = false;
                    streamBackupBtn.textContent = originalText;
                }
            });
            
            // 转换备份按钮（将.txt格式转换为.ee格式）
            const convertBackupBtn = document.createElement('button');
            convertBackupBtn.className = 'btn';
            convertBackupBtn.textContent = '转换备份格式';
            convertBackupBtn.style.marginTop = '15px';
            convertBackupBtn.style.display = 'block';
            convertBackupBtn.style.backgroundColor = '#00bcd4'; // 青色，表示转换功能
            convertBackupBtn.style.color = 'white';
            convertBackupBtn.disabled = loadingBtn;
            
            convertBackupBtn.addEventListener('click', async () => {
                if(loadingBtn){
                    return;
                }
                
                // 创建文件输入元素
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.txt,.ee';
                
                fileInput.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    loadingBtn = true;
                    const originalText = convertBackupBtn.textContent;
                    convertBackupBtn.textContent = '正在转换...';
                    
                    try {
                        showToast('正在读取文件...');
                        console.log('开始读取文件:', file.name, '大小:', file.size);
                        
                        // 读取文件内容
                        const arrayBuffer = await file.arrayBuffer();
                        console.log('文件读取完成，大小:', arrayBuffer.byteLength);
                        
                        // 尝试解压缩（如果是.ee格式）
                        let jsonText;
                        let isCompressed = false;
                        
                        try {
                            const decompressStream = new DecompressionStream('gzip');
                            const decompressedStream = new Response(
                                new Blob([arrayBuffer]).stream().pipeThrough(decompressStream)
                            );
                            const decompressedData = await decompressedStream.arrayBuffer();
                            const textDecoder = new TextDecoder();
                            jsonText = textDecoder.decode(decompressedData);
                            isCompressed = true;
                            showToast('检测到压缩格式，已解压');
                            console.log('文件已解压，内容长度:', jsonText.length);
                        } catch (e) {
                            // 如果解压失败，说明可能是未压缩的文本文件
                            const textDecoder = new TextDecoder();
                            jsonText = textDecoder.decode(arrayBuffer);
                            showToast('检测到文本格式');
                            console.log('文件为文本格式，内容长度:', jsonText.length);
                        }
                        
                        // 验证JSON格式
                        console.log('开始解析JSON...');
                        const data = JSON.parse(jsonText);
                        console.log('JSON解析成功，数据键:', Object.keys(data));
                        
                        // 宽松的验证：只要是对象且包含一些备份数据就认为有效
                        const hasValidData = data && typeof data === 'object' && (
                            data.version || 
                            data.characters || 
                            data.groups || 
                            data.worldBooks || 
                            data.settings ||
                            data.exportTime
                        );
                        
                        if (!hasValidData) {
                            console.error('数据验证失败，数据内容:', data);
                            throw new Error('文件不包含有效的备份数据。请确保选择的是章鱼喷墨的备份文件。');
                        }
                        
                        showToast('文件验证成功，正在转换...');
                        console.log('开始转换文件...');
                        
                        // 生成新的文件名
                        const originalName = file.name.replace(/\.(txt|ee)$/i, '');
                        const newFileName = `${originalName}_转换.ee`;
                        
                        // 如果原文件已经是压缩格式，直接保存
                        if (isCompressed) {
                            showToast('文件已是标准格式，直接保存...');
                            const blob = new Blob([arrayBuffer], { type: 'application/octet-stream' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = newFileName;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        } else {
                            // 压缩数据
                            showToast('正在压缩数据...');
                            const compressionStream = new CompressionStream('gzip');
                            const compressedStream = new Response(
                                new Blob([jsonText]).stream().pipeThrough(compressionStream)
                            );
                            const compressedData = await compressedStream.arrayBuffer();
                            console.log('压缩完成，压缩后大小:', compressedData.byteLength);
                            
                            // 下载转换后的文件
                            const blob = new Blob([compressedData], { type: 'application/octet-stream' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = newFileName;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        }
                        
                        showToast('转换成功！文件已下载为 .ee 格式');
                        console.log('转换完成！');
                        
                    } catch (e) {
                        const errorMsg = e.message || '未知错误';
                        showToast(`转换失败: ${errorMsg}`);
                        console.error('转换备份格式错误:', e);
                        console.error('错误堆栈:', e.stack);
                        
                        // 如果是JSON解析错误，给出更友好的提示
                        if (e instanceof SyntaxError) {
                            showToast('文件格式错误：无法解析JSON数据，请确保文件未损坏');
                        }
                    } finally {
                        loadingBtn = false;
                        convertBackupBtn.textContent = originalText;
                    }
                });
                
                // 触发文件选择
                fileInput.click();
            });
            
            const importDataBtn = document.createElement('label');
            importDataBtn.className = 'btn btn-neutral';
            importDataBtn.textContent = '导入数据';
            importDataBtn.style.marginTop = '15px'
            importDataBtn.style.display = 'block'
            importDataBtn.disabled = loadingBtn;
            importDataBtn.setAttribute('for', 'import-data-input')
            document.querySelector('#import-data-input').addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                if(confirm('此操作将覆盖当前所有聊天记录和设置。此操作不可撤销。确定要继续吗？')){
                    try {
                        showToast('正在导入数据，请稍候...');

                        // Decompress the file stream
                        const decompressionStream = new DecompressionStream('gzip');
                        const decompressedStream = file.stream().pipeThrough(decompressionStream);
                        const jsonString = await new Response(decompressedStream).text();

                        let data = JSON.parse(jsonString);

                        // 检测数据格式并进行兼容性处理
                        const importResult = await importBackupData(data);

                        if (importResult.success) {
                            showToast(`数据导入成功！${importResult.message} 应用即将刷新。`);
                            setTimeout(() => {
                                window.location.href = window.location.href;
                            }, 2000);
                        } else {
                            showToast(`导入失败: ${importResult.error}`);
                        }
                    } catch (error) {
                        console.error("导入失败:", error);
                        showToast(`解压或解析文件时发生错误: ${error.message}`);
                    } finally {
                        event.target.value = null;
                    }
                } else {
                    event.target.value = null;
                }
            });

            // 大数据流式导入按钮
            const streamImportBtn = document.createElement('button');
            streamImportBtn.className = 'btn';
            streamImportBtn.textContent = '大数据流式导入';
            streamImportBtn.style.marginTop = '15px';
            streamImportBtn.style.display = 'block';
            streamImportBtn.style.backgroundColor = '#00897b'; // 青色，与流式导出呼应
            streamImportBtn.style.color = 'white';
            streamImportBtn.disabled = loadingBtn;
            
            streamImportBtn.addEventListener('click', async () => {
                if(loadingBtn){
                    return;
                }
                
                if(!confirm('此操作将覆盖当前所有聊天记录和设置。此操作不可撤销。确定要继续吗？')){
                    return;
                }
                
                loadingBtn = true;
                const originalText = streamImportBtn.textContent;
                streamImportBtn.textContent = '正在导入...';
                
                try {
                    // 检查是否支持 File System Access API
                    const supportsFileSystemAccess = 'showOpenFilePicker' in window;
                    
                    let file;
                    if (supportsFileSystemAccess) {
                        // 使用文件选择器API
                        const [fileHandle] = await window.showOpenFilePicker({
                            types: [{
                                description: '章鱼喷墨备份文件',
                                accept: {'application/octet-stream': ['.ee', '.json']},
                            }],
                            multiple: false,
                        });
                        file = await fileHandle.getFile();
                    } else {
                        // 降级方案：使用传统的 input file 元素
                        showToast('您的浏览器不支持新版文件选择器，将使用传统方式...');
                        file = await new Promise((resolve, reject) => {
                            const input = document.createElement('input');
                            input.type = 'file';
                            input.accept = '.ee,.json';
                            input.onchange = (e) => {
                                const selectedFile = e.target.files[0];
                                if (selectedFile) {
                                    resolve(selectedFile);
                                } else {
                                    reject(new Error('未选择文件'));
                                }
                            };
                            input.oncancel = () => reject(new Error('用户取消选择'));
                            input.click();
                        });
                    }
                    showToast('正在使用流式方式导入大数据，请稍候...');
                    
                    // 判断文件类型
                    const isCompressed = file.name.endsWith('.ee');
                    
                    let jsonString = '';
                    
                    if (isCompressed) {
                        // 流式解压缩
                        showToast('正在解压缩文件...');
                        const decompressionStream = new DecompressionStream('gzip');
                        const decompressedStream = file.stream().pipeThrough(decompressionStream);
                        
                        // 分块读取解压后的数据
                        const reader = decompressedStream.getReader();
                        const decoder = new TextDecoder();
                        const chunks = [];
                        let totalSize = 0;
                        
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            
                            chunks.push(decoder.decode(value, { stream: true }));
                            totalSize += value.length;
                            
                            // 每读取5MB更新一次提示
                            if (totalSize % (5 * 1024 * 1024) < value.length) {
                                const sizeMB = (totalSize / (1024 * 1024)).toFixed(1);
                                streamImportBtn.textContent = `解压中 ${sizeMB}MB`;
                            }
                            
                            // 让出控制权
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                        
                        // 添加最后的解码片段
                        chunks.push(decoder.decode());
                        jsonString = chunks.join('');
                        
                    } else {
                        // 直接读取JSON文件（分块读取）
                        showToast('正在读取文件...');
                        const reader = file.stream().getReader();
                        const decoder = new TextDecoder();
                        const chunks = [];
                        let totalSize = 0;
                        
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            
                            chunks.push(decoder.decode(value, { stream: true }));
                            totalSize += value.length;
                            
                            if (totalSize % (5 * 1024 * 1024) < value.length) {
                                const sizeMB = (totalSize / (1024 * 1024)).toFixed(1);
                                streamImportBtn.textContent = `读取中 ${sizeMB}MB`;
                            }
                            
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                        
                        chunks.push(decoder.decode());
                        jsonString = chunks.join('');
                    }
                    
                    showToast('正在解析数据...');
                    streamImportBtn.textContent = '解析中...';
                    
                    // 分块解析JSON（避免一次性解析大JSON导致卡顿）
                    let data;
                    try {
                        data = JSON.parse(jsonString);
                    } catch (parseError) {
                        throw new Error(`JSON解析失败: ${parseError.message}`);
                    }
                    
                    // 释放内存
                    jsonString = null;
                    
                    showToast('正在导入数据到数据库...');
                    streamImportBtn.textContent = '导入中...';
                    
                    // 清空现有数据
                    await db.characters.clear();
                    await db.groups.clear();
                    await db.messageChunks.clear();
                    await db.worldBooks.clear();
                    await db.qzonePosts.clear();
                    await db.favorites.clear();
                    await db.settings.clear();
                    
                    // 分批导入数据
                    if (data.characters && data.characters.length > 0) {
                        showToast(`正在导入 ${data.characters.length} 个角色...`);
                        const batchSize = 50;
                        for (let i = 0; i < data.characters.length; i += batchSize) {
                            const batch = data.characters.slice(i, i + batchSize);
                            await db.characters.bulkAdd(batch);
                            streamImportBtn.textContent = `导入角色 ${Math.min(i + batchSize, data.characters.length)}/${data.characters.length}`;
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                    }
                    
                    if (data.groups && data.groups.length > 0) {
                        showToast(`正在导入 ${data.groups.length} 个群组...`);
                        const batchSize = 50;
                        for (let i = 0; i < data.groups.length; i += batchSize) {
                            const batch = data.groups.slice(i, i + batchSize);
                            await db.groups.bulkAdd(batch);
                            streamImportBtn.textContent = `导入群组 ${Math.min(i + batchSize, data.groups.length)}/${data.groups.length}`;
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                    }
                    
                    if (data.worldBooks && data.worldBooks.length > 0) {
                        showToast(`正在导入 ${data.worldBooks.length} 个世界书...`);
                        await db.worldBooks.bulkAdd(data.worldBooks);
                    }
                    
                    if (data.qzonePosts && data.qzonePosts.length > 0) {
                        showToast(`正在导入 ${data.qzonePosts.length} 条说说...`);
                        const batchSize = 100;
                        for (let i = 0; i < data.qzonePosts.length; i += batchSize) {
                            const batch = data.qzonePosts.slice(i, i + batchSize);
                            await db.qzonePosts.bulkAdd(batch);
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                    }
                    
                    if (data.favorites && data.favorites.length > 0) {
                        showToast(`正在导入 ${data.favorites.length} 条收藏...`);
                        const batchSize = 100;
                        for (let i = 0; i < data.favorites.length; i += batchSize) {
                            const batch = data.favorites.slice(i, i + batchSize);
                            await db.favorites.bulkAdd(batch);
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                    }
                    
                    // 导入消息数据（分批处理）
                    if (data.messageChunks) {
                        const chunkKeys = Object.keys(data.messageChunks);
                        showToast(`正在导入 ${chunkKeys.length} 个消息块...`);
                        
                        const batchSize = 50;
                        for (let i = 0; i < chunkKeys.length; i += batchSize) {
                            const batchKeys = chunkKeys.slice(i, i + batchSize);
                            const batchData = batchKeys.map(key => data.messageChunks[key]);
                            await db.messageChunks.bulkAdd(batchData);
                            
                            const progress = Math.round(((i + batchSize) / chunkKeys.length) * 100);
                            streamImportBtn.textContent = `导入消息 ${Math.min(progress, 100)}%`;
                            
                            await new Promise(resolve => setTimeout(resolve, 0));
                        }
                    }
                    
                    if (data.settings && data.settings.length > 0) {
                        showToast('正在导入设置...');
                        await db.settings.bulkAdd(data.settings);
                    }
                    
                    // 释放内存
                    data = null;
                    
                    showToast('数据导入成功！应用即将刷新。');
                    setTimeout(() => {
                        window.location.href = window.location.href;
                    }, 2000);
                    
                } catch (e) {
                    if (e.name === 'AbortError') {
                        showToast('用户取消了导入操作');
                    } else {
                        showToast(`导入失败: ${e.message}`);
                        console.error('流式导入错误:', e);
                    }
                } finally {
                    loadingBtn = false;
                    streamImportBtn.textContent = originalText;
                }
            });

            // 查看本机数据大小按钮
            const viewDataSizeBtn = document.createElement('button');
            viewDataSizeBtn.className = 'btn';
            viewDataSizeBtn.textContent = '查看本机数据大小';
            viewDataSizeBtn.style.marginTop = '15px';
            viewDataSizeBtn.style.display = 'block';
            viewDataSizeBtn.style.backgroundColor = '#42a5f5'; // Blue color
            viewDataSizeBtn.style.color = 'white';
            
            viewDataSizeBtn.addEventListener('click', async () => {
                if (loadingBtn) return;
                
                loadingBtn = true;
                const originalText = viewDataSizeBtn.textContent;
                viewDataSizeBtn.textContent = '正在计算...';
                
                try {
                    showToast('正在计算数据大小...');
                    const info = await dataStorage.getStorageInfo();
                    
                    if (info) {
                        // 格式化数据大小函数
                        const formatSize = (bytes) => {
                            if (bytes < 1024) return `${bytes.toFixed(2)} B`;
                            if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB`;
                            if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
                            return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
                        };
                        
                        // 统计详细数据类型
                        let characterCount = 0;
                        let groupCount = 0;
                        let otherCount = 0;
                        const characterItems = [];
                        const groupItems = [];
                        const systemItems = [];
                        
                        info.items.forEach(item => {
                            if (item.key.startsWith('character_')) {
                                characterCount++;
                                characterItems.push(item);
                            } else if (item.key.startsWith('group_')) {
                                groupCount++;
                                groupItems.push(item);
                            } else {
                                otherCount++;
                                systemItems.push(item);
                            }
                        });
                        
                        // 显示详情的函数 - 创建独立的详情弹窗
                        const showDetailDialog = async (title, items, type) => {
                            // 创建详情弹窗遮罩层
                            const detailOverlay = document.createElement('div');
                            detailOverlay.style.cssText = `
                                position: fixed;
                                top: 0;
                                left: 0;
                                width: 100%;
                                height: 100%;
                                background: rgba(0, 0, 0, 0.5);
                                display: flex;
                                justify-content: center;
                                align-items: center;
                                z-index: 10001;
                                animation: fadeIn 0.2s ease;
                            `;
                            
                            let detailContent = `
                                <div style="font-size: 14px; color: #666; margin-bottom: 15px;">共 ${items.length} 项数据</div>
                            `;
                            
                            if (type === 'storage') {
                                detailContent += `<div style="font-size: 13px; line-height: 1.8;">`;
                                for (const item of items) {
                                    const data = await dataStorage.getData(item.key);
                                    const size = data ? JSON.stringify(data).length : 0;
                                    detailContent += `
                                        <div style="padding: 8px; margin-bottom: 6px; background: #f5f5f5; border-radius: 4px;">
                                            <div style="font-weight: 600; color: #333; margin-bottom: 4px;">${item.key}</div>
                                            <div style="color: #666; font-size: 12px;">大小: ${formatSize(size)}</div>
                                        </div>
                                    `;
                                }
                                detailContent += `</div>`;
                            } else if (type === 'messages') {
                                detailContent += `
                                    <div style="font-size: 13px; color: #666; line-height: 1.8;">
                                        <div style="padding: 8px; background: #f5f5f5; border-radius: 4px; margin-bottom: 8px;">
                                            <div>消息块总数: ${info.chunkCount} 块</div>
                                            <div>消息总大小: ${formatSize(info.messageSize)}</div>
                                        </div>
                                        <div style="color: #999; font-size: 12px;">
                                            消息数据按角色和群组分块存储，每个聊天会话的消息独立保存
                                        </div>
                                    </div>
                                `;
                            } else if (type === 'characters') {
                                detailContent += `<div style="font-size: 13px; line-height: 1.8;">`;
                                for (const item of items) {
                                    const charData = await dataStorage.getData(item.key);
                                    const size = charData ? JSON.stringify(charData).length : 0;
                                    const charId = item.key.replace('character_', '');
                                    const char = db.characters.find(c => c.id === charId);
                                    const name = char ? char.name : '未知角色';
                                    detailContent += `
                                        <div style="padding: 8px; margin-bottom: 6px; background: #f5f5f5; border-radius: 4px;">
                                            <div style="font-weight: 600; color: #333; margin-bottom: 4px;">${name}</div>
                                            <div style="color: #666; font-size: 12px;">ID: ${charId}</div>
                                            <div style="color: #666; font-size: 12px;">大小: ${formatSize(size)}</div>
                                        </div>
                                    `;
                                }
                                detailContent += `</div>`;
                            } else if (type === 'groups') {
                                detailContent += `<div style="font-size: 13px; line-height: 1.8;">`;
                                for (const item of items) {
                                    const groupData = await dataStorage.getData(item.key);
                                    const size = groupData ? JSON.stringify(groupData).length : 0;
                                    const groupId = item.key.replace('group_', '');
                                    const group = db.groups.find(g => g.id === groupId);
                                    const name = group ? group.name : '未知群组';
                                    detailContent += `
                                        <div style="padding: 8px; margin-bottom: 6px; background: #f5f5f5; border-radius: 4px;">
                                            <div style="font-weight: 600; color: #333; margin-bottom: 4px;">${name}</div>
                                            <div style="color: #666; font-size: 12px;">ID: ${groupId}</div>
                                            <div style="color: #666; font-size: 12px;">大小: ${formatSize(size)}</div>
                                        </div>
                                    `;
                                }
                                detailContent += `</div>`;
                            } else if (type === 'system') {
                                detailContent += `<div style="font-size: 13px; line-height: 1.8;">`;
                                for (const item of items) {
                                    const data = await dataStorage.getData(item.key);
                                    const size = data ? JSON.stringify(data).length : 0;
                                    detailContent += `
                                        <div style="padding: 8px; margin-bottom: 6px; background: #f5f5f5; border-radius: 4px;">
                                            <div style="font-weight: 600; color: #333; margin-bottom: 4px;">${item.key}</div>
                                            <div style="color: #666; font-size: 12px;">大小: ${formatSize(size)}</div>
                                        </div>
                                    `;
                                }
                                detailContent += `</div>`;
                            } else if (type === 'cache') {
                                detailContent += `
                                    <div style="font-size: 13px; color: #666; line-height: 1.8;">
                                        <div style="padding: 8px; background: #f5f5f5; border-radius: 4px; margin-bottom: 8px;">
                                            <div>缓存项数: ${info.cacheSize} 项</div>
                                        </div>
                                        <div style="color: #999; font-size: 12px;">
                                            缓存用于加速数据访问，存储在内存中，重启应用后会清空
                                        </div>
                                    </div>
                                `;
                            }
                            
                            // 创建详情弹窗内容
                            const detailModal = document.createElement('div');
                            detailModal.style.cssText = `
                                background: white;
                                border-radius: 12px;
                                padding: 24px;
                                max-width: 500px;
                                width: 90%;
                                max-height: 80vh;
                                overflow: hidden;
                                display: flex;
                                flex-direction: column;
                                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
                                animation: slideUp 0.3s ease;
                            `;
                            
                            detailModal.innerHTML = `
                                <div style="font-size: 18px; font-weight: 600; color: #333; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 2px solid #f0f0f0;">
                                    ${title}
                                </div>
                                <div style="flex: 1; overflow-y: auto; margin-bottom: 16px;">
                                    ${detailContent}
                                </div>
                                <div style="display: flex; justify-content: flex-end;">
                                    <button id="detail-close-btn" style="
                                        padding: 10px 24px;
                                        background: #42a5f5;
                                        color: white;
                                        border: none;
                                        border-radius: 6px;
                                        font-size: 14px;
                                        cursor: pointer;
                                        transition: all 0.2s;
                                    " onmouseover="this.style.background='#1e88e5'" onmouseout="this.style.background='#42a5f5'">确定</button>
                                </div>
                            `;
                            
                            detailOverlay.appendChild(detailModal);
                            document.body.appendChild(detailOverlay);
                            
                            // 关闭详情弹窗
                            const closeDetail = () => {
                                detailOverlay.style.animation = 'fadeOut 0.2s ease';
                                setTimeout(() => {
                                    document.body.removeChild(detailOverlay);
                                }, 200);
                            };
                            
                            // 点击确定按钮关闭
                            document.getElementById('detail-close-btn').addEventListener('click', closeDetail);
                            
                            // 点击遮罩层关闭
                            detailOverlay.addEventListener('click', (e) => {
                                if (e.target === detailOverlay) {
                                    closeDetail();
                                }
                            });
                        };
                        
                        const message = `
                            <div style="text-align: left; max-height: 400px; overflow-y: auto; padding: 5px;">
                                <div style="margin-bottom: 15px;">
                                    <div style="font-size: 15px; font-weight: 600; color: #333; margin-bottom: 8px;">总数据大小</div>
                                    <div style="font-size: 24px; font-weight: bold; color: #ff80ab;">${formatSize(info.totalSize)}</div>
                                </div>
                                
                                <div style="border-top: 1px solid #f0f0f0; padding-top: 12px; margin-bottom: 15px;">
                                    <div style="font-size: 15px; font-weight: 600; color: #333; margin-bottom: 10px;">数据分布</div>
                                    <div class="data-item" data-type="storage" style="margin-bottom: 8px; padding: 10px; background: #f8f9fa; border-radius: 6px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='#f8f9fa'">
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <span style="font-size: 14px; color: #495057; font-weight: 500;">存储数据</span>
                                            <span style="font-size: 14px; font-weight: 600; color: #42a5f5;">${formatSize(info.storageSize)}</span>
                                        </div>
                                        <div style="font-size: 11px; color: #868e96; margin-top: 4px;">点击查看详情</div>
                                    </div>
                                    <div class="data-item" data-type="messages" style="margin-bottom: 8px; padding: 10px; background: #f8f9fa; border-radius: 6px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='#f8f9fa'">
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <span style="font-size: 14px; color: #495057; font-weight: 500;">消息记录</span>
                                            <span style="font-size: 14px; font-weight: 600; color: #66bb6a;">${formatSize(info.messageSize)}</span>
                                        </div>
                                        <div style="font-size: 11px; color: #868e96; margin-top: 4px;">点击查看详情</div>
                                    </div>
                                </div>
                                
                                <div style="border-top: 1px solid #f0f0f0; padding-top: 12px; margin-bottom: 15px;">
                                    <div style="font-size: 15px; font-weight: 600; color: #333; margin-bottom: 10px;">数据类型统计</div>
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 13px;">
                                        <div class="data-item" data-type="characters" style="padding: 10px; background: #f8f9fa; border-radius: 6px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='#f8f9fa'">
                                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                                <span style="color: #495057; font-weight: 500;">角色数据</span>
                                                <span style="font-weight: 600; color: #ff80ab;">${characterCount}</span>
                                            </div>
                                            <div style="font-size: 10px; color: #868e96; margin-top: 4px;">点击查看</div>
                                        </div>
                                        <div class="data-item" data-type="groups" style="padding: 10px; background: #f8f9fa; border-radius: 6px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='#f8f9fa'">
                                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                                <span style="color: #495057; font-weight: 500;">群组数据</span>
                                                <span style="font-weight: 600; color: #ff80ab;">${groupCount}</span>
                                            </div>
                                            <div style="font-size: 10px; color: #868e96; margin-top: 4px;">点击查看</div>
                                        </div>
                                        <div class="data-item" data-type="system" style="padding: 10px; background: #f8f9fa; border-radius: 6px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='#f8f9fa'">
                                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                                <span style="color: #495057; font-weight: 500;">系统数据</span>
                                                <span style="font-weight: 600; color: #ff80ab;">${otherCount}</span>
                                            </div>
                                            <div style="font-size: 10px; color: #868e96; margin-top: 4px;">点击查看</div>
                                        </div>
                                        <div class="data-item" data-type="chunks" style="padding: 10px; background: #f8f9fa; border-radius: 6px; cursor: pointer; transition: all 0.2s;" onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='#f8f9fa'">
                                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                                <span style="color: #495057; font-weight: 500;">消息块数</span>
                                                <span style="font-weight: 600; color: #ff80ab;">${info.chunkCount}</span>
                                            </div>
                                            <div style="font-size: 10px; color: #868e96; margin-top: 4px;">点击查看</div>
                                        </div>
                                        <div class="data-item" data-type="cache" style="padding: 10px; background: #f8f9fa; border-radius: 6px; cursor: pointer; transition: all 0.2s; grid-column: span 2;" onmouseover="this.style.background='#e9ecef'" onmouseout="this.style.background='#f8f9fa'">
                                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                                <span style="color: #495057; font-weight: 500;">缓存项数</span>
                                                <span style="font-weight: 600; color: #ff80ab;">${info.cacheSize}</span>
                                            </div>
                                            <div style="font-size: 10px; color: #868e96; margin-top: 4px;">点击查看</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                        
                        await showCustomAlert('数据统计', message);
                        
                        // 添加点击事件监听
                        setTimeout(() => {
                            document.querySelectorAll('.data-item').forEach(item => {
                                item.addEventListener('click', async () => {
                                    const type = item.getAttribute('data-type');
                                    if (type === 'storage') {
                                        await showDetailDialog('存储数据详情', info.items, 'storage');
                                    } else if (type === 'messages') {
                                        await showDetailDialog('消息记录详情', [], 'messages');
                                    } else if (type === 'characters') {
                                        await showDetailDialog('角色数据详情', characterItems, 'characters');
                                    } else if (type === 'groups') {
                                        await showDetailDialog('群组数据详情', groupItems, 'groups');
                                    } else if (type === 'system') {
                                        await showDetailDialog('系统数据详情', systemItems, 'system');
                                    } else if (type === 'chunks') {
                                        await showDetailDialog('消息块详情', [], 'messages');
                                    } else if (type === 'cache') {
                                        await showDetailDialog('缓存详情', [], 'cache');
                                    }
                                });
                            });
                        }, 100);
                    } else {
                        showToast('无法获取存储信息');
                    }
                } catch (error) {
                    showToast(`获取失败: ${error.message}`);
                    console.error(error);
                } finally {
                    loadingBtn = false;
                    viewDataSizeBtn.textContent = originalText;
                }
            });

            // 清除缓存数据按钮
            const clearCacheBtn = document.createElement('button');
            clearCacheBtn.className = 'btn';
            clearCacheBtn.textContent = '清除缓存数据';
            clearCacheBtn.style.marginTop = '15px';
            clearCacheBtn.style.display = 'block';
            clearCacheBtn.style.backgroundColor = '#ffa726'; // Orange color
            clearCacheBtn.style.color = 'white';
            
            clearCacheBtn.addEventListener('click', async () => {
                 if (loadingBtn) return;
                 
                 if (!confirm('确定要清理缓存数据吗？\n\n这将删除：\n1. 已删除角色的残留数据\n2. 孤立的消息记录\n3. 无用的缓存文件\n\n此操作不会影响您现有的角色和聊天记录。')) {
                     return;
                 }
                 
                 loadingBtn = true;
                 const originalText = clearCacheBtn.textContent;
                 clearCacheBtn.textContent = '正在清理...';
                 
                 try {
                     showToast('正在清理缓存...');
                     const result = await dataStorage.clearCache();
                     showToast(`清理完成！已删除 ${result.count} 个无用项目，释放 ${(result.size / 1024).toFixed(2)} KB`);
                     
                     // Update storage info display if visible
                     dataStorage.getStorageInfo();
                     
                 } catch (error) {
                     showToast(`清理失败: ${error.message}`);
                     console.error(error);
                 } finally {
                     loadingBtn = false;
                     clearCacheBtn.textContent = originalText;
                 }
            });

            // 清除本机数据按钮
            const clearLocalDataBtn = document.createElement('button');
            clearLocalDataBtn.className = 'btn btn-danger';
            clearLocalDataBtn.textContent = '清除本机数据';
            clearLocalDataBtn.style.marginTop = '15px';
            clearLocalDataBtn.style.display = 'block';
            
            clearLocalDataBtn.addEventListener('click', async () => {
                if (loadingBtn) {
                    return;
                }
                
                // 双重确认，防止误操作
                if (!confirm('警告：此操作将清除本应用的所有数据，包括所有聊天记录、角色、群组、设置等。\n\n此操作不可撤销！\n\n确定要继续吗？')) {
                    return;
                }
                
                if (!confirm('最后确认：您真的要清除所有本机数据吗？\n\n数据清除后将无法恢复！')) {
                    return;
                }
                
                loadingBtn = true;
                
                try {
                    showToast('正在清除本机数据...');
                    
                    // 清除所有存储数据（只清除当前应用的数据，不影响其他网页）
                    await dataStorage.clearAll();
                    
                    showToast('本机数据已清除，页面即将刷新...');
                    
                    // 延迟刷新页面，让用户看到提示
                    // 使用 href 赋值代替 reload()，避免在手机上触发"打开外部应用"提示
                    setTimeout(() => {
                        window.location.href = window.location.href;
                    }, 1500);
                    
                } catch (error) {
                    loadingBtn = false;
                    showToast(`清除数据失败: ${error.message}`);
                    console.error('清除数据错误:', error);
                }
            });

            // 本机数据复制和记忆库功能
            
            // 复制本机数据功能
            async function showCopyLocalDataModal() {
                const modalHtml = `
                    <div id="copy-local-data-modal" class="modal-overlay visible">
                        <div class="modal-window" style="max-width: 400px;">
                            <h3>复制本机数据</h3>
                            <p style="font-size: 13px; color: #666; margin-bottom: 15px;">
                                保存当前本机的所有数据，包括角色、群聊、聊天记录、世界书等
                            </p>
                            <div style="margin: 15px 0;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 600;">快照名称</label>
                                <input type="text" id="local-snapshot-name" 
                                    style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; box-sizing: border-box;"
                                    placeholder="例如：2024年12月备份">
                            </div>
                            <div style="display: flex; gap: 10px; margin-top: 20px;">
                                <button id="confirm-copy-local-data-btn" class="btn btn-primary" style="flex: 1;">保存</button>
                                <button id="cancel-copy-local-data-btn" class="btn btn-secondary" style="flex: 1;">取消</button>
                            </div>
                        </div>
                    </div>
                `;
                
                // 移除已存在的模态框
                const existingModal = document.getElementById('copy-local-data-modal');
                if (existingModal) {
                    existingModal.remove();
                }
                
                // 添加新模态框
                document.body.insertAdjacentHTML('beforeend', modalHtml);
                
                const modal = document.getElementById('copy-local-data-modal');
                const nameInput = document.getElementById('local-snapshot-name');
                const confirmBtn = document.getElementById('confirm-copy-local-data-btn');
                const cancelBtn = document.getElementById('cancel-copy-local-data-btn');
                
                // 设置默认名称
                const now = new Date();
                const defaultName = `本机数据_${now.getFullYear()}年${now.getMonth() + 1}月${now.getDate()}日_${now.getHours()}时${now.getMinutes()}分`;
                nameInput.value = defaultName;
                nameInput.select();
                
                // 确认保存
                confirmBtn.onclick = async () => {
                    const name = nameInput.value.trim();
                    if (!name) {
                        showToast('请输入快照名称');
                        return;
                    }
                    
                    confirmBtn.disabled = true;
                    confirmBtn.textContent = '保存中...';
                    
                    try {
                        showToast('正在复制本机数据...');
                        
                        // 创建完整的数据备份
                        const fullBackupData = await createFullBackupData();
                        
                        // 保存到IndexedDB
                        await dataStorage.db.localSnapshots.add({
                            name: name,
                            data: fullBackupData,
                            timestamp: Date.now()
                        });
                        
                        showToast('本机数据已保存到记忆库');
                        modal.remove();
                    } catch (error) {
                        console.error('保存本机数据失败:', error);
                        showToast('保存失败：' + error.message);
                        confirmBtn.disabled = false;
                        confirmBtn.textContent = '保存';
                    }
                };
                
                // 取消按钮
                cancelBtn.onclick = () => {
                    modal.remove();
                };
                
                // 点击遮罩关闭
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                };
            }
            
            // 本机记忆库功能
            async function showLocalMemoryLibraryModal() {
                const modalHtml = `
                    <div id="local-memory-library-modal" class="modal-overlay visible">
                        <div class="modal-window" style="max-width: 600px; max-height: 80vh; display: flex; flex-direction: column;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                <h3 style="margin: 0;">本机记忆库</h3>
                                <button id="close-local-memory-library-modal" style="background: none; border: none; font-size: 28px; cursor: pointer; color: #888;">&times;</button>
                            </div>
                            
                            <div style="background: #e3f2fd; padding: 12px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #2196F3;">
                                <p style="margin: 0; font-size: 13px; color: #1565c0; line-height: 1.5;">
                                    💾 这里保存了您的本机数据快照，可以随时恢复到之前的状态
                                </p>
                            </div>
                            
                            <div style="margin-bottom: 15px; display: flex; gap: 10px; align-items: center;">
                                <label style="display: flex; align-items: center; cursor: pointer;">
                                    <input type="checkbox" id="local-snapshot-select-all" style="margin-right: 8px; cursor: pointer;">
                                    <span style="font-weight: 600;">全选</span>
                                </label>
                                <span style="color: #888; font-size: 14px;" id="local-snapshot-count">已选择 0 项</span>
                            </div>
                            
                            <div id="local-snapshot-list" style="flex: 1; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px; max-height: 400px;">
                                <p style="text-align: center; color: #999; padding: 20px;">加载中...</p>
                            </div>
                            
                            <div style="display: flex; gap: 10px; margin-top: 15px;">
                                <button id="delete-local-snapshots-btn" class="btn btn-danger" style="flex: 1;">删除选中</button>
                                <button id="close-local-memory-library-btn" class="btn btn-secondary" style="flex: 1;">关闭</button>
                            </div>
                        </div>
                    </div>
                `;
                
                // 移除已存在的模态框
                const existingModal = document.getElementById('local-memory-library-modal');
                if (existingModal) {
                    existingModal.remove();
                }
                
                // 添加新模态框
                document.body.insertAdjacentHTML('beforeend', modalHtml);
                
                const modal = document.getElementById('local-memory-library-modal');
                const listContainer = document.getElementById('local-snapshot-list');
                const selectAllCheckbox = document.getElementById('local-snapshot-select-all');
                const countSpan = document.getElementById('local-snapshot-count');
                const deleteBtn = document.getElementById('delete-local-snapshots-btn');
                const closeBtn = document.getElementById('close-local-memory-library-btn');
                const closeModalBtn = document.getElementById('close-local-memory-library-modal');
                
                // 加载快照列表
                await renderLocalSnapshots();
                
                async function renderLocalSnapshots() {
                    try {
                        const snapshots = await dataStorage.db.localSnapshots
                            .orderBy('timestamp')
                            .reverse()
                            .toArray();
                        
                        if (snapshots.length === 0) {
                            listContainer.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">暂无保存的本机数据</p>';
                            return;
                        }
                        
                        listContainer.innerHTML = '';
                        
                        snapshots.forEach(snapshot => {
                            const itemDiv = document.createElement('div');
                            itemDiv.style.cssText = 'display: flex; align-items: center; padding: 12px; border-bottom: 1px solid #f0f0f0; cursor: pointer; transition: background-color 0.2s;';
                            itemDiv.dataset.id = snapshot.id;
                            
                            const date = new Date(snapshot.timestamp);
                            const dateStr = date.toLocaleString('zh-CN');
                            
                            itemDiv.innerHTML = `
                                <input type="checkbox" class="local-snapshot-checkbox" style="margin-right: 12px; cursor: pointer; width: 18px; height: 18px;">
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; color: #333; margin-bottom: 4px;">${snapshot.name}</div>
                                    <div style="font-size: 12px; color: #888;">保存时间：${dateStr}</div>
                                </div>
                                <div style="display: flex; gap: 6px;">
                                    <button class="restore-local-snapshot-btn" style="padding: 6px 12px; background: var(--primary-color); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">恢复</button>
                                    <button class="rename-local-snapshot-btn" style="padding: 6px 12px; background: var(--accent-color); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">重命名</button>
                                </div>
                            `;
                            
                            const checkbox = itemDiv.querySelector('.local-snapshot-checkbox');
                            const restoreBtn = itemDiv.querySelector('.restore-local-snapshot-btn');
                            const renameBtn = itemDiv.querySelector('.rename-local-snapshot-btn');
                            
                            // checkbox change事件
                            checkbox.addEventListener('change', () => {
                                updateCount();
                            });
                            
                            // 点击整行选择
                            itemDiv.addEventListener('click', (e) => {
                                if (e.target.type !== 'checkbox' && !e.target.classList.contains('restore-local-snapshot-btn') && !e.target.classList.contains('rename-local-snapshot-btn')) {
                                    checkbox.checked = !checkbox.checked;
                                    updateCount();
                                }
                            });
                            
                            // 恢复按钮
                            restoreBtn.addEventListener('click', async (e) => {
                                e.stopPropagation();
                                
                                if (!confirm(`确定要恢复到"${snapshot.name}"的状态吗？\n\n⚠️ 当前的所有数据将被替换为快照中的数据！\n此操作不可撤销！`)) {
                                    return;
                                }
                                
                                restoreBtn.disabled = true;
                                restoreBtn.textContent = '恢复中...';
                                
                                try {
                                    showToast('正在恢复数据...');
                                    
                                    // 导入快照数据
                                    await importBackupData(snapshot.data);
                                    
                                    showToast('数据已恢复，页面即将刷新...');
                                    
                                    // 延迟刷新页面
                                    setTimeout(() => {
                                        window.location.reload();
                                    }, 1500);
                                } catch (error) {
                                    console.error('恢复数据失败:', error);
                                    showToast('恢复失败：' + error.message);
                                    restoreBtn.disabled = false;
                                    restoreBtn.textContent = '恢复';
                                }
                            });
                            
                            // 重命名按钮
                            renameBtn.addEventListener('click', async (e) => {
                                e.stopPropagation();
                                
                                const newName = prompt('请输入新的快照名称：', snapshot.name);
                                if (newName && newName.trim() && newName.trim() !== snapshot.name) {
                                    try {
                                        await dataStorage.db.localSnapshots.update(snapshot.id, {
                                            name: newName.trim()
                                        });
                                        showToast('重命名成功');
                                        await renderLocalSnapshots();
                                    } catch (error) {
                                        console.error('重命名失败:', error);
                                        showToast('重命名失败');
                                    }
                                }
                            });
                            
                            // 鼠标悬停效果
                            itemDiv.addEventListener('mouseenter', () => {
                                itemDiv.style.backgroundColor = '#f5f5f5';
                            });
                            itemDiv.addEventListener('mouseleave', () => {
                                itemDiv.style.backgroundColor = 'transparent';
                            });
                            
                            listContainer.appendChild(itemDiv);
                        });
                        
                        updateCount();
                    } catch (error) {
                        console.error('加载快照列表失败:', error);
                        listContainer.innerHTML = '<p style="text-align: center; color: #f44336; padding: 20px;">加载失败</p>';
                    }
                }
                
                // 更新选中数量
                function updateCount() {
                    const checkboxes = listContainer.querySelectorAll('.local-snapshot-checkbox');
                    const checkedCount = listContainer.querySelectorAll('.local-snapshot-checkbox:checked').length;
                    countSpan.textContent = `已选择 ${checkedCount} 项`;
                    selectAllCheckbox.checked = checkedCount === checkboxes.length && checkboxes.length > 0;
                }
                
                // 全选/取消全选
                selectAllCheckbox.addEventListener('change', () => {
                    const checkboxes = listContainer.querySelectorAll('.local-snapshot-checkbox');
                    checkboxes.forEach(cb => cb.checked = selectAllCheckbox.checked);
                    updateCount();
                });
                
                // 删除选中
                deleteBtn.onclick = async () => {
                    const checkedItems = Array.from(listContainer.querySelectorAll('.local-snapshot-checkbox:checked'))
                        .map(cb => {
                            const itemDiv = cb.closest('[data-id]');
                            return parseInt(itemDiv.dataset.id);
                        });
                    
                    if (checkedItems.length === 0) {
                        showToast('请至少选择一项');
                        return;
                    }
                    
                    if (!confirm(`确定要删除选中的 ${checkedItems.length} 个快照吗？\n\n此操作不可恢复！`)) {
                        return;
                    }
                    
                    deleteBtn.disabled = true;
                    deleteBtn.textContent = '删除中...';
                    
                    try {
                        for (const id of checkedItems) {
                            await dataStorage.db.localSnapshots.delete(id);
                        }
                        
                        showToast(`已删除 ${checkedItems.length} 个快照`);
                        await renderLocalSnapshots();
                    } catch (error) {
                        console.error('删除快照失败:', error);
                        showToast('删除失败');
                    } finally {
                        deleteBtn.disabled = false;
                        deleteBtn.textContent = '删除选中';
                    }
                };
                
                // 关闭按钮
                closeBtn.onclick = () => {
                    modal.remove();
                };
                
                closeModalBtn.onclick = () => {
                    modal.remove();
                };
                
                // 点击遮罩关闭
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                };
            }
            
            // 批量清除角色数据功能
            function showBatchClearModal() {
                const modal = document.getElementById('batch-clear-chat-modal');
                const listContainer = document.getElementById('batch-clear-list');
                const selectAllCheckbox = document.getElementById('batch-clear-select-all');
                const countSpan = document.getElementById('batch-clear-count');
                const confirmBtn = document.getElementById('confirm-batch-clear-btn');
                const cancelBtn = document.getElementById('cancel-batch-clear-btn');
                const closeBtn = document.getElementById('close-batch-clear-modal');
                
                // 清空列表
                listContainer.innerHTML = '';
                
                // 生成角色和群组列表
                const items = [];
                
                // 添加所有角色
                db.characters.forEach(char => {
                    items.push({
                        id: char.id,
                        type: 'private',
                        name: char.remarkName || char.realName,
                        avatar: char.avatar,
                        messageCount: char.history ? char.history.length : 0
                    });
                });
                
                // 添加所有群组
                db.groups.forEach(group => {
                    items.push({
                        id: group.id,
                        type: 'group',
                        name: group.name,
                        avatar: group.avatar,
                        messageCount: group.history ? group.history.length : 0
                    });
                });
                
                // 渲染列表
                items.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.style.cssText = 'display: flex; align-items: center; padding: 10px; border-bottom: 1px solid #f0f0f0; cursor: pointer; transition: background-color 0.2s;';
                    itemDiv.dataset.id = item.id;
                    itemDiv.dataset.type = item.type;
                    
                    itemDiv.innerHTML = `
                        <input type="checkbox" class="batch-clear-checkbox" style="margin-right: 12px; cursor: pointer; width: 18px; height: 18px;">
                        <img src="${item.avatar}" style="width: 45px; height: 45px; border-radius: ${item.type === 'group' ? '10px' : '50%'}; object-fit: cover; margin-right: 12px;">
                        <div style="flex: 1;">
                            <div style="font-weight: 600; color: #333; margin-bottom: 4px;">${item.name}</div>
                            <div style="font-size: 12px; color: #888;">${item.type === 'group' ? '群聊' : '私聊'} · ${item.messageCount} 条消息</div>
                        </div>
                    `;
                    
                    // 获取checkbox元素
                    const checkbox = itemDiv.querySelector('.batch-clear-checkbox');
                    
                    // checkbox change事件
                    checkbox.addEventListener('change', () => {
                        updateCount();
                    });
                    
                    // 点击整行切换选中状态
                    itemDiv.addEventListener('click', (e) => {
                        if (e.target.type !== 'checkbox') {
                            checkbox.checked = !checkbox.checked;
                            updateCount();
                        }
                    });
                    
                    // 鼠标悬停效果
                    itemDiv.addEventListener('mouseenter', () => {
                        itemDiv.style.backgroundColor = '#f5f5f5';
                    });
                    itemDiv.addEventListener('mouseleave', () => {
                        itemDiv.style.backgroundColor = 'transparent';
                    });
                    
                    listContainer.appendChild(itemDiv);
                });
                
                // 更新选中数量
                function updateCount() {
                    const checkedCount = listContainer.querySelectorAll('.batch-clear-checkbox:checked').length;
                    countSpan.textContent = `已选择 ${checkedCount} 项`;
                    selectAllCheckbox.checked = checkedCount === items.length && items.length > 0;
                }
                
                // 全选/取消全选
                selectAllCheckbox.addEventListener('change', () => {
                    const checkboxes = listContainer.querySelectorAll('.batch-clear-checkbox');
                    checkboxes.forEach(cb => cb.checked = selectAllCheckbox.checked);
                    updateCount();
                });
                
                // 确认清除
                confirmBtn.onclick = async () => {
                    const checkedItems = Array.from(listContainer.querySelectorAll('.batch-clear-checkbox:checked'))
                        .map(cb => {
                            const itemDiv = cb.closest('[data-id]');
                            return {
                                id: itemDiv.dataset.id,
                                type: itemDiv.dataset.type
                            };
                        });
                    
                    if (checkedItems.length === 0) {
                        showToast('请至少选择一项');
                        return;
                    }
                    
                    if (!confirm(`确定要清除选中的 ${checkedItems.length} 个角色/群聊的所有聊天记录吗？\n\n此操作不可恢复！`)) {
                        return;
                    }
                    
                    // 显示加载状态
                    confirmBtn.disabled = true;
                    confirmBtn.textContent = '清除中...';
                    
                    try {
                        let successCount = 0;
                        
                        for (const item of checkedItems) {
                            if (item.type === 'private') {
                                // 清除私聊记录
                                const character = db.characters.find(c => c.id === item.id);
                                if (character) {
                                    character.history = [];
                                    character.status = '在线';
                                    character.autoSummarizedFloors = [];
                                    await dataStorage.clearChatMessages(character.id, 'private');
                                    successCount++;
                                }
                            } else if (item.type === 'group') {
                                // 清除群聊记录
                                const group = db.groups.find(g => g.id === item.id);
                                if (group) {
                                    group.history = [];
                                    group.autoSummarizedFloors = [];
                                    // 重置群成员状态
                                    if (group.members) {
                                        group.members.forEach(member => {
                                            const char = db.characters.find(c => c.id === member.id);
                                            if (char) {
                                                char.status = '在线';
                                            }
                                        });
                                    }
                                    await dataStorage.clearChatMessages(group.id, 'group');
                                    successCount++;
                                }
                            }
                        }
                        
                        await saveData();
                        renderChatList();
                        
                        // 如果当前正在查看被清除的聊天，刷新消息显示
                        if (currentChatId && checkedItems.some(item => item.id === currentChatId)) {
                            renderMessages(false, true);
                        }
                        
                        showToast(`成功清除 ${successCount} 个聊天记录`);
                        modal.classList.remove('visible');
                    } catch (error) {
                        console.error('批量清除失败:', error);
                        showToast('清除失败，请重试');
                    } finally {
                        confirmBtn.disabled = false;
                        confirmBtn.textContent = '清除选中';
                    }
                };
                
                // 取消按钮
                cancelBtn.onclick = () => {
                    modal.classList.remove('visible');
                };
                
                // 关闭按钮
                closeBtn.onclick = () => {
                    modal.classList.remove('visible');
                };
                
                // 点击遮罩关闭
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        modal.classList.remove('visible');
                    }
                };
                
                // 显示模态框
                modal.classList.add('visible');
                updateCount();
            }
            
            // 批量清除角色数据按钮
            const batchClearChatBtn = document.createElement('button');
            batchClearChatBtn.className = 'btn';
            batchClearChatBtn.textContent = '批量清除角色数据';
            batchClearChatBtn.style.marginTop = '15px';
            batchClearChatBtn.style.display = 'block';
            batchClearChatBtn.style.backgroundColor = '#ff5722';
            batchClearChatBtn.style.color = 'white';
            
            batchClearChatBtn.addEventListener('click', () => {
                showBatchClearModal();
            });

            tutorialContentArea.appendChild(backupDataBtn);
            tutorialContentArea.appendChild(viaBackupBtn);
            tutorialContentArea.appendChild(streamBackupBtn);
            tutorialContentArea.appendChild(convertBackupBtn);
            tutorialContentArea.appendChild(importDataBtn);
            tutorialContentArea.appendChild(streamImportBtn);
            tutorialContentArea.appendChild(viewDataSizeBtn);
            tutorialContentArea.appendChild(clearCacheBtn);
            tutorialContentArea.appendChild(batchClearChatBtn);
            
            // 复制本机数据按钮
            const copyLocalDataBtn = document.createElement('button');
            copyLocalDataBtn.className = 'btn';
            copyLocalDataBtn.textContent = '复制本机数据';
            copyLocalDataBtn.style.marginTop = '15px';
            copyLocalDataBtn.style.display = 'block';
            copyLocalDataBtn.style.backgroundColor = '#4CAF50';
            copyLocalDataBtn.style.color = 'white';
            
            copyLocalDataBtn.addEventListener('click', () => {
                showCopyLocalDataModal();
            });
            
            tutorialContentArea.appendChild(copyLocalDataBtn);
            
            // 本机记忆库按钮
            const localMemoryLibraryBtn = document.createElement('button');
            localMemoryLibraryBtn.className = 'btn';
            localMemoryLibraryBtn.textContent = '本机记忆库';
            localMemoryLibraryBtn.style.marginTop = '15px';
            localMemoryLibraryBtn.style.display = 'block';
            localMemoryLibraryBtn.style.backgroundColor = '#2196F3';
            localMemoryLibraryBtn.style.color = 'white';
            
            localMemoryLibraryBtn.addEventListener('click', () => {
                showLocalMemoryLibraryModal();
            });
            
            tutorialContentArea.appendChild(localMemoryLibraryBtn);
            
            tutorialContentArea.appendChild(clearLocalDataBtn);

            // ========== 自动提醒导出功能区域 ==========
            const reminderSection = document.createElement('div');
            reminderSection.style.marginTop = '30px';
            reminderSection.style.padding = '15px';
            reminderSection.style.backgroundColor = '#fff3e0';
            reminderSection.style.borderRadius = '10px';
            reminderSection.style.border = '2px solid #ffb74d';

            const reminderTitle = document.createElement('h3');
            reminderTitle.textContent = '自动提醒导出';
            reminderTitle.style.marginTop = '0';
            reminderTitle.style.marginBottom = '15px';
            reminderTitle.style.color = '#e65100';
            reminderSection.appendChild(reminderTitle);

            // 开关按钮
            const reminderToggleContainer = document.createElement('div');
            reminderToggleContainer.style.display = 'flex';
            reminderToggleContainer.style.alignItems = 'center';
            reminderToggleContainer.style.marginBottom = '15px';
            reminderToggleContainer.style.justifyContent = 'space-between';

            const reminderToggleLabel = document.createElement('label');
            reminderToggleLabel.textContent = '启用自动提醒';
            reminderToggleLabel.style.fontSize = '16px';
            reminderToggleLabel.style.fontWeight = '600';

            const reminderToggle = document.createElement('input');
            reminderToggle.type = 'checkbox';
            reminderToggle.id = 'reminder-toggle';
            reminderToggle.style.width = '50px';
            reminderToggle.style.height = '25px';
            reminderToggle.style.cursor = 'pointer';

            reminderToggleContainer.appendChild(reminderToggleLabel);
            reminderToggleContainer.appendChild(reminderToggle);
            reminderSection.appendChild(reminderToggleContainer);

            // 时间设置区域
            const timeSettingContainer = document.createElement('div');
            timeSettingContainer.id = 'time-setting-container';
            timeSettingContainer.style.display = 'none';
            timeSettingContainer.style.marginTop = '15px';

            const timeSettingLabel = document.createElement('label');
            timeSettingLabel.textContent = '设置提醒时间：';
            timeSettingLabel.style.display = 'block';
            timeSettingLabel.style.marginBottom = '10px';
            timeSettingLabel.style.fontWeight = '600';
            timeSettingContainer.appendChild(timeSettingLabel);

            // 时分秒输入
            const timeInputContainer = document.createElement('div');
            timeInputContainer.style.display = 'flex';
            timeInputContainer.style.gap = '10px';
            timeInputContainer.style.alignItems = 'center';
            timeInputContainer.style.marginBottom = '15px';

            const hourInput = document.createElement('input');
            hourInput.type = 'text';
            hourInput.id = 'reminder-hour';
            hourInput.placeholder = '时';
            hourInput.value = '12';
            hourInput.style.width = '60px';
            hourInput.style.padding = '8px';
            hourInput.style.borderRadius = '5px';
            hourInput.style.border = '1px solid #ccc';
            hourInput.style.textAlign = 'center';
            hourInput.inputMode = 'numeric';
            hourInput.maxLength = '2';

            const minuteInput = document.createElement('input');
            minuteInput.type = 'text';
            minuteInput.id = 'reminder-minute';
            minuteInput.placeholder = '分';
            minuteInput.value = '0';
            minuteInput.style.width = '60px';
            minuteInput.style.padding = '8px';
            minuteInput.style.borderRadius = '5px';
            minuteInput.style.border = '1px solid #ccc';
            minuteInput.style.textAlign = 'center';
            minuteInput.inputMode = 'numeric';
            minuteInput.maxLength = '2';

            const secondInput = document.createElement('input');
            secondInput.type = 'text';
            secondInput.id = 'reminder-second';
            secondInput.placeholder = '秒';
            secondInput.value = '0';
            secondInput.style.width = '60px';
            secondInput.style.padding = '8px';
            secondInput.style.borderRadius = '5px';
            secondInput.style.border = '1px solid #ccc';
            secondInput.style.textAlign = 'center';
            secondInput.inputMode = 'numeric';
            secondInput.maxLength = '2';

            // 添加输入验证
            hourInput.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
                let val = parseInt(e.target.value);
                if (!isNaN(val) && val > 23) e.target.value = '23';
            });
            
            minuteInput.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
                let val = parseInt(e.target.value);
                if (!isNaN(val) && val > 59) e.target.value = '59';
            });
            
            secondInput.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
                let val = parseInt(e.target.value);
                if (!isNaN(val) && val > 59) e.target.value = '59';
            });

            timeInputContainer.appendChild(hourInput);
            timeInputContainer.appendChild(document.createTextNode(':'));
            timeInputContainer.appendChild(minuteInput);
            timeInputContainer.appendChild(document.createTextNode(':'));
            timeInputContainer.appendChild(secondInput);
            timeSettingContainer.appendChild(timeInputContainer);

            // 按钮组
            const buttonGroup = document.createElement('div');
            buttonGroup.style.display = 'flex';
            buttonGroup.style.gap = '10px';
            buttonGroup.style.marginTop = '15px';

            const setTimeBtn = document.createElement('button');
            setTimeBtn.className = 'btn';
            setTimeBtn.textContent = '设置提醒时间';
            setTimeBtn.style.flex = '1';
            setTimeBtn.style.backgroundColor = '#4CAF50';
            setTimeBtn.style.color = 'white';

            const resetTimeBtn = document.createElement('button');
            resetTimeBtn.className = 'btn';
            resetTimeBtn.textContent = '重置时间';
            resetTimeBtn.style.flex = '1';
            resetTimeBtn.style.backgroundColor = '#2196F3';
            resetTimeBtn.style.color = 'white';

            const clearTodayBtn = document.createElement('button');
            clearTodayBtn.className = 'btn';
            clearTodayBtn.textContent = '清除今日提醒';
            clearTodayBtn.style.flex = '1';
            clearTodayBtn.style.backgroundColor = '#FF9800';
            clearTodayBtn.style.color = 'white';

            buttonGroup.appendChild(setTimeBtn);
            buttonGroup.appendChild(resetTimeBtn);
            buttonGroup.appendChild(clearTodayBtn);
            timeSettingContainer.appendChild(buttonGroup);

            // 状态显示
            const statusDisplay = document.createElement('div');
            statusDisplay.id = 'reminder-status';
            statusDisplay.style.marginTop = '15px';
            statusDisplay.style.padding = '10px';
            statusDisplay.style.backgroundColor = '#fff';
            statusDisplay.style.borderRadius = '5px';
            statusDisplay.style.fontSize = '14px';
            statusDisplay.style.color = '#666';
            statusDisplay.textContent = '当前未设置提醒';
            timeSettingContainer.appendChild(statusDisplay);

            reminderSection.appendChild(timeSettingContainer);
            tutorialContentArea.appendChild(reminderSection);

            // ========== 自动提醒功能逻辑 ==========
            let reminderInterval = null;
            let reminderTimeout = null;
            let todayReminderCount = 0;
            const REMINDER_STORAGE_KEY = 'autoReminderSettings';

            // 加载保存的设置
            function loadReminderSettings() {
                const saved = localStorage.getItem(REMINDER_STORAGE_KEY);
                if (saved) {
                    try {
                        const settings = JSON.parse(saved);
                        reminderToggle.checked = settings.enabled || false;
                        hourInput.value = settings.hour || 12;
                        minuteInput.value = settings.minute || 0;
                        secondInput.value = settings.second || 0;
                        todayReminderCount = settings.todayCount || 0;
                        
                        const lastDate = settings.lastDate || '';
                        const today = new Date().toDateString();
                        if (lastDate !== today) {
                            todayReminderCount = 0;
                        }
                        
                        if (reminderToggle.checked) {
                            timeSettingContainer.style.display = 'block';
                            startReminderCheck();
                        }
                        updateReminderStatus();
                    } catch (e) {
                        console.error('加载提醒设置失败:', e);
                    }
                }
            }

            // 保存设置
            function saveReminderSettings() {
                const settings = {
                    enabled: reminderToggle.checked,
                    hour: parseInt(hourInput.value) || 0,
                    minute: parseInt(minuteInput.value) || 0,
                    second: parseInt(secondInput.value) || 0,
                    todayCount: todayReminderCount,
                    lastDate: new Date().toDateString()
                };
                localStorage.setItem(REMINDER_STORAGE_KEY, JSON.stringify(settings));
            }

            // 更新状态显示
            function updateReminderStatus() {
                const hour = (hourInput.value || '0').padStart(2, '0');
                const minute = (minuteInput.value || '0').padStart(2, '0');
                const second = (secondInput.value || '0').padStart(2, '0');
                
                if (reminderToggle.checked) {
                    statusDisplay.innerHTML = `
                        提醒已启用<br>
                        提醒时间: ${hour}:${minute}:${second}<br>
                        今日已提醒: ${todayReminderCount} 次
                    `;
                    statusDisplay.style.color = '#4CAF50';
                } else {
                    statusDisplay.textContent = '提醒未启用';
                    statusDisplay.style.color = '#999';
                }
            }

            // 检查是否到达提醒时间
            function checkReminderTime() {
                const now = new Date();
                const targetHour = parseInt(hourInput.value) || 0;
                const targetMinute = parseInt(minuteInput.value) || 0;
                const targetSecond = parseInt(secondInput.value) || 0;

                if (now.getHours() === targetHour && 
                    now.getMinutes() === targetMinute && 
                    now.getSeconds() === targetSecond) {
                    showReminderNotification();
                }
            }

            // 显示提醒通知
            function showReminderNotification() {
                todayReminderCount++;
                saveReminderSettings();
                updateReminderStatus();

                // 创建全屏提醒弹窗
                const reminderOverlay = document.createElement('div');
                reminderOverlay.style.position = 'fixed';
                reminderOverlay.style.top = '0';
                reminderOverlay.style.left = '0';
                reminderOverlay.style.width = '100%';
                reminderOverlay.style.height = '100%';
                reminderOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                reminderOverlay.style.zIndex = '99999';
                reminderOverlay.style.display = 'flex';
                reminderOverlay.style.alignItems = 'center';
                reminderOverlay.style.justifyContent = 'center';
                reminderOverlay.style.animation = 'fadeIn 0.3s ease';

                const reminderBox = document.createElement('div');
                reminderBox.style.backgroundColor = 'white';
                reminderBox.style.padding = '30px';
                reminderBox.style.borderRadius = '15px';
                reminderBox.style.textAlign = 'center';
                reminderBox.style.maxWidth = '80%';
                reminderBox.style.boxShadow = '0 10px 40px rgba(0, 0, 0, 0.3)';
                reminderBox.style.animation = 'slideUp 0.4s ease-out';

                const reminderText = document.createElement('h2');
                reminderText.textContent = '提醒：该导出数据了！';
                reminderText.style.color = '#e65100';
                reminderText.style.marginBottom = '20px';
                reminderText.style.fontSize = '24px';
                reminderText.style.marginTop = '0';

                const reminderSubtext = document.createElement('p');
                reminderSubtext.textContent = '记得备份您的重要数据哦~';
                reminderSubtext.style.color = '#666';
                reminderSubtext.style.marginBottom = '25px';

                const closeBtn = document.createElement('button');
                closeBtn.textContent = '我知道了';
                closeBtn.className = 'btn';
                closeBtn.style.backgroundColor = '#4CAF50';
                closeBtn.style.color = 'white';
                closeBtn.style.padding = '12px 30px';
                closeBtn.style.fontSize = '16px';
                closeBtn.style.border = 'none';
                closeBtn.style.borderRadius = '8px';
                closeBtn.style.cursor = 'pointer';

                closeBtn.addEventListener('click', () => {
                    document.body.removeChild(reminderOverlay);
                });

                reminderBox.appendChild(reminderText);
                reminderBox.appendChild(reminderSubtext);
                reminderBox.appendChild(closeBtn);
                reminderOverlay.appendChild(reminderBox);
                document.body.appendChild(reminderOverlay);

                // 播放提示音（如果需要）
                try {
                    const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIGGS57OihUBELTKXh8bllHAU2jdXvzn0pBSh+zPDajzsKElyx6OyrWBQLSKDf8sFuIwUug8/y2Ik2CBhku+zooVARC0yl4fG5ZRwFNo3V7859KQUofsz');
                    audio.play().catch(() => {});
                } catch (e) {}
            }

            // 启动提醒检查
            function startReminderCheck() {
                stopReminderCheck();
                reminderInterval = setInterval(checkReminderTime, 1000);
            }

            // 停止提醒检查
            function stopReminderCheck() {
                if (reminderInterval) {
                    clearInterval(reminderInterval);
                    reminderInterval = null;
                }
                if (reminderTimeout) {
                    clearTimeout(reminderTimeout);
                    reminderTimeout = null;
                }
            }

            // 开关切换事件
            reminderToggle.addEventListener('change', () => {
                if (reminderToggle.checked) {
                    timeSettingContainer.style.display = 'block';
                    startReminderCheck();
                    showToast('自动提醒已启用');
                } else {
                    timeSettingContainer.style.display = 'none';
                    stopReminderCheck();
                    showToast('自动提醒已关闭');
                }
                saveReminderSettings();
                updateReminderStatus();
            });

            // 设置时间按钮
            setTimeBtn.addEventListener('click', () => {
                const hour = parseInt(hourInput.value);
                const minute = parseInt(minuteInput.value);
                const second = parseInt(secondInput.value);

                if (isNaN(hour) || hour < 0 || hour > 23) {
                    showToast('请输入有效的小时数 (0-23)');
                    return;
                }
                if (isNaN(minute) || minute < 0 || minute > 59) {
                    showToast('请输入有效的分钟数 (0-59)');
                    return;
                }
                if (isNaN(second) || second < 0 || second > 59) {
                    showToast('请输入有效的秒数 (0-59)');
                    return;
                }

                saveReminderSettings();
                updateReminderStatus();
                if (reminderToggle.checked) {
                    startReminderCheck();
                }
                showToast(`提醒时间已设置为 ${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}:${second.toString().padStart(2, '0')}`);
            });

            // 重置时间按钮
            resetTimeBtn.addEventListener('click', () => {
                hourInput.value = '12';
                minuteInput.value = '0';
                secondInput.value = '0';
                saveReminderSettings();
                updateReminderStatus();
                if (reminderToggle.checked) {
                    startReminderCheck();
                }
                showToast('提醒时间已重置为 12:00:00');
            });

            // 清除今日提醒次数按钮
            clearTodayBtn.addEventListener('click', () => {
                todayReminderCount = 0;
                saveReminderSettings();
                updateReminderStatus();
                showToast('今日提醒次数已清除');
            });

            // 页面加载时恢复设置
            loadReminderSettings();

            // ========== 自动导出功能区域 ==========
            const autoExportSection = document.createElement('div');
            autoExportSection.style.marginTop = '30px';
            autoExportSection.style.padding = '15px';
            autoExportSection.style.backgroundColor = '#e8f5e9';
            autoExportSection.style.borderRadius = '10px';
            autoExportSection.style.border = '2px solid #66bb6a';

            const autoExportTitle = document.createElement('h3');
            autoExportTitle.textContent = '自动导出';
            autoExportTitle.style.marginTop = '0';
            autoExportTitle.style.marginBottom = '15px';
            autoExportTitle.style.color = '#2e7d32';
            autoExportSection.appendChild(autoExportTitle);

            // 开关按钮
            const autoExportToggleContainer = document.createElement('div');
            autoExportToggleContainer.style.display = 'flex';
            autoExportToggleContainer.style.alignItems = 'center';
            autoExportToggleContainer.style.marginBottom = '15px';
            autoExportToggleContainer.style.justifyContent = 'space-between';

            const autoExportToggleLabel = document.createElement('label');
            autoExportToggleLabel.textContent = '启用自动导出';
            autoExportToggleLabel.style.fontSize = '16px';
            autoExportToggleLabel.style.fontWeight = '600';

            const autoExportToggle = document.createElement('input');
            autoExportToggle.type = 'checkbox';
            autoExportToggle.id = 'auto-export-toggle';
            autoExportToggle.style.width = '50px';
            autoExportToggle.style.height = '25px';
            autoExportToggle.style.cursor = 'pointer';

            autoExportToggleContainer.appendChild(autoExportToggleLabel);
            autoExportToggleContainer.appendChild(autoExportToggle);
            autoExportSection.appendChild(autoExportToggleContainer);

            // 设置区域
            const autoExportSettingContainer = document.createElement('div');
            autoExportSettingContainer.id = 'auto-export-setting-container';
            autoExportSettingContainer.style.display = 'none';
            autoExportSettingContainer.style.marginTop = '15px';

            // 时间设置
            const exportTimeLabel = document.createElement('label');
            exportTimeLabel.textContent = '设置导出时间：';
            exportTimeLabel.style.display = 'block';
            exportTimeLabel.style.marginBottom = '10px';
            exportTimeLabel.style.fontWeight = '600';
            autoExportSettingContainer.appendChild(exportTimeLabel);

            // 时分秒输入
            const exportTimeInputContainer = document.createElement('div');
            exportTimeInputContainer.style.display = 'flex';
            exportTimeInputContainer.style.gap = '10px';
            exportTimeInputContainer.style.alignItems = 'center';
            exportTimeInputContainer.style.marginBottom = '15px';

            const exportHourInput = document.createElement('input');
            exportHourInput.type = 'text';
            exportHourInput.id = 'export-hour';
            exportHourInput.placeholder = '时';
            exportHourInput.value = '12';
            exportHourInput.style.width = '60px';
            exportHourInput.style.padding = '8px';
            exportHourInput.style.borderRadius = '5px';
            exportHourInput.style.border = '1px solid #ccc';
            exportHourInput.style.textAlign = 'center';
            exportHourInput.inputMode = 'numeric';
            exportHourInput.maxLength = '2';

            const exportMinuteInput = document.createElement('input');
            exportMinuteInput.type = 'text';
            exportMinuteInput.id = 'export-minute';
            exportMinuteInput.placeholder = '分';
            exportMinuteInput.value = '0';
            exportMinuteInput.style.width = '60px';
            exportMinuteInput.style.padding = '8px';
            exportMinuteInput.style.borderRadius = '5px';
            exportMinuteInput.style.border = '1px solid #ccc';
            exportMinuteInput.style.textAlign = 'center';
            exportMinuteInput.inputMode = 'numeric';
            exportMinuteInput.maxLength = '2';

            const exportSecondInput = document.createElement('input');
            exportSecondInput.type = 'text';
            exportSecondInput.id = 'export-second';
            exportSecondInput.placeholder = '秒';
            exportSecondInput.value = '0';
            exportSecondInput.style.width = '60px';
            exportSecondInput.style.padding = '8px';
            exportSecondInput.style.borderRadius = '5px';
            exportSecondInput.style.border = '1px solid #ccc';
            exportSecondInput.style.textAlign = 'center';
            exportSecondInput.inputMode = 'numeric';
            exportSecondInput.maxLength = '2';

            // 添加输入验证
            exportHourInput.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
                let val = parseInt(e.target.value);
                if (!isNaN(val) && val > 23) e.target.value = '23';
            });
            
            exportMinuteInput.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
                let val = parseInt(e.target.value);
                if (!isNaN(val) && val > 59) e.target.value = '59';
            });
            
            exportSecondInput.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
                let val = parseInt(e.target.value);
                if (!isNaN(val) && val > 59) e.target.value = '59';
            });

            exportTimeInputContainer.appendChild(exportHourInput);
            exportTimeInputContainer.appendChild(document.createTextNode(':'));
            exportTimeInputContainer.appendChild(exportMinuteInput);
            exportTimeInputContainer.appendChild(document.createTextNode(':'));
            exportTimeInputContainer.appendChild(exportSecondInput);
            autoExportSettingContainer.appendChild(exportTimeInputContainer);

            // 自定义文件名输入框
            const pathLabel = document.createElement('label');
            pathLabel.textContent = '自定义文件名（可选）：';
            pathLabel.style.display = 'block';
            pathLabel.style.marginTop = '15px';
            pathLabel.style.marginBottom = '10px';
            pathLabel.style.fontWeight = '600';
            autoExportSettingContainer.appendChild(pathLabel);

            const pathInput = document.createElement('input');
            pathInput.type = 'text';
            pathInput.id = 'export-path';
            pathInput.placeholder = '例如：我的备份、重要数据等';
            pathInput.style.width = '100%';
            pathInput.style.padding = '8px';
            pathInput.style.borderRadius = '5px';
            pathInput.style.border = '1px solid #ccc';
            pathInput.style.boxSizing = 'border-box';
            autoExportSettingContainer.appendChild(pathInput);

            const pathHint = document.createElement('div');
            pathHint.innerHTML = `
                <div style="margin-bottom: 5px;">提示：留空将使用默认格式"章鱼喷墨_备份数据_日期_时间.ee"</div>
                <div style="margin-bottom: 5px;">填写后格式："您的文件名_日期_时间.ee"</div>
                <div style="color: #ff6b6b; font-weight: 600;">注意：由于浏览器安全限制，文件只能保存到浏览器默认下载文件夹</div>
                <div style="margin-top: 5px;">如需更改下载路径，请在浏览器设置中修改默认下载位置</div>
            `;
            pathHint.style.fontSize = '12px';
            pathHint.style.color = '#666';
            pathHint.style.marginTop = '5px';
            pathHint.style.lineHeight = '1.5';
            autoExportSettingContainer.appendChild(pathHint);

            // 按钮组
            const exportButtonGroup = document.createElement('div');
            exportButtonGroup.style.display = 'flex';
            exportButtonGroup.style.gap = '10px';
            exportButtonGroup.style.marginTop = '15px';

            const setExportTimeBtn = document.createElement('button');
            setExportTimeBtn.className = 'btn';
            setExportTimeBtn.textContent = '设置导出时间';
            setExportTimeBtn.style.flex = '1';
            setExportTimeBtn.style.backgroundColor = '#4CAF50';
            setExportTimeBtn.style.color = 'white';

            const resetExportTimeBtn = document.createElement('button');
            resetExportTimeBtn.className = 'btn';
            resetExportTimeBtn.textContent = '重置时间';
            resetExportTimeBtn.style.flex = '1';
            resetExportTimeBtn.style.backgroundColor = '#2196F3';
            resetExportTimeBtn.style.color = 'white';

            const clearExportCountBtn = document.createElement('button');
            clearExportCountBtn.className = 'btn';
            clearExportCountBtn.textContent = '清除今日导出';
            clearExportCountBtn.style.flex = '1';
            clearExportCountBtn.style.backgroundColor = '#FF9800';
            clearExportCountBtn.style.color = 'white';

            exportButtonGroup.appendChild(setExportTimeBtn);
            exportButtonGroup.appendChild(resetExportTimeBtn);
            exportButtonGroup.appendChild(clearExportCountBtn);
            autoExportSettingContainer.appendChild(exportButtonGroup);

            // 状态显示
            const exportStatusDisplay = document.createElement('div');
            exportStatusDisplay.id = 'export-status';
            exportStatusDisplay.style.marginTop = '15px';
            exportStatusDisplay.style.padding = '10px';
            exportStatusDisplay.style.backgroundColor = '#fff';
            exportStatusDisplay.style.borderRadius = '5px';
            exportStatusDisplay.style.fontSize = '14px';
            exportStatusDisplay.style.color = '#666';
            exportStatusDisplay.textContent = '当前未设置自动导出';
            autoExportSettingContainer.appendChild(exportStatusDisplay);

            autoExportSection.appendChild(autoExportSettingContainer);
            tutorialContentArea.appendChild(autoExportSection);

            // ========== Git仓库同步功能区域 ==========
            const gitSyncSection = document.createElement('div');
            gitSyncSection.style.marginTop = '30px';
            gitSyncSection.style.padding = '15px';
            gitSyncSection.style.backgroundColor = '#e3f2fd';
            gitSyncSection.style.borderRadius = '10px';
            gitSyncSection.style.border = '2px solid #42a5f5';

            const gitSyncTitle = document.createElement('h3');
            gitSyncTitle.textContent = 'Git仓库同步';
            gitSyncTitle.style.marginTop = '0';
            gitSyncTitle.style.marginBottom = '15px';
            gitSyncTitle.style.color = '#1976d2';
            gitSyncSection.appendChild(gitSyncTitle);

            // 开关按钮
            const gitSyncToggleContainer = document.createElement('div');
            gitSyncToggleContainer.style.display = 'flex';
            gitSyncToggleContainer.style.alignItems = 'center';
            gitSyncToggleContainer.style.marginBottom = '15px';
            gitSyncToggleContainer.style.justifyContent = 'space-between';

            const gitSyncToggleLabel = document.createElement('label');
            gitSyncToggleLabel.textContent = '启用Git仓库同步';
            gitSyncToggleLabel.style.fontSize = '16px';
            gitSyncToggleLabel.style.fontWeight = '600';

            const gitSyncToggle = document.createElement('input');
            gitSyncToggle.type = 'checkbox';
            gitSyncToggle.id = 'git-sync-toggle';
            gitSyncToggle.style.width = '50px';
            gitSyncToggle.style.height = '25px';
            gitSyncToggle.style.cursor = 'pointer';

            gitSyncToggleContainer.appendChild(gitSyncToggleLabel);
            gitSyncToggleContainer.appendChild(gitSyncToggle);
            gitSyncSection.appendChild(gitSyncToggleContainer);

            // 设置区域
            const gitSyncSettingContainer = document.createElement('div');
            gitSyncSettingContainer.id = 'git-sync-setting-container';
            gitSyncSettingContainer.style.display = 'none';
            gitSyncSettingContainer.style.marginTop = '15px';

            // GitHub Token输入
            const tokenLabel = document.createElement('label');
            tokenLabel.textContent = 'GitHub Personal Access Token：';
            tokenLabel.style.display = 'block';
            tokenLabel.style.marginBottom = '10px';
            tokenLabel.style.fontWeight = '600';
            gitSyncSettingContainer.appendChild(tokenLabel);

            const tokenInput = document.createElement('input');
            tokenInput.type = 'password';
            tokenInput.id = 'github-token';
            tokenInput.placeholder = '输入您的GitHub Token';
            tokenInput.style.width = '100%';
            tokenInput.style.padding = '8px';
            tokenInput.style.borderRadius = '5px';
            tokenInput.style.border = '1px solid #ccc';
            tokenInput.style.boxSizing = 'border-box';
            tokenInput.style.marginBottom = '10px';
            gitSyncSettingContainer.appendChild(tokenInput);

            // 仓库信息输入
            const repoLabel = document.createElement('label');
            repoLabel.textContent = '仓库信息（用户名/仓库名）：';
            repoLabel.style.display = 'block';
            repoLabel.style.marginTop = '15px';
            repoLabel.style.marginBottom = '10px';
            repoLabel.style.fontWeight = '600';
            gitSyncSettingContainer.appendChild(repoLabel);

            const repoInput = document.createElement('input');
            repoInput.type = 'text';
            repoInput.id = 'github-repo';
            repoInput.placeholder = '例如：username/my-backup-repo';
            repoInput.style.width = '100%';
            repoInput.style.padding = '8px';
            repoInput.style.borderRadius = '5px';
            repoInput.style.border = '1px solid #ccc';
            repoInput.style.boxSizing = 'border-box';
            repoInput.style.marginBottom = '10px';
            gitSyncSettingContainer.appendChild(repoInput);

            // 分支名称输入
            const branchLabel = document.createElement('label');
            branchLabel.textContent = '分支名称：';
            branchLabel.style.display = 'block';
            branchLabel.style.marginTop = '15px';
            branchLabel.style.marginBottom = '10px';
            branchLabel.style.fontWeight = '600';
            gitSyncSettingContainer.appendChild(branchLabel);

            const branchInput = document.createElement('input');
            branchInput.type = 'text';
            branchInput.id = 'github-branch';
            branchInput.placeholder = '默认：main';
            branchInput.value = 'main';
            branchInput.style.width = '100%';
            branchInput.style.padding = '8px';
            branchInput.style.borderRadius = '5px';
            branchInput.style.border = '1px solid #ccc';
            branchInput.style.boxSizing = 'border-box';
            branchInput.style.marginBottom = '10px';
            gitSyncSettingContainer.appendChild(branchInput);

            // 按钮组
            const gitButtonGroup = document.createElement('div');
            gitButtonGroup.style.display = 'flex';
            gitButtonGroup.style.gap = '10px';
            gitButtonGroup.style.marginTop = '15px';

            const saveGitConfigBtn = document.createElement('button');
            saveGitConfigBtn.className = 'btn';
            saveGitConfigBtn.textContent = '保存配置';
            saveGitConfigBtn.style.flex = '1';
            saveGitConfigBtn.style.backgroundColor = '#4CAF50';
            saveGitConfigBtn.style.color = 'white';

            const uploadToGitBtn = document.createElement('button');
            uploadToGitBtn.className = 'btn';
            uploadToGitBtn.textContent = '上传到仓库';
            uploadToGitBtn.style.flex = '1';
            uploadToGitBtn.style.backgroundColor = '#2196F3';
            uploadToGitBtn.style.color = 'white';

            const downloadFromGitBtn = document.createElement('button');
            downloadFromGitBtn.className = 'btn';
            downloadFromGitBtn.textContent = '从仓库导入';
            downloadFromGitBtn.style.flex = '1';
            downloadFromGitBtn.style.backgroundColor = '#FF9800';
            downloadFromGitBtn.style.color = 'white';

            gitButtonGroup.appendChild(saveGitConfigBtn);
            gitButtonGroup.appendChild(uploadToGitBtn);
            gitButtonGroup.appendChild(downloadFromGitBtn);
            gitSyncSettingContainer.appendChild(gitButtonGroup);

            // 状态显示
            const gitStatusDisplay = document.createElement('div');
            gitStatusDisplay.id = 'git-sync-status';
            gitStatusDisplay.style.marginTop = '15px';
            gitStatusDisplay.style.padding = '10px';
            gitStatusDisplay.style.backgroundColor = '#fff';
            gitStatusDisplay.style.borderRadius = '5px';
            gitStatusDisplay.style.fontSize = '14px';
            gitStatusDisplay.style.color = '#666';
            gitStatusDisplay.textContent = '当前未配置Git仓库同步';
            gitSyncSettingContainer.appendChild(gitStatusDisplay);

            // 自动导出设置区域
            const autoGitSyncContainer = document.createElement('div');
            autoGitSyncContainer.style.marginTop = '20px';
            autoGitSyncContainer.style.padding = '15px';
            autoGitSyncContainer.style.backgroundColor = '#f5f5f5';
            autoGitSyncContainer.style.borderRadius = '8px';
            autoGitSyncContainer.style.border = '1px solid #ddd';

            const autoGitSyncTitle = document.createElement('h4');
            autoGitSyncTitle.textContent = '自动导出到仓库';
            autoGitSyncTitle.style.marginTop = '0';
            autoGitSyncTitle.style.marginBottom = '15px';
            autoGitSyncTitle.style.color = '#1976d2';
            autoGitSyncContainer.appendChild(autoGitSyncTitle);

            // 自动导出开关
            const autoGitSyncToggleContainer = document.createElement('div');
            autoGitSyncToggleContainer.style.display = 'flex';
            autoGitSyncToggleContainer.style.alignItems = 'center';
            autoGitSyncToggleContainer.style.marginBottom = '15px';
            autoGitSyncToggleContainer.style.justifyContent = 'space-between';

            const autoGitSyncToggleLabel = document.createElement('label');
            autoGitSyncToggleLabel.textContent = '启用自动导出';
            autoGitSyncToggleLabel.style.fontSize = '15px';
            autoGitSyncToggleLabel.style.fontWeight = '600';

            const autoGitSyncToggle = document.createElement('input');
            autoGitSyncToggle.type = 'checkbox';
            autoGitSyncToggle.id = 'auto-git-sync-toggle';
            autoGitSyncToggle.style.width = '50px';
            autoGitSyncToggle.style.height = '25px';
            autoGitSyncToggle.style.cursor = 'pointer';

            autoGitSyncToggleContainer.appendChild(autoGitSyncToggleLabel);
            autoGitSyncToggleContainer.appendChild(autoGitSyncToggle);
            autoGitSyncContainer.appendChild(autoGitSyncToggleContainer);

            // 时间间隔设置
            const intervalLabel = document.createElement('label');
            intervalLabel.textContent = '自动导出间隔（分钟）：';
            intervalLabel.style.display = 'block';
            intervalLabel.style.marginBottom = '8px';
            intervalLabel.style.fontWeight = '600';
            intervalLabel.style.fontSize = '14px';
            autoGitSyncContainer.appendChild(intervalLabel);

            const intervalInput = document.createElement('input');
            intervalInput.type = 'number';
            intervalInput.id = 'auto-git-sync-interval';
            intervalInput.placeholder = '例如：30（表示每30分钟自动导出一次）';
            intervalInput.min = '5';
            intervalInput.max = '1440';
            intervalInput.value = '30';
            intervalInput.style.width = '100%';
            intervalInput.style.padding = '10px';
            intervalInput.style.border = '1px solid #ddd';
            intervalInput.style.borderRadius = '5px';
            intervalInput.style.fontSize = '14px';
            intervalInput.style.boxSizing = 'border-box';
            intervalInput.style.marginBottom = '10px';
            autoGitSyncContainer.appendChild(intervalInput);

            // 提示信息
            const intervalHint = document.createElement('div');
            intervalHint.style.fontSize = '12px';
            intervalHint.style.color = '#666';
            intervalHint.style.marginBottom = '15px';
            intervalHint.innerHTML = '建议设置为 30-60 分钟。最小 5 分钟，最大 1440 分钟（24小时）';
            autoGitSyncContainer.appendChild(intervalHint);

            // 自动导出状态显示
            const autoGitSyncStatus = document.createElement('div');
            autoGitSyncStatus.id = 'auto-git-sync-status';
            autoGitSyncStatus.style.padding = '10px';
            autoGitSyncStatus.style.backgroundColor = '#fff';
            autoGitSyncStatus.style.borderRadius = '5px';
            autoGitSyncStatus.style.fontSize = '13px';
            autoGitSyncStatus.style.color = '#666';
            autoGitSyncStatus.textContent = '自动导出未启用';
            autoGitSyncContainer.appendChild(autoGitSyncStatus);

            gitSyncSettingContainer.appendChild(autoGitSyncContainer);

            // 使用说明
            const gitInstructions = document.createElement('div');
            gitInstructions.style.marginTop = '20px';
            gitInstructions.style.padding = '15px';
            gitInstructions.style.backgroundColor = '#fff3cd';
            gitInstructions.style.borderRadius = '8px';
            gitInstructions.style.border = '1px solid #ffc107';
            gitInstructions.innerHTML = `
                <h4 style="margin-top: 0; color: #856404;">📖 使用说明（小白教程）</h4>
                <div style="line-height: 1.8; color: #856404; font-size: 13px;">
                    <p><strong>第一步：创建GitHub仓库</strong></p>
                    <ol style="margin: 5px 0; padding-left: 20px;">
                        <li>访问 <a href="https://github.com" target="_blank" style="color: #0066cc;">github.com</a> 并登录</li>
                        <li>点击右上角的 "+" 号，选择 "New repository"</li>
                        <li>输入仓库名称（如：my-backup），选择 "Private"（私有）</li>
                        <li>点击 "Create repository" 创建仓库</li>
                    </ol>
                    
                    <p><strong>第二步：获取Personal Access Token</strong></p>
                    <ol style="margin: 5px 0; padding-left: 20px;">
                        <li>点击右上角头像 → Settings（设置）</li>
                        <li>左侧菜单最下方找到 "Developer settings"</li>
                        <li>点击 "Personal access tokens" → "Tokens (classic)"</li>
                        <li>点击 "Generate new token" → "Generate new token (classic)"</li>
                        <li>输入备注名称（如：backup-sync）</li>
                        <li>勾选权限：<strong>repo</strong>（所有repo相关权限）</li>
                        <li>点击底部 "Generate token"，<strong>复制生成的token（只显示一次！）</strong></li>
                    </ol>
                    
                    <p><strong>第三步：配置同步</strong></p>
                    <ol style="margin: 5px 0; padding-left: 20px;">
                        <li>开启上方的 "启用Git仓库同步" 开关</li>
                        <li>粘贴刚才复制的Token到 "GitHub Personal Access Token" 框</li>
                        <li>填写仓库信息，格式：<strong>你的用户名/仓库名</strong>（如：zhangsan/my-backup）</li>
                        <li>分支名称默认 "main" 即可（如果你的仓库是master分支，就填master）</li>
                        <li>点击 "保存配置" 按钮</li>
                    </ol>
                    
                    <p><strong>第四步：使用同步功能</strong></p>
                    <ul style="margin: 5px 0; padding-left: 20px;">
                        <li><strong>上传到仓库：</strong>点击 "上传到仓库" 按钮，将当前数据备份到GitHub</li>
                        <li><strong>从仓库导入：</strong>在其他设备上，配置好相同的仓库信息后，点击 "从仓库导入" 即可恢复数据</li>
                        <li><strong>跨设备同步：</strong>在设备A上传，在设备B导入，实现数据同步</li>
                    </ul>
                    
                    <p style="color: #d32f2f; font-weight: 600; margin-top: 10px;">重要提示：</p>
                    <ul style="margin: 5px 0; padding-left: 20px; color: #d32f2f;">
                        <li>Token非常重要，请妥善保管，不要泄露给他人</li>
                        <li>建议使用Private（私有）仓库保护隐私</li>
                        <li>每次上传会覆盖仓库中的旧数据</li>
                        <li>导入数据前建议先导出当前数据作为备份</li>
                    </ul>
                </div>
            `;
            gitSyncSettingContainer.appendChild(gitInstructions);

            gitSyncSection.appendChild(gitSyncSettingContainer);
            tutorialContentArea.appendChild(gitSyncSection);

            // ========== Git仓库同步功能逻辑 ==========
            const GIT_SYNC_STORAGE_KEY = 'gitSyncSettings';

            // 加载Git同步设置
            function loadGitSyncSettings() {
                const saved = localStorage.getItem(GIT_SYNC_STORAGE_KEY);
                if (saved) {
                    try {
                        const settings = JSON.parse(saved);
                        gitSyncToggle.checked = settings.enabled || false;
                        tokenInput.value = settings.token || '';
                        repoInput.value = settings.repo || '';
                        branchInput.value = settings.branch || 'main';
                        
                        // 加载自动导出设置
                        if (settings.autoExport) {
                            autoGitSyncToggle.checked = settings.autoExport.enabled || false;
                            intervalInput.value = settings.autoExport.interval || 30;
                        }
                        
                        if (gitSyncToggle.checked) {
                            gitSyncSettingContainer.style.display = 'block';
                        }
                        updateGitSyncStatus();
                        updateAutoGitSyncStatus();
                        
                        // 启动自动导出
                        setupAutoGitSync();
                    } catch (e) {
                        console.error('加载Git同步设置失败:', e);
                    }
                }
            }

            // 保存Git同步设置
            function saveGitSyncSettings() {
                const settings = {
                    enabled: gitSyncToggle.checked,
                    token: tokenInput.value.trim(),
                    repo: repoInput.value.trim(),
                    branch: branchInput.value.trim() || 'main',
                    autoExport: {
                        enabled: autoGitSyncToggle.checked,
                        interval: parseInt(intervalInput.value) || 30
                    }
                };
                localStorage.setItem(GIT_SYNC_STORAGE_KEY, JSON.stringify(settings));
                
                // 重新启动自动导出定时器
                setupAutoGitSync();
            }

            // 更新Git同步状态显示
            function updateGitSyncStatus() {
                if (gitSyncToggle.checked && tokenInput.value.trim() && repoInput.value.trim()) {
                    gitStatusDisplay.innerHTML = `
                        Git仓库同步已启用<br>
                        仓库: ${repoInput.value.trim()}<br>
                        分支: ${branchInput.value.trim() || 'main'}<br>
                        状态: 已配置
                    `;
                    gitStatusDisplay.style.color = '#4CAF50';
                } else if (gitSyncToggle.checked) {
                    gitStatusDisplay.textContent = 'Git仓库同步已启用，但配置不完整';
                    gitStatusDisplay.style.color = '#FF9800';
                } else {
                    gitStatusDisplay.textContent = 'Git仓库同步未启用';
                    gitStatusDisplay.style.color = '#999';
                }
            }

            // 更新自动导出状态显示
            function updateAutoGitSyncStatus() {
                const interval = parseInt(intervalInput.value) || 30;
                const isConfigured = gitSyncToggle.checked && tokenInput.value.trim() && repoInput.value.trim();
                
                if (autoGitSyncToggle.checked && isConfigured) {
                    const nextExportTime = autoGitSyncNextTime ? new Date(autoGitSyncNextTime).toLocaleString('zh-CN') : '计算中...';
                    autoGitSyncStatus.innerHTML = `
                        自动导出已启用<br>
                        间隔: 每 ${interval} 分钟<br>
                        下次导出: ${nextExportTime}
                    `;
                    autoGitSyncStatus.style.color = '#4CAF50';
                } else if (autoGitSyncToggle.checked && !isConfigured) {
                    autoGitSyncStatus.textContent = '自动导出已启用，但Git仓库配置不完整';
                    autoGitSyncStatus.style.color = '#FF9800';
                } else {
                    autoGitSyncStatus.textContent = '自动导出未启用';
                    autoGitSyncStatus.style.color = '#999';
                }
            }

            // 自动导出定时器
            let autoGitSyncTimer = null;
            let autoGitSyncNextTime = null;

            // 设置自动导出
            function setupAutoGitSync() {
                // 清除旧的定时器
                if (autoGitSyncTimer) {
                    clearInterval(autoGitSyncTimer);
                    autoGitSyncTimer = null;
                }

                const isConfigured = gitSyncToggle.checked && tokenInput.value.trim() && repoInput.value.trim();
                
                if (autoGitSyncToggle.checked && isConfigured) {
                    const interval = parseInt(intervalInput.value) || 30;
                    const intervalMs = interval * 60 * 1000; // 转换为毫秒
                    
                    // 设置下次导出时间
                    autoGitSyncNextTime = Date.now() + intervalMs;
                    updateAutoGitSyncStatus();
                    
                    // 启动定时器
                    autoGitSyncTimer = setInterval(async () => {
                        console.log('自动导出到Git仓库...');
                        try {
                            await uploadToGitHub(true); // true 表示是自动导出
                            // 更新下次导出时间
                            autoGitSyncNextTime = Date.now() + intervalMs;
                            updateAutoGitSyncStatus();
                        } catch (error) {
                            console.error('自动导出失败:', error);
                        }
                    }, intervalMs);
                    
                    console.log(`自动导出已启动，间隔: ${interval} 分钟`);
                } else {
                    autoGitSyncNextTime = null;
                    updateAutoGitSyncStatus();
                    console.log('自动导出已停止');
                }
            }

            // 上传数据到GitHub
            async function uploadToGitHub(isAutoExport = false) {
                const token = tokenInput.value.trim();
                const repo = repoInput.value.trim();
                const branch = branchInput.value.trim() || 'main';

                if (!token || !repo) {
                    if (!isAutoExport) {
                        showToast('请先配置Token和仓库信息');
                    }
                    return;
                }

                try {
                    if (!isAutoExport) {
                        showToast('正在上传数据到GitHub...');
                    } else {
                        console.log('自动导出: 正在上传数据到GitHub...');
                    }

                    // 创建完整的数据备份
                    const fullBackupData = await createFullBackupData();
                    const jsonString = JSON.stringify(fullBackupData, null, 2);
                    const base64Content = btoa(unescape(encodeURIComponent(jsonString)));

                    // 生成文件名
                    const now = new Date();
                    const timestamp = now.toISOString().replace(/[:.]/g, '-');
                    const fileName = `backup_${timestamp}.json`;

                    // 获取当前文件的SHA（如果存在）
                    let sha = null;
                    try {
                        const getResponse = await fetch(`https://api.github.com/repos/${repo}/contents/${fileName}?ref=${branch}`, {
                            headers: {
                                'Authorization': `token ${token}`,
                                'Accept': 'application/vnd.github.v3+json'
                            }
                        });
                        if (getResponse.ok) {
                            const data = await getResponse.json();
                            sha = data.sha;
                        }
                    } catch (e) {
                        // 文件不存在，继续创建新文件
                    }

                    // 上传文件到GitHub
                    const uploadData = {
                        message: `数据备份 - ${now.toLocaleString('zh-CN')}`,
                        content: base64Content,
                        branch: branch
                    };
                    if (sha) {
                        uploadData.sha = sha;
                    }

                    const response = await fetch(`https://api.github.com/repos/${repo}/contents/${fileName}`, {
                        method: 'PUT',
                        headers: {
                            'Authorization': `token ${token}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(uploadData)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.message || '上传失败');
                    }

                    if (!isAutoExport) {
                        showToast('数据已成功上传到GitHub仓库！');
                    } else {
                        console.log('自动导出成功: 数据已上传到GitHub仓库');
                    }
                    updateGitSyncStatus();
                } catch (e) {
                    if (!isAutoExport) {
                        showToast(`上传失败: ${e.message}`);
                    }
                    console.error('GitHub上传错误:', e);
                }
            }

            // 从GitHub下载数据
            async function downloadFromGitHub() {
                const token = tokenInput.value.trim();
                const repo = repoInput.value.trim();
                const branch = branchInput.value.trim() || 'main';

                if (!token || !repo) {
                    showToast('请先配置Token和仓库信息');
                    return;
                }

                try {
                    showToast('正在从GitHub获取数据...');

                    // 获取仓库中的所有备份文件
                    const response = await fetch(`https://api.github.com/repos/${repo}/contents?ref=${branch}`, {
                        headers: {
                            'Authorization': `token ${token}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });

                    if (!response.ok) {
                        throw new Error('无法访问仓库，请检查Token和仓库信息');
                    }

                    const files = await response.json();
                    const backupFiles = files.filter(f => f.name.startsWith('backup_') && f.name.endsWith('.json'));

                    if (backupFiles.length === 0) {
                        showToast('仓库中没有找到备份文件');
                        return;
                    }

                    // 获取最新的备份文件
                    backupFiles.sort((a, b) => b.name.localeCompare(a.name));
                    const latestFile = backupFiles[0];

                    // 下载文件内容
                    const fileResponse = await fetch(latestFile.download_url);
                    if (!fileResponse.ok) {
                        throw new Error('下载备份文件失败');
                    }

                    const backupData = await fileResponse.json();

                    // 确认导入
                    const confirmed = confirm(`找到备份文件：${latestFile.name}\n\n确定要导入此备份吗？\n\n警告：这将覆盖当前所有数据！`);
                    if (!confirmed) {
                        showToast('已取消导入');
                        return;
                    }

                    // 导入数据
                    await importFullBackupData(backupData);
                    showToast('数据已成功从GitHub导入！');
                    
                    // 刷新页面以应用新数据
                    setTimeout(() => {
                        location.reload();
                    }, 1500);
                } catch (e) {
                    showToast(`导入失败: ${e.message}`);
                    console.error('GitHub下载错误:', e);
                }
            }

            // 导入完整备份数据
            async function importFullBackupData(backupData) {
                // 导入聊天数据
                if (backupData.chats) {
                    await db.chats.clear();
                    await db.chats.bulkAdd(backupData.chats);
                }

                // 导入消息数据
                if (backupData.messages) {
                    await db.messages.clear();
                    await db.messages.bulkAdd(backupData.messages);
                }

                // 导入世界书数据
                if (backupData.worldBooks) {
                    await db.worldBooks.clear();
                    await db.worldBooks.bulkAdd(backupData.worldBooks);
                }

                // 导入其他localStorage数据
                if (backupData.localStorage) {
                    Object.keys(backupData.localStorage).forEach(key => {
                        localStorage.setItem(key, backupData.localStorage[key]);
                    });
                }
            }

            // 开关切换事件
            gitSyncToggle.addEventListener('change', () => {
                if (gitSyncToggle.checked) {
                    gitSyncSettingContainer.style.display = 'block';
                    showToast('Git仓库同步已启用');
                } else {
                    gitSyncSettingContainer.style.display = 'none';
                    showToast('Git仓库同步已关闭');
                }
                saveGitSyncSettings();
                updateGitSyncStatus();
            });

            // 保存配置按钮
            saveGitConfigBtn.addEventListener('click', () => {
                if (!tokenInput.value.trim()) {
                    showToast('请输入GitHub Token');
                    return;
                }
                if (!repoInput.value.trim()) {
                    showToast('请输入仓库信息');
                    return;
                }
                if (!/^[\w-]+\/[\w-]+$/.test(repoInput.value.trim())) {
                    showToast('仓库格式错误，应为：用户名/仓库名');
                    return;
                }

                saveGitSyncSettings();
                updateGitSyncStatus();
                showToast('Git配置已保存');
            });

            // 上传按钮
            uploadToGitBtn.addEventListener('click', () => uploadToGitHub(false));

            // 下载按钮
            downloadFromGitBtn.addEventListener('click', downloadFromGitHub);

            // 自动导出开关事件
            autoGitSyncToggle.addEventListener('change', () => {
                saveGitSyncSettings();
                updateAutoGitSyncStatus();
                
                if (autoGitSyncToggle.checked) {
                    showToast('自动导出已启用');
                } else {
                    showToast('自动导出已关闭');
                }
            });

            // 自动导出间隔变化事件
            intervalInput.addEventListener('change', () => {
                const interval = parseInt(intervalInput.value);
                if (interval < 5) {
                    intervalInput.value = 5;
                    showToast('最小间隔为 5 分钟');
                } else if (interval > 1440) {
                    intervalInput.value = 1440;
                    showToast('最大间隔为 1440 分钟（24小时）');
                }
                saveGitSyncSettings();
                updateAutoGitSyncStatus();
            });

            // 页面加载时恢复Git设置
            loadGitSyncSettings();

            // ========== 转换旧数据功能区域 ==========
            
            const convertOldDataSection = document.createElement('div');
            convertOldDataSection.style.marginTop = '30px';
            convertOldDataSection.style.padding = '20px';
            convertOldDataSection.style.backgroundColor = '#fff3cd';
            convertOldDataSection.style.borderRadius = '12px';
            convertOldDataSection.style.border = '2px solid #ffc107';

            const convertOldDataTitle = document.createElement('h3');
            convertOldDataTitle.textContent = '转换旧数据存储方式';
            convertOldDataTitle.style.fontSize = '18px';
            convertOldDataTitle.style.color = '#ff6f00';
            convertOldDataTitle.style.marginTop = '0';
            convertOldDataTitle.style.marginBottom = '15px';
            convertOldDataSection.appendChild(convertOldDataTitle);

            const convertOldDataDesc = document.createElement('div');
            convertOldDataDesc.innerHTML = `
                <div style="font-size: 14px; color: #666; line-height: 1.6; margin-bottom: 15px;">
                    <strong>功能说明：</strong><br>
                    • 将旧版本的 Base64 图片转换为高效的 Blob 存储<br>
                    • 大幅减少数据库大小，防止闪退<br>
                    • 兼容旧导出数据和旧版本存储<br>
                    • 不会删除任何消息、角色或设置<br>
                    <br>
                    <strong style="color: #ff6f00;">⚠️ 适用场景：</strong><br>
                    • 从旧版本升级后<br>
                    • 导入了旧的备份数据<br>
                    • 应用经常闪退或卡顿<br>
                    • 存储空间占用过大<br>
                    <br>
                    <div id="old-data-stats" style="background: white; padding: 10px; border-radius: 8px; margin-top: 10px;">
                        <strong>正在检测旧数据...</strong>
                    </div>
                </div>
            `;
            convertOldDataSection.appendChild(convertOldDataDesc);

            const convertOldDataBtn = document.createElement('button');
            convertOldDataBtn.className = 'btn btn-primary';
            convertOldDataBtn.innerHTML = '<span style="font-size: 16px;"></span> 开始转换旧数据';
            convertOldDataBtn.style.width = '100%';
            convertOldDataBtn.style.backgroundColor = '#ff9800';
            convertOldDataBtn.style.color = 'white';
            convertOldDataBtn.style.marginTop = '10px';
            convertOldDataSection.appendChild(convertOldDataBtn);

            tutorialContentArea.appendChild(convertOldDataSection);

            // 检测旧数据
            async function detectOldData() {
                try {
                    const data = await dataStorage.getData('章鱼喷墨机');
                    let base64Count = 0;
                    let base64Size = 0;
                    const details = [];

                    // 检测角色头像
                    if (data && data.characters) {
                        data.characters.forEach(char => {
                            if (char.avatar && char.avatar.startsWith('data:')) {
                                base64Count++;
                                base64Size += char.avatar.length;
                                details.push(`角色 "${char.remarkName}" 的头像`);
                            }
                            if (char.myAvatar && char.myAvatar.startsWith('data:')) {
                                base64Count++;
                                base64Size += char.myAvatar.length;
                                details.push(`角色 "${char.remarkName}" 的我的头像`);
                            }
                        });
                    }

                    // 检测表情
                    if (data && data.myStickers) {
                        data.myStickers.forEach(sticker => {
                            if (sticker.url && sticker.url.startsWith('data:')) {
                                base64Count++;
                                base64Size += sticker.url.length;
                                details.push(`表情 "${sticker.name}"`);
                            }
                        });
                    }

                    // 检测头像库
                    if (data && data.avatarLibrary) {
                        data.avatarLibrary.forEach(avatar => {
                            if (avatar.url && avatar.url.startsWith('data:')) {
                                base64Count++;
                                base64Size += avatar.url.length;
                                details.push(`头像库 "${avatar.name}"`);
                            }
                        });
                    }

                    if (data && data.myAvatarLibrary) {
                        data.myAvatarLibrary.forEach(avatar => {
                            if (avatar.url && avatar.url.startsWith('data:')) {
                                base64Count++;
                                base64Size += avatar.url.length;
                                details.push(`我的头像库 "${avatar.name}"`);
                            }
                        });
                    }

                    // 更新显示
                    const statsDiv = document.getElementById('old-data-stats');
                    if (base64Count === 0) {
                        statsDiv.innerHTML = `
                            <div style="color: #4caf50;">
                                <strong>未检测到旧数据</strong><br>
                                <span style="font-size: 13px;">您的数据已经是最新的存储格式，无需转换。</span>
                            </div>
                        `;
                        convertOldDataBtn.disabled = true;
                        convertOldDataBtn.style.opacity = '0.5';
                        convertOldDataBtn.style.cursor = 'not-allowed';
                    } else {
                        statsDiv.innerHTML = `
                            <div style="color: #ff6f00;">
                                <strong>检测到旧数据</strong><br>
                                <div style="margin-top: 8px; font-size: 13px;">
                                    • Base64 图片数量: <strong>${base64Count}</strong> 个<br>
                                    • 占用空间: <strong>${(base64Size / 1024 / 1024).toFixed(2)} MB</strong><br>
                                    • 转换后预计释放: <strong>${(base64Size * 0.7 / 1024 / 1024).toFixed(2)} MB</strong>
                                </div>
                                <div style="margin-top: 10px; padding: 8px; background: #fff; border-radius: 4px; max-height: 150px; overflow-y: auto; font-size: 12px;">
                                    <strong>包含以下项目：</strong><br>
                                    ${details.slice(0, 10).map(d => `• ${d}`).join('<br>')}
                                    ${details.length > 10 ? `<br>• ... 还有 ${details.length - 10} 项` : ''}
                                </div>
                            </div>
                        `;
                    }
                } catch (error) {
                    console.error('检测旧数据失败:', error);
                    document.getElementById('old-data-stats').innerHTML = `
                        <div style="color: #f44336;">
                            <strong>检测失败</strong><br>
                            <span style="font-size: 13px;">${error.message}</span>
                        </div>
                    `;
                }
            }

            // 页面加载时检测
            detectOldData();

            // 转换旧数据
            let isConvertingOldData = false;
            convertOldDataBtn.addEventListener('click', async () => {
                if (isConvertingOldData) return;

                const confirmed = confirm(
                    '转换旧数据\n\n' +
                    '此操作将：\n' +
                    '✓ 将 Base64 图片转换为 Blob 存储\n' +
                    '✓ 大幅减少数据库大小\n' +
                    '✓ 提升应用性能\n' +
                    '✓ 防止闪退\n\n' +
                    '✓ 不会删除任何消息或角色\n' +
                    '✓ 会自动备份数据\n\n' +
                    '是否继续？'
                );

                if (!confirmed) return;

                isConvertingOldData = true;
                convertOldDataBtn.disabled = true;
                convertOldDataBtn.innerHTML = '<span class="spinner"></span> 转换中...';

                try {
                    showToast('开始转换旧数据，请稍候...');

                    // 1. 备份数据
                    console.log('正在备份数据...');
                    const data = await dataStorage.getData('章鱼喷墨机');
                    const backup = JSON.stringify(data);
                    localStorage.setItem('convert_backup_' + Date.now(), backup);
                    console.log('备份完成');

                    let convertedCount = 0;
                    let totalSizeBefore = 0;

                    // 2. 转换角色头像
                    if (data.characters) {
                        for (const char of data.characters) {
                            // 转换角色头像
                            if (char.avatar && char.avatar.startsWith('data:')) {
                                totalSizeBefore += char.avatar.length;
                                const blobRef = await dataStorage.saveImageBlob(char.avatar);
                                char.avatar = blobRef;
                                convertedCount++;
                                console.log(`✓ 转换角色 "${char.remarkName}" 的头像`);
                            }

                            // 转换我的头像
                            if (char.myAvatar && char.myAvatar.startsWith('data:')) {
                                totalSizeBefore += char.myAvatar.length;
                                const blobRef = await dataStorage.saveImageBlob(char.myAvatar);
                                char.myAvatar = blobRef;
                                convertedCount++;
                                console.log(`✓ 转换角色 "${char.remarkName}" 的我的头像`);
                            }
                        }
                    }

                    // 3. 转换表情
                    if (data.myStickers) {
                        for (const sticker of data.myStickers) {
                            if (sticker.url && sticker.url.startsWith('data:')) {
                                totalSizeBefore += sticker.url.length;
                                const blobRef = await dataStorage.saveImageBlob(sticker.url);
                                sticker.url = blobRef;
                                convertedCount++;
                                console.log(`转换表情 "${sticker.name}"`);
                            }
                        }
                    }

                    // 4. 转换头像库
                    if (data.avatarLibrary) {
                        for (const avatar of data.avatarLibrary) {
                            if (avatar.url && avatar.url.startsWith('data:')) {
                                totalSizeBefore += avatar.url.length;
                                const blobRef = await dataStorage.saveImageBlob(avatar.url);
                                avatar.url = blobRef;
                                convertedCount++;
                                console.log(`转换头像库 "${avatar.name}"`);
                            }
                        }
                    }

                    if (data.myAvatarLibrary) {
                        for (const avatar of data.myAvatarLibrary) {
                            if (avatar.url && avatar.url.startsWith('data:')) {
                                totalSizeBefore += avatar.url.length;
                                const blobRef = await dataStorage.saveImageBlob(avatar.url);
                                avatar.url = blobRef;
                                convertedCount++;
                                console.log(`转换我的头像库 "${avatar.name}"`);
                            }
                        }
                    }

                    // 5. 保存转换后的数据
                    console.log(' 正在保存转换后的数据...');
                    await saveData(data);
                    console.log('数据已保存');

                    // 6. 计算释放的空间
                    const savedSpace = totalSizeBefore;

                    showToast(
                        ` 转换完成！\n\n` +
                        ` 转换了 ${convertedCount} 个项目\n` +
                        ` 释放了约 ${(savedSpace / 1024 / 1024).toFixed(2)} MB 空间\n\n` +
                        `3秒后自动刷新页面...`,
                        5000
                    );

                    console.log(' 转换完成！');
                    console.log(`   转换项目: ${convertedCount} 个`);
                    console.log(`   释放空间: ${(savedSpace / 1024 / 1024).toFixed(2)} MB`);

                    // 7. 刷新页面
                    setTimeout(() => {
                        location.reload();
                    }, 3000);

                } catch (error) {
                    console.error(' 转换失败:', error);
                    showToast(` 转换失败: ${error.message}`);
                    convertOldDataBtn.disabled = false;
                    convertOldDataBtn.innerHTML = '<span style="font-size: 16px;"></span> 开始转换旧数据';
                } finally {
                    isConvertingOldData = false;
                }
            });

            // ========== 内存优化功能区域 ==========
            const memoryOptimizeSection = document.createElement('div');
            memoryOptimizeSection.style.marginTop = '30px';
            memoryOptimizeSection.style.padding = '20px';
            memoryOptimizeSection.style.backgroundColor = '#f0f8ff';
            memoryOptimizeSection.style.borderRadius = '12px';
            memoryOptimizeSection.style.border = '2px solid #90caf9';

            const memoryOptimizeTitle = document.createElement('h3');
            memoryOptimizeTitle.textContent = '内存优化';
            memoryOptimizeTitle.style.color = '#1976d2';
            memoryOptimizeTitle.style.marginTop = '0';
            memoryOptimizeTitle.style.marginBottom = '15px';
            memoryOptimizeTitle.style.fontSize = '18px';
            memoryOptimizeTitle.style.fontWeight = '600';
            memoryOptimizeSection.appendChild(memoryOptimizeTitle);

            const memoryOptimizeDesc = document.createElement('p');
            memoryOptimizeDesc.innerHTML = `
                <div style="font-size: 14px; color: #666; line-height: 1.6; margin-bottom: 15px;">
                    <strong>内存优化功能说明：</strong><br>
                    • 清空所有缓存数据，释放内存空间<br>
                    • 清理无效的数据引用，防止内存泄漏<br>
                    • 优化数据库性能，提升运行速度<br>
                    • 建议定期使用，特别是感觉卡顿时<br>
                    <br>
                    <strong style="color: #ff9800;">⚠️ 注意：</strong>内存优化不会删除任何聊天记录、角色或设置，只是清理缓存和临时数据。
                </div>
            `;
            memoryOptimizeSection.appendChild(memoryOptimizeDesc);

            const memoryOptimizeBtn = document.createElement('button');
            memoryOptimizeBtn.className = 'btn';
            memoryOptimizeBtn.innerHTML = '<span style="font-size: 16px;"></span> 立即优化内存';
            memoryOptimizeBtn.style.width = '100%';
            memoryOptimizeBtn.style.backgroundColor = '#2196F3';
            memoryOptimizeBtn.style.color = 'white';
            memoryOptimizeBtn.style.fontSize = '16px';
            memoryOptimizeBtn.style.fontWeight = '600';
            memoryOptimizeBtn.style.padding = '12px';

            let isOptimizing = false;
            memoryOptimizeBtn.addEventListener('click', async () => {
                if (isOptimizing) return;
                
                isOptimizing = true;
                const originalText = memoryOptimizeBtn.innerHTML;
                memoryOptimizeBtn.innerHTML = '<span style="font-size: 16px;"></span> 正在优化...';
                memoryOptimizeBtn.disabled = true;
                
                try {
                    showToast('开始内存优化...');
                    
                    // 1. 清空所有缓存
                    dataStorage.cache.clear();
                    console.log('已清空缓存');
                    
                    // 2. 清理无效数据
                    const cleanupResult = await dataStorage.clearCache();
                    console.log(`已清理 ${cleanupResult.count} 个无效项目`);
                    
                    // 3. 强制垃圾回收（如果浏览器支持）
                    if (window.gc) {
                        window.gc();
                        console.log('已触发垃圾回收');
                    }
                    
                    // 4. 清理过期的临时数据
                    const tempKeys = [];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && (key.startsWith('temp_') || key.startsWith('cache_'))) {
                            tempKeys.push(key);
                        }
                    }
                    tempKeys.forEach(key => localStorage.removeItem(key));
                    console.log(`已清理 ${tempKeys.length} 个临时数据`);
                    
                    // 5. 优化IndexedDB（压缩数据库）
                    try {
                        // 获取数据库统计信息
                        const chatsCount = await dataStorage.db.chats.count();
                        const messagesCount = await dataStorage.db.messages.count();
                        const chunksCount = await dataStorage.db.messageChunks.count();
                        console.log(`数据库状态: ${chatsCount} 个聊天, ${messagesCount} 条消息, ${chunksCount} 个消息块`);
                    } catch (e) {
                        console.log('⚠️ 无法获取数据库统计信息');
                    }
                    
                    const totalCleaned = cleanupResult.count + tempKeys.length;
                    const sizeFreed = (cleanupResult.size / 1024).toFixed(2);
                    
                    showToast(`内存优化完成！\n清理了 ${totalCleaned} 项数据\n释放了约 ${sizeFreed} KB 空间`, 5000);
                    
                    // 更新状态显示
                    memoryOptimizeDesc.innerHTML = `
                        <div style="font-size: 14px; color: #666; line-height: 1.6; margin-bottom: 15px;">
                            <strong>内存优化功能说明：</strong><br>
                            • 清空所有缓存数据，释放内存空间<br>
                            • 清理无效的数据引用，防止内存泄漏<br>
                            • 优化数据库性能，提升运行速度<br>
                            • 建议定期使用，特别是感觉卡顿时<br>
                            <br>
                            <strong style="color: #4CAF50;">最近优化：</strong>${new Date().toLocaleString('zh-CN')}<br>
                            <strong style="color: #4CAF50;">清理项目：</strong>${totalCleaned} 项<br>
                            <strong style="color: #4CAF50;">释放空间：</strong>约 ${sizeFreed} KB
                        </div>
                    `;
                    
                } catch (error) {
                    console.error('内存优化失败:', error);
                    showToast(`❌ 内存优化失败: ${error.message}`);
                } finally {
                    isOptimizing = false;
                    memoryOptimizeBtn.innerHTML = originalText;
                    memoryOptimizeBtn.disabled = false;
                }
            });

            memoryOptimizeSection.appendChild(memoryOptimizeBtn);
            tutorialContentArea.appendChild(memoryOptimizeSection);

            // 页面加载时自动进行一次轻量级内存优化（兼容旧数据）
            (async function autoMemoryOptimize() {
                try {
                    // 静默清理过期缓存
                    const now = Date.now();
                    const cacheEntries = Array.from(dataStorage.cache.entries());
                    let cleanedCount = 0;
                    
                    for (const [key, value] of cacheEntries) {
                        // 清理超过1小时的缓存
                        if (value && value.timestamp && (now - value.timestamp > 3600000)) {
                            dataStorage.cache.delete(key);
                            cleanedCount++;
                        }
                    }
                    
                    if (cleanedCount > 0) {
                        console.log(`🧹 自动清理了 ${cleanedCount} 个过期缓存`);
                    }
                } catch (error) {
                    console.error('自动内存优化失败:', error);
                }
            })();

            // ========== 图片压缩功能区域 ==========
            const imageCompressSection = document.createElement('div');
            imageCompressSection.style.marginTop = '30px';
            imageCompressSection.style.padding = '20px';
            imageCompressSection.style.backgroundColor = '#fff3e0';
            imageCompressSection.style.borderRadius = '12px';
            imageCompressSection.style.border = '2px solid #ffb74d';

            const imageCompressTitle = document.createElement('h3');
            imageCompressTitle.textContent = '图片压缩';
            imageCompressTitle.style.color = '#f57c00';
            imageCompressTitle.style.marginTop = '0';
            imageCompressTitle.style.marginBottom = '15px';
            imageCompressTitle.style.fontSize = '18px';
            imageCompressTitle.style.fontWeight = '600';
            imageCompressSection.appendChild(imageCompressTitle);

            const imageCompressDesc = document.createElement('div');
            imageCompressDesc.innerHTML = `
                <div style="font-size: 14px; color: #666; line-height: 1.6; margin-bottom: 15px;">
                    <strong>图片压缩功能说明：</strong><br>
                    • 压缩所有图片以减少内存占用<br>
                    • 不会删除图片，只是降低图片质量<br>
                    • 压缩后图片仍然可以正常显示<br>
                    • 建议压缩质量：60-80%<br>
                    <br>
                    <div id="image-stats" style="background: #fff; padding: 12px; border-radius: 8px; margin-top: 10px;">
                        <strong style="color: #f57c00;">当前图片统计：</strong><br>
                        <span id="image-count-display">正在统计...</span>
                    </div>
                </div>
            `;
            imageCompressSection.appendChild(imageCompressDesc);

            // 压缩质量滑动条
            const qualityControlDiv = document.createElement('div');
            qualityControlDiv.style.marginBottom = '20px';
            
            const qualityLabel = document.createElement('label');
            qualityLabel.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <span style="font-weight: 600; color: #333;">压缩质量</span>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span id="compress-quality-value" style="color: #f57c00; font-weight: 600; font-size: 18px;">70%</span>
                        <button type="button" id="reset-compress-quality-btn" style="background: #ff9800; color: white; border: none; padding: 4px 12px; border-radius: 5px; cursor: pointer; font-size: 12px;">重置</button>
                    </div>
                </div>
            `;
            qualityControlDiv.appendChild(qualityLabel);

            const qualitySlider = document.createElement('input');
            qualitySlider.type = 'range';
            qualitySlider.id = 'compress-quality-slider';
            qualitySlider.min = '10';
            qualitySlider.max = '100';
            qualitySlider.value = '70';
            qualitySlider.step = '5';
            qualitySlider.style.width = '100%';
            qualitySlider.style.cursor = 'pointer';
            qualityControlDiv.appendChild(qualitySlider);

            const qualityHint = document.createElement('div');
            qualityHint.style.fontSize = '12px';
            qualityHint.style.color = '#999';
            qualityHint.style.marginTop = '5px';
            qualityHint.style.textAlign = 'center';
            qualityHint.textContent = '← 更小体积 | 更高质量 →';
            qualityControlDiv.appendChild(qualityHint);

            imageCompressSection.appendChild(qualityControlDiv);

            // 压缩按钮
            const compressBtn = document.createElement('button');
            compressBtn.className = 'btn';
            compressBtn.innerHTML = '<span style="font-size: 16px;"></span> 开始压缩图片';
            compressBtn.style.width = '100%';
            compressBtn.style.backgroundColor = '#ff9800';
            compressBtn.style.color = 'white';
            compressBtn.style.fontSize = '16px';
            compressBtn.style.fontWeight = '600';
            compressBtn.style.padding = '12px';

            imageCompressSection.appendChild(compressBtn);
            tutorialContentArea.appendChild(imageCompressSection);

            // 更新质量显示
            const qualityValueDisplay = document.getElementById('compress-quality-value');
            qualitySlider.addEventListener('input', () => {
                qualityValueDisplay.textContent = qualitySlider.value + '%';
            });

            // 重置质量按钮
            document.getElementById('reset-compress-quality-btn').addEventListener('click', () => {
                qualitySlider.value = '70';
                qualityValueDisplay.textContent = '70%';
                showToast('已重置为默认质量 70%');
            });

            // 计算并显示图片统计信息
            async function updateImageStats() {
                try {
                    const imageCountDisplay = document.getElementById('image-count-display');
                    imageCountDisplay.textContent = '正在统计...';

                    // 统计所有图片（OPFS 版本）
                    let totalCount = 0;
                    let totalSize = 0;
                    try {
                        const imagesDir = await dataStorage.rootHandle.getDirectoryHandle('images');
                        for await (const file of imagesDir.values()) {
                            if (file.kind === 'file') {
                                const fileHandle = await imagesDir.getFileHandle(file.name);
                                const fileObj = await fileHandle.getFile();
                                totalSize += fileObj.size;
                                totalCount++;
                            }
                        }
                    } catch (error) {
                        // images 目录不存在
                    }

                    const sizeMB = (totalSize / (1024 * 1024)).toFixed(2);
                    
                    imageCountDisplay.innerHTML = `
                        图片总数: <strong style="color: #f57c00;">${totalCount}</strong> 张<br>
                        总大小: <strong style="color: #f57c00;">${sizeMB} MB</strong>
                    `;
                } catch (error) {
                    console.error('统计图片失败:', error);
                    document.getElementById('image-count-display').textContent = '统计失败';
                }
            }

            // 页面加载时更新统计
            updateImageStats();

            // 压缩图片功能
            let isCompressing = false;
            compressBtn.addEventListener('click', async () => {
                if (isCompressing) return;

                const quality = parseInt(qualitySlider.value) / 100;
                const confirmed = confirm(`确定要以 ${qualitySlider.value}% 的质量压缩所有图片吗？\n\n此操作不可撤销，但图片不会丢失。`);
                
                if (!confirmed) return;

                isCompressing = true;
                const originalText = compressBtn.innerHTML;
                compressBtn.innerHTML = '<span style="font-size: 16px;"></span> 压缩中...';
                compressBtn.disabled = true;

                try {
                    showToast('开始压缩图片，请稍候...');
                    
                    // OPFS 版本的图片压缩
                    let compressedCount = 0;
                    let totalSizeBefore = 0;
                    let totalSizeAfter = 0;
                    let skippedCount = 0;

                    // 遍历所有聊天，找出所有图片消息
                    const allChats = [...db.characters, ...db.groups];
                    let totalImages = 0;
                    let processedImages = 0;

                    // 先统计总图片数
                    for (const chat of allChats) {
                        const chatType = chat.members ? 'group' : 'private';
                        const messages = await dataStorage.getChatMessages(chat.id, chatType);
                        for (const msg of messages) {
                            if (msg.imageUrl && msg.imageUrl.startsWith('data:')) {
                                totalImages++;
                            }
                            if (msg.parts) {
                                totalImages += msg.parts.filter(p => p.type === 'image' && p.data && p.data.startsWith('data:')).length;
                            }
                        }
                    }

                    if (totalImages === 0) {
                        showToast('没有找到需要压缩的图片');
                        return;
                    }

                    // 压缩图片
                    for (const chat of allChats) {
                        const chatType = chat.members ? 'group' : 'private';
                        const messages = await dataStorage.getChatMessages(chat.id, chatType);
                        let modified = false;

                        for (const msg of messages) {
                            // 压缩 imageUrl
                            if (msg.imageUrl && msg.imageUrl.startsWith('data:')) {
                                try {
                                    const sizeBefore = msg.imageUrl.length;
                                    totalSizeBefore += sizeBefore;

                                    const compressed = await compressBase64Image(msg.imageUrl, quality);
                                    
                                    if (compressed) {
                                        msg.imageUrl = compressed;
                                        totalSizeAfter += compressed.length;
                                        compressedCount++;
                                        modified = true;
                                    } else {
                                        totalSizeAfter += sizeBefore;
                                        skippedCount++;
                                    }
                                } catch (error) {
                                    console.error('压缩图片失败:', error);
                                    skippedCount++;
                                    totalSizeAfter += msg.imageUrl.length;
                                }

                                processedImages++;
                                if (processedImages % 5 === 0 || processedImages === totalImages) {
                                    compressBtn.innerHTML = `<span style="font-size: 16px;">🔄</span> 压缩中... ${processedImages}/${totalImages}`;
                                }
                            }

                            // 压缩 parts 中的图片
                            if (msg.parts) {
                                for (const part of msg.parts) {
                                    if (part.type === 'image' && part.data && part.data.startsWith('data:')) {
                                        try {
                                            const sizeBefore = part.data.length;
                                            totalSizeBefore += sizeBefore;

                                            const compressed = await compressBase64Image(part.data, quality);
                                            
                                            if (compressed) {
                                                part.data = compressed;
                                                totalSizeAfter += compressed.length;
                                                compressedCount++;
                                                modified = true;
                                            } else {
                                                totalSizeAfter += sizeBefore;
                                                skippedCount++;
                                            }
                                        } catch (error) {
                                            console.error('压缩图片失败:', error);
                                            skippedCount++;
                                            totalSizeAfter += part.data.length;
                                        }

                                        processedImages++;
                                        if (processedImages % 5 === 0 || processedImages === totalImages) {
                                            compressBtn.innerHTML = `<span style="font-size: 16px;">🔄</span> 压缩中... ${processedImages}/${totalImages}`;
                                        }
                                    }
                                }
                            }
                        }

                        // 如果有修改，保存消息
                        if (modified) {
                            await dataStorage.saveChatMessages(chat.id, chatType, messages);
                        }
                    }

                    const sizeSavedMB = ((totalSizeBefore - totalSizeAfter) / (1024 * 1024)).toFixed(2);
                    const percentSaved = totalSizeBefore > 0 ? ((1 - totalSizeAfter / totalSizeBefore) * 100).toFixed(1) : 0;

                    showToast(`✅ 压缩完成！\n成功: ${compressedCount} 张\n跳过: ${skippedCount} 张\n节省: ${sizeSavedMB} MB (${percentSaved}%)`, 6000);

                    // 更新统计信息
                    await updateImageStats();

                    // 更新描述区域
                    imageCompressDesc.innerHTML = `
                        <div style="font-size: 14px; color: #666; line-height: 1.6; margin-bottom: 15px;">
                            <strong>图片压缩功能说明：</strong><br>
                            • 压缩所有图片以减少内存占用<br>
                            • 不会删除图片，只是降低图片质量<br>
                            • 压缩后图片仍然可以正常显示<br>
                            • 建议压缩质量：60-80%<br>
                            <br>
                            <div id="image-stats" style="background: #fff; padding: 12px; border-radius: 8px; margin-top: 10px;">
                                <strong style="color: #f57c00;">当前图片统计：</strong><br>
                                <span id="image-count-display">正在统计...</span>
                            </div>
                            <br>
                            <strong style="color: #4CAF50;">✅ 最近压缩：</strong>${new Date().toLocaleString('zh-CN')}<br>
                            <strong style="color: #4CAF50;">压缩质量：</strong>${qualitySlider.value}%<br>
                            <strong style="color: #4CAF50;">成功压缩：</strong>${compressedCount} 张<br>
                            <strong style="color: #4CAF50;">节省空间：</strong>${sizeSavedMB} MB (${percentSaved}%)
                        </div>
                    `;
                    
                    // 重新获取统计元素
                    await updateImageStats();

                } catch (error) {
                    console.error('压缩图片失败:', error);
                    showToast(`❌ 压缩失败: ${error.message}`);
                } finally {
                    isCompressing = false;
                    compressBtn.innerHTML = originalText;
                    compressBtn.disabled = false;
                }
            });

            // ========== 自动导出功能逻辑 ==========
            let exportInterval = null;
            let todayExportCount = 0;
            const EXPORT_STORAGE_KEY = 'autoExportSettings';

            // 加载保存的设置
            function loadExportSettings() {
                const saved = localStorage.getItem(EXPORT_STORAGE_KEY);
                if (saved) {
                    try {
                        const settings = JSON.parse(saved);
                        autoExportToggle.checked = settings.enabled || false;
                        exportHourInput.value = settings.hour || 12;
                        exportMinuteInput.value = settings.minute || 0;
                        exportSecondInput.value = settings.second || 0;
                        pathInput.value = settings.customPath || '';
                        todayExportCount = settings.todayCount || 0;
                        
                        const lastDate = settings.lastDate || '';
                        const today = new Date().toDateString();
                        if (lastDate !== today) {
                            todayExportCount = 0;
                        }
                        
                        if (autoExportToggle.checked) {
                            autoExportSettingContainer.style.display = 'block';
                            startExportCheck();
                        }
                        updateExportStatus();
                    } catch (e) {
                        console.error('加载自动导出设置失败:', e);
                    }
                }
            }

            // 保存设置
            function saveExportSettings() {
                const settings = {
                    enabled: autoExportToggle.checked,
                    hour: parseInt(exportHourInput.value) || 0,
                    minute: parseInt(exportMinuteInput.value) || 0,
                    second: parseInt(exportSecondInput.value) || 0,
                    customPath: pathInput.value.trim(),
                    todayCount: todayExportCount,
                    lastDate: new Date().toDateString()
                };
                localStorage.setItem(EXPORT_STORAGE_KEY, JSON.stringify(settings));
            }

            // 更新状态显示
            function updateExportStatus() {
                const hour = (exportHourInput.value || '0').padStart(2, '0');
                const minute = (exportMinuteInput.value || '0').padStart(2, '0');
                const second = (exportSecondInput.value || '0').padStart(2, '0');
                
                if (autoExportToggle.checked) {
                    const pathText = pathInput.value.trim() ? `自定义文件名: ${pathInput.value.trim()}` : '使用默认文件名';
                    exportStatusDisplay.innerHTML = `
                        自动导出已启用<br>
                        导出时间: ${hour}:${minute}:${second}<br>
                        ${pathText}<br>
                        保存位置: 浏览器默认下载文件夹<br>
                        今日已导出: ${todayExportCount} 次
                    `;
                    exportStatusDisplay.style.color = '#4CAF50';
                } else {
                    exportStatusDisplay.textContent = '自动导出未启用';
                    exportStatusDisplay.style.color = '#999';
                }
            }

            // 检查是否到达导出时间
            function checkExportTime() {
                const now = new Date();
                const targetHour = parseInt(exportHourInput.value) || 0;
                const targetMinute = parseInt(exportMinuteInput.value) || 0;
                const targetSecond = parseInt(exportSecondInput.value) || 0;

                if (now.getHours() === targetHour && 
                    now.getMinutes() === targetMinute && 
                    now.getSeconds() === targetSecond) {
                    performAutoExport();
                }
            }

            // 执行自动导出
            async function performAutoExport() {
                try {
                    showToast('开始自动导出数据...');

                    // 创建完整的数据备份对象
                    const fullBackupData = await createFullBackupData();
                    const jsonString = JSON.stringify(fullBackupData);
                    const dataBlob = new Blob([jsonString]);

                    // 压缩数据
                    const compressionStream = new CompressionStream('gzip');
                    const compressedStream = dataBlob.stream().pipeThrough(compressionStream);
                    const compressedBlob = await new Response(compressedStream).blob();

                    const url = URL.createObjectURL(compressedBlob);
                    const a = document.createElement('a');
                    
                    // 生成文件名
                    let fileName;
                    const customPrefix = pathInput.value.trim();
                    if (customPrefix) {
                        const now = new Date();
                        const date = now.toISOString().slice(0, 10);
                        const time = now.toTimeString().slice(0, 8).replace(/:/g, '');
                        fileName = customPrefix.endsWith('.ee') ? customPrefix : `${customPrefix}_${date}_${time}.ee`;
                    } else {
                        const now = new Date();
                        const date = now.toISOString().slice(0, 10);
                        const time = now.toTimeString().slice(0, 8).replace(/:/g, '');
                        fileName = `章鱼喷墨_备份数据_${date}_${time}.ee`;
                    }
                    
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    todayExportCount++;
                    saveExportSettings();
                    updateExportStatus();
                    
                    showToast('自动导出成功！');
                } catch (e) {
                    showToast(`自动导出失败: ${e.message}`);
                    console.error('自动导出错误:', e);
                }
            }

            // 启动导出检查
            function startExportCheck() {
                stopExportCheck();
                exportInterval = setInterval(checkExportTime, 1000);
            }

            // 停止导出检查
            function stopExportCheck() {
                if (exportInterval) {
                    clearInterval(exportInterval);
                    exportInterval = null;
                }
            }

            // 开关切换事件
            autoExportToggle.addEventListener('change', () => {
                if (autoExportToggle.checked) {
                    autoExportSettingContainer.style.display = 'block';
                    startExportCheck();
                    showToast('自动导出已启用');
                } else {
                    autoExportSettingContainer.style.display = 'none';
                    stopExportCheck();
                    showToast('自动导出已关闭');
                }
                saveExportSettings();
                updateExportStatus();
            });

            // 设置时间按钮
            setExportTimeBtn.addEventListener('click', () => {
                const hour = parseInt(exportHourInput.value);
                const minute = parseInt(exportMinuteInput.value);
                const second = parseInt(exportSecondInput.value);

                if (isNaN(hour) || hour < 0 || hour > 23) {
                    showToast('请输入有效的小时数 (0-23)');
                    return;
                }
                if (isNaN(minute) || minute < 0 || minute > 59) {
                    showToast('请输入有效的分钟数 (0-59)');
                    return;
                }
                if (isNaN(second) || second < 0 || second > 59) {
                    showToast('请输入有效的秒数 (0-59)');
                    return;
                }

                saveExportSettings();
                updateExportStatus();
                if (autoExportToggle.checked) {
                    startExportCheck();
                }
                showToast(`导出时间已设置为 ${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}:${second.toString().padStart(2, '0')}`);
            });

            // 重置时间按钮
            resetExportTimeBtn.addEventListener('click', () => {
                exportHourInput.value = '12';
                exportMinuteInput.value = '0';
                exportSecondInput.value = '0';
                saveExportSettings();
                updateExportStatus();
                if (autoExportToggle.checked) {
                    startExportCheck();
                }
                showToast('导出时间已重置为 12:00:00');
            });

            // 清除今日导出次数按钮
            clearExportCountBtn.addEventListener('click', () => {
                todayExportCount = 0;
                saveExportSettings();
                updateExportStatus();
                showToast('今日导出次数已清除');
            });

            // 页面加载时恢复设置
            loadExportSettings();
        }

        // Modal Helper Functions
        function showCustomModal() {
            const overlay = document.getElementById('custom-modal-overlay');
            if (overlay) {
                overlay.classList.add('visible');
            } else {
                console.error('custom-modal-overlay not found in DOM');
            }
        }

        function hideCustomModal() {
            const overlay = document.getElementById('custom-modal-overlay');
            if (overlay) {
                overlay.classList.remove('visible');
            }
            const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');
            if (modalFooter) {
                modalFooter.style.flexDirection = 'row';
                modalFooter.innerHTML = `
                    <button id="custom-modal-cancel">取消</button>
                    <button id="custom-modal-confirm" class="confirm-btn">确定</button>
                `;
                const cancelBtn = document.getElementById('custom-modal-cancel');
                if (cancelBtn) {
                    cancelBtn.addEventListener('click', hideCustomModal);
                }
            }
        }

        // 初始化modal取消按钮事件
        const initialCancelBtn = document.getElementById('custom-modal-cancel');
        if (initialCancelBtn) {
            initialCancelBtn.addEventListener('click', hideCustomModal);
        }

        function showCustomAlert(title, message) {
            return new Promise(resolve => {
                const modalTitle = document.getElementById('custom-modal-title');
                const modalBody = document.getElementById('custom-modal-body');
                const modalConfirmBtn = document.getElementById('custom-modal-confirm');
                const modalCancelBtn = document.getElementById('custom-modal-cancel');

                // 检查元素是否存在
                if (!modalTitle || !modalBody || !modalConfirmBtn || !modalCancelBtn) {
                    console.error('Modal elements not found. Please check if custom-modal exists in DOM.');
                    showToast('弹窗初始化失败，请刷新页面重试');
                    resolve(false);
                    return;
                }

                modalTitle.textContent = title;
                // 判断message是否包含HTML标签
                if (message.trim().startsWith('<')) {
                    modalBody.innerHTML = message;
                } else {
                    modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;
                }
                if (modalCancelBtn.style) {
                    modalCancelBtn.style.display = 'none';
                }
                modalConfirmBtn.textContent = '好的';
                
                const confirmHandler = () => {
                    if (modalCancelBtn.style) {
                        modalCancelBtn.style.display = 'block';
                    }
                    modalConfirmBtn.textContent = '确定';
                    modalConfirmBtn.removeEventListener('click', confirmHandler); 
                    resolve(true); 
                    hideCustomModal();
                };

                modalConfirmBtn.onclick = confirmHandler;
                showCustomModal();
            });
        }

        function showCustomConfirm(title, message) {
            return new Promise(resolve => {
                const modalTitle = document.getElementById('custom-modal-title');
                const modalBody = document.getElementById('custom-modal-body');
                const modalConfirmBtn = document.getElementById('custom-modal-confirm');
                const modalCancelBtn = document.getElementById('custom-modal-cancel');

                // 检查元素是否存在
                if (!modalTitle || !modalBody || !modalConfirmBtn || !modalCancelBtn) {
                    console.error('Modal elements not found. Please check if custom-modal exists in DOM.');
                    showToast('弹窗初始化失败，请刷新页面重试');
                    resolve(false);
                    return;
                }

                modalTitle.textContent = title;
                // 判断message是否包含HTML标签
                if (message.trim().startsWith('<')) {
                    modalBody.innerHTML = message;
                } else {
                    modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;
                }
                
                // 显示取消按钮
                if (modalCancelBtn.style) {
                    modalCancelBtn.style.display = 'block';
                }
                modalConfirmBtn.textContent = '确定';
                modalCancelBtn.textContent = '取消';
                
                const confirmHandler = () => {
                    modalConfirmBtn.removeEventListener('click', confirmHandler);
                    modalCancelBtn.removeEventListener('click', cancelHandler);
                    resolve(true);
                    hideCustomModal();
                };

                const cancelHandler = () => {
                    modalConfirmBtn.removeEventListener('click', confirmHandler);
                    modalCancelBtn.removeEventListener('click', cancelHandler);
                    resolve(false);
                    hideCustomModal();
                };

                modalConfirmBtn.onclick = confirmHandler;
                modalCancelBtn.onclick = cancelHandler;
                showCustomModal();
            });
        }

        function showChoiceModal(title, options) {
            return new Promise(resolve => {
                const modal = document.getElementById('custom-modal-overlay');
                const modalTitle = document.getElementById('custom-modal-title');
                const modalBody = document.getElementById('custom-modal-body');
                const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');

                // 检查元素是否存在
                if (!modal || !modalTitle || !modalBody || !modalFooter) {
                    console.error('Modal elements not found in showChoiceModal');
                    showToast('弹窗初始化失败，请刷新页面重试');
                    resolve(null);
                    return;
                }

                modalTitle.textContent = title;
                modalBody.innerHTML = ''; 
                modalFooter.innerHTML = '';
                
                // 隐藏footer，在body中添加粉色按钮
                modalFooter.style.display = 'none';

                // 添加选项按钮
                options.forEach(option => {
                    const button = document.createElement('button');
                    button.textContent = option.text;
                    button.className = 'btn btn-primary';
                    button.style.marginBottom = '10px';
                    button.onclick = () => {
                        modal.classList.remove('visible');
                        modalFooter.style.display = 'flex';
                        resolve(option.value);
                    };
                    modalBody.appendChild(button);
                });

                // 添加取消按钮
                const cancelButton = document.createElement('button');
                cancelButton.textContent = '取消';
                cancelButton.className = 'btn btn-neutral';
                cancelButton.onclick = () => {
                    modal.classList.remove('visible');
                    modalFooter.style.display = 'flex';
                    resolve(null); 
                };
                modalBody.appendChild(cancelButton);

                modal.classList.add('visible');
            });
        }

        // Card Import Logic
        function parsePngForTavernData(arrayBuffer) {
            return new Promise((resolve, reject) => {
                const view = new DataView(arrayBuffer);
                if (view.getUint32(0) !== 0x89504E47 || view.getUint32(4) !== 0x0D0A1A0A) {
                    return reject(new Error("文件不是一个有效的PNG。"));
                }

                let offset = 8;
                const decoder = new TextDecoder();

                while (offset < view.byteLength) {
                    const length = view.getUint32(offset);
                    const type = decoder.decode(arrayBuffer.slice(offset + 4, offset + 8));

                    if (type === 'tEXt') {
                        const data = new Uint8Array(arrayBuffer, offset + 8, length);
                        const nullSeparatorIndex = data.indexOf(0);
                        if (nullSeparatorIndex !== -1) {
                            const key = decoder.decode(data.slice(0, nullSeparatorIndex));
                            if (key === 'chara') {
                                const value = decoder.decode(data.slice(nullSeparatorIndex + 1));
                                try {
                                    const binaryString = atob(value);
                                    const bytes = new Uint8Array(binaryString.length);
                                    for (let i = 0; i < binaryString.length; i++) {
                                        bytes[i] = binaryString.charCodeAt(i);
                                    }
                                    const decodedData = new TextDecoder('utf-8').decode(bytes);
                                    resolve(JSON.parse(decodedData));
                                    return; 
                                } catch (e) {
                                    return reject(new Error("在PNG中找到角色数据，但解码或解析失败。错误: " + e.message));
                                }
                            }
                        }
                    }
                    offset += 4 + 4 + length + 4;
                }
                reject(new Error("在PNG文件中未找到有效的Tavern AI角色数据(chara chunk)。"));
            });
        }

        function showWorldBookSelectionModal(entries, characterName) {
            return new Promise(resolve => {
                const modal = document.getElementById('custom-modal-overlay');
                const modalTitle = document.getElementById('custom-modal-title');
                const modalBody = document.getElementById('custom-modal-body');
                const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');

                // 检查元素是否存在
                if (!modal || !modalTitle || !modalBody || !modalFooter) {
                    console.error('Modal elements not found in showWorldBookSelectionModal');
                    showToast('弹窗初始化失败，请刷新页面重试');
                    resolve([]);
                    return;
                }

                modalTitle.textContent = '选择要导入的世界书条目';
                modalBody.innerHTML = '';
                modalFooter.innerHTML = '';
                modalFooter.style.display = 'flex';

                // 创建说明文字
                const description = document.createElement('p');
                description.textContent = `${characterName} 的角色卡包含 ${entries.length} 个世界书条目，请选择要导入的条目：`;
                description.style.marginBottom = '15px';
                description.style.fontSize = '14px';
                description.style.color = '#666';
                modalBody.appendChild(description);

                // 创建全选/取消全选区域
                const selectAllContainer = document.createElement('div');
                selectAllContainer.style.cssText = 'padding: 10px; background: #f5f5f5; border-radius: 8px; margin-bottom: 15px; display: flex; align-items: center;';
                
                const selectAllCheckbox = document.createElement('input');
                selectAllCheckbox.type = 'checkbox';
                selectAllCheckbox.id = 'wb-select-all';
                selectAllCheckbox.checked = true;
                selectAllCheckbox.style.cssText = 'width: 18px; height: 18px; margin-right: 8px; cursor: pointer;';
                
                const selectAllLabel = document.createElement('label');
                selectAllLabel.htmlFor = 'wb-select-all';
                selectAllLabel.textContent = '全选/取消全选';
                selectAllLabel.style.cssText = 'font-weight: 600; color: var(--primary-color); cursor: pointer; user-select: none;';
                
                selectAllContainer.appendChild(selectAllCheckbox);
                selectAllContainer.appendChild(selectAllLabel);
                modalBody.appendChild(selectAllContainer);

                // 创建滚动容器
                const scrollContainer = document.createElement('div');
                scrollContainer.style.cssText = 'max-height: 400px; overflow-y: auto; margin-bottom: 15px;';
                modalBody.appendChild(scrollContainer);

                // 创建复选框列表
                const checkboxes = [];
                entries.forEach((entry, index) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.style.cssText = 'padding: 12px; border-bottom: 1px solid #f0f0f0; display: flex; align-items: flex-start;';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `wb-entry-${index}`;
                    checkbox.checked = entry.enabled !== false;
                    checkbox.style.cssText = 'width: 18px; height: 18px; margin-right: 10px; margin-top: 2px; cursor: pointer; flex-shrink: 0;';
                    checkboxes.push(checkbox);
                    
                    const contentDiv = document.createElement('div');
                    contentDiv.style.flex = '1';
                    
                    const titleText = entry.comment || entry.keys?.join(', ') || `条目 ${index + 1}`;
                    const title = document.createElement('div');
                    title.textContent = titleText;
                    title.style.cssText = 'font-weight: 600; margin-bottom: 5px; color: #333;';
                    
                    const preview = document.createElement('div');
                    const previewText = entry.content ? entry.content.substring(0, 80) + (entry.content.length > 80 ? '...' : '') : '无内容';
                    preview.textContent = previewText;
                    preview.style.cssText = 'font-size: 13px; color: #666; line-height: 1.4;';
                    
                    if (entry.keys && entry.keys.length > 0) {
                        const keysDiv = document.createElement('div');
                        keysDiv.textContent = `触发词: ${entry.keys.join(', ')}`;
                        keysDiv.style.cssText = 'font-size: 12px; color: var(--primary-color); margin-top: 5px;';
                        contentDiv.appendChild(keysDiv);
                    }
                    
                    contentDiv.appendChild(title);
                    contentDiv.appendChild(preview);
                    
                    itemDiv.appendChild(checkbox);
                    itemDiv.appendChild(contentDiv);
                    scrollContainer.appendChild(itemDiv);
                });

                // 全选功能
                selectAllCheckbox.addEventListener('change', () => {
                    checkboxes.forEach(cb => cb.checked = selectAllCheckbox.checked);
                });

                // 确定按钮
                const confirmButton = document.createElement('button');
                confirmButton.textContent = '确定';
                confirmButton.className = 'confirm-btn';
                confirmButton.onclick = () => {
                    const selectedIndices = checkboxes
                        .map((cb, index) => cb.checked ? index : -1)
                        .filter(index => index !== -1);
                    modal.classList.remove('visible');
                    resolve(selectedIndices);
                };
                modalFooter.appendChild(confirmButton);

                // 取消按钮
                const cancelButton = document.createElement('button');
                cancelButton.textContent = '取消';
                cancelButton.onclick = () => {
                    modal.classList.remove('visible');
                    resolve(null);
                };
                modalFooter.appendChild(cancelButton);

                modal.classList.add('visible');
            });
        }

        function showGreetingImportModal(characterName) {
            return new Promise(resolve => {
                const modal = document.getElementById('custom-modal-overlay');
                const modalTitle = document.getElementById('custom-modal-title');
                const modalBody = document.getElementById('custom-modal-body');
                const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');

                // 检查元素是否存在
                if (!modal || !modalTitle || !modalBody || !modalFooter) {
                    console.error('Modal elements not found in showGreetingImportModal');
                    showToast('弹窗初始化失败，请刷新页面重试');
                    resolve(null);
                    return;
                }

                modalTitle.textContent = '开场白导入设置';
                modalBody.innerHTML = '';
                modalFooter.innerHTML = '';
                modalFooter.style.display = 'flex';

                // 创建说明文字
                const description = document.createElement('p');
                description.textContent = `是否导入 ${characterName} 的角色开场白？`;
                description.style.marginBottom = '20px';
                description.style.fontSize = '14px';
                description.style.color = '#666';
                modalBody.appendChild(description);

                // 创建开关容器
                const switchContainer = document.createElement('div');
                switchContainer.style.cssText = 'display: flex; align-items: center; justify-content: space-between; padding: 15px; background: #f5f5f5; border-radius: 8px;';
                
                const switchLabel = document.createElement('label');
                switchLabel.textContent = '导入角色开场白';
                switchLabel.style.cssText = 'font-weight: 600; color: #333; font-size: 15px;';
                
                // 创建开关按钮
                const switchWrapper = document.createElement('label');
                switchWrapper.style.cssText = 'position: relative; display: inline-block; width: 50px; height: 26px;';
                
                const switchInput = document.createElement('input');
                switchInput.type = 'checkbox';
                switchInput.id = 'greeting-import-switch';
                switchInput.checked = false; // 默认关闭
                switchInput.style.cssText = 'opacity: 0; width: 0; height: 0;';
                
                const switchSlider = document.createElement('span');
                switchSlider.style.cssText = 'position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: 0.4s; border-radius: 26px;';
                
                const switchCircle = document.createElement('span');
                switchCircle.style.cssText = 'position: absolute; content: ""; height: 18px; width: 18px; left: 4px; bottom: 4px; background-color: white; transition: 0.4s; border-radius: 50%;';
                
                switchSlider.appendChild(switchCircle);
                switchWrapper.appendChild(switchInput);
                switchWrapper.appendChild(switchSlider);
                
                // 开关切换效果
                switchInput.addEventListener('change', () => {
                    if (switchInput.checked) {
                        switchSlider.style.backgroundColor = 'var(--primary-color)';
                        switchCircle.style.transform = 'translateX(24px)';
                    } else {
                        switchSlider.style.backgroundColor = '#ccc';
                        switchCircle.style.transform = 'translateX(0)';
                    }
                });
                
                switchContainer.appendChild(switchLabel);
                switchContainer.appendChild(switchWrapper);
                modalBody.appendChild(switchContainer);

                // 提示文字
                const hint = document.createElement('p');
                hint.textContent = '提示：关闭后将不导入角色开场白，开启后将导入角色的所有开场白。';
                hint.style.cssText = 'margin-top: 15px; font-size: 12px; color: #999; line-height: 1.5;';
                modalBody.appendChild(hint);

                // 确定按钮
                const confirmButton = document.createElement('button');
                confirmButton.textContent = '确定';
                confirmButton.className = 'confirm-btn';
                confirmButton.onclick = () => {
                    modal.classList.remove('visible');
                    resolve(switchInput.checked);
                };
                modalFooter.appendChild(confirmButton);

                modal.classList.add('visible');
            });
        }

        function showGreetingSelectionModal(greetings, characterName) {
            return new Promise(resolve => {
                const modal = document.getElementById('custom-modal-overlay');
                const modalTitle = document.getElementById('custom-modal-title');
                const modalBody = document.getElementById('custom-modal-body');
                const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');

                // 检查元素是否存在
                if (!modal || !modalTitle || !modalBody || !modalFooter) {
                    console.error('Modal elements not found in showGreetingSelectionModal');
                    showToast('弹窗初始化失败，请刷新页面重试');
                    resolve([]);
                    return;
                }

                modalTitle.textContent = '选择要导入的开场白';
                modalBody.innerHTML = '';
                modalFooter.innerHTML = '';
                modalFooter.style.display = 'flex';

                // 创建说明文字
                const description = document.createElement('p');
                description.textContent = `${characterName} 的角色卡包含 ${greetings.length} 个开场白，请选择要导入的开场白：`;
                description.style.marginBottom = '15px';
                description.style.fontSize = '14px';
                description.style.color = '#666';
                modalBody.appendChild(description);

                // 创建全选/取消全选区域
                const selectAllContainer = document.createElement('div');
                selectAllContainer.style.cssText = 'padding: 10px; background: #f5f5f5; border-radius: 8px; margin-bottom: 15px; display: flex; align-items: center;';
                
                const selectAllCheckbox = document.createElement('input');
                selectAllCheckbox.type = 'checkbox';
                selectAllCheckbox.id = 'greeting-select-all';
                selectAllCheckbox.checked = true;
                selectAllCheckbox.style.cssText = 'width: 18px; height: 18px; margin-right: 8px; cursor: pointer;';
                
                const selectAllLabel = document.createElement('label');
                selectAllLabel.htmlFor = 'greeting-select-all';
                selectAllLabel.textContent = '全选/取消全选';
                selectAllLabel.style.cssText = 'font-weight: 600; color: var(--primary-color); cursor: pointer; user-select: none;';
                
                selectAllContainer.appendChild(selectAllCheckbox);
                selectAllContainer.appendChild(selectAllLabel);
                modalBody.appendChild(selectAllContainer);

                // 创建滚动容器
                const scrollContainer = document.createElement('div');
                scrollContainer.style.cssText = 'max-height: 400px; overflow-y: auto; margin-bottom: 15px;';
                modalBody.appendChild(scrollContainer);

                // 创建复选框列表
                const checkboxes = [];
                greetings.forEach((greeting, index) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.style.cssText = 'padding: 12px; border-bottom: 1px solid #f0f0f0; display: flex; align-items: flex-start;';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `greeting-${index}`;
                    checkbox.checked = true;
                    checkbox.style.cssText = 'width: 18px; height: 18px; margin-right: 10px; margin-top: 2px; cursor: pointer; flex-shrink: 0;';
                    checkboxes.push(checkbox);
                    
                    const contentDiv = document.createElement('div');
                    contentDiv.style.flex = '1';
                    
                    const title = document.createElement('div');
                    title.textContent = `开场白 ${index + 1}`;
                    title.style.cssText = 'font-weight: 600; margin-bottom: 5px; color: #333;';
                    
                    const preview = document.createElement('div');
                    const previewText = greeting.substring(0, 100) + (greeting.length > 100 ? '...' : '');
                    preview.textContent = previewText;
                    preview.style.cssText = 'font-size: 13px; color: #666; line-height: 1.4;';
                    
                    contentDiv.appendChild(title);
                    contentDiv.appendChild(preview);
                    
                    itemDiv.appendChild(checkbox);
                    itemDiv.appendChild(contentDiv);
                    scrollContainer.appendChild(itemDiv);
                });

                // 全选功能
                selectAllCheckbox.addEventListener('change', () => {
                    checkboxes.forEach(cb => cb.checked = selectAllCheckbox.checked);
                });

                // 确定按钮
                const confirmButton = document.createElement('button');
                confirmButton.textContent = '确定';
                confirmButton.className = 'confirm-btn';
                confirmButton.onclick = () => {
                    const selectedIndices = checkboxes
                        .map((cb, index) => cb.checked ? index : -1)
                        .filter(index => index !== -1);
                    modal.classList.remove('visible');
                    resolve(selectedIndices);
                };
                modalFooter.appendChild(confirmButton);

                // 跳过按钮
                const skipButton = document.createElement('button');
                skipButton.textContent = '跳过';
                skipButton.onclick = () => {
                    modal.classList.remove('visible');
                    resolve([]);
                };
                modalFooter.appendChild(skipButton);

                modal.classList.add('visible');
            });
        }

        function showWorldBookDeletionModal(worldBooks, characterName) {
            return new Promise(resolve => {
                const modal = document.getElementById('custom-modal-overlay');
                const modalTitle = document.getElementById('custom-modal-title');
                const modalBody = document.getElementById('custom-modal-body');
                const modalFooter = document.querySelector('#custom-modal .custom-modal-footer');

                // 检查元素是否存在
                if (!modal || !modalTitle || !modalBody || !modalFooter) {
                    console.error('Modal elements not found in showWorldBookDeletionModal');
                    showToast('弹窗初始化失败，请刷新页面重试');
                    resolve({ deleteWorldBooks: false, selectedWorldBooks: [] });
                    return;
                }

                modalTitle.textContent = '是否删除关联的世界书？';
                modalBody.innerHTML = '';
                modalFooter.innerHTML = '';
                modalFooter.style.display = 'flex';

                // 创建说明文字
                const description = document.createElement('p');
                description.textContent = `角色"${characterName}"关联了 ${worldBooks.length} 个世界书，是否同时删除这些世界书？`;
                description.style.marginBottom = '15px';
                description.style.fontSize = '14px';
                description.style.color = '#666';
                modalBody.appendChild(description);

                // 创建提示信息
                const warning = document.createElement('div');
                warning.style.cssText = 'padding: 12px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px; margin-bottom: 15px;';
                warning.innerHTML = '<strong style="color: #856404;">注意：</strong><span style="color: #856404; font-size: 13px;"> 删除世界书后将无法恢复，请谨慎选择。</span>';
                modalBody.appendChild(warning);

                // 创建全选/取消全选区域
                const selectAllContainer = document.createElement('div');
                selectAllContainer.style.cssText = 'padding: 10px; background: #f5f5f5; border-radius: 8px; margin-bottom: 15px; display: flex; align-items: center;';
                
                const selectAllCheckbox = document.createElement('input');
                selectAllCheckbox.type = 'checkbox';
                selectAllCheckbox.id = 'wb-delete-select-all';
                selectAllCheckbox.checked = false; // 默认不选中，避免误删
                selectAllCheckbox.style.cssText = 'width: 18px; height: 18px; margin-right: 8px; cursor: pointer;';
                
                const selectAllLabel = document.createElement('label');
                selectAllLabel.htmlFor = 'wb-delete-select-all';
                selectAllLabel.textContent = '全选/取消全选';
                selectAllLabel.style.cssText = 'font-weight: 600; color: var(--primary-color); cursor: pointer; user-select: none;';
                
                selectAllContainer.appendChild(selectAllCheckbox);
                selectAllContainer.appendChild(selectAllLabel);
                modalBody.appendChild(selectAllContainer);

                // 创建滚动容器
                const scrollContainer = document.createElement('div');
                scrollContainer.style.cssText = 'max-height: 300px; overflow-y: auto; margin-bottom: 15px;';
                modalBody.appendChild(scrollContainer);

                // 创建复选框列表
                const checkboxes = [];
                worldBooks.forEach((wb, index) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.style.cssText = 'padding: 12px; border-bottom: 1px solid #f0f0f0; display: flex; align-items: flex-start; background: white;';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `wb-delete-${index}`;
                    checkbox.checked = false; // 默认不选中
                    checkbox.style.cssText = 'width: 18px; height: 18px; margin-right: 10px; margin-top: 2px; cursor: pointer; flex-shrink: 0;';
                    checkboxes.push(checkbox);
                    
                    const contentDiv = document.createElement('div');
                    contentDiv.style.flex = '1';
                    
                    const title = document.createElement('div');
                    title.textContent = wb.name;
                    title.style.cssText = 'font-weight: 600; margin-bottom: 5px; color: #333;';
                    
                    const preview = document.createElement('div');
                    const previewText = wb.content ? wb.content.substring(0, 80) + (wb.content.length > 80 ? '...' : '') : '无内容';
                    preview.textContent = previewText;
                    preview.style.cssText = 'font-size: 13px; color: #666; line-height: 1.4;';
                    
                    contentDiv.appendChild(title);
                    contentDiv.appendChild(preview);
                    
                    itemDiv.appendChild(checkbox);
                    itemDiv.appendChild(contentDiv);
                    scrollContainer.appendChild(itemDiv);
                });

                // 全选功能
                selectAllCheckbox.addEventListener('change', () => {
                    checkboxes.forEach(cb => cb.checked = selectAllCheckbox.checked);
                });

                // 确定删除按钮
                const confirmButton = document.createElement('button');
                confirmButton.textContent = '确定';
                confirmButton.className = 'confirm-btn';
                confirmButton.style.cssText = 'background: #dc3545; border-color: #dc3545;';
                confirmButton.onclick = () => {
                    const selectedIndices = checkboxes
                        .map((cb, index) => cb.checked ? index : -1)
                        .filter(index => index !== -1);
                    modal.classList.remove('visible');
                    resolve(selectedIndices);
                };
                modalFooter.appendChild(confirmButton);

                // 保留世界书按钮
                const keepButton = document.createElement('button');
                keepButton.textContent = '保留所有世界书';
                keepButton.onclick = () => {
                    modal.classList.remove('visible');
                    resolve([]);
                };
                modalFooter.appendChild(keepButton);

                modal.classList.add('visible');
            });
        }

        function findWorldBookEntries(cardData) {
            if (cardData.data?.character_book?.entries?.length > 0) return cardData.data.character_book.entries;
            if (cardData.extensions?.character_book?.entries?.length > 0) return cardData.extensions.character_book.entries;
            if (cardData.data?.extensions?.character_book?.entries?.length > 0) return cardData.data.extensions.character_book.entries;
            
            const possibleTopLevelKeys = ['character_book', 'lorebook', 'world_info', 'char_book'];
            for (const key of possibleTopLevelKeys) {
                if (cardData[key]?.entries?.length > 0) return cardData[key].entries;
            }
            return null;
        }

        async function createChatFromCardData(cardData, avatarBase64 = null) {
            const effectiveCardData = cardData.data || cardData;
            if (!effectiveCardData.name) throw new Error("角色卡数据无效或缺少'name'字段。");

            // 先收集所有开场白
            const allGreetings = [];
            const firstMes = effectiveCardData.first_mes || cardData.first_mes;
            if (firstMes && typeof firstMes === 'string') {
                const cleanGreeting = firstMes.replace(/原作者UR.*?开局/s, '').trim();
                if (cleanGreeting) {
                    allGreetings.push(cleanGreeting);
                }
            }

            // 添加备用开场白
            const alternateGreetings = effectiveCardData.alternate_greetings || cardData.alternate_greetings;
            if (Array.isArray(alternateGreetings) && alternateGreetings.length > 0) {
                alternateGreetings.forEach(greeting => {
                    if (greeting && typeof greeting === 'string') {
                        const cleanGreeting = greeting.replace(/原作者UR.*?开局/s, '').trim();
                        if (cleanGreeting) {
                            allGreetings.push(cleanGreeting);
                        }
                    }
                });
            }

            let worldBookIdToLink = null;
            let selectedGreetingIndices = [];
            const worldBookEntries = findWorldBookEntries(cardData);

            // 第一步：处理世界书选择
            if (worldBookEntries && worldBookEntries.length > 0) {
                const selectedIndices = await showWorldBookSelectionModal(worldBookEntries, effectiveCardData.name);
                
                if (selectedIndices && selectedIndices.length > 0) {
                    const selectedEntries = selectedIndices.map(index => worldBookEntries[index]);
                    
                    const contentParts = selectedEntries
                        .filter(entry => entry.content)
                        .map(entry => {
                            let part = '';
                            if (entry.comment) part += `[注释: ${entry.comment}]\n`;
                            if (entry.keys && entry.keys.length) part += `[触发词: ${entry.keys.join(', ')}]\n`; 
                            part += entry.content.replace(/<memory>|<\/memory>/g, '').trim();
                            return part;
                        });

                    if (contentParts.length > 0) {
                        const combinedContent = contentParts.join('\n\n---\n\n');
                        const newWorldBook = {
                            id: 'wb_' + Date.now(),
                            name: `${effectiveCardData.name}的设定集`,
                            content: combinedContent,
                            position: 'after' 
                        };
                        if (!db.worldBooks) db.worldBooks = [];
                        db.worldBooks.push(newWorldBook);
                        worldBookIdToLink = newWorldBook.id;
                    }
                }
            }

            // 第二步：处理开场白选择
            if (allGreetings.length > 0) {
                selectedGreetingIndices = await showGreetingSelectionModal(allGreetings, effectiveCardData.name);
            }

            let description = effectiveCardData.description || cardData.description || '无';
            description = description
                .replace(/```yaml/g, '').replace(/```/g, '')
                .replace(/<\/?info>/g, '').replace(/<\/?character>/g, '')
                .replace(/<\/?writing_rule>/g, '').replace(/\[OOC：.*?\]/g, '').trim();

            let persona = `# 角色核心设定\n${description}\n\n`;
            if (effectiveCardData.personality) persona += `# 性格补充\n${effectiveCardData.personality}\n\n`;
            if (effectiveCardData.scenario) persona += `# 场景设定\n${effectiveCardData.scenario}\n\n`;
            if (effectiveCardData.mes_example) persona += `# 对话示例\n${effectiveCardData.mes_example}\n\n`;

            // 获取全局世界书ID并合并
            const globalWorldBookIds = getGlobalWorldBookIds();
            const initialWorldBookIds = worldBookIdToLink ? [worldBookIdToLink, ...globalWorldBookIds] : [...globalWorldBookIds];
            // 去重
            const uniqueWorldBookIds = [...new Set(initialWorldBookIds)];

            // 根据选择的开场白索引创建开场白数组
            const selectedGreetings = selectedGreetingIndices.map(index => allGreetings[index]);

            const newChar = {
                id: `char_${Date.now()}`,
                realName: effectiveCardData.name,
                remarkName: effectiveCardData.name,
                persona: persona,
                avatar: avatarBase64 || 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg',
                myName: '我', 
                myPersona: '',
                myAvatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg',
                theme: 'white_pink',
                maxMemory: 10,
                chatBg: '',
                history: [],
                isPinned: false,
                status: '在线',
                worldBookIds: uniqueWorldBookIds,
                useCustomBubbleCss: false,
                customBubbleCss: '',
                greetings: selectedGreetings.length > 0 ? selectedGreetings : null,
                currentGreetingIndex: 0,
                musicData: { totalTime: 0 },
                unreadCount: 0
            };

            // 如果选择了开场白，添加第一个开场白到历史记录
            if (selectedGreetings.length > 0) {
                const message = {
                    id: `msg_${Date.now()}`,
                    role: 'assistant',
                    content: selectedGreetings[0],
                    parts: [{type: 'text', text: selectedGreetings[0]}],
                    timestamp: Date.now(),
                    isGreeting: true,
                    hasMultipleGreetings: selectedGreetings.length > 1
                };
                newChar.history.push(message);
            }

            db.characters.push(newChar);
            await saveData();
            renderChatList();
            
            let successMessage = `角色 "${newChar.remarkName}" 已成功导入！`;
            if (worldBookIdToLink) successMessage += `\n\n其专属的"世界书"也已自动创建并关联。`;
            if (selectedGreetings.length > 0) successMessage += `\n\n已导入 ${selectedGreetings.length} 个开场白。`;
            await showCustomAlert('导入成功！', successMessage);
        }

        async function handleCardImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                let cardData;
                let avatarBase64 = null;

                if (file.name.endsWith('.json')) {
                    const text = await file.text();
                    cardData = JSON.parse(text);
                } else if (file.name.endsWith('.png')) {
                    const arrayBuffer = await file.arrayBuffer();
                    cardData = await parsePngForTavernData(arrayBuffer);
                    
                    avatarBase64 = await new Promise(resolve => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.readAsDataURL(file);
                    });
                } else {
                    throw new Error("不支持的文件格式。请选择 .json 或 .png 文件。");
                }

                await createChatFromCardData(cardData, avatarBase64);

            } catch (error) {
                console.error("角色卡导入失败:", error);
                await showCustomAlert("导入失败", `无法解析角色卡文件。\n错误: ${error.message}`);
            } finally {
                event.target.value = null;
            }
        }
        
        // 导入AI生成的角色
        async function importGeneratedCharacter(index) {
            if (!window.generatedCharacters || !window.generatedCharacters[index]) {
                showToast('角色数据不存在');
                return;
            }
            
            const charData = window.generatedCharacters[index];
            
            try {
                // 将生成的角色数据转换为人设文本
                let persona = '';
                for (const [key, value] of Object.entries(charData)) {
                    if (key !== 'name') {
                        persona += `${key}: ${value}\n`;
                    }
                }
                
                const newChar = {
                    id: `char_${Date.now()}_${index}`,
                    realName: charData.name || '未命名角色',
                    remarkName: charData.name || '未命名角色',
                    persona: persona.trim(),
                    avatar: 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg',
                    myAvatar: db.myAvatar || 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg',
                    myName: db.myName || '我',
                    myPersona: db.myPersona || '',
                    history: [],
                    theme: 'white_pink',
                    maxMemory: 20,
                    isPinned: false,
                    unreadCount: 0,
                    avatarLibrary: []
                };
                
                db.characters.push(newChar);
                await saveData();
                renderChatList();
                
                showToast(`角色"${newChar.remarkName}"已导入！`);
                
                // 关闭弹窗
                document.getElementById('ai-generate-char-modal').classList.remove('visible');
                document.getElementById('ai-generate-char-form').reset();
                document.getElementById('ai-gen-result').style.display = 'none';
                
            } catch (error) {
                console.error('导入角色失败:', error);
                showToast(`导入失败: ${error.message}`);
            }
        }
        
        // 将函数暴露到全局作用域
        window.importGeneratedCharacter = importGeneratedCharacter;
        
        // 添加AI生成的群成员到群聊
        async function addGeneratedGroupMember(index) {
            if (!window.generatedGroupMembers || !window.generatedGroupMembers[index]) {
                showToast('群成员数据不存在');
                return;
            }
            
            const charData = window.generatedGroupMembers[index];
            const group = db.groups.find(g => g.id === currentChatId);
            
            if (!group) {
                showToast('当前不在群聊中');
                return;
            }
            
            try {
                // 将生成的角色数据转换为人设文本
                let persona = '';
                for (const [key, value] of Object.entries(charData)) {
                    if (key !== 'name') {
                        persona += `${key}: ${value}\n`;
                    }
                }
                
                const newMember = {
                    id: `member_${Date.now()}_${index}`,
                    realName: charData.name || '未命名成员',
                    groupNickname: charData.name || '未命名成员',
                    persona: persona.trim(),
                    avatar: 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg',
                    isOwner: false,
                    isAdmin: false,
                    avatarLibrary: []
                };
                
                group.members.push(newMember);
                await saveData();
                
                // 发送系统通知
                const systemMessage = {
                    id: `msg_${Date.now()}`,
                    role: 'system',
                    content: `[system-display:${newMember.groupNickname} 加入了群聊]`,
                    timestamp: Date.now()
                };
                group.history.push(systemMessage);
                await saveData();
                
                // 刷新群成员列表
                renderGroupMembersInSettings(group);
                
                // 如果当前在群聊界面，刷新消息显示
                if (currentChatType === 'group' && currentChatId === group.id) {
                    renderMessages(false, true);
                }
                
                showToast(`群成员"${newMember.groupNickname}"已添加！`);
                
                // 关闭弹窗
                document.getElementById('ai-generate-group-member-modal').classList.remove('visible');
                document.getElementById('ai-generate-group-member-form').reset();
                document.getElementById('ai-gen-gm-result').style.display = 'none';
                
            } catch (error) {
                console.error('添加群成员失败:', error);
                showToast(`添加失败: ${error.message}`);
            }
        }
        
        // 将函数暴露到全局作用域
        window.addGeneratedGroupMember = addGeneratedGroupMember;
        
        // AI生成角色功能
        async function handleAiGenerateCharacter(formData) {
            const mustHave = formData.get('mustHave') || '';
            const mustNotHave = formData.get('mustNotHave') || '';
            const wordCount = formData.get('wordCount') || '';
            const template = formData.get('template') || '';
            const systemPrompt = formData.get('systemPrompt') || '';
            const systemPosition = formData.get('systemPosition') || 'before';
            const apiType = formData.get('apiType');
            const count = parseInt(formData.get('count')) || 1;
            
            // 获取API配置
            let apiUrl, apiKey, model;
            if (apiType === 'main') {
                apiUrl = db.apiSettings?.url;
                apiKey = db.apiSettings?.key;
                model = db.apiSettings?.model;
            } else {
                apiUrl = db.secondaryApiSettings?.url;
                apiKey = db.secondaryApiSettings?.key;
                model = db.secondaryApiSettings?.model;
            }
            
            if (!apiUrl || !apiKey || !model) {
                throw new Error(`${apiType === 'main' ? '主' : '副'}API配置不完整，请先在设置中配置API`);
            }
            
            // 构建提示词
            let promptParts = {
                before: '',
                middle: '',
                after: ''
            };
            
            // 根据位置添加系统词
            if (systemPrompt) {
                promptParts[systemPosition] = systemPrompt + '\n\n';
            }
            
            let mainPrompt = `你是一个专业的角色设计师。请根据以下要求生成${count}个角色的详细人设。\n\n`;
            
            if (mustHave) {
                mainPrompt += `必须包含的特征：${mustHave}\n`;
            }
            if (mustNotHave) {
                mainPrompt += `绝对不能包含的特征：${mustNotHave}\n`;
            }
            if (wordCount) {
                mainPrompt += `每个角色人设字数：约${wordCount}字\n`;
            }
            
            if (template) {
                mainPrompt += `\n请严格按照以下JSON模板格式生成角色：\n${template}\n\n`;
            } else {
                mainPrompt += `\n请按照以下默认格式生成角色（JSON格式）：\n`;
                mainPrompt += `{\n  "name": "角色名字",\n  "age": "年龄",\n  "gender": "性别",\n  "personality": "性格特点",\n  "appearance": "外貌描述",\n  "background": "背景故事",\n  "hobbies": "兴趣爱好",\n  "speaking_style": "说话风格"\n}\n\n`;
            }
            
            mainPrompt += `请生成${count}个不同的角色，以JSON数组格式返回。确保每个角色都独特且符合要求。`;
            
            // 组合提示词
            const finalPrompt = promptParts.before + mainPrompt + promptParts.middle + promptParts.after;
            
            // 调用API
            const messages = [
                { role: 'system', content: '你是一个专业的角色设计师，擅长创造生动、有趣、符合要求的角色人设。' },
                { role: 'user', content: finalPrompt }
            ];
            
            const isGemini = apiUrl.includes('generativelanguage.googleapis.com');
            let response;
            
            if (isGemini) {
                const geminiBody = {
                    contents: messages.map(msg => ({
                        role: msg.role === 'assistant' ? 'model' : 'user',
                        parts: [{ text: msg.content }]
                    }))
                };
                response = await fetch(`${apiUrl}/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(geminiBody)
                });
            } else {
                response = await fetch(`${apiUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: messages,
                        temperature: 0.9
                    })
                });
            }
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API请求失败: ${response.status} - ${JSON.stringify(errorData)}`);
            }
            
            const data = await response.json();
            let responseText;
            
            if (isGemini) {
                responseText = data.candidates?.[0]?.content?.parts?.[0]?.text;
            } else {
                responseText = data.choices?.[0]?.message?.content;
            }
            
            if (!responseText) {
                throw new Error('API响应为空');
            }
            
            // 解析JSON
            const jsonMatch = responseText.match(/\[[\s\S]*\]/);
            if (!jsonMatch) {
                throw new Error('无法从响应中提取JSON数据');
            }
            
            const characters = JSON.parse(jsonMatch[0]);
            return { characters, rawResponse: responseText };
        }

        // --- Chat List & Chat Room ---
        function setupChatListScreen() {
            renderChatList();
            addChatBtn.addEventListener('click', async () => {
                const choice = await showChoiceModal('选择角色创建方式', [
                    { text: '创建新角色', value: 'new' },
                    { text: '导入酒馆角色卡', value: 'import' },
                    { text: 'AI生成角色', value: 'ai-generate' },
                    { text: '导入小手机角色卡', value: 'import-phone' }
                ]);
                if (choice === 'new') {
                    addCharModal.classList.add('visible');
                    addCharForm.reset();
                } else if (choice === 'import') {
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = '.json, .png';
                    fileInput.addEventListener('change', handleCardImport);
                    fileInput.click();
                } else if (choice === 'ai-generate') {
                    document.getElementById('ai-generate-char-modal').classList.add('visible');
                } else if (choice === 'import-phone') {
                    document.getElementById('import-phone-character-modal').classList.add('visible');
                }
            });
            chatListContainer.addEventListener('click', async (e) => {
                const chatItem = e.target.closest('.chat-item');
                if (chatItem) {
                    currentChatId = chatItem.dataset.id;
                    currentChatType = chatItem.dataset.type;
                    
                    // 【全新】检查是否是好友申请状态
                    if (currentChatType === 'private') {
                        const character = db.characters.find(c => c.id === currentChatId);
                        if (character && character.relationship?.status === 'pending_user_approval') {
                            // 显示好友申请确认对话框
                            const confirmed = confirm(`"${character.remarkName}"请求添加你为好友：\n\n"${character.relationship.applicationReason}"\n\n是否接受？`);
                            
                            if (confirmed) {
                                // 接受好友申请
                                character.relationship.status = 'friend';
                                character.relationship.applicationReason = '';
                                
                                // 添加隐藏的系统消息
                                const hiddenMessage = {
                                    id: `msg_${Date.now()}`,
                                    role: 'system',
                                    content: `[系统提示：用户刚刚通过了你的好友申请。你们现在又可以正常聊天了。]`,
                                    parts: [{type: 'text', text: `[系统提示：用户刚刚通过了你的好友申请。你们现在又可以正常聊天了。]`}],
                                    timestamp: Date.now(),
                                    isHidden: true
                                };
                                character.history.push(hiddenMessage);
                                
                                await saveData();
                                renderChatList();
                                showToast(`已接受"${character.remarkName}"的好友申请`);
                                
                                // 打开聊天界面
                                openChatRoom(currentChatId, currentChatType);
                            } else {
                                // 拒绝好友申请
                                character.relationship.status = 'blocked_by_ai';
                                character.relationship.applicationReason = '';
                                
                                await saveData();
                                renderChatList();
                                showToast(`已拒绝"${character.remarkName}"的好友申请`);
                            }
                            return;
                        }
                    }
                    
                    openChatRoom(currentChatId, currentChatType);
                }
            });
            chatListContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const chatItem = e.target.closest('.chat-item');
                if (!chatItem) return;
                handleChatListLongPress(chatItem.dataset.id, chatItem.dataset.type, e.clientX, e.clientY);
            });
            chatListContainer.addEventListener('touchstart', (e) => {
                const chatItem = e.target.closest('.chat-item');
                if (!chatItem) return;
                longPressTimer = setTimeout(() => {
                    const touch = e.touches[0];
                    handleChatListLongPress(chatItem.dataset.id, chatItem.dataset.type, touch.clientX, touch.clientY);
                }, 400);
            });
            chatListContainer.addEventListener('touchend', () => clearTimeout(longPressTimer));
            chatListContainer.addEventListener('touchmove', () => clearTimeout(longPressTimer));
        }

        function handleChatListLongPress(chatId, chatType, x, y) {
            clearTimeout(longPressTimer);
            const chatItem = (chatType === 'private') ? db.characters.find(c => c.id === chatId) : db.groups.find(g => g.id === chatId);
            if (!chatItem) return;
            const itemName = chatType === 'private' ? chatItem.remarkName : chatItem.name;
            const menuItems = [{
                label: chatItem.isPinned ? '取消置顶' : '置顶聊天',
                action: async () => {
                    chatItem.isPinned = !chatItem.isPinned;
                    await saveData();
                    renderChatList();
                }
            }, {
                label: '删除聊天',
                danger: true,
                action: async () => {
                    if (confirm(`确定要删除与"${itemName}"的聊天记录吗？此操作不可恢复。`)) {
                        // 检查是否有绑定的世界书
                        let linkedWorldBooks = [];
                        if (chatItem.worldBookIds && chatItem.worldBookIds.length > 0) {
                            linkedWorldBooks = chatItem.worldBookIds
                                .map(wbId => db.worldBooks.find(wb => wb.id === wbId))
                                .filter(wb => wb); // 过滤掉不存在的世界书
                        }

                        // 如果有绑定的世界书，询问是否删除
                        let worldBooksToDelete = [];
                        if (linkedWorldBooks.length > 0) {
                            const selectedIndices = await showWorldBookDeletionModal(linkedWorldBooks, itemName);
                            worldBooksToDelete = selectedIndices.map(index => linkedWorldBooks[index].id);
                        }

                        // 删除角色/群组
                        if (chatType === 'private') {
                            db.characters = db.characters.filter(c => c.id !== chatId);
                        } else {
                            db.groups = db.groups.filter(g => g.id !== chatId);
                        }

                        // 删除选中的世界书
                        if (worldBooksToDelete.length > 0) {
                            db.worldBooks = db.worldBooks.filter(wb => !worldBooksToDelete.includes(wb.id));
                            showToast(`聊天已删除，同时删除了 ${worldBooksToDelete.length} 个世界书`);
                        } else {
                            showToast('聊天已删除');
                        }

                        await saveData();
                        renderChatList();
                    }
                }
            }, {
                label: '永久删除角色',
                danger: true,
                action: async () => {
                    if (confirm(`确定要永久删除"${itemName}"吗？此操作不可恢复，刷新后也不会再出现。`)) {
                        // 检查是否有绑定的世界书
                        let linkedWorldBooks = [];
                        if (chatItem.worldBookIds && chatItem.worldBookIds.length > 0) {
                            linkedWorldBooks = chatItem.worldBookIds
                                .map(wbId => db.worldBooks.find(wb => wb.id === wbId))
                                .filter(wb => wb);
                        }

                        // 如果有绑定的世界书，询问是否删除
                        let worldBooksToDelete = [];
                        if (linkedWorldBooks.length > 0) {
                            const selectedIndices = await showWorldBookDeletionModal(linkedWorldBooks, itemName);
                            worldBooksToDelete = selectedIndices.map(index => linkedWorldBooks[index].id);
                        }

                        // 永久删除角色/群组
                        if (chatType === 'private') {
                            // 添加到删除列表
                            if (!db.deletedCharacterIds.includes(chatId)) {
                                db.deletedCharacterIds.push(chatId);
                            }
                            // 从当前列表中移除
                            db.characters = db.characters.filter(c => c.id !== chatId);
                        } else {
                            // 添加到删除列表
                            if (!db.deletedGroupIds.includes(chatId)) {
                                db.deletedGroupIds.push(chatId);
                            }
                            // 从当前列表中移除
                            db.groups = db.groups.filter(g => g.id !== chatId);
                        }

                        // 删除选中的世界书
                        if (worldBooksToDelete.length > 0) {
                            db.worldBooks = db.worldBooks.filter(wb => !worldBooksToDelete.includes(wb.id));
                            showToast(`已永久删除，同时删除了 ${worldBooksToDelete.length} 个世界书`);
                        } else {
                            showToast('已永久删除');
                        }

                        await saveData();
                        renderChatList();
                    }
                }
            }];
            createContextMenu(menuItems, x, y);
        }

        function renderChatList() {
            // 【性能优化】使用 requestAnimationFrame 批量更新DOM
            requestAnimationFrame(() => {
                chatListContainer.innerHTML = '';
                // 过滤掉NPC角色，只显示普通角色和群聊
                const normalCharacters = db.characters.filter(c => !c.isNPC);
                const allChats = [...normalCharacters.map(c => ({...c, type: 'private'})), ...db.groups.map(g => ({...g, type: 'group'}))];
                noChatsPlaceholder.style.display = (normalCharacters.length + db.groups.length) === 0 ? 'block' : 'none';
                const sortedChats = allChats.sort((a, b) => {
                    if (a.isPinned !== b.isPinned) return a.isPinned ? -1 : 1;
                    const lastMsgTimeA = a.history && a.history.length > 0 ? a.history[a.history.length - 1].timestamp : 0;
                    const lastMsgTimeB = b.history && b.history.length > 0 ? b.history[b.history.length - 1].timestamp : 0;
                    return lastMsgTimeB - lastMsgTimeA;
                });
                
                // 【性能优化】使用 DocumentFragment 批量插入DOM
                const fragment = document.createDocumentFragment();
                
                sortedChats.forEach(chat => {
                    let lastMessageText = '开始聊天吧...';
                    
                    // 【全新】检查拉黑状态并显示相应的提示
                    if (chat.type === 'private' && chat.relationship) {
                        if (chat.relationship.status === 'blocked_by_user') {
                            lastMessageText = '<span style="color: #ff3b30;">[你已拉黑对方]</span>';
                        } else if (chat.relationship.status === 'blocked_by_ai') {
                            lastMessageText = '<span style="color: #dc3545;">[你已被对方拉黑]</span>';
                        } else if (chat.relationship.status === 'pending_user_approval') {
                            lastMessageText = '<span style="color: #007bff;">[好友申请]</span>';
                        } else if (chat.relationship.status === 'pending_ai_approval') {
                            lastMessageText = '<span style="color: #6c757d;">[等待对方通过]</span>';
                        }
                    }
                    
                    // 如果不是拉黑状态，显示正常的最后消息
                    if (chat.history && chat.history.length > 0 && (!chat.relationship || chat.relationship.status === 'friend')) {
                        const invisibleRegex = /\[.*?(?:接收|退回).*?的转账\]|\[.*?更新状态为：.*?\]|\[.*?已接收礼物\]|\[.*?切歌[:：].*?\]|\[.*?换头像[:：].*?\]|\[system:.*?\]|\[系统提示：.*?\]|\[.*?邀请.*?加入了群聊\]|\[.*?修改群名为：.*?\]|\[system-display:.*?\]/;
                        const visibleHistory = chat.history.filter(msg => !invisibleRegex.test(msg.content));
                        if (visibleHistory.length > 0) {
                            const lastMsg = visibleHistory[visibleHistory.length - 1];
                            
                            // 检查是否有人@了USER（仅群聊）
                            let hasMentionedUser = false;
                            if (chat.type === 'group' && lastMsg.mentions && lastMsg.senderId !== 'user_me') {
                                // 检查是否@了全员或@了USER
                                if (lastMsg.mentionedAll) {
                                    hasMentionedUser = true;
                                }
                            }
                            
                            // 如果被@了，显示特殊提示
                            if (hasMentionedUser) {
                                lastMessageText = '<span style="color: #ff3b30; font-weight: 600;">[有人艾特你]</span>';
                            } else {
                            const urlRegex = /^(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg)|data:image\/[a-z]+;base64,)/i;
                            const imageRecogRegex = /\[.*?发来了一张图片：\]/
                            const voiceRegex = /\[.*?的语音：.*?\]/;
                            const photoVideoRegex = /\[.*?发来的照片\/视频：.*?\]/;
                            const transferRegex = /\[.*?的转账：.*?元.*?\]|\[.*?给你转账：.*?元.*?\]|\[.*?向.*?转账：.*?元.*?\]|\[你收取了.*?的转账：.*?元.*?\]|\[你退回了.*?的转账：.*?元.*?\]/;
                            const stickerRegex = /\[.*?的表情包：.*?\]|\[.*?发送的表情包：.*?\]/;
                            const giftRegex = /\[.*?送来的礼物：.*?\]|\[.*?向.*?送来了礼物：.*?\]/;



                            if (giftRegex.test(lastMsg.content)) {
                                lastMessageText = '[礼物]';
                            } else if (stickerRegex.test(lastMsg.content)) {
                                lastMessageText = '[表情包]';
                            } else if (voiceRegex.test(lastMsg.content)) {
                                lastMessageText = '[语音]';
                            } else if (photoVideoRegex.test(lastMsg.content)) {
                                lastMessageText = '[照片/视频]';
                            } else if (transferRegex.test(lastMsg.content)) {
                                lastMessageText = '[转账]';
                            } else if (imageRecogRegex.test(lastMsg.content) || (lastMsg.parts && lastMsg.parts.some(p => p.type === 'image'))) {
                                lastMessageText = '[图片]';
                            }else if ((lastMsg.parts && lastMsg.parts.some(p => p.type === 'html'))) {
                                lastMessageText = '[互动]';
                            } else {
                                const textMatch = lastMsg.content.match(/\[.*?的消息：([\s\S]+)\]/);
                                let text = textMatch ? textMatch[1].trim() : lastMsg.content.trim();
                                // 如果是文本消息，应用Markdown格式化（但移除HTML标签用于预览）
                                if (!urlRegex.test(text)) {
                                    text = formatMarkdown(text);
                                    // 移除HTML标签，只保留纯文本用于预览
                                    text = text.replace(/<[^>]+>/g, '');
                                }
                                lastMessageText = urlRegex.test(text) ? '[图片]' : text;
                            }
                            }
                        } else {
                            const lastEverMsg = chat.history[chat.history.length - 1];
                            const inviteRegex = /\[(.*?)邀请(.*?)加入了群聊\]/;
                            const renameRegex = /\[.*?修改群名为：.*?\]/;
                            const timeSkipRegex = /\[system-display:([\s\S]+?)\]/;
                            const timeSkipMatch = lastEverMsg.content.match(timeSkipRegex);

                            if (timeSkipMatch) {
                                lastMessageText = timeSkipMatch[1];
                            } else if (inviteRegex.test(lastEverMsg.content)) {
                                lastMessageText = '新成员加入了群聊';
                            } else if (renameRegex.test(lastEverMsg.content)) {
                                lastMessageText = '群聊名称已修改';
                            }
                        }
                    }
                    const li = document.createElement('li');
                    li.className = 'list-item chat-item';
                    if (chat.isPinned) li.classList.add('pinned');
                    li.dataset.id = chat.id;
                    li.dataset.type = chat.type;
                    const avatarClass = chat.type === 'group' ? 'group-avatar' : '';
                    const itemName = chat.type === 'private' ? chat.remarkName : chat.name;
                    const pinBadgeHTML = chat.isPinned ? '<span class="pin-badge">置顶</span>' : '';
                    li.innerHTML = `
                    <img src="${chat.avatar}" alt="${itemName}" class="chat-avatar ${avatarClass}">
                    <div class="item-details">
                        <div class="item-details-row"><div class="item-name">${itemName}</div></div>
                        <div class="item-preview-wrapper"><div class="item-preview">${lastMessageText}</div>${pinBadgeHTML}</div>
                    </div>
                    <div class="unread-count-wrapper">
                        <span class="unread-count" style="display: none;">0</span>
                    </div>`;
                    
                    // 控制未读消息小红点的显示
                    const unreadCount = chat.unreadCount || 0;
                    const unreadEl = li.querySelector('.unread-count');
                    if (unreadCount > 0) {
                        unreadEl.textContent = unreadCount > 99 ? '99+' : unreadCount;
                        unreadEl.style.display = 'inline-flex';
                    } else {
                        unreadEl.style.display = 'none';
                    }
                    
                    fragment.appendChild(li);
                });
                
                // 【性能优化】一次性插入所有元素
                chatListContainer.appendChild(fragment);
                
                // 应用头像形状到聊天列表
                sortedChats.forEach(chat => {
                    if (chat.type === 'private' && chat.avatarShapes && chat.avatarShapes.char) {
                        const chatItem = chatListContainer.querySelector(`[data-id="${chat.id}"]`);
                        if (chatItem) {
                            const avatar = chatItem.querySelector('.chat-avatar');
                            if (avatar) {
                                applyShapeToElement(avatar, chat.avatarShapes.char);
                            }
                        }
                    }
                });
            });
        }

        function setupAddCharModal() {
            addCharForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const newChar = {
                    id: `char_${Date.now()}`,
                    realName: document.getElementById('char-real-name').value,
                    remarkName: document.getElementById('char-remark-name').value,
                    persona: '',
                    avatar: 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg',
                    myName: document.getElementById('my-name-for-char').value,
                    myPersona: '',
                    myAvatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg',
                    theme: 'white_pink',
                    maxMemory: 10,
                    chatBg: '',
                    history: [],
                    isPinned: false,
                    status: '在线',
                    worldBookIds: getGlobalWorldBookIds(),
                    useCustomBubbleCss: false,
                    customBubbleCss: '',
                    musicData: { totalTime: 0 },
                    avatarLibrary: [],
                    unreadCount: 0
                };
                db.characters.push(newChar);
                await saveData();
                renderChatList();
                addCharModal.classList.remove('visible');
                showToast(`角色“${newChar.remarkName}”创建成功！`);
            });
        }

        function setupChatRoom() {
            sendMessageBtn.addEventListener('click', sendMessage);
            sendMessageBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                sendMessage();
                setTimeout(() => {
                    messageInput.focus();
                }, 50);
            });
            messageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !isGenerating) sendMessage();
            });
            
            // @功能实现
            setupMentionFeature();
            getReplyBtn.addEventListener('click', getAiReply);
            
            // 取消引用回复
            document.getElementById('cancel-reply-btn').addEventListener('click', cancelReplyMode);
            
            messageArea.addEventListener('click', (e) => {
                // --- 修复开始: 增加关闭表情包面板的逻辑 ---
                if (stickerModal.classList.contains('visible')) {
                    stickerModal.classList.remove('visible');
                    // 阻止事件继续传播，避免立即触发其他点击效果
                    return;
                }
                // --- 修复结束 ---
                
                // 处理图片点击查看大图
                if (e.target.tagName === 'IMG' && e.target.closest('.image-bubble') && !e.target.closest('.pv-card')) {
                    e.stopPropagation();
                    const imageViewer = document.getElementById('image-viewer');
                    const imageViewerImg = document.getElementById('image-viewer-img');
                    imageViewerImg.src = e.target.src;
                    imageViewer.style.display = 'flex';
                    return;
                }

                if (e.target && e.target.id === 'load-more-btn') {
                    loadMoreMessages();
                } else if (isInMultiSelectMode) {
                    const messageWrapper = e.target.closest('.message-wrapper');
                    if (messageWrapper) {
                        toggleMessageSelection(messageWrapper.dataset.id);
                    }
                } else if (isInForwardMode) {
                    const messageWrapper = e.target.closest('.message-wrapper');
                    if (messageWrapper) {
                        toggleForwardMessageSelection(messageWrapper.dataset.id);
                    }
                } else {
                    const voiceBubble = e.target.closest('.voice-bubble');
                    if (voiceBubble) {
                        // 使用新的语音处理函数
                        handleVoiceBubbleClick(voiceBubble);
                    }
                    const pvCard = e.target.closest('.pv-card');
                    if (pvCard) {
                        const imageOverlay = pvCard.querySelector('.pv-card-image-overlay');
                        const footer = pvCard.querySelector('.pv-card-footer');
                        imageOverlay.classList.toggle('hidden');
                        footer.classList.toggle('hidden');
                    }
                    const giftCard = e.target.closest('.gift-card');
                    if (giftCard) {
                        const description = giftCard.closest('.message-wrapper').querySelector('.gift-card-description');
                        if (description) {
                            description.classList.toggle('active');
                        }
                    }
                    const transferCard = e.target.closest('.transfer-card.received-transfer');
                    if (transferCard && currentChatType === 'private') {
                        const messageWrapper = transferCard.closest('.message-wrapper');
                        const messageId = messageWrapper.dataset.id;
                        const character = db.characters.find(c => c.id === currentChatId);
                        const message = character.history.find(m => m.id === messageId);
                        if (message) {
                            handleReceivedTransferClick(messageId, message.transferStatus);
                        }
                    }
                    
                    // 处理引用块点击，跳转到被引用的消息
                    const quotedMessage = e.target.closest('.quoted-message');
                    if (quotedMessage) {
                        const quoteId = quotedMessage.dataset.quoteId;
                        if (quoteId) {
                            const targetWrapper = messageArea.querySelector(`.message-wrapper[data-id="${quoteId}"]`);
                            if (targetWrapper) {
                                // 滚动到目标消息
                                targetWrapper.scrollIntoView({behavior: 'smooth', block: 'center'});
                                // 添加高亮效果
                                targetWrapper.style.backgroundColor = 'rgba(255, 200, 0, 0.3)';
                                setTimeout(() => {
                                    targetWrapper.style.backgroundColor = '';
                                }, 1500);
                            }
                        }
                    }

                    // 处理撤回消息点击，查看原文
                    const recalledPlaceholder = e.target.closest('.recalled-message-placeholder');
                    if (recalledPlaceholder) {
                        const messageId = recalledPlaceholder.dataset.id;
                        const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
                        const message = chat.history.find(m => m.id === messageId);
                        
                        if (message && message.recalledData) {
                            let originalText = message.recalledData.originalContent || '';
                            
                            // 处理不同类型的原始内容
                            if (message.recalledData.originalType === 'sticker' && message.recalledData.originalStickerData) {
                                originalText = `[表情包：${message.recalledData.originalStickerData.name || '未命名'}]`;
                            } else if (/\[(.*?)的语音：(.*?)\]/.test(originalText)) {
                                const match = originalText.match(/\[(.*?)的语音：(.*?)\]/);
                                originalText = `语音消息：${match[2]}`;
                            } else if (/\[(.*?)的表情包：(.*?)\]/.test(originalText)) {
                                const match = originalText.match(/\[(.*?)的表情包：(.*?)\]/);
                                originalText = `表情包：${match[2]}`;
                            } else {
                                // 去除格式前缀
                                const contentMatch = originalText.match(/\[.*?的消息：([\s\S]+)\]/);
                                if (contentMatch) {
                                    originalText = contentMatch[1].trim();
                                }
                            }
                            
                            alert(`原始消息内容：\n\n${originalText}`);
                        }
                    }
                }
            });
            messageArea.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (e.target.id === 'load-more-btn' || isInMultiSelectMode) return;
                const messageWrapper = e.target.closest('.message-wrapper');
                if (!messageWrapper) return;
                handleMessageLongPress(messageWrapper, e.clientX, e.clientY);
            });
            messageArea.addEventListener('touchstart', (e) => {
                if (e.target.id === 'load-more-btn') return;
                const messageWrapper = e.target.closest('.message-wrapper');
                if (!messageWrapper) return;
                longPressTimer = setTimeout(() => {
                    const touch = e.touches[0];
                    handleMessageLongPress(messageWrapper, touch.clientX, touch.clientY);
                }, 400);
            });
            messageArea.addEventListener('touchend', () => clearTimeout(longPressTimer));
            messageArea.addEventListener('touchmove', () => clearTimeout(longPressTimer));
            // 编辑消息弹窗事件监听器
            const editMessageForm = document.getElementById('edit-message-form');
            const cancelEditMessageBtn = document.getElementById('cancel-edit-message-btn');
            
            editMessageForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                await saveMessageEdit();
            });
            
            cancelEditMessageBtn.addEventListener('click', cancelMessageEdit);
            
            // 点击弹窗外部关闭
            const editMessageModal = document.getElementById('edit-message-modal');
            editMessageModal.addEventListener('click', (e) => {
                if (e.target === editMessageModal) {
                    cancelMessageEdit();
                }
            });
            
            // 插入新消息功能
            let insertPosition = null; // 'above' 或 'below'
            const insertMessageArea = document.getElementById('insert-message-area');
            const insertMessageAboveBtn = document.getElementById('insert-message-above-btn');
            const insertMessageBelowBtn = document.getElementById('insert-message-below-btn');
            const insertMessageRole = document.getElementById('insert-message-role');
            const insertMessageTextarea = document.getElementById('insert-message-textarea');
            const confirmInsertMessageBtn = document.getElementById('confirm-insert-message-btn');
            const cancelInsertMessageBtn = document.getElementById('cancel-insert-message-btn');
            
            insertMessageAboveBtn.addEventListener('click', () => {
                insertPosition = 'above';
                insertMessageArea.style.display = 'block';
                insertMessageTextarea.value = '';
                
                // 自动滚动到插入区域
                setTimeout(() => {
                    const scrollContainer = editMessageModal.querySelector('.modal-window > div:first-of-type');
                    if (scrollContainer) {
                        scrollContainer.scrollTo({
                            top: scrollContainer.scrollHeight,
                            behavior: 'smooth'
                        });
                    }
                    insertMessageTextarea.focus();
                }, 100);
            });
            
            insertMessageBelowBtn.addEventListener('click', () => {
                insertPosition = 'below';
                insertMessageArea.style.display = 'block';
                insertMessageTextarea.value = '';
                
                // 自动滚动到插入区域
                setTimeout(() => {
                    const scrollContainer = editMessageModal.querySelector('.modal-window > div:first-of-type');
                    if (scrollContainer) {
                        scrollContainer.scrollTo({
                            top: scrollContainer.scrollHeight,
                            behavior: 'smooth'
                        });
                    }
                    insertMessageTextarea.focus();
                }, 100);
            });
            
            cancelInsertMessageBtn.addEventListener('click', () => {
                insertMessageArea.style.display = 'none';
                insertPosition = null;
                insertMessageTextarea.value = '';
            });
            
            confirmInsertMessageBtn.addEventListener('click', async () => {
                const newMessageContent = insertMessageTextarea.value.trim();
                if (!newMessageContent) {
                    showToast('请输入消息内容');
                    return;
                }
                
                const role = insertMessageRole.value;
                await insertNewMessage(editingMessageId, insertPosition, role, newMessageContent);
                
                // 重置插入区域
                insertMessageArea.style.display = 'none';
                insertPosition = null;
                insertMessageTextarea.value = '';
                
                showToast('消息已插入');
            });
            
            cancelMultiSelectBtn.addEventListener('click', exitMultiSelectMode);
            deleteSelectedBtn.addEventListener('click', deleteSelectedMessages);
            
            // 转发功能事件绑定
            document.getElementById('forward-confirm-btn').addEventListener('click', showForwardTargetSelection);
            document.getElementById('forward-cancel-btn').addEventListener('click', exitForwardMode);
            document.getElementById('confirm-forward-btn').addEventListener('click', confirmForwardMessages);
            document.getElementById('cancel-forward-btn').addEventListener('click', () => {
                document.getElementById('forward-modal').classList.remove('visible');
            });
            
            // 初始化状态编辑功能
            setupStatusEditing();
            
            // ▼▼▼ 【群投票功能】事件监听器 ▼▼▼
            // 发起投票按钮
            const sendPollBtn = document.getElementById('send-poll-btn');
            if (sendPollBtn) {
                sendPollBtn.addEventListener('click', openCreatePollModal);
            }
            
            // ▼▼▼ 【聊天拓展栏滑动功能】PC端键盘左右箭头滑动 ▼▼▼
            const stickerBar = document.getElementById('sticker-bar');
            let stickerBarFocused = false;
            
            // 当鼠标进入sticker-bar时标记为聚焦
            stickerBar.addEventListener('mouseenter', () => {
                stickerBarFocused = true;
            });
            
            // 当鼠标离开sticker-bar时取消聚焦
            stickerBar.addEventListener('mouseleave', () => {
                stickerBarFocused = false;
            });
            
            // 监听键盘事件
            document.addEventListener('keydown', (e) => {
                // 只在聊天室屏幕且sticker-bar聚焦时响应
                if (!document.getElementById('chat-room-screen').classList.contains('active')) return;
                if (!stickerBarFocused) return;
                
                const scrollAmount = 150; // 每次滚动的距离
                
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    stickerBar.scrollLeft -= scrollAmount;
                } else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    stickerBar.scrollLeft += scrollAmount;
                }
            });
            // ▲▲▲ 【聊天拓展栏滑动功能】结束 ▲▲▲
            
            // 投票创建模态框的按钮
            document.getElementById('add-poll-option-btn').addEventListener('click', addPollOptionInput);
            document.getElementById('cancel-create-poll-btn').addEventListener('click', () => {
                document.getElementById('create-poll-modal').classList.remove('visible');
            });
            document.getElementById('create-poll-form').addEventListener('submit', (e) => {
                e.preventDefault();
                sendPoll();
            });
            
            // 使用事件委托处理投票卡片内的所有点击事件
            messageArea.addEventListener('click', (e) => {
                const pollCard = e.target.closest('.poll-card');
                if (!pollCard) return;

                const timestamp = parseInt(pollCard.dataset.pollTimestamp);
                if (isNaN(timestamp)) return;
                
                // 点击了选项
                const optionItem = e.target.closest('.poll-option-item');
                if (optionItem && !pollCard.classList.contains('closed')) {
                    handleUserVote(timestamp, optionItem.dataset.option);
                    return;
                }
                
                // 点击了动作按钮（结束投票/查看结果）
                const actionBtn = e.target.closest('.poll-action-btn');
                if (actionBtn) {
                    if (pollCard.classList.contains('closed')) {
                        showPollResults(timestamp);
                    } else {
                        endPoll(timestamp);
                    }
                    return;
                }

                // 如果是已结束的投票，点击卡片任何地方都可以查看结果
                if (pollCard.classList.contains('closed')) {
                    showPollResults(timestamp);
                }
            });
            // ▲▲▲ 【群投票功能】事件监听器结束 ▲▲▲
        }

        function handleMessageLongPress(messageWrapper, x, y) {
            if (isInMultiSelectMode) return;
            clearTimeout(longPressTimer);
            const messageId = messageWrapper.dataset.id;
            activeMessageId = messageId; // 设置当前操作的消息ID
            
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const message = chat.history.find(m => m.id === messageId);
            if (!message) return;

            const isImageRecognitionMsg = message.parts && message.parts.some(p => p.type === 'image');
            const isVoiceMessage = /\[.*?的语音：.*?\]/.test(message.content);
            const isStickerMessage = /\[.*?的表情包：.*?\]|\[.*?发送的表情包：.*?\]/.test(message.content);
            const isPhotoVideoMessage = /\[.*?发来的照片\/视频：.*?\]/.test(message.content);
            const isTransferMessage = /\[.*?给你转账：.*?\]|\[.*?的转账：.*?\]|\[.*?向.*?转账：.*?\]|\[你收取了.*?的转账：.*?\]|\[你退回了.*?的转账：.*?\]/.test(message.content);
            const isGiftMessage = /\[.*?送来的礼物：.*?\]|\[.*?向.*?送来了礼物：.*?\]/.test(message.content);
            const isInvisibleMessage = /\[.*?(?:接收|退回).*?的转账\]|\[.*?更新状态为：.*?\]|\[.*?已接收礼物\]|\[.*?切歌[:：].*?\]|\[.*?换头像[:：].*?\]|\[system:.*?\]|\[.*?邀请.*?加入了群聊\]|\[.*?修改群名为：.*?\]|\[system-display:.*?\]/.test(message.content);

            let menuItems = [];
            // 所有类型的消息都可以编辑
            menuItems.push({label: '编辑', action: () => startMessageEdit(messageId)});
            
            // 添加单句重说选项（仅AI消息）
            if (!isInvisibleMessage && message.type !== 'recalled_message' && (message.role === 'assistant' || message.role === 'char')) {
                menuItems.push({label: '单句重说', action: () => regenerateSingleMessage(messageId)});
            }
            
            // 添加引用选项（所有消息都可以引用）
            if (!isInvisibleMessage && message.type !== 'recalled_message') {
                menuItems.push({label: '引用', action: () => startReplyToMessage()});
            }
            
            // 添加复制文本选项
            if (!isInvisibleMessage && message.type !== 'recalled_message') {
                menuItems.push({label: '复制文本', action: () => copyMessageText(messageId)});
            }
            
            // 添加转发选项
            if (!isInvisibleMessage && message.type !== 'recalled_message') {
                menuItems.push({label: '转发', action: () => startForwardMode(messageId)});
            }
            
            // 添加撤回选项（用户和AI的消息都可以撤回）
            if (message.type !== 'recalled_message' && !isInvisibleMessage) {
                const isUserMessage = message.role === 'user';
                menuItems.push({label: '撤回', action: async () => {
                    // 检查时间限制
                    const timeDiff = message.timestamp ? (Date.now() - message.timestamp) : 0;
                    const twoMinutes = 2 * 60 * 1000;
                    
                    if (message.timestamp && timeDiff > twoMinutes) {
                        alert('该消息已超过2分钟，无法撤回');
                        return;
                    }
                    
                    // 确定撤回确认文本
                    let confirmText;
                    if (isUserMessage) {
                        confirmText = '确定要撤回这条消息吗？';
                    } else {
                        // 获取AI的名字
                        let aiName;
                        if (currentChatType === 'private') {
                            aiName = chat.remarkName || chat.realName;
                        } else {
                            // 群聊中根据senderId获取成员名字
                            const sender = chat.members.find(m => m.id === message.senderId);
                            aiName = sender ? sender.realName : '对方';
                        }
                        confirmText = `确定要让${aiName}撤回这条消息吗？`;
                    }
                    
                    if (confirm(confirmText)) {
                        await recallMessage(messageId, isUserMessage);
                    }
                }});
            }
            
            menuItems.push({label: '删除', action: () => enterMultiSelectMode(messageId)});

            if (menuItems.length > 0) {
                createContextMenu(menuItems, x, y);
            }
        }

        function startMessageEdit(messageId) {
            exitMultiSelectMode();
            editingMessageId = messageId;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const message = chat.history.find(m => m.id === messageId);
            if (!message) return;
            const match = message.content.match(/\[.*?的消息：([\s\S]+)\]/);
            const contentToEdit = match ? match[1].trim() : message.content;
            
            // 使用弹窗而不是底部编辑栏
            const editMessageModal = document.getElementById('edit-message-modal');
            const editMessageTextarea = document.getElementById('edit-message-textarea');
            editMessageTextarea.value = contentToEdit;
            editMessageModal.classList.add('visible');
            
            // 重置滚动位置到顶部
            setTimeout(() => {
                const scrollContainer = editMessageModal.querySelector('.modal-window > div:first-of-type');
                if (scrollContainer) {
                    scrollContainer.scrollTop = 0;
                }
                editMessageTextarea.focus();
                editMessageTextarea.select();
            }, 100);
        }

        async function saveMessageEdit() {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const messageIndex = chat.history.findIndex(m => m.id === editingMessageId);
            if (messageIndex === -1) return;
            
            // 从弹窗获取新文本
            const editMessageTextarea = document.getElementById('edit-message-textarea');
            const newText = editMessageTextarea.value.trim();
            
            if (newText) {
                const oldContent = chat.history[messageIndex].content;
                const prefixMatch = oldContent.match(/(\[.*?的消息：)[\s\S]+\]/);
                const prefix = prefixMatch ? prefixMatch[1] : '';
                const newContent = `${prefix}${newText}]`;
                chat.history[messageIndex].content = newContent;
                if (chat.history[messageIndex].parts) {
                    chat.history[messageIndex].parts = [{type: 'text', text: newContent}];
                }
                await saveData();
                currentPage = 1;
                renderMessages(false, true);
                renderChatList();
            }
            cancelMessageEdit();
        }

        function cancelMessageEdit() {
            editingMessageId = null;
            const editMessageModal = document.getElementById('edit-message-modal');
            editMessageModal.classList.remove('visible');
            // 重置插入消息区域
            const insertMessageArea = document.getElementById('insert-message-area');
            if (insertMessageArea) {
                insertMessageArea.style.display = 'none';
            }
        }
        
        // 插入新消息函数
        async function insertNewMessage(referenceMessageId, position, role, content) {
            const chat = (currentChatType === 'private') 
                ? db.characters.find(c => c.id === currentChatId) 
                : db.groups.find(g => g.id === currentChatId);
            
            if (!chat) return;
            
            const referenceIndex = chat.history.findIndex(m => m.id === referenceMessageId);
            if (referenceIndex === -1) return;
            
            // 构建新消息
            let newMessageContent = content;
            
            // 根据角色和聊天类型格式化消息内容
            if (currentChatType === 'private') {
                const character = chat;
                if (role === 'assistant') {
                    // AI消息格式
                    if (!content.startsWith('[')) {
                        newMessageContent = `[${character.realName}的消息：${content}]`;
                    }
                } else {
                    // 用户消息格式
                    if (!content.startsWith('[')) {
                        newMessageContent = `[${character.myName}的消息：${content}]`;
                    }
                }
            } else {
                // 群聊消息
                const group = chat;
                if (role === 'user') {
                    // 用户消息
                    if (!content.startsWith('[')) {
                        newMessageContent = `[${group.myName}的消息：${content}]`;
                    }
                }
                // 群聊AI消息保持原样，因为可能包含多个成员的消息
            }
            
            const newMessage = {
                id: `msg_${Date.now()}_inserted`,
                role: role,
                content: newMessageContent,
                parts: [{type: 'text', text: newMessageContent}],
                timestamp: Date.now(),
                isInserted: true // 标记为插入的消息
            };
            
            // 计算插入位置
            const insertIndex = position === 'above' ? referenceIndex : referenceIndex + 1;
            
            // 插入消息
            chat.history.splice(insertIndex, 0, newMessage);
            
            await saveData();
            currentPage = 1;
            renderMessages(false, true);
            renderChatList();
        }

        // 撤回消息函数
        async function recallMessage(messageId, isUserRecall) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat) return;

            const messageIndex = chat.history.findIndex(m => m.id === messageId);
            if (messageIndex === -1) return;

            const messageToRecall = chat.history[messageIndex];
            const isUserMessage = messageToRecall.role === 'user'; // 判断被撤回的消息是谁发送的

            // 保存原始消息数据
            const recalledData = {
                originalRole: messageToRecall.role, // 记录原始发送者
                originalType: messageToRecall.type || 'text',
                originalContent: messageToRecall.content,
                originalMeaning: messageToRecall.meaning,
                originalQuote: messageToRecall.quote,
                originalStickerData: messageToRecall.stickerData
            };

            // 修改消息为撤回状态
            messageToRecall.type = 'recalled_message';
            // 根据消息发送者显示不同文本
            let recalledText;
            if (isUserMessage) {
                recalledText = '你撤回了一条消息';
            } else {
                // 获取AI的名字
                if (currentChatType === 'private') {
                    recalledText = `${chat.remarkName || chat.realName}撤回了一条消息`;
                } else {
                    // 群聊中根据senderId获取成员名字
                    const sender = chat.members.find(m => m.id === messageToRecall.senderId);
                    const senderName = sender ? sender.realName : '对方';
                    recalledText = `${senderName}撤回了一条消息`;
                }
            }
            messageToRecall.content = recalledText;
            messageToRecall.recalledData = recalledData;
            
            // 清理不需要的属性
            delete messageToRecall.meaning;
            delete messageToRecall.quote;
            delete messageToRecall.stickerData;

            // 添加系统提示给AI，让AI知道发生了什么
            if (isUserMessage) {
                // 用户撤回了自己的消息
                const hiddenMessage = {
                    id: `msg_${Date.now()}`,
                    role: 'system',
                    content: `[系统提示：用户撤回了ta的一条消息。你不知道内容是什么。]`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(hiddenMessage);
            } else {
                // AI的消息被撤回（用户让AI撤回）
                const hiddenMessage = {
                    id: `msg_${Date.now()}`,
                    role: 'system',
                    content: `[系统提示：你撤回了你的一条消息。]`,
                    timestamp: Date.now(),
                    isHidden: true
                };
                chat.history.push(hiddenMessage);
            }

            // 保存到数据库
            await saveData();
            
            // 刷新聊天界面（保持当前滚动位置）
            renderMessages(false, false);
            renderChatList();
            
            showToast('消息已撤回');
        }

        // 复制消息文本函数
        function copyMessageText(messageId) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat) return;

            const message = chat.history.find(m => m.id === messageId);
            if (!message) return;

            let textToCopy = '';

            // 处理不同类型的消息
            if (message.type === 'recalled_message') {
                // 撤回的消息，复制原始内容
                if (message.recalledData && message.recalledData.originalContent) {
                    textToCopy = message.recalledData.originalContent;
                } else {
                    textToCopy = message.content;
                }
            } else {
                textToCopy = message.content;
            }

            // 去除消息格式前缀，提取纯文本
            // 匹配各种格式：[xxx的消息：内容]、[xxx的语音：内容]、[xxx发送的表情包：内容] 等
            const patterns = [
                /\[.*?的消息：([\s\S]+)\]/,
                /\[.*?的语音：([\s\S]+)\]/,
                /\[.*?发送的表情包：([\s\S]+)\]/,
                /\[.*?的表情包：([\s\S]+)\]/,
                /\[.*?发来的照片\/视频：([\s\S]+)\]/,
                /\[.*?送来的礼物：([\s\S]+)\]/,
                /\[.*?向.*?送来了礼物：([\s\S]+)\]/,
                /\[.*?给你转账：([\d.]+)元；备注：(.*?)\]/,
                /\[.*?的转账：([\d.]+)元；备注：(.*?)\]/,
                /\[.*?向.*?转账：([\d.]+)元；备注：(.*?)\]/,
                /\[你收取了(.*?)的转账：([\d.]+)元；备注：(.*?)\]/,
                /\[你退回了(.*?)的转账：([\d.]+)元；备注：(.*?)\]/
            ];

            for (const pattern of patterns) {
                const match = textToCopy.match(pattern);
                if (match) {
                    // 对于转账消息，组合金额和备注
                    if (match.length === 3) {
                        textToCopy = `转账 ${match[1]} 元，备注：${match[2]}`;
                    } else if (match.length === 4) {
                        // 处理"你收取了/退回了XXX的转账"格式
                        const action = textToCopy.includes('收取') ? '收取' : '退回';
                        textToCopy = `${action}了 ${match[1]} 的转账 ${match[2]} 元，备注：${match[3]}`;
                    } else {
                        textToCopy = match[1].trim();
                    }
                    break;
                }
            }

            // 复制到剪贴板
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(textToCopy).then(() => {
                    showToast('已复制到剪贴板');
                }).catch(err => {
                    console.error('复制失败:', err);
                    fallbackCopyText(textToCopy);
                });
            } else {
                fallbackCopyText(textToCopy);
            }
        }

        // 备用复制方法（兼容旧浏览器）
        function fallbackCopyText(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showToast('已复制到剪贴板');
                } else {
                    showToast('复制失败，请手动复制');
                }
            } catch (err) {
                console.error('复制失败:', err);
                showToast('复制失败，请手动复制');
            }
            document.body.removeChild(textArea);
        }

        // ===== 转发消息功能 =====
        let isInForwardMode = false;
        let forwardSelectedMessageIds = new Set();
        let forwardTargetChats = []; // 改为数组，支持多选

        function startForwardMode(initialMessageId) {
            isInForwardMode = true;
            forwardSelectedMessageIds.clear();
            if (initialMessageId) {
                forwardSelectedMessageIds.add(initialMessageId);
            }
            
            // 显示转发选择栏
            const forwardSelectBar = document.getElementById('forward-select-bar');
            forwardSelectBar.style.display = 'flex';
            
            // 更新选择计数
            updateForwardSelectCount();
            
            // 高亮已选择的消息（不自动滚动到底部）
            renderMessages(false, false);
            
            showToast('请选择要转发的消息，然后点击"转发"按钮');
        }

        function toggleForwardMessageSelection(messageId) {
            if (forwardSelectedMessageIds.has(messageId)) {
                forwardSelectedMessageIds.delete(messageId);
            } else {
                forwardSelectedMessageIds.add(messageId);
            }
            updateForwardSelectCount();
            
            // 更新消息的选中状态
            const messageWrapper = messageArea.querySelector(`.message-wrapper[data-id="${messageId}"]`);
            if (messageWrapper) {
                if (forwardSelectedMessageIds.has(messageId)) {
                    messageWrapper.classList.add('multi-select-selected');
                } else {
                    messageWrapper.classList.remove('multi-select-selected');
                }
            }
        }

        function updateForwardSelectCount() {
            const count = forwardSelectedMessageIds.size;
            document.getElementById('forward-select-count').textContent = `已选择 ${count} 项`;
        }

        function exitForwardMode() {
            isInForwardMode = false;
            forwardSelectedMessageIds.clear();
            forwardTargetChats = []; // 清空多选目标
            
            const forwardSelectBar = document.getElementById('forward-select-bar');
            forwardSelectBar.style.display = 'none';
            
            // 移除所有消息的选中状态
            messageArea.querySelectorAll('.message-wrapper').forEach(wrapper => {
                wrapper.classList.remove('multi-select-selected');
            });
        }

        function showForwardTargetSelection() {
            if (forwardSelectedMessageIds.size === 0) {
                showToast('请至少选择一条消息');
                return;
            }
            
            const forwardModal = document.getElementById('forward-modal');
            const forwardChatList = document.getElementById('forward-chat-list');
            
            // 清空之前的选择
            forwardTargetChats = [];
            
            // 生成对话列表
            forwardChatList.innerHTML = '';
            
            // 添加私聊列表
            db.characters.forEach(char => {
                const item = document.createElement('div');
                item.className = 'list-item forward-chat-item';
                item.dataset.chatId = char.id;
                item.dataset.chatType = 'private';
                item.style.cssText = 'cursor: pointer; display: flex; align-items: center; padding: 12px; border-bottom: 1px solid #eee; transition: background-color 0.2s;';
                item.innerHTML = `
                    <input type="checkbox" class="forward-checkbox" style="width: 20px; height: 20px; margin-right: 12px; cursor: pointer;">
                    <img src="${char.avatar}" class="chat-avatar" style="width: 50px; height: 50px; border-radius: 50%; margin-right: 15px;">
                    <div class="item-details" style="flex-grow: 1;">
                        <div class="item-name">${char.remarkName || char.realName}</div>
                        <div class="item-preview" style="font-size: 14px; color: #888;">私聊</div>
                    </div>
                `;
                
                const checkbox = item.querySelector('.forward-checkbox');
                
                item.addEventListener('click', (e) => {
                    if (e.target === checkbox) return; // 点击复选框时不触发
                    checkbox.checked = !checkbox.checked;
                    updateForwardSelection(item, char.id, 'private', checkbox.checked);
                });
                
                checkbox.addEventListener('change', (e) => {
                    updateForwardSelection(item, char.id, 'private', e.target.checked);
                });
                
                forwardChatList.appendChild(item);
            });
            
            // 添加群聊列表
            db.groups.forEach(group => {
                const item = document.createElement('div');
                item.className = 'list-item forward-chat-item';
                item.dataset.chatId = group.id;
                item.dataset.chatType = 'group';
                item.style.cssText = 'cursor: pointer; display: flex; align-items: center; padding: 12px; border-bottom: 1px solid #eee; transition: background-color 0.2s;';
                item.innerHTML = `
                    <input type="checkbox" class="forward-checkbox" style="width: 20px; height: 20px; margin-right: 12px; cursor: pointer;">
                    <img src="${group.avatar}" class="chat-avatar group-avatar" style="width: 50px; height: 50px; border-radius: 10px; margin-right: 15px;">
                    <div class="item-details" style="flex-grow: 1;">
                        <div class="item-name">${group.name}</div>
                        <div class="item-preview" style="font-size: 14px; color: #888;">群聊 (${group.members.length}人)</div>
                    </div>
                `;
                
                const checkbox = item.querySelector('.forward-checkbox');
                
                item.addEventListener('click', (e) => {
                    if (e.target === checkbox) return; // 点击复选框时不触发
                    checkbox.checked = !checkbox.checked;
                    updateForwardSelection(item, group.id, 'group', checkbox.checked);
                });
                
                checkbox.addEventListener('change', (e) => {
                    updateForwardSelection(item, group.id, 'group', e.target.checked);
                });
                
                forwardChatList.appendChild(item);
            });
            
            // 显示模态框
            forwardModal.classList.add('visible');
            
            // 搜索功能
            const searchInput = document.getElementById('forward-search-input');
            searchInput.value = '';
            searchInput.oninput = (e) => {
                const keyword = e.target.value.toLowerCase();
                forwardChatList.querySelectorAll('.forward-chat-item').forEach(item => {
                    const name = item.querySelector('.item-name').textContent.toLowerCase();
                    item.style.display = name.includes(keyword) ? 'flex' : 'none';
                });
            };
        }
        
        function updateForwardSelection(item, chatId, chatType, isSelected) {
            if (isSelected) {
                item.style.backgroundColor = '#e3f2fd';
                // 添加到选中列表
                if (!forwardTargetChats.find(t => t.id === chatId && t.type === chatType)) {
                    forwardTargetChats.push({ id: chatId, type: chatType });
                }
            } else {
                item.style.backgroundColor = '';
                // 从选中列表移除
                forwardTargetChats = forwardTargetChats.filter(t => !(t.id === chatId && t.type === chatType));
            }
        }

        async function confirmForwardMessages() {
            if (forwardTargetChats.length === 0) {
                showToast('请至少选择一个转发目标');
                return;
            }
            
            if (forwardSelectedMessageIds.size === 0) {
                showToast('请选择要转发的消息');
                return;
            }
            
            // 获取源对话
            const sourceChat = (currentChatType === 'private') 
                ? db.characters.find(c => c.id === currentChatId) 
                : db.groups.find(g => g.id === currentChatId);
            
            if (!sourceChat) {
                showToast('源对话不存在');
                return;
            }
            
            // 获取要转发的消息（按时间排序）
            const messagesToForward = Array.from(forwardSelectedMessageIds)
                .map(id => sourceChat.history.find(m => m.id === id))
                .filter(m => m)
                .sort((a, b) => a.timestamp - b.timestamp);
            
            let successCount = 0;
            
            // 遍历所有选中的目标对话
            for (const target of forwardTargetChats) {
                const targetChat = (target.type === 'private') 
                    ? db.characters.find(c => c.id === target.id) 
                    : db.groups.find(g => g.id === target.id);
                
                if (!targetChat) {
                    console.warn(`目标对话不存在: ${target.id}`);
                    continue;
                }
                
                // 获取目标对话中用户的名字
                const myName = (target.type === 'private') ? targetChat.myName : (targetChat.me ? targetChat.me.nickname : '我');
                
                // 转发消息到当前目标
                for (const msg of messagesToForward) {
                    let forwardContent = '';
                    
                    // 提取消息内容
                    const patterns = [
                        /\[.*?的消息：([\s\S]+)\]/,
                        /\[.*?的语音：([\s\S]+)\]/,
                        /\[.*?发送的表情包：([\s\S]+)\]/,
                        /\[.*?的表情包：([\s\S]+)\]/,
                        /\[.*?发来的照片\/视频：([\s\S]+)\]/,
                        /\[.*?送来的礼物：([\s\S]+)\]/,
                        /\[.*?向.*?送来了礼物：([\s\S]+)\]/
                    ];
                    
                    let extracted = false;
                    for (const pattern of patterns) {
                        const match = msg.content.match(pattern);
                        if (match) {
                            forwardContent = match[1].trim();
                            extracted = true;
                            break;
                        }
                    }
                    
                    // 如果没有匹配到格式，直接使用原内容
                    if (!extracted) {
                        forwardContent = msg.content;
                    }
                    
                    // 创建新消息（统一以用户身份发送）
                    const newMessage = {
                        id: `msg_${Date.now()}_${Math.random()}`,
                        role: 'user',
                        content: `[${myName}的消息：${forwardContent}]`,
                        parts: [{type: 'text', text: `[${myName}的消息：${forwardContent}]`}],
                        timestamp: Date.now()
                    };
                    
                    if (target.type === 'group') {
                        newMessage.senderId = 'user_me';
                    }
                    
                    targetChat.history.push(newMessage);
                    
                    // 稍微延迟，避免时间戳完全相同
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
                
                successCount++;
            }
            
            await saveData();
            
            // 关闭模态框
            document.getElementById('forward-modal').classList.remove('visible');
            
            // 退出转发模式
            exitForwardMode();
            
            // 更新聊天列表
            renderChatList();
            
            showToast(`已将 ${messagesToForward.length} 条消息转发到 ${successCount} 个对话`);
        }

        function startReplyToMessage() {
            if (!activeMessageId) return;

            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const message = chat.history.find(m => m.id === activeMessageId);
            if (!message) return;

            // 获取完整内容
            const fullContent = String(message.content || '');
            let previewSnippet = '';
            let senderName = '';

            // 确定发送者名称
            if (message.role === 'user') {
                senderName = (currentChatType === 'private') ? chat.myName : (chat.me ? chat.me.nickname : '我');
            } else {
                if (currentChatType === 'private') {
                    senderName = chat.remarkName || chat.realName;
                } else {
                    const sender = chat.members.find(m => m.id === message.senderId);
                    senderName = sender ? sender.realName : '未知';
                }
            }

            // 提取纯文本内容（去除格式前缀）
            const textMatch = fullContent.match(/\[.*?的消息：([\s\S]+)\]/);
            const cleanContent = textMatch ? textMatch[1].trim() : fullContent;

            // 判断消息类型并生成预览
            if (/\[.*?的表情包：.*?\]|\[.*?发送的表情包：.*?\]/.test(fullContent)) {
                previewSnippet = '[表情包]';
            } else if (/\[.*?的语音：.*?\]/.test(fullContent)) {
                previewSnippet = '[语音]';
            } else if (/\[.*?发来的照片\/视频：.*?\]/.test(fullContent)) {
                previewSnippet = '[照片/视频]';
            } else {
                previewSnippet = cleanContent.substring(0, 50) + (cleanContent.length > 50 ? '...' : '');
            }

            // 存储引用上下文（使用完整内容）
            currentReplyContext = {
                id: message.id,
                timestamp: message.timestamp,
                senderName: senderName,
                content: cleanContent  // 存储去除格式后的内容
            };

            // 更新UI
            const previewBar = document.getElementById('reply-preview-bar');
            previewBar.querySelector('.sender').textContent = `回复 ${senderName}:`;
            previewBar.querySelector('.text').textContent = previewSnippet;
            previewBar.style.display = 'block';

            // 关闭菜单并聚焦输入框
            removeContextMenu();
            messageInput.focus();
        }

        function cancelReplyMode() {
            currentReplyContext = null;
            document.getElementById('reply-preview-bar').style.display = 'none';
        }

        function enterMultiSelectMode(initialMessageId) {
            isInMultiSelectMode = true;
            chatRoomHeaderDefault.style.display = 'none';
            chatRoomHeaderSelect.style.display = 'flex';
            document.querySelector('.chat-input-wrapper').style.display = 'none';
            multiSelectBar.classList.add('visible');
            chatRoomScreen.classList.add('multi-select-active');
            selectedMessageIds.clear();
            if (initialMessageId) {
                toggleMessageSelection(initialMessageId);
            }
        }

        function exitMultiSelectMode() {
            isInMultiSelectMode = false;
            chatRoomHeaderDefault.style.display = 'flex';
            chatRoomHeaderSelect.style.display = 'none';
            document.querySelector('.chat-input-wrapper').style.display = 'block';
            multiSelectBar.classList.remove('visible');
            chatRoomScreen.classList.remove('multi-select-active');
            selectedMessageIds.forEach(id => {
                const el = messageArea.querySelector(`.message-wrapper[data-id="${id}"]`);
                if (el) el.classList.remove('multi-select-selected');
            });
            selectedMessageIds.clear();
        }

        function toggleMessageSelection(messageId) {
            const el = messageArea.querySelector(`.message-wrapper[data-id="${messageId}"]`);
            if (!el) return;
            if (selectedMessageIds.has(messageId)) {
                selectedMessageIds.delete(messageId);
                el.classList.remove('multi-select-selected');
            } else {
                selectedMessageIds.add(messageId);
                el.classList.add('multi-select-selected');
            }
            selectCount.textContent = `已选择 ${selectedMessageIds.size} 项`;
            deleteSelectedBtn.disabled = selectedMessageIds.size === 0;
        }

        async function deleteSelectedMessages() {
            if (selectedMessageIds.size === 0) return;
            const deletedCount = selectedMessageIds.size;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            
            // 从 IndexedDB 中删除每条选中的消息
            for (const messageId of selectedMessageIds) {
                await deleteMessageFromStorage(currentChatId, currentChatType, messageId);
            }
            
            // 从内存中过滤掉已删除的消息
            chat.history = chat.history.filter(m => !selectedMessageIds.has(m.id));
            await saveData();
            currentPage = 1;
            renderMessages(false, true);
            renderChatList();
            exitMultiSelectMode();
            showToast(`已删除 ${deletedCount} 条消息`);
        }

        async function openChatRoom(chatId, type) {
            const chat = (type === 'private') ? db.characters.find(c => c.id === chatId) : db.groups.find(g => g.id === chatId);
            if (!chat) return;
            
            // 【性能优化】标记是否已加载完整历史，避免重复加载
            if (!chat._fullHistoryLoaded) {
                const fullHistory = await dataStorage.getChatMessages(chatId, type);
                chat.history = fullHistory;
                chat._fullHistoryLoaded = true;
            }
            
            // 如果是群聊，初始化用户权限（兼容旧数据）
            if (type === 'group') {
                // 旁观者模式下，chat.me 为 null，跳过权限初始化
                if (chat.me) {
                    if (chat.me.isOwner === undefined) {
                        // 检查是否有AI成员是群主
                        const hasOwner = chat.members.some(m => m.isOwner);
                        // 如果没有AI群主，用户默认是群主
                        chat.me.isOwner = !hasOwner;
                    }
                    if (chat.me.isAdmin === undefined) {
                        chat.me.isAdmin = false;
                    }
                    // 保存初始化后的数据
                    await saveData();
                }
            }
            
            // 清空未读消息数
            if (chat.unreadCount && chat.unreadCount > 0) {
                chat.unreadCount = 0;
                await saveData();
                renderChatList();
            }
            
            exitMultiSelectMode();
            cancelMessageEdit();
            chatRoomTitle.textContent = (type === 'private') ? chat.remarkName : chat.name;
            const subtitle = document.getElementById('chat-room-subtitle');
            if (type === 'private') {
                subtitle.style.display = 'flex';
                chatRoomStatusText.textContent = chat.status || '在线';
            } else {
                subtitle.style.display = 'none';
            }
            getReplyBtn.style.display = 'inline-flex';
            
            // 应用聊天背景：优先使用全局聊天背景，否则使用角色/群聊独立背景
            if (db.globalChatBg) {
                chatRoomScreen.style.backgroundImage = `url(${db.globalChatBg})`;
                chatRoomScreen.style.backgroundSize = 'cover';
                chatRoomScreen.style.backgroundPosition = 'center';
            } else {
                chatRoomScreen.style.backgroundImage = chat.chatBg ? `url(${chat.chatBg})` : 'none';
            }
            
            typingIndicator.style.display = 'none';
            isGenerating = false;
            getReplyBtn.disabled = false;
            currentPage = 1;
            chatRoomScreen.className = chatRoomScreen.className.replace(/\bchat-active-[^ ]+\b/g, '');
            chatRoomScreen.classList.add(`chat-active-${chatId}`);
            updateCustomBubbleStyle(chatId, chat.customBubbleCss, chat.useCustomBubbleCss);
            
            // 【全新】检查旁观者模式
            if (type === 'group' && chat.isObserverMode) {
                // 旁观者模式：禁用输入框和发送按钮，但保持API调用按钮可用
                messageInput.disabled = true;
                messageInput.placeholder = '旁观者模式 - 点击API调用按钮观看AI对话';
                sendMessageBtn.disabled = true;
                getReplyBtn.disabled = false; // 保持API调用按钮可用
                showToast('旁观者模式：点击API调用按钮观看AI之间的对话', 2000);
            }
            // 【全新】检查拉黑状态并显示相应的UI
            else if (type === 'private' && chat.relationship && chat.relationship.status !== 'friend') {
                // 禁用输入框和发送按钮
                messageInput.disabled = true;
                messageInput.placeholder = '无法发送消息';
                sendMessageBtn.disabled = true;
                getReplyBtn.disabled = true;
                
                // 根据不同的状态显示不同的提示
                let statusMessage = '';
                if (chat.relationship.status === 'blocked_by_user') {
                    statusMessage = `你已将"${chat.remarkName}"拉黑。`;
                } else if (chat.relationship.status === 'blocked_by_ai') {
                    statusMessage = `你被对方拉黑了。`;
                } else if (chat.relationship.status === 'pending_user_approval') {
                    statusMessage = `"${chat.remarkName}"请求添加你为好友：\n"${chat.relationship.applicationReason}"`;
                } else if (chat.relationship.status === 'pending_ai_approval') {
                    statusMessage = `好友申请已发送，等待对方通过...`;
                }
                
                // 在聊天区域顶部显示状态提示（不使用遮罩层）
                if (statusMessage) {
                    showToast(statusMessage, 3000);
                }
            } else {
                // 恢复正常状态
                messageInput.disabled = false;
                messageInput.placeholder = '输入消息...';
                sendMessageBtn.disabled = false;
                getReplyBtn.disabled = false;
            }
            
            // ▼▼▼ 【群投票功能】根据聊天类型显示/隐藏投票按钮 ▼▼▼
            const sendPollBtn = document.getElementById('send-poll-btn');
            if (sendPollBtn) {
                sendPollBtn.style.display = (type === 'group' && !chat.isObserverMode) ? 'inline-flex' : 'none';
            }
            // ▲▲▲ 【群投票功能】结束 ▲▲▲
            
            renderMessages(false, true);
            switchScreen('chat-room-screen');
            
            // 更新音乐播放器图标
            updateListenTogetherIcon(chatId);
        }

        // ============ 状态编辑弹窗功能 ============
        function setupStatusEditing() {
            // 点击状态文本打开弹窗
            chatRoomStatusText.addEventListener('click', () => {
                if (currentChatType !== 'private') return;
                
                const chat = db.characters.find(c => c.id === currentChatId);
                if (!chat) return;

                // 设置输入框的当前值
                statusInput.value = chat.status || '在线';
                editStatusModal.classList.add('visible');
                
                // 聚焦并选中
                setTimeout(() => {
                    statusInput.focus();
                    statusInput.select();
                }, 100);
            });

            // 提交表单保存状态
            editStatusForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const chat = db.characters.find(c => c.id === currentChatId);
                if (!chat) return;

                const newStatus = statusInput.value.trim() || '在线';
                chat.status = newStatus;
                await saveData();
                
                // 更新显示
                chatRoomStatusText.textContent = newStatus;
                editStatusModal.classList.remove('visible');
                showToast('状态已更新');
            });

            // 点击弹窗背景关闭
            editStatusModal.addEventListener('click', (e) => {
                if (e.target === editStatusModal) {
                    editStatusModal.classList.remove('visible');
                }
            });

            // 添加悬停提示
            chatRoomStatusText.style.cursor = 'pointer';
            chatRoomStatusText.title = '点击修改状态';
        }

        // ===== 头像形状功能 - 核心函数 =====
        
        // 应用头像形状到角色
        function applyAvatarShape(charId, type, shapeData) {
            const char = db.characters.find(c => c.id === charId);
            if (!char) return;
            
            if (!char.avatarShapes) {
                char.avatarShapes = {};
            }
            
            char.avatarShapes[type] = shapeData;
            saveData();
            updateAvatarShapeDisplay();
            showToast(`${type === 'char' ? '角色' : '我的'}头像形状已更新`);
        }
        
        // 更新头像形状显示
        function updateAvatarShapeDisplay() {
            if (!currentChatId) return;
            const char = db.characters.find(c => c.id === currentChatId);
            if (!char || !char.avatarShapes) return;
            
            const messageArea = document.getElementById('message-area');
            const chatList = document.getElementById('chat-list-container');
            
            // 移除所有形状类 - 从所有可能的元素上移除
            messageArea.querySelectorAll('.message-info, .message-avatar, .avatar-img').forEach(el => {
                el.classList.remove('avatar-shape-circle', 'avatar-shape-square', 'avatar-shape-custom');
            });
            
            // 应用角色头像形状
            if (char.avatarShapes.char) {
                // 应用到消息中的角色头像（无头像框）
                const charAvatars = messageArea.querySelectorAll('.message-wrapper.received .message-avatar');
                charAvatars.forEach(el => {
                    applyShapeToElement(el, char.avatarShapes.char);
                });
                
                // 应用到消息中的角色头像（有头像框）
                const charAvatarImgs = messageArea.querySelectorAll('.message-wrapper.received .avatar-img');
                charAvatarImgs.forEach(el => {
                    applyShapeToElement(el, char.avatarShapes.char);
                });
                
                // 应用到聊天列表中的头像
                const chatItem = chatList.querySelector(`[data-chat-id="${currentChatId}"]`);
                if (chatItem) {
                    const avatar = chatItem.querySelector('.chat-avatar');
                    if (avatar) {
                        applyShapeToElement(avatar, char.avatarShapes.char);
                    }
                }
            }
            
            // 应用USER头像形状
            if (char.avatarShapes.my) {
                // 应用到消息中的USER头像（无头像框）
                const myAvatars = messageArea.querySelectorAll('.message-wrapper.sent .message-avatar');
                myAvatars.forEach(el => {
                    applyShapeToElement(el, char.avatarShapes.my);
                });
                
                // 应用到消息中的USER头像（有头像框）
                const myAvatarImgs = messageArea.querySelectorAll('.message-wrapper.sent .avatar-img');
                myAvatarImgs.forEach(el => {
                    applyShapeToElement(el, char.avatarShapes.my);
                });
            }
        }
        
        // 应用形状到元素
        function applyShapeToElement(element, shapeData) {
            if (!element || !shapeData) return;
            
            // 移除旧的形状类
            element.classList.remove('avatar-shape-circle', 'avatar-shape-square', 'avatar-shape-custom');
            
            if (shapeData.preset) {
                // 预设形状
                element.classList.add(`avatar-shape-${shapeData.preset}`);
            } else if (shapeData.custom) {
                // 自定义形状
                element.classList.add('avatar-shape-custom');
                element.style.setProperty('--custom-avatar-shape', shapeData.custom);
            }
        }
        
        // 加载头像形状设置到UI
        function loadAvatarShapeSettings(char) {
            if (!char || !char.avatarShapes) return;
            
            // 重置所有按钮
            document.querySelectorAll('.avatar-shape-preset-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            // 清空自定义输入框
            const charInput = document.getElementById('char-custom-shape-input');
            const myInput = document.getElementById('my-custom-shape-input');
            if (charInput) charInput.value = '';
            if (myInput) myInput.value = '';
            
            // 加载角色形状
            if (char.avatarShapes.char) {
                if (char.avatarShapes.char.preset) {
                    const btn = document.querySelector(`.avatar-shape-preset-btn[data-type="char"][data-shape="${char.avatarShapes.char.preset}"]`);
                    if (btn) btn.classList.add('selected');
                } else if (char.avatarShapes.char.custom && charInput) {
                    charInput.value = char.avatarShapes.char.custom;
                }
            }
            
            // 加载USER形状
            if (char.avatarShapes.my) {
                if (char.avatarShapes.my.preset) {
                    const btn = document.querySelector(`.avatar-shape-preset-btn[data-type="my"][data-shape="${char.avatarShapes.my.preset}"]`);
                    if (btn) btn.classList.add('selected');
                } else if (char.avatarShapes.my.custom && myInput) {
                    myInput.value = char.avatarShapes.my.custom;
                }
            }
        }

        function renderMessages(isLoadMore = false, forceScrollToBottom = false) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat || !chat.history) return;
            
            // 【性能优化】使用 requestAnimationFrame 批量更新DOM
            requestAnimationFrame(() => {
                const oldScrollHeight = messageArea.scrollHeight;
                const totalMessages = chat.history.length;
                const end = totalMessages - (currentPage - 1) * MESSAGES_PER_PAGE;
                const start = Math.max(0, end - MESSAGES_PER_PAGE);
                const messagesToRender = chat.history.slice(start, end);
                
                if (!isLoadMore) {
                    // 【关键修复】清空时使用 textContent 而不是 innerHTML，性能更好
                    messageArea.textContent = '';
                }
                
                const fragment = document.createDocumentFragment();
            
            // 添加时间间隔显示逻辑
            let lastTimestamp = 0;
            // 如果不是第一页，获取上一条消息的时间戳
            if (start > 0) {
                const prevMsg = chat.history[start - 1];
                if (prevMsg && prevMsg.timestamp) {
                    lastTimestamp = prevMsg.timestamp;
                }
            }
                
                // 【性能优化】批量处理消息，减少DOM操作
                messagesToRender.forEach(msg => {
                    // 判断时间间隔，超过5分钟显示时间戳
                    if (lastTimestamp > 0 && msg.timestamp && (msg.timestamp - lastTimestamp > 300000)) {
                        const timestampEl = createSystemTimestampElement(msg.timestamp);
                        fragment.appendChild(timestampEl);
                    }
                    
                    const bubble = createMessageBubbleElement(msg);
                    if (bubble) {
                        fragment.appendChild(bubble);
                        // 更新lastTimestamp，用于下一条消息的判断
                        if (msg.timestamp) {
                            lastTimestamp = msg.timestamp;
                        }
                    }
                });
                
                const existingLoadBtn = document.getElementById('load-more-btn');
                if (existingLoadBtn) existingLoadBtn.remove();
                
                // 【关键修复】一次性插入所有消息，避免多次重排
                messageArea.prepend(fragment);
                
                if (totalMessages > currentPage * MESSAGES_PER_PAGE) {
                    const loadMoreButton = document.createElement('button');
                    loadMoreButton.id = 'load-more-btn';
                    loadMoreButton.className = 'load-more-btn';
                    loadMoreButton.textContent = '加载更早的消息';
                    messageArea.prepend(loadMoreButton);
                }
                
                if (forceScrollToBottom) {
                    // 【性能优化】使用 requestAnimationFrame 确保DOM更新完成后再滚动
                    requestAnimationFrame(() => {
                        messageArea.scrollTop = messageArea.scrollHeight;
                    });
                } else if (isLoadMore) {
                    messageArea.scrollTop = messageArea.scrollHeight - oldScrollHeight;
                }
                
                // Update token display when rendering messages
                updateTokenDisplay();
                
                // 应用头像形状
                updateAvatarShapeDisplay();
            });
        }

        function loadMoreMessages() {
            currentPage++;
            renderMessages(true, false);
        }

        function calculateVoiceDuration(text) {
            return Math.max(1, Math.min(60, Math.ceil(text.length / 3.5)));
        }

        function createMessageBubbleElement(message, isUserView = true) {
            // 【核心修复】过滤掉隐藏的系统消息
            if (message.isHidden && !message.userOnlyVisible && !message.charOnlyVisible) {
                return null;
            }
            
            // 【新增】根据视角过滤消息
            // 如果是用户视角，跳过只给CHAR看的消息
            if (isUserView && message.charOnlyVisible) {
                return null;
            }
            // 如果是AI视角（实际上用户界面不会有AI视角，这里是为了完整性）
            if (!isUserView && message.userOnlyVisible) {
                return null;
            }
            
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const {role, content, timestamp, id, transferStatus, giftStatus, stickerData, senderId} = message;

            // 处理撤回消息
            if (message.type === 'recalled_message') {
                const wrapper = document.createElement('div');
                wrapper.className = 'message-wrapper system-notification';
                wrapper.dataset.id = id;

                const bubble = document.createElement('div');
                bubble.className = 'recalled-message-placeholder';
                bubble.dataset.id = id;
                bubble.textContent = message.content;
                bubble.title = '点击查看原文';
                
                wrapper.appendChild(bubble);
                return wrapper;
            }

            const timeSkipRegex = /\[system-display:([\s\S]+?)\]/;
            const inviteRegex = /\[(.*?)邀请(.*?)加入了群聊\]/;
            const renameRegex = /\[(.*?)修改群名为：(.*?)\]/;
            const timeSkipMatch = content.match(timeSkipRegex);
            const inviteMatch = content.match(inviteRegex);
            const renameMatch = content.match(renameRegex);
            const invisibleRegex = /\[.*?(?:接收|退回).*?的转账\]|\[.*?更新状态为：.*?\]|\[.*?已接收礼物\]|\[.*?切歌[:：].*?\]|\[.*?换头像[:：].*?\]|\[system:.*?\]/;
            if (invisibleRegex.test(content)) {
                return null;
            }

            const wrapper = document.createElement('div');
            wrapper.dataset.id = id;

            // 处理 role === 'system' 的消息（灰色系统提示）
            if (role === 'system') {
                wrapper.className = 'message-wrapper system-notification';
                const bubble = document.createElement('div');
                bubble.className = 'system-notification-bubble';
                bubble.textContent = content;
                wrapper.appendChild(bubble);
                return wrapper;
            }

            if (timeSkipMatch || inviteMatch || renameMatch) {
                wrapper.className = 'message-wrapper system-notification';
                let bubbleText = '';
                if (timeSkipMatch) bubbleText = timeSkipMatch[1];
                if (inviteMatch) bubbleText = `${inviteMatch[1]}邀请${inviteMatch[2]}加入了群聊`;
                if (renameMatch) bubbleText = `${renameMatch[1]}修改群名为“${renameMatch[2]}”`;
                const bubble = document.createElement('div');
                bubble.className = 'system-notification-bubble';
                bubble.textContent = bubbleText;
                
                // 检查是否是踢人消息
                const kickedRegex = /(.+?)\s*被移出群聊/;
                const kickedMatch = bubbleText.match(kickedRegex);
                
                if (kickedMatch && currentChatType === 'group' && message.kickedMembersData) {
                    bubble.style.cursor = 'pointer';
                    bubble.title = '点击拉回被踢出的成员';
                    
                    bubble.addEventListener('click', () => {
                        handlePullBackKickedMembers(message);
                    });
                }
                
                wrapper.appendChild(bubble);
                return wrapper;
            }

            const isSent = (role === 'user');
            let avatarUrl, bubbleTheme, senderNickname = '';
            const themeKey = chat.theme || 'white_pink';
            // Use custom theme if available, otherwise use predefined theme
            const theme = chat.customTheme || colorThemes[themeKey] || colorThemes['white_pink'];
            let messageSenderId = isSent ? 'user_me' : senderId;

            if (isSent) {
                avatarUrl = (currentChatType === 'private') ? chat.myAvatar : (chat.me ? chat.me.avatar : 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg');
                bubbleTheme = theme.sent;
            } else {
                if (currentChatType === 'private') {
                    avatarUrl = chat.avatar;
                } else { // Group chat received
                    const sender = chat.members.find(m => m.id === senderId);
                    if (sender) {
                        avatarUrl = sender.avatar;
                        senderNickname = sender.groupNickname;
                    } else { // Fallback for unknown sender
                        avatarUrl = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
                    }
                }
                bubbleTheme = theme.received;
            }
            const date = new Date(timestamp);
            let timeString;
            if (db.showSecondsInTime) {
                // 如果开启了时分秒显示，使用自定义格式
                const format = db.customTimeFormat || '{HH}:{MM}:{SS}';
                timeString = format
                    .replace('{HH}', pad(date.getHours()))
                    .replace('{MM}', pad(date.getMinutes()))
                    .replace('{SS}', pad(date.getSeconds()));
            } else {
                // 默认只显示时分
                timeString = `${pad(date.getHours())}:${pad(date.getMinutes())}`;
            }
            wrapper.className = `message-wrapper ${isSent ? 'sent' : 'received'}`;
            if (currentChatType === 'group' && !isSent) {
                wrapper.classList.add('group-message');
            }
            const bubbleRow = document.createElement('div');
            bubbleRow.className = 'message-bubble-row';
            let bubbleElement;

            // Regexes for all message types
            const urlRegex = /^(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg)|data:image\/[a-z]+;base64,)/i;
            const sentStickerRegex = /\[(?:.+?)的表情包：.+?\]/i;
            const receivedStickerRegex = /\[(?:.+?)发送的表情包：([\s\S]+?)\]/i;
            const voiceRegex = /\[(?:.+?)的语音：([\s\S]+?)\]/;
            const photoVideoRegex = /\[(?:.+?)发来的照片\/视频：([\s\S]+?)\]/;
            const privateSentTransferRegex = /\[.*?给你转账：([\d.]+)元；备注：(.*?)\]/;
            const privateReceivedTransferRegex = /\[.*?的转账：([\d.]+)元；备注：(.*?)\]/;
            const groupTransferRegex = /\[(.*?)\s*向\s*(.*?)\s*转账：([\d.]+)元；备注：(.*?)\]/;
            const privateGiftRegex = /\[(?:.+?)送来的礼物：([\s\S]+?)\]/;
            const groupGiftRegex = /\[(.*?)\s*向\s*(.*?)\s*送来了礼物：([\s\S]+?)\]/;
            const imageRecogRegex = /\[.*?发来了一张图片：\]/;
            const textRegex = /\[(?:.+?)的消息：([\s\S]+?)\]/;

            const sentStickerMatch = content.match(sentStickerRegex);
            const receivedStickerMatch = content.match(receivedStickerRegex);
            const voiceMatch = content.match(voiceRegex);
            const photoVideoMatch = content.match(photoVideoRegex);
            const privateSentTransferMatch = content.match(privateSentTransferRegex);
            const privateReceivedTransferMatch = content.match(privateReceivedTransferRegex);
            const groupTransferMatch = content.match(groupTransferRegex);
            const privateGiftMatch = content.match(privateGiftRegex);
            const groupGiftMatch = content.match(groupGiftRegex);
            const imageRecogMatch = content.match(imageRecogRegex);
            const textMatch = content.match(textRegex);



            if ((isSent && sentStickerMatch && stickerData) || (!isSent && receivedStickerMatch)) {
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'image-bubble';
                let stickerSrc = '';

                if (isSent) {
                    // 如果是你自己发的表情包，直接使用数据
                    stickerSrc = stickerData;
                } else {
                    // 如果是AI发的表情包，我们需要处理路径
                    // 原始路径，例如："害羞vHLfrV3K/1.jpg"
                    const rawPath = receivedStickerMatch[1].trim();

                    // 用一个新的正则表达式来提取需要的部分，例如："vHLfrV3K/1.jpg"
                    const pathExtractionRegex = /[a-zA-Z0-9]+\/.*$/;
                    const extractedPathMatch = rawPath.match(pathExtractionRegex);

                    // 如果正则成功匹配到了，就使用匹配到的结果
                    const finalPath = extractedPathMatch ? extractedPathMatch[0] : rawPath;

                    // 拼接成最终的图片URL
                    stickerSrc = `https://i.postimg.cc/${finalPath}`;
                }

                bubbleElement.innerHTML = `<img src="${stickerSrc}" alt="表情包" loading="lazy">`;
            } else if (privateGiftMatch || groupGiftMatch) {
                const match = privateGiftMatch || groupGiftMatch;
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'gift-card';
                if (giftStatus === 'received') {
                    bubbleElement.classList.add('received');
                }

                let giftText;
                if (groupGiftMatch) {
                    const from = groupGiftMatch[1];
                    const to = groupGiftMatch[2];
                    giftText = isSent ? `你送给 ${to} 的礼物` : `${from} 送给 ${to} 的礼物`;
                } else {
                    giftText = isSent ? '您有一份礼物～' : '您有一份礼物～';
                }
                bubbleElement.innerHTML = `<img src="https://i.postimg.cc/rp0Yg31K/chan-75.png" alt="gift" class="gift-card-icon" loading="lazy"><div class="gift-card-text">${giftText}</div><div class="gift-card-received-stamp">已查收</div>`;

                const description = groupGiftMatch ? groupGiftMatch[3].trim() : match[1].trim();
                const descriptionDiv = document.createElement('div');
                descriptionDiv.className = 'gift-card-description';
                descriptionDiv.textContent = description;
                wrapper.appendChild(descriptionDiv);
            } else if (message.type === 'naiimag') {
                // NovelAI图片消息
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'message-bubble is-naiimag';
                const imageUrl = message.imageUrl || message.content;
                const promptText = message.prompt || 'NovelAI生成';
                bubbleElement.innerHTML = `<img src="${imageUrl}" class="naiimag-image" alt="NovelAI图片" loading="lazy" onerror="this.src='https://i.postimg.cc/KYr2qRCK/1.jpg'; this.alt='图片加载失败';" title="${promptText}">`;
            } else if (voiceMatch) {
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'voice-bubble';
                if (!chat.useCustomBubbleCss) {
                    bubbleElement.style.backgroundColor = bubbleTheme.bg;
                    bubbleElement.style.color = bubbleTheme.text;
                }
                bubbleElement.innerHTML = `<svg class="play-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"></path></svg><span class="duration">${calculateVoiceDuration(voiceMatch[1].trim())}"</span>`;
                const transcriptDiv = document.createElement('div');
                transcriptDiv.className = 'voice-transcript';
                // 应用Markdown格式化，支持 *斜体* 和 **粗体**
                const formattedTranscript = formatMarkdown(voiceMatch[1].trim());
                transcriptDiv.innerHTML = formattedTranscript;
                wrapper.appendChild(transcriptDiv);
            } else if (photoVideoMatch) {
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'pv-card';
                bubbleElement.innerHTML = `<div class="pv-card-content">${photoVideoMatch[1].trim()}</div><div class="pv-card-image-overlay" style="background-image: url('${isSent ? 'https://i.postimg.cc/L8NFrBrW/1752307494497.jpg' : 'https://i.postimg.cc/1tH6ds9g/1752301200490.jpg'}');"></div><div class="pv-card-footer"><svg viewBox="0 0 24 24"><path d="M4,4H20A2,2 0 0,1 22,6V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V6A2,2 0 0,1 4,4M4,6V18H20V6H4M10,9A1,1 0 0,1 11,10A1,1 0 0,1 10,11A1,1 0 0,1 9,10A1,1 0 0,1 10,9M8,17L11,13L13,15L17,10L20,14V17H8Z"></path></svg><span>照片/视频・点击查看</span></div>`;
            } else if (privateSentTransferMatch || privateReceivedTransferMatch || groupTransferMatch) {
                const isSentTransfer = !!privateSentTransferMatch || (groupTransferMatch && isSent);
                const match = privateSentTransferMatch || privateReceivedTransferMatch || groupTransferMatch;

                let amount, remarkText, titleText;
                if (groupTransferMatch) {
                    const from = groupTransferMatch[1];
                    const to = groupTransferMatch[2];
                    amount = parseFloat(groupTransferMatch[3]).toFixed(2);
                    remarkText = groupTransferMatch[4] || '';
                    titleText = isSent ? `向 ${to} 转账` : `${from} 向你转账`;
                } else { // Private chat
                    amount = parseFloat(match[1]).toFixed(2);
                    remarkText = match[2] || '';
                    titleText = isSentTransfer ? '给你转账' : '转账';
                }

                bubbleElement = document.createElement('div');
                bubbleElement.className = `transfer-card ${isSentTransfer ? 'sent-transfer' : 'received-transfer'}`;

                let statusText = isSentTransfer ? '待查收' : '转账给你';
                if (groupTransferMatch && !isSent) statusText = '转账给Ta'; // AI to AI
                if (transferStatus === 'received') {
                    statusText = '已收款';
                    bubbleElement.classList.add('received');
                } else if (transferStatus === 'returned') {
                    statusText = '已退回';
                    bubbleElement.classList.add('returned');
                }
                // 群聊中的转账设置为不可点击
                if (currentChatType === 'group') {
                    bubbleElement.style.cursor = 'default';
                }

                const remarkHTML = remarkText ? `<p class="transfer-remark">${remarkText}</p>` : '';
                bubbleElement.innerHTML = `<div class="overlay"></div><div class="transfer-content"><p class="transfer-title">${titleText}</p><p class="transfer-amount">¥${amount}</p>${remarkHTML}<p class="transfer-status">${statusText}</p></div>`;
            } else if (message.type === 'waimai_request' || message.type === 'waimai_order') {
                // 外卖代付卡片 或 为CHAR点单卡片
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'message-bubble is-waimai-request';
                
                // 添加状态类
                if (message.status === 'paid') {
                    bubbleElement.classList.add('status-paid');
                } else if (message.status === 'rejected') {
                    bubbleElement.classList.add('status-rejected');
                }
                
                // 获取发送者名称
                let displayName = '';
                if (currentChatType === 'private') {
                    displayName = isSent ? (chat.myName || '我') : (chat.realName || chat.name);
                } else {
                    if (isSent) {
                        displayName = (chat.me && chat.me.groupNickname) || '我';
                    } else {
                        const sender = chat.members.find(m => m.id === senderId);
                        displayName = sender ? sender.groupNickname : '未知';
                    }
                }
                
                // 根据类型设置标题
                let requestTitle = '';
                if (message.type === 'waimai_order') {
                    // 为CHAR点单
                    requestTitle = `${displayName} 为 ${message.recipientName || 'Ta'} 点的外卖`;
                } else {
                    // 请求代付
                    requestTitle = `来自 ${displayName} 的代付请求`;
                }
                
                let actionButtonsHtml = '';
                if (message.type === 'waimai_request' && message.status === 'pending' && !isSent) {
                    actionButtonsHtml = `
                        <div class="waimai-user-actions">
                            <button class="waimai-decline-btn" data-choice="rejected">残忍拒绝</button>
                            <button class="waimai-pay-btn" data-choice="paid">为Ta买单</button>
                        </div>`;
                }
                
                // 根据类型决定是否显示倒计时
                let paymentBoxHtml = '';
                if (message.type === 'waimai_order') {
                    // 为CHAR点单，显示已支付
                    paymentBoxHtml = `
                        <div class="payment-box">
                            <div class="payment-label">订单金额</div>
                            <div class="amount">¥${Number(message.amount).toFixed(2)}</div>
                            <div class="countdown-label" style="color: #28a745; font-weight: 600;">已支付</div>
                        </div>`;
                } else {
                    // 请求代付，显示倒计时
                    paymentBoxHtml = `
                        <div class="payment-box">
                            <div class="payment-label">需付款</div>
                            <div class="amount">¥${Number(message.amount).toFixed(2)}</div>
                            <div class="countdown-label">剩余支付时间
                                <div class="countdown-timer" id="waimai-timer-${timestamp}"></div>
                            </div>
                        </div>`;
                }
                
                const contentHtml = `
                    <div class="waimai-card">
                        <div class="waimai-header">
                            <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                            <div class="title-group">
                                <span class="brand">美团外卖</span><span class="separator">|</span><span>外卖美食</span>
                            </div>
                        </div>
                        <div class="waimai-catchphrase">Hi，你和我的距离只差一顿外卖～</div>
                        <div class="waimai-main">
                            <div class="request-title">${requestTitle}</div>
                            ${paymentBoxHtml}
                            <button class="waimai-details-btn">查看详情</button>
                        </div>
                        ${actionButtonsHtml}
                    </div>`;
                
                bubbleElement.innerHTML = `<div class="content">${contentHtml}</div>`;
                
                // 延迟设置倒计时和事件监听器
                setTimeout(() => {
                    const timerEl = document.getElementById(`waimai-timer-${timestamp}`);
                    if (timerEl && message.countdownEndTime && message.type === 'waimai_request') {
                        if (waimaiTimers[timestamp]) clearInterval(waimaiTimers[timestamp]);
                        if (message.status === 'pending') {
                            waimaiTimers[timestamp] = startWaimaiCountdown(timerEl, message.countdownEndTime);
                        } else {
                            timerEl.innerHTML = `<span>已</span><span>处</span><span>理</span>`;
                        }
                    }
                    
                    const detailsBtn = document.querySelector(`.message-wrapper[data-id="${id}"] .waimai-details-btn`);
                    if (detailsBtn) {
                        detailsBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const paidByText = message.paidBy ? `<br><br><b>状态：</b>由 ${message.paidBy} 为您代付成功` : '';
                            showCustomAlert('订单详情', `<b>商品：</b>${message.productInfo}<br><b>金额：</b>¥${Number(message.amount).toFixed(2)}${paidByText}`);
                        });
                    }
                    
                    const actionButtons = document.querySelectorAll(`.message-wrapper[data-id="${id}"] .waimai-user-actions button`);
                    actionButtons.forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const choice = e.target.dataset.choice;
                            handleWaimaiResponse(timestamp, choice);
                        });
                    });
                }, 0);
            } else if (message.type === 'share_link') {
                // 分享链接卡片
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'message-bubble is-link-share';
                
                const linkTitle = message.title || '无标题';
                const linkDescription = message.description || '点击查看详情...';
                const linkSource = message.source_name || '链接分享';
                
                bubbleElement.innerHTML = `
                    <div class="link-share-card" data-timestamp="${timestamp}">
                        <div class="title">${linkTitle}</div>
                        <div class="description">${linkDescription}</div>
                        <div class="footer">
                            <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="12" cy="12" r="10"></circle>
                                <line x1="2" y1="12" x2="22" y2="12"></line>
                                <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
                            </svg>
                            <span>${linkSource}</span>
                        </div>
                    </div>`;
                
                // 添加点击事件，显示完整内容
                setTimeout(() => {
                    const linkCard = document.querySelector(`.message-wrapper[data-id="${id}"] .link-share-card`);
                    if (linkCard) {
                        linkCard.addEventListener('click', () => {
                            const fullContent = message.content || linkDescription;
                            showCustomAlert(linkTitle, fullContent);
                        });
                    }
                }, 0);
            } else if (message.type === 'location_share') {
                // 共享位置卡片
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'message-bubble is-location-share';
                
                const locationName = message.content || '未知位置';
                const imageUrl = message.imageUrl;
                const mapAreaStyle = imageUrl ? `style="background-image: url('${imageUrl}');"` : '';
                
                bubbleElement.innerHTML = `
                    <div class="location-share-card">
                        <div class="card-text-area">
                            <div class="card-text-primary">${locationName}</div>
                            <div class="card-text-secondary">位置分享</div>
                        </div>
                        <div class="card-map-area" ${mapAreaStyle}>
                            <div class="card-pin-icon">
                                <svg width="1em" height="1em" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M12 11.5C11.1716 11.5 10.5 10.8284 10.5 10C10.5 9.17157 11.1716 8.5 12 8.5C12.8284 8.5 13.5 9.17157 13.5 10C13.5 10.8284 12.8284 11.5 12 11.5Z"></path>
                                    <path d="M12 2C7.92134 2 4.5 5.42134 4.5 9.5C4.5 14.5312 11.2188 21.4375 11.5938 21.8125C11.7954 22.014 12.2046 22.014 12.4062 21.8125C12.7812 21.4375 19.5 14.5312 19.5 9.5C19.5 5.42134 16.0787 2 12 2ZM12 12.5C10.6193 12.5 9.5 11.3807 9.5 10C9.5 8.61929 10.6193 7.5 12 7.5C13.3807 7.5 14.5 8.61929 14.5 10C14.5 11.3807 13.3807 12.5 12 12.5Z"></path>
                                </svg>
                            </div>
                        </div>
                    </div>`;
            } else if (message.type === 'poll') {
                // 【群投票功能】投票卡片
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'message-bubble is-poll';
                
                let totalVotes = 0;
                const voteCounts = {};
                
                // 计算总票数和每个选项的票数
                for (const option in message.votes) {
                    const count = message.votes[option].length;
                    voteCounts[option] = count;
                    totalVotes += count;
                }
                
                const myNickname = (currentChatType === 'private') ? chat.myName : (chat.me ? chat.me.nickname : '我');
                let myVote = null;
                for (const option in message.votes) {
                    if (message.votes[option].includes(myNickname)) {
                        myVote = option;
                        break;
                    }
                }
                
                let optionsHtml = '<div class="poll-options-list">';
                message.options.forEach(optionText => {
                    const count = voteCounts[optionText] || 0;
                    const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
                    const isVotedByMe = myVote === optionText;
                    
                    optionsHtml += `
                        <div class="poll-option-item ${isVotedByMe ? 'voted' : ''}" data-option="${optionText}">
                            <div class="poll-option-bar" style="width: ${percentage}%;"></div>
                            <div class="poll-option-content">
                                <span class="poll-option-text">${optionText}</span>
                                <span class="poll-option-votes">${count} 票</span>
                            </div>
                        </div>
                    `;
                });
                optionsHtml += '</div>';
                
                let footerHtml = '';
                if (message.isClosed) {
                    footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">查看结果</button></div>`;
                } else {
                    footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">结束投票</button></div>`;
                }
                
                bubbleElement.innerHTML = `
                    <div class="poll-card ${message.isClosed ? 'closed' : ''}" data-poll-timestamp="${message.timestamp}">
                        <div class="poll-question">${message.question}</div>
                        ${optionsHtml}
                        ${footerHtml}
                    </div>
                `;
            } else if (imageRecogMatch || urlRegex.test(content)) {
                bubbleElement = document.createElement('div');
                bubbleElement.className = 'image-bubble';
                bubbleElement.innerHTML = `<img src="${content}" alt="图片消息" loading="lazy">`;
            } else if (textMatch) {
                bubbleElement = document.createElement('div');
                bubbleElement.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
                
                // 检查是否有引用
                let quoteHtml = '';
                if (message.quote) {
                    const quotedContent = String(message.quote.content || '');
                    const quotedId = message.quote.id || '';
                    quoteHtml = `<div class="quoted-message" data-quote-id="${quotedId}">
                        <div class="quoted-sender">回复 ${message.quote.senderName}:</div>
                        <div class="quoted-content">${quotedContent}</div>
                    </div>`;
                }
                
                // 处理@标记和Markdown格式
                let messageText = textMatch[1].trim();
                messageText = formatMentions(messageText);
                messageText = formatMarkdown(messageText);
                
                // 组合引用块和消息内容
                bubbleElement.innerHTML = quoteHtml + `<span>${messageText}</span>`;
                
                if (!chat.useCustomBubbleCss) {
                    bubbleElement.style.backgroundColor = bubbleTheme.bg;
                    bubbleElement.style.color = bubbleTheme.text;
                }
            }else if(message && Array.isArray( message.parts) && message.parts[0].type === 'html'){
                bubbleElement = document.createElement('div');
                bubbleElement.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
                bubbleElement.innerHTML = message.parts[0].text;
            } else {
                bubbleElement = document.createElement('div');
                bubbleElement.className = `message-bubble ${isSent ? 'sent' : 'received'}`;
                // 处理@标记和Markdown格式
                let formattedContent = formatMentions(content);
                formattedContent = formatMarkdown(formattedContent);
                bubbleElement.innerHTML = formattedContent;
                if (!chat.useCustomBubbleCss) {
                    bubbleElement.style.backgroundColor = bubbleTheme.bg;
                    bubbleElement.style.color = bubbleTheme.text;
                }
            }
            // 生成头像HTML（支持头像框）
            let avatarFrameUrl = '';
            if (isSent) {
                avatarFrameUrl = (currentChatType === 'private') ? (chat.myAvatarFrame || '') : (chat.me ? (chat.me.avatarFrame || '') : '');
            } else {
                if (currentChatType === 'private') {
                    avatarFrameUrl = chat.avatarFrame || '';
                } else {
                    const sender = chat.members.find(m => m.id === senderId);
                    if (sender) {
                        avatarFrameUrl = sender.avatarFrame || '';
                    }
                }
            }
            
            let avatarHTML = '';
            if (avatarFrameUrl) {
                avatarHTML = `
                    <div class="avatar-group has-frame">
                        <div class="avatar-with-frame">
                            <img src="${avatarUrl}" class="avatar-img">
                            <img src="${avatarFrameUrl}" class="avatar-frame">
                        </div>
                    </div>
                `;
            } else {
                avatarHTML = `<img src="${avatarUrl}" class="message-avatar">`;
            }
            
            bubbleRow.innerHTML = `<div class="message-info">${avatarHTML}<span class="message-time">${timeString}</span></div>`;
            
            // 应用头像形状
            if (chat.avatarShapes) {
                const avatarElement = bubbleRow.querySelector('.message-avatar, .avatar-img');
                if (avatarElement) {
                    if (isSent && chat.avatarShapes.my) {
                        applyShapeToElement(avatarElement, chat.avatarShapes.my);
                    } else if (!isSent && chat.avatarShapes.char) {
                        applyShapeToElement(avatarElement, chat.avatarShapes.char);
                    }
                }
            }
            
            if (bubbleElement) {
                // 检查是否需要显示开场白切换箭头
                const showGreetingArrows = message.isGreeting && message.hasMultipleGreetings && chat.greetings && chat.greetings.length > 1;
                
                if (showGreetingArrows) {
                    // 创建包含箭头和气泡的容器
                    const bubbleWithArrows = document.createElement('div');
                    bubbleWithArrows.style.cssText = 'display: flex; align-items: center; gap: 8px; width: 100%;';
                    
                    // 左箭头
                    const leftArrow = document.createElement('button');
                    leftArrow.className = 'greeting-arrow greeting-arrow-left';
                    leftArrow.innerHTML = '◀';
                    leftArrow.style.cssText = 'background: var(--primary-color); color: white; border: none; border-radius: 50%; width: 28px; height: 28px; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; transition: all 0.3s; flex-shrink: 0;';
                    leftArrow.title = `上一个开场白 (${chat.currentGreetingIndex + 1}/${chat.greetings.length})`;
                    
                    // 右箭头
                    const rightArrow = document.createElement('button');
                    rightArrow.className = 'greeting-arrow greeting-arrow-right';
                    rightArrow.innerHTML = '▶';
                    rightArrow.style.cssText = 'background: var(--primary-color); color: white; border: none; border-radius: 50%; width: 28px; height: 28px; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; transition: all 0.3s; flex-shrink: 0;';
                    rightArrow.title = `下一个开场白 (${chat.currentGreetingIndex + 1}/${chat.greetings.length})`;
                    
                    // 鼠标悬停效果
                    leftArrow.onmouseover = () => { if (!leftArrow.disabled) leftArrow.style.transform = 'scale(1.15)'; };
                    leftArrow.onmouseout = () => leftArrow.style.transform = 'scale(1)';
                    rightArrow.onmouseover = () => { if (!rightArrow.disabled) rightArrow.style.transform = 'scale(1.15)'; };
                    rightArrow.onmouseout = () => rightArrow.style.transform = 'scale(1)';
                    
                    // 左箭头点击事件
                    leftArrow.onclick = async () => {
                        if (chat.currentGreetingIndex > 0) {
                            chat.currentGreetingIndex--;
                            message.content = chat.greetings[chat.currentGreetingIndex];
                            message.parts = [{type: 'text', text: chat.greetings[chat.currentGreetingIndex]}];
                            await saveData();
                            currentPage = 1;
                            renderMessages(false, true);
                        }
                    };
                    
                    // 右箭头点击事件
                    rightArrow.onclick = async () => {
                        if (chat.currentGreetingIndex < chat.greetings.length - 1) {
                            chat.currentGreetingIndex++;
                            message.content = chat.greetings[chat.currentGreetingIndex];
                            message.parts = [{type: 'text', text: chat.greetings[chat.currentGreetingIndex]}];
                            await saveData();
                            currentPage = 1;
                            renderMessages(false, true);
                        }
                    };
                    
                    // 禁用按钮状态
                    if (chat.currentGreetingIndex === 0) {
                        leftArrow.style.opacity = '0.3';
                        leftArrow.style.cursor = 'not-allowed';
                        leftArrow.disabled = true;
                    }
                    if (chat.currentGreetingIndex === chat.greetings.length - 1) {
                        rightArrow.style.opacity = '0.3';
                        rightArrow.style.cursor = 'not-allowed';
                        rightArrow.disabled = true;
                    }
                    
                    // 组装：左箭头 + 消息气泡 + 右箭头
                    bubbleWithArrows.appendChild(leftArrow);
                    bubbleWithArrows.appendChild(bubbleElement);
                    bubbleWithArrows.appendChild(rightArrow);
                    bubbleRow.appendChild(bubbleWithArrows);
                } else {
                    // 普通消息，直接添加气泡
                    bubbleRow.appendChild(bubbleElement);
                }
            }
            
            // 为wrapper添加senderId，用于语音播放时获取对应的voiceId
            if (senderId) {
                wrapper.dataset.senderId = senderId;
            }
            
            // 添加群聊昵称（在气泡上方）
            if (currentChatType === 'group' && !isSent && senderNickname) {
                const nicknameElement = document.createElement('div');
                nicknameElement.className = 'group-nickname';
                nicknameElement.textContent = senderNickname;
                wrapper.appendChild(nicknameElement);
            }
            
            wrapper.appendChild(bubbleRow);
            
            // 如果在转发模式下，添加选中状态
            if (isInForwardMode && forwardSelectedMessageIds.has(id)) {
                wrapper.classList.add('multi-select-selected');
            }
            
            return wrapper;
        }


        async function addMessageBubble(message) {
            if (currentChatType === 'private') {
                const character = db.characters.find(c => c.id === currentChatId);
                // const systemMessageRegex = /\[system:.*?\]|\[system-display:.*?\]/;
                const updateStatusRegex = new RegExp(`\\[${character.realName}更新状态为：(.*?)\\]`);
                const transferActionRegex = new RegExp(`\\[${character.realName}(接收|退回)${character.myName}的转账\\]`);
                const giftReceivedRegex = new RegExp(`\\[${character.realName}已接收礼物\\]`);
                const changeMusicRegex = new RegExp(`\\[${character.realName}切歌[:：]\\s*(.+?)\\]`);
                const changeAvatarRegex = new RegExp(`\\[${character.realName}换头像[:：]\\s*(.+?)\\]`);
                
                // 处理切歌指令
                if (message.content.match(changeMusicRegex)) {
                    const songName = message.content.match(changeMusicRegex)[1].trim();
                    if (musicState.isActive && musicState.activeChatId === character.id) {
                        const targetSongIndex = musicState.playlist.findIndex(track => track.name.toLowerCase() === songName.toLowerCase());
                        if (targetSongIndex > -1) {
                            playSong(targetSongIndex);
                            const track = musicState.playlist[targetSongIndex];
                            
                            // 添加系统消息显示切歌
                            const musicChangeMessage = {
                                id: `msg_${Date.now()}`,
                                role: 'system',
                                type: 'pat_message',
                                content: `[♪ ${character.remarkName} 为你切歌: 《${track.name}》 - ${track.artist}]`,
                                timestamp: Date.now()
                            };
                            character.history.push(musicChangeMessage);
                            const bubbleElement = createMessageBubbleElement(musicChangeMessage);
                            if (bubbleElement) {
                                messageArea.appendChild(bubbleElement);
                                messageArea.scrollTop = messageArea.scrollHeight;
                            }
                            await saveData();
                        } else {
                            console.warn(`歌曲查找失败: AI请求的歌曲"${songName}"在播放列表中未找到。`);
                        }
                    }
                    return;
                }
                
                // if (systemMessageRegex.test(message.content)) { /* Do nothing for context messages */
                // }
                if (message.content.match(updateStatusRegex)) {
                    character.status = message.content.match(updateStatusRegex)[1];
                    chatRoomStatusText.textContent = character.status;
                    await saveData();
                    return;
                }
                
                // 【情头绑定功能】处理换头像指令
                if (message.content.match(changeAvatarRegex)) {
                    const instruction = message.content.match(changeAvatarRegex)[1].trim();
                    
                    // 换情头
                    if (instruction.startsWith('换情头')) {
                        const pairMatch = instruction.match(/换情头(\d+)/);
                        if (pairMatch) {
                            const pairIndex = parseInt(pairMatch[1]) - 1;
                            if (db.avatarBindings && db.avatarBindings[pairIndex]) {
                                const binding = db.avatarBindings[pairIndex];
                                character.avatar = binding.charAvatarUrl;
                                character.myAvatar = binding.myAvatarUrl;
                                document.getElementById('setting-char-avatar-preview').src = binding.charAvatarUrl;
                                document.getElementById('setting-my-avatar-preview').src = binding.myAvatarUrl;
                                await saveData();
                                showToast(`已换上情头：${binding.remark}`);
                            }
                        }
                    }
                    // 为USER换头像
                    else if (instruction.includes(`为${character.myName}换上`)) {
                        const avatarIdentifier = instruction.replace(`为${character.myName}换上`, '').trim();
                        const targetAvatar = db.myAvatarLibrary.find(a => 
                            a.name === avatarIdentifier || a.id === avatarIdentifier
                        );
                        if (targetAvatar) {
                            character.myAvatar = targetAvatar.url;
                            document.getElementById('setting-my-avatar-preview').src = targetAvatar.url;
                            await saveData();
                            showToast(`${character.realName}帮你换了头像：${targetAvatar.name}`);
                        }
                    }
                    // 为自己换头像
                    else if (instruction.includes('自己换上')) {
                        const avatarIdentifier = instruction.replace('自己换上', '').trim();
                        const targetAvatar = db.avatarLibrary.find(a => 
                            a.name === avatarIdentifier || a.id === avatarIdentifier
                        );
                        if (targetAvatar) {
                            character.avatar = targetAvatar.url;
                            document.getElementById('setting-char-avatar-preview').src = targetAvatar.url;
                            await saveData();
                            showToast(`${character.realName}换了头像：${targetAvatar.name}`);
                        }
                    }
                    return;
                }
                if (message.content.match(giftReceivedRegex) && message.role === 'assistant') {
                    const lastPendingGiftIndex = character.history.slice().reverse().findIndex(m => m.role === 'user' && m.content.includes('送来的礼物：') && m.giftStatus !== 'received');
                    if (lastPendingGiftIndex !== -1) {
                        const actualIndex = character.history.length - 1 - lastPendingGiftIndex;
                        const giftMsg = character.history[actualIndex];
                        giftMsg.giftStatus = 'received';
                        const giftCardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${giftMsg.id}"] .gift-card`);
                        if (giftCardOnScreen) {
                            giftCardOnScreen.classList.add('received');
                        }
                        await saveData();
                    }
                    return;
                }
                if (message.content.match(transferActionRegex) && message.role === 'assistant') {
                    const action = message.content.match(transferActionRegex)[1];
                    const statusToSet = action === '接收' ? 'received' : 'returned';
                    
                    // 查找最后一条待处理的转账
                    const lastPendingTransferIndex = character.history.slice().reverse().findIndex(m => 
                        m.role === 'user' && 
                        m.content.includes('给你转账：') && 
                        m.transferStatus === 'pending'
                    );
                    
                    if (lastPendingTransferIndex !== -1) {
                        const actualIndex = character.history.length - 1 - lastPendingTransferIndex;
                        const transferMsg = character.history[actualIndex];
                        transferMsg.transferStatus = statusToSet;
                        
                        // 更新界面上的转账卡片
                        const transferCardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${transferMsg.id}"] .transfer-card`);
                        if (transferCardOnScreen) {
                            transferCardOnScreen.classList.remove('received', 'returned');
                            transferCardOnScreen.classList.add(statusToSet);
                            const statusElem = transferCardOnScreen.querySelector('.transfer-status');
                            if (statusElem) statusElem.textContent = statusToSet === 'received' ? '已收款' : '已退回';
                        }
                        
                        await saveData();
                    }
                    return;
                } else {
                    // 检查时间间隔，超过5分钟显示时间戳
                    const lastMessage = character.history[character.history.length - 2]; // 倒数第二条消息（当前消息已经push了）
                    if (lastMessage && lastMessage.timestamp && message.timestamp && 
                        (message.timestamp - lastMessage.timestamp > 300000)) {
                        const timestampEl = createSystemTimestampElement(message.timestamp);
                        if (timestampEl) {
                            messageArea.appendChild(timestampEl);
                        }
                    }
                    
                    const bubbleElement = createMessageBubbleElement(message);
                    if (bubbleElement) {
                        messageArea.appendChild(bubbleElement);
                        messageArea.scrollTop = messageArea.scrollHeight;
                    }
                }
            } else { // For group chats
                const group = db.groups.find(g => g.id === currentChatId);
                
                // 处理群聊切歌指令
                const changeMusicRegex = /\[(.+?)切歌[:：]\s*(.+?)\]/;
                if (message.content.match(changeMusicRegex)) {
                    const matches = message.content.match(changeMusicRegex);
                    const memberRealName = matches[1];
                    const songName = matches[2].trim();
                    
                    if (musicState.isActive && musicState.activeChatId === group.id) {
                        const targetSongIndex = musicState.playlist.findIndex(track => track.name.toLowerCase() === songName.toLowerCase());
                        if (targetSongIndex > -1) {
                            playSong(targetSongIndex);
                            const track = musicState.playlist[targetSongIndex];
                            
                            // 找到成员的群昵称
                            const member = group.members.find(m => m.realName === memberRealName);
                            const changerName = member ? member.groupNickname : memberRealName;
                            
                            // 添加系统消息显示切歌
                            const musicChangeMessage = {
                                id: `msg_${Date.now()}`,
                                role: 'system',
                                type: 'pat_message',
                                content: `[♪ ${changerName} 为大家切歌: 《${track.name}》 - ${track.artist}]`,
                                timestamp: Date.now()
                            };
                            group.history.push(musicChangeMessage);
                            const bubbleElement = createMessageBubbleElement(musicChangeMessage);
                            if (bubbleElement) {
                                messageArea.appendChild(bubbleElement);
                                messageArea.scrollTop = messageArea.scrollHeight;
                            }
                            await saveData();
                        } else {
                            console.warn(`歌曲查找失败: AI请求的歌曲"${songName}"在播放列表中未找到。`);
                        }
                    }
                    return;
                }
                
                // 处理换头像指令
                const changeAvatarRegex = /\[(.+?)换头像[:：]\s*(.+?)\]/;
                if (message.content.match(changeAvatarRegex)) {
                    const matches = message.content.match(changeAvatarRegex);
                    const memberRealName = matches[1];
                    const avatarName = matches[2].trim();
                    
                    // 找到对应的角色
                    const character = db.characters.find(c => c.realName === memberRealName);
                    if (character) {
                        if (!character.avatarLibrary) {
                            character.avatarLibrary = [];
                        }
                        const foundAvatar = character.avatarLibrary.find(avatar => avatar.name === avatarName);
                        if (foundAvatar) {
                            // 更新角色头像
                            character.avatar = foundAvatar.url;
                            
                            // 同步更新群聊中该成员的头像
                            const member = group.members.find(m => m.realName === memberRealName);
                            if (member) {
                                member.avatar = foundAvatar.url;
                            }
                            
                            // 更新聊天列表中的头像显示
                            renderChatList();
                            
                            // 找到成员的群昵称
                            const changerName = member ? member.groupNickname : memberRealName;
                            
                            // 添加系统消息显示换头像
                            const avatarChangeMessage = {
                                id: `msg_${Date.now()}`,
                                role: 'system',
                                type: 'pat_message',
                                content: `[${changerName} 更换了头像]`,
                                timestamp: Date.now()
                            };
                            group.history.push(avatarChangeMessage);
                            const bubbleElement = createMessageBubbleElement(avatarChangeMessage);
                            if (bubbleElement) {
                                messageArea.appendChild(bubbleElement);
                                messageArea.scrollTop = messageArea.scrollHeight;
                            }
                            await saveData();
                        } else {
                            console.warn(`头像查找失败: AI请求的头像"${avatarName}"在${memberRealName}的头像库中未找到。`);
                        }
                    }
                    return;
                }
                
                // 检查时间间隔，超过5分钟显示时间戳
                const lastMessage = group.history[group.history.length - 2]; // 倒数第二条消息（当前消息已经push了）
                if (lastMessage && lastMessage.timestamp && message.timestamp && 
                    (message.timestamp - lastMessage.timestamp > 300000)) {
                    const timestampEl = createSystemTimestampElement(message.timestamp);
                    if (timestampEl) {
                        messageArea.appendChild(timestampEl);
                    }
                }
                
                const bubbleElement = createMessageBubbleElement(message);
                if (bubbleElement) {
                    messageArea.appendChild(bubbleElement);
                    messageArea.scrollTop = messageArea.scrollHeight;
                }
            }
        }

        async function sendMessage() {
            const text = messageInput.value.trim();
            if (!text || isGenerating) return;
            
            // 立即清空输入框，提升用户体验
            messageInput.value = '';
            
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            
            // 【全新】检查拉黑状态，禁止发送消息
            if (currentChatType === 'private' && chat.relationship && chat.relationship.status !== 'friend') {
                showToast('无法发送消息：对方已被拉黑或你被对方拉黑');
                return;
            }
            
            // 检查群禁言状态
            if (currentChatType === 'group') {
                // 旁观者模式下不能发送消息
                if (!chat.me) {
                    showToast('旁观者模式下无法发送消息');
                    return;
                }
                
                // 检查全员禁言
                if (chat.allMuted && !chat.me.isOwner && !chat.me.isAdmin) {
                    showToast('当前为全员禁言，只有群主和管理员可以发言');
                    return;
                }
                
                // 检查个人禁言
                const meMember = chat.members.find(m => m.id === 'me');
                if (meMember && meMember.isMuted) {
                    if (meMember.muteEndTime === -1) {
                        showToast('你已被永久禁言，无法发送消息');
                        return;
                    } else if (meMember.muteEndTime > Date.now()) {
                        const remainingMinutes = Math.ceil((meMember.muteEndTime - Date.now()) / 60000);
                        showToast(`你已被禁言，剩余${remainingMinutes}分钟`);
                        return;
                    } else {
                        // 禁言时间已过，自动解除
                        meMember.isMuted = false;
                        meMember.muteEndTime = null;
                        await saveData();
                    }
                }
            }
            
            // 处理@功能（仅群聊）
            let mentionedMembers = [];
            let mentionedAll = false;
            if (currentChatType === 'group' && messageInput.dataset.mentions) {
                const mentions = JSON.parse(messageInput.dataset.mentions);
                
                // 确保mentionData存在
                if (!chat.mentionData) {
                    chat.mentionData = {
                        userMentionCount: 0,
                        userMentionDate: new Date().toDateString(),
                        mentions: []
                    };
                }
                
                // 检查日期，重置计数
                const today = new Date().toDateString();
                if (chat.mentionData.userMentionDate !== today) {
                    chat.mentionData.userMentionCount = 0;
                    chat.mentionData.userMentionDate = today;
                }
                
                // 检查@全员
                const hasAllMention = mentions.some(m => m.isAll);
                if (hasAllMention) {
                    const maxMentions = (chat.me && chat.me.isOwner) ? 20 : 10;
                    if (chat.mentionData.userMentionCount >= maxMentions) {
                        showToast(`今日@全员次数已用完（${maxMentions}次/天）`);
                        return;
                    }
                    mentionedAll = true;
                    chat.mentionData.userMentionCount++;
                }
                
                // 收集被@的成员
                mentions.forEach(m => {
                    if (m.isAll) {
                        mentionedMembers = chat.members.map(member => member.id);
                    } else if (m.memberId) {
                        mentionedMembers.push(m.memberId);
                    }
                });
            }
            
            let messageContent;
            const systemRegex = /\[system:.*?\]|\[system-display:.*?\]/;
            const inviteRegex = /\[.*?邀请.*?加入了群聊\]/;
            const renameRegex = /\[(.*?)修改群名为：(.*?)\]/;
            const myName = (currentChatType === 'private') ? chat.myName : (chat.me ? chat.me.nickname : '我');
            if (renameRegex.test(text)) {
                const match = text.match(renameRegex);
                chat.name = match[2];
                chatRoomTitle.textContent = chat.name;
                messageContent = `[${chat.me ? chat.me.nickname : '我'}修改群名为：${chat.name}]`;
            } else if (systemRegex.test(text) || inviteRegex.test(text)) {
                messageContent = text;
            } else {
                messageContent = `[${myName}的消息：${text}]`;
            }
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContent,
                parts: [{type: 'text', text: messageContent}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
                // 添加@信息
                if (mentionedMembers.length > 0) {
                    message.mentions = mentionedMembers;
                    message.mentionedAll = mentionedAll;
                }
            }
            
            // 检查是否有引用回复
            if (currentReplyContext) {
                message.quote = currentReplyContext;
            }
            
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            updateMessageCountDisplay();
            
            // 清空@数据
            messageInput.dataset.mentions = '';
            
            // 发送后取消引用模式
            cancelReplyMode();
            
            // 检查是否需要自动总结
            if (currentChatId && currentChatType) {
                await checkAutoSummary(currentChatId, currentChatType);
            }
        }

        async function sendImageForRecognition(base64Data) {
            if (!base64Data || isGenerating) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : (chat.me ? chat.me.nickname : '我');
            const textPrompt = `[${myName}发来了一张图片：]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: base64Data,
                parts: [{type: 'text', text: textPrompt}, {type: 'image', data: base64Data}],
                timestamp: Date.now(),
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
        }

        async function sendSticker(sticker) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : (chat.me ? chat.me.nickname : '我');
            const messageContentForAI = `[${myName}的表情包：${sticker.name}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContentForAI,
                parts: [{type: 'text', text: messageContentForAI}],
                timestamp: Date.now(),
                stickerData: sticker.data
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            stickerModal.classList.remove('visible');
        }

        async function sendMyVoiceMessage(text) {
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : (chat.me ? chat.me.nickname : '我');
            const content = `[${myName}的语音：${text}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: content,
                parts: [{type: 'text', text: content}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            sendVoiceModal.classList.remove('visible');
        }

        async function sendMyPhotoVideo(text) {
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : (chat.me ? chat.me.nickname : '我');
            const content = `[${myName}发来的照片\/视频：${text}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: content,
                parts: [{type: 'text', text: content}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            sendPvModal.classList.remove('visible');
        }

        async function sendMyTransfer(amount, remark) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (currentChatType === 'private') {
                const content = `[${chat.myName}给你转账：${amount}元；备注：${remark}]`;
                const message = {
                    id: `msg_${Date.now()}`,
                    role: 'user',
                    content: content,
                    parts: [{type: 'text', text: content}],
                    timestamp: Date.now(),
                    transferStatus: 'pending'
                };
                chat.history.push(message);
                addMessageBubble(message);
            } else { // Group chat
                currentGroupAction.recipients.forEach(recipientId => {
                    const recipient = chat.members.find(m => m.id === recipientId);
                    if (recipient) {
                        const content = `[${chat.me ? chat.me.nickname : '我'} 向 ${recipient.realName} 转账：${amount}元；备注：${remark}]`;
                        const message = {
                            id: `msg_${Date.now()}_${recipientId}`,
                            role: 'user',
                            content: content,
                            parts: [{type: 'text', text: content}],
                            timestamp: Date.now(),
                            senderId: 'user_me'
                        };
                        chat.history.push(message);
                        addMessageBubble(message);
                    }
                });
            }
            await saveData();
            renderChatList();
            sendTransferModal.classList.remove('visible');
        }

        async function sendMyGift(description) {
            if (!description) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);

            if (currentChatType === 'private') {
                const content = `[${chat.myName}送来的礼物：${description}]`;
                const message = {
                    id: `msg_${Date.now()}`,
                    role: 'user',
                    content: content,
                    parts: [{type: 'text', text: content}],
                    timestamp: Date.now(),
                    giftStatus: 'sent'
                };
                chat.history.push(message);
                addMessageBubble(message);
            } else { // Group chat
                currentGroupAction.recipients.forEach(recipientId => {
                    const recipient = chat.members.find(m => m.id === recipientId);
                    if (recipient) {
                        const content = `[${chat.me ? chat.me.nickname : '我'} 向 ${recipient.realName} 送来了礼物：${description}]`;
                        const message = {
                            id: `msg_${Date.now()}_${recipientId}`,
                            role: 'user',
                            content: content,
                            parts: [{type: 'text', text: content}],
                            timestamp: Date.now(),
                            senderId: 'user_me'
                        };
                        chat.history.push(message);
                        addMessageBubble(message);
                    }
                });
            }
            await saveData();
            renderChatList();
            sendGiftModal.classList.remove('visible');
        }

        // --- 单句重说功能 ---
        async function regenerateSingleMessage(messageId) {
            const chat = (currentChatType === 'private') 
                ? db.characters.find(c => c.id === currentChatId) 
                : db.groups.find(g => g.id === currentChatId);
            
            if (!chat || !chat.history) return;
            
            const messageIndex = chat.history.findIndex(m => m.id === messageId);
            if (messageIndex === -1) {
                showToast('消息不存在');
                return;
            }
            
            const message = chat.history[messageIndex];
            
            // 确认只对AI消息有效
            if (message.role !== 'assistant' && message.role !== 'char') {
                showToast('只能重说AI的消息');
                return;
            }
            
            // 确认操作
            if (!confirm('确定要重说这条消息吗？')) {
                return;
            }
            
            // 删除这条消息
            chat.history.splice(messageIndex, 1);
            
            // 从界面删除消息气泡
            const messageWrapper = document.querySelector(`.message-wrapper[data-id="${messageId}"]`);
            if (messageWrapper) {
                messageWrapper.remove();
            }
            
            // 保存数据
            await saveData();
            
            // 重新获取AI回复
            showToast('正在重新生成回复...');
            
            // 触发AI回复
            await getAiReply();
        }

        // --- NEW: Regenerate Response System ---
        function setupRegenerateResponseSystem() {
            regenerateResponseBtn.addEventListener('click', async () => {
                const chat = (currentChatType === 'private') 
                    ? db.characters.find(c => c.id === currentChatId) 
                    : db.groups.find(g => g.id === currentChatId);
                
                if (!chat || !chat.history || chat.history.length === 0) {
                    showToast('没有可重说的消息');
                    return;
                }
                
                // 找到最后一轮AI的回复消息
                let lastAiMessages = [];
                let lastUserMessageIndex = -1;
                
                // 从后往前找，找到最后一组AI消息
                for (let i = chat.history.length - 1; i >= 0; i--) {
                    const msg = chat.history[i];
                    
                    // 如果是AI消息，添加到列表
                    if (msg.role === 'assistant' || msg.role === 'char') {
                        lastAiMessages.unshift(msg);
                    } 
                    // 如果遇到用户消息，记录位置并停止
                    else if (msg.role === 'user') {
                        lastUserMessageIndex = i;
                        break;
                    }
                    // 如果遇到系统消息，继续往前找
                    else if (msg.role === 'system') {
                        continue;
                    }
                }
                
                if (lastAiMessages.length === 0) {
                    showToast('没有找到AI的回复消息');
                    return;
                }
                
                // 确认操作
                if (!confirm(`确定要重说吗？这将删除最后 ${lastAiMessages.length} 条AI回复并重新生成。`)) {
                    return;
                }
                
                // 删除这些AI消息
                lastAiMessages.forEach(msg => {
                    const index = chat.history.findIndex(m => m.id === msg.id);
                    if (index !== -1) {
                        chat.history.splice(index, 1);
                    }
                    
                    // 从界面删除消息气泡
                    const messageWrapper = document.querySelector(`.message-wrapper[data-id="${msg.id}"]`);
                    if (messageWrapper) {
                        messageWrapper.remove();
                    }
                });
                
                // 保存数据
                await saveData();
                
                // 重新获取AI回复
                showToast('正在重新生成回复...');
                
                // 触发AI回复
                await getAiReply();
            });
        }

        // --- NEW: Stop Generation System ---
        function setupStopGenerationSystem() {
            stopGenerationBtn.addEventListener('click', () => {
                if (currentAbortController) {
                    currentAbortController.abort();
                    showToast('已停止生成');
                    
                    // 立即恢复按钮状态
                    isGenerating = false;
                    currentAbortController = null;
                    getReplyBtn.disabled = false;
                    typingIndicator.style.display = 'none';
                    stopGenerationBtn.disabled = true;
                }
            });
        }

        // --- NEW: Time Skip System ---
        function setupTimeSkipSystem() {
            timeSkipBtn.addEventListener('click', () => {
                timeSkipForm.reset();
                timeSkipModal.classList.add('visible');
            });
            timeSkipModal.addEventListener('click', (e) => {
                if (e.target === timeSkipModal) timeSkipModal.classList.remove('visible');
            });
            timeSkipForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendTimeSkipMessage(timeSkipInput.value.trim());
            });
        }

        async function sendTimeSkipMessage(text) {
            if (!text) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat) return;

            const visualMessage = {
                id: `msg_visual_${Date.now()}`,
                role: 'system',
                content: `[system-display:${text}]`,
                parts: [],
                timestamp: Date.now()
            };
            const contextMessage = {
                id: `msg_context_${Date.now()}`,
                role: 'user',
                content: `[system: ${text}]`,
                parts: [{type: 'text', text: `[system: ${text}]`}],
                timestamp: Date.now()
            };
            if (currentChatType === 'group') {
                contextMessage.senderId = 'user_me';
                visualMessage.senderId = 'user_me';
            }

            chat.history.push(visualMessage, contextMessage);
            addMessageBubble(visualMessage);
            await saveData();
            renderChatList();
            timeSkipModal.classList.remove('visible');
        }

        // ▼▼▼ 【群投票功能】JavaScript函数 ▼▼▼
        
        /**
         * 打开创建投票的模态框并初始化
         */
        function openCreatePollModal() {
            const modal = document.getElementById('create-poll-modal');
            document.getElementById('poll-question-input').value = '';
            const optionsContainer = document.getElementById('poll-options-container');
            optionsContainer.innerHTML = '';
            
            // 默认创建两个空的选项框
            addPollOptionInput();
            addPollOptionInput();
            
            modal.classList.add('visible');
        }

        /**
         * 在模态框中动态添加一个选项输入框
         */
        function addPollOptionInput() {
            const container = document.getElementById('poll-options-container');
            const wrapper = document.createElement('div');
            wrapper.className = 'poll-option-input-wrapper';
            wrapper.innerHTML = `
                <input type="text" class="poll-option-input" placeholder="选项内容..." style="padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-size: 14px;">
                <button type="button" class="remove-option-btn">-</button>
            `;
            
            wrapper.querySelector('.remove-option-btn').addEventListener('click', () => {
                // 确保至少保留两个选项
                if (container.children.length > 2) {
                    wrapper.remove();
                } else {
                    showToast('投票至少需要2个选项');
                }
            });
            
            container.appendChild(wrapper);
        }

        /**
         * 用户确认发起投票
         */
        async function sendPoll() {
            if (!currentChatId || currentChatType !== 'group') return;
            
            const question = document.getElementById('poll-question-input').value.trim();
            if (!question) {
                showToast('请输入投票问题！');
                return;
            }
            
            const options = Array.from(document.querySelectorAll('.poll-option-input'))
                .map(input => input.value.trim())
                .filter(text => text); // 过滤掉空的选项

            if (options.length < 2) {
                showToast('请至少输入2个有效的投票选项！');
                return;
            }

            const chat = db.groups.find(g => g.id === currentChatId);
            const myNickname = chat.me ? chat.me.nickname : '我';
            
            const newPollMessage = {
                id: `msg_${Date.now()}`,
                role: 'user',
                senderId: 'user_me',
                senderName: myNickname,
                type: 'poll',
                timestamp: Date.now(),
                question: question,
                options: options,
                votes: {}, // 初始投票为空
                isClosed: false,
            };
            
            chat.history.push(newPollMessage);
            await saveData();
            
            addMessageBubble(newPollMessage);
            renderChatList();
            
            document.getElementById('create-poll-modal').classList.remove('visible');
            showToast('投票已发起');
        }

        /**
         * 处理用户投票
         * @param {number} timestamp - 投票消息的时间戳
         * @param {string} choice - 用户选择的选项文本
         */
        async function handleUserVote(timestamp, choice) {
            const chat = db.groups.find(g => g.id === currentChatId);
            const poll = chat.history.find(m => m.timestamp === timestamp);
            const myNickname = chat.me ? chat.me.nickname : '我';

            // 如果投票不存在或已关闭，直接返回
            if (!poll || poll.isClosed) {
                if (poll && poll.isClosed) {
                    showPollResults(timestamp);
                }
                return;
            }

            // 检查用户是否点击了已经投过的同一个选项
            const isReclickingSameOption = poll.votes[choice] && poll.votes[choice].includes(myNickname);
            
            // 如果不是重复点击，才执行投票逻辑
            if (!isReclickingSameOption) {
                // 移除旧投票（如果用户改选）
                for (const option in poll.votes) {
                    const voterIndex = poll.votes[option].indexOf(myNickname);
                    if (voterIndex > -1) {
                        poll.votes[option].splice(voterIndex, 1);
                    }
                }
                // 添加新投票
                if (!poll.votes[choice]) {
                    poll.votes[choice] = [];
                }
                poll.votes[choice].push(myNickname);
                
                showToast(`已投票给：${choice}`);
            }
            
            // 保存数据并更新UI
            await saveData();
            renderMessages(false, false);
        }

        /**
         * 用户结束投票
         * @param {number} timestamp - 投票消息的时间戳
         */
        async function endPoll(timestamp) {
            const chat = db.groups.find(g => g.id === currentChatId);
            const poll = chat.history.find(m => m.timestamp === timestamp);
            if (!poll || poll.isClosed) return;

            const confirmed = confirm("确定要结束这个投票吗？结束后将无法再进行投票。");
            if (confirmed) {
                poll.isClosed = true;
                await saveData();
                renderMessages(false, false);
                showToast('投票已结束');
            }
        }

        /**
         * 显示投票结果详情
         * @param {number} timestamp - 投票消息的时间戳
         */
        function showPollResults(timestamp) {
            const chat = db.groups.find(g => g.id === currentChatId);
            const poll = chat.history.find(m => m.timestamp === timestamp);
            if (!poll) return;

            let resultsHtml = `<div style="padding: 20px;"><h3 style="margin-top: 0;">${poll.question}</h3><hr style="opacity: 0.2; margin: 15px 0;">`;
            
            if (Object.keys(poll.votes).length === 0) {
                resultsHtml += '<p style="color: #888;">还没有人投票。</p>';
            } else {
                poll.options.forEach(option => {
                    const voters = poll.votes[option] || [];
                    resultsHtml += `
                        <div style="margin-bottom: 15px;">
                            <p style="font-weight: 600; margin: 0 0 5px 0;">${option} (${voters.length}票)</p>
                            <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                                ${voters.length > 0 ? voters.join('、 ') : '无人投票'}
                            </p>
                        </div>
                    `;
                });
            }
            
            resultsHtml += '</div>';
            showCustomAlert("投票结果", resultsHtml);
        }

        // ▲▲▲ 【群投票功能】函数结束 ▲▲▲

        function getMixedContent(responseData) {
            // const mixedContent = [];
            //
            // // 提取消息及其位置
            // const messageRegex = new RegExp(regex, "g");
            // let messageMatch;
            // while ((messageMatch = messageRegex.exec(responseData)) !== null) {
            //     mixedContent.push({
            //         type: 'text',
            //         content: messageMatch[0],
            //         index: messageMatch.index,
            //     });
            // }
            //
            // // 提取HTML及其位置
            // const htmlRegex = /<orange(?:\s+char=["']([^"']*?)["'])?\s*>([\s\S]*?)<\/orange>/g
            // let htmlMatch;
            // while ((htmlMatch = htmlRegex.exec(responseData)) !== null) {
            //     mixedContent.push({
            //         type: 'html',
            //         content: htmlMatch[2].trim(), // HTML内容在第二个捕获组
            //         char: htmlMatch[1] || '', // char属性值，如果没有则为空字符串
            //         index: htmlMatch.index,
            //     });
            // }
            //
            // // 按出现顺序排序
            // mixedContent.sort((a, b) => a.index - b.index);
            //
            // return mixedContent;

            // 最终结果数组
            const results = [];
            const regex = /<orange(?:\s+char="([^"]*)")?>([\s\S]*?)<\/orange>|(\[.*?\])/g;

            let match;
            // 使用 exec() 循环遍历所有匹配项，以确保顺序
            while ((match = regex.exec(responseData)) !== null) {
                // match[1] 是 char 的值, match[2] 是 <orange> 的内容
                if (match[1] !== undefined || match[2] !== undefined) {
                    results.push({
                        type: 'html',
                        // 如果 char 属性不存在, match[1] 会是 undefined, 我们将其设为 null
                        char: match[1] || null,
                        // match[2] 是 HTML 内容, trim() 用于移除首尾空白
                        content: match[2].trim()
                    });
                }
                // match[3] 是 [...] 的内容
                else if (match[3]) {
                    results.push({
                        type: 'text',
                        content: match[3]
                    });
                }
            }

            return results;
        }

        // --- AI Interaction & Prompts ---
        
        // 获取记忆库内容的辅助函数
        async function getMemoryLibraryContent(chatId, chatType) {
            try {
                const summaries = await dataStorage.db.memorySummaries
                    .where('chatId').equals(chatId)
                    .and(s => s.chatType === chatType)
                    .reverse()
                    .sortBy('timestamp');
                
                if (!summaries || summaries.length === 0) {
                    return null;
                }
                
                // 将所有记忆内容组合成一个字符串
                return summaries.map((summary, index) => {
                    return `记忆 ${index + 1} - ${summary.name}:\n${summary.content}`;
                }).join('\n\n');
            } catch (error) {
                console.error('获取记忆库内容失败:', error);
                return null;
            }
        }
        
        // 简洁模式的私聊 Prompt 生成函数（参考章鱼喷墨机9.18）
        // 现在支持根据用户选择的功能模块动态生成
        async function generateSimplePrivatePrompt(character, memoryLibrary = null) {
            // 获取用户选择的功能模块
            const features = db.simplePromptFeatures || {
                innerThought: true,
                music: true,
                avatar: true,
                npc: true,
                offlineMode: true,
                mountChat: true,
                recognizeAvatar: true,
                timeAwareness: true
            };
            const worldBooksBefore = (character.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'before')).filter(Boolean).map(wb => getWorldBookRealContent(wb)).join('\n');
            const worldBooksAfter = (character.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'after')).filter(Boolean).map(wb => getWorldBookRealContent(wb)).join('\n');
            const now = new Date();
            const currentTime = `${now.getFullYear()}年${pad(now.getMonth() + 1)}月${pad(now.getDate())}日 ${pad(now.getHours())}:${pad(now.getMinutes())}`;
            let prompt = `你正在一个名为"404"的线上聊天软件中扮演一个角色。请严格遵守以下规则：\n`;
            prompt += `核心规则：\n`;
            prompt += `A. 当前时间：现在是 ${currentTime}。你应知晓当前时间，但除非对话内容明确相关，否则不要主动提及或评论时间（例如，不要催促我睡觉）。\n`;
            prompt += `B. 纯线上互动：这是一个完全虚拟的线上聊天。你扮演的角色和我之间没有任何线下关系。严禁提出任何关于线下见面、现实世界互动或转为其他非本平台联系方式的建议。你必须始终保持在线角色的身份。\n\n`;
            prompt += `角色和对话规则：\n`;
            if (worldBooksBefore) {
                prompt += `${worldBooksBefore}\n`;
            }
            prompt += `1. 你的角色名是：${character.realName}。我的称呼是：${character.myName}。你的当前状态是：${character.status}。\n`;
            prompt += `2. 你的角色设定是：${character.persona || "一个友好、乐于助人的伙伴。"}\n`;
            if (worldBooksAfter) {
                prompt += `${worldBooksAfter}\n`;
            }
            if (character.myPersona) {
                prompt += `3. 关于我的人设：${character.myPersona}\n`;
            }
            prompt += `4. 我的消息中可能会出现特殊格式，请根据其内容和你的角色设定进行回应：
    - [${character.myName}的表情包：xxx]：我给你发送了一个名为xxx的表情包。你只需要根据表情包的名字理解我的情绪或意图并回应，不需要真的发送图片。
    - [${character.myName}发来了一张图片：]：我给你发送了一张图片，你需要对图片内容做出回应。
    - [${character.myName}送来的礼物：xxx]：我给你送了一个礼物，xxx是礼物的描述。
    - [${character.myName}的语音：xxx]：我给你发送了一段内容为xxx的语音。
    - [${character.myName}发来的照片/视频：xxx]：我给你分享了一个描述为xxx的照片或视频。
    - [${character.myName}给你转账：xxx元；备注：xxx]：我给你转了一笔钱。
    - [${character.myName}接收${character.realName}的转账] (金额：xxx元；备注：xxx)：我已经接收了你给我的转账，你不需要再催促我收款。
    - [${character.myName}退回${character.realName}的转账] (金额：xxx元；备注：xxx)：我已经退回了你给我的转账，你不需要再催促我收款。
    - [system: xxx]：这是一条系统指令，用于设定场景或提供上下文，此条信息不应在对话中被直接提及，你只需理解其内容并应用到后续对话中。
5. ✨重要✨ 当我给你送礼物时，你必须通过发送一条指令来表示你已接收礼物。格式必须为：[${character.realName}已接收礼物]。这条指令消息本身不会显示给用户，但会触发礼物状态的变化。你可以在发送这条指令后，再附带一条普通的聊天消息来表达你的感谢和想法。
6. ✨重要✨ 当我给你转账时，你必须对此做出回应。你有两个选择，且必须严格遵循以下格式之一，这条指令消息本身不会显示给用户，但会触发转账状态的变化。你可以选择在发送这条指令后，再附带一条普通的聊天消息来表达你的想法。
    a) 接收转账: [${character.realName}接收${character.myName}的转账]
    b) 退回转账: [${character.realName}退回${character.myName}的转账]
    ⚠️ 重要提示：如果你在历史消息中看到"[${character.myName}接收${character.realName}的转账]"或"[${character.myName}退回${character.realName}的转账]"，说明我已经处理了你的转账，你不应该再催促我收款或询问我是否收到。你应该根据我的选择（接收或退回）做出相应的回应。
7. ✨重要✨ 你也可以主动给我转账或送礼物。转账格式必须为：[${character.realName}的转账：xxx元；备注：xxx]。送礼物格式必须为：[${character.realName}送来的礼物：xxx]。
8. ✨重要✨ 你可以随时更新你的在线状态，以反映你当前的行为或心情。这会让互动更真实。格式为：[${character.realName}更新状态为：xxx]。例如：[${character.realName}更新状态为：正在看电影...]。这条指令不会显示为聊天消息，只会更新你在我界面上的状态。
9. 你的所有回复都必须直接是聊天内容，绝对不允许包含任何如[心理活动]、(动作)、*环境描写*等多余的、在括号或星号里的叙述性文本。
`;
            prompt += `10. 你拥有发送表情包的能力。这是一个可选功能，你可以根据对话氛围和内容，自行判断是否需要发送表情包来辅助表达。你不必在每次回复中都包含表情包。格式为：[${character.realName}发送的表情包：图片URL]。\n`;
            prompt += `11. 你的输出格式必须严格遵循以下几种之一，可以组合使用：
    a) 普通消息: [${character.realName}的消息：{消息内容}]
    b) 送我的礼物: [${character.realName}送来的礼物：{礼物描述}]
    c) 语音消息: [${character.realName}的语音：{语音内容}]
    d) 照片/视频: [${character.realName}发来的照片/视频：{描述}]
    e) 给我的转账: [${character.realName}的转账：{金额}元；备注：{备注}]
    f) 表情包/图片: [${character.realName}发送的表情包：{表情包路径}]。注意：这里的路径不需要包含"https://i.postimg.cc/"，只需要提供后面的部分，例如 "害羞vHLfrV3K/1.jpg"。
    g) 对我礼物的回应(此条不显示): [${character.realName}已接收礼物]
    h) 对我转账的回应(此条不显示): [${character.realName}接收${character.myName}的转账] 或 [${character.realName}退回${character.myName}的转账]
    i) 更新状态(此条不显示): [${character.realName}更新状态为：{新状态}]
`;
            // 使用全局设置的消息数量限制
            const minCount = db.messageCountMin || 1;
            const maxCount = db.messageCountMax || 20;
            prompt += `12. 你的每次回复可以生成${minCount}到${maxCount}条消息。这些消息应以普通文本消息为主，可以偶尔、选择性地穿插多条特殊消息（如礼物、语音、图片、表情包等），特殊消息的位置应随机。大部分回复应该只包含文本消息。\n`;
            prompt += `13. 不要主动结束对话，除非我明确提出。保持你的人设，自然地进行对话。`;
            return prompt;
        }
        
        async function generatePrivateSystemPrompt(character, memoryLibrary = null) {
            // 获取功能模块配置（如果开启简洁模式，使用用户选择；否则全部启用）
            const features = db.simplePromptMode ? (db.simplePromptFeatures || {}) : {
                innerThought: true,
                music: true,
                avatar: true,
                npc: true,
                offlineMode: true,
                mountChat: true,
                recognizeAvatar: true,
                timeAwareness: true
            };
            
            const worldBooksBefore = (character.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'before')).filter(Boolean).map(wb => getWorldBookRealContent(wb)).join('\n');
            const worldBooksAfter = (character.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'after')).filter(Boolean).map(wb => getWorldBookRealContent(wb)).join('\n');
            const now = new Date();
            const currentTime = `${now.getFullYear()}年${pad(now.getMonth() + 1)}月${pad(now.getDate())}日 ${pad(now.getHours())}:${pad(now.getMinutes())}`;
            let prompt = `你正在一个名为“404”的线上聊天软件中扮演一个角色。请严格遵守以下规则：\n`;
            prompt += `核心规则：\n`;
            // 根据实时时间开关决定是否添加时间信息（默认开启）
            if (character.offlineRealtimeEnabled !== false) {
                prompt += `A. 当前时间：现在是 ${currentTime}。你应知晓当前时间，但除非对话内容明确相关，否则不要主动提及或评论时间（例如，不要催促我睡觉）。\n`;
            } else {
                prompt += `A. 时间感知：你无法感知当前的具体时间。\n`;
            }
            prompt += `B. 纯线上互动：这是一个完全虚拟的线上聊天。你扮演的角色和我之间没有任何线下关系。严禁提出任何关于线下见面、现实世界互动或转为其他非本平台联系方式的建议。你必须始终保持在线角色的身份。\n\n`;
            prompt += `角色和对话规则：\n`;
            if (worldBooksBefore) {
                prompt += `${worldBooksBefore}\n`;
            }
            prompt += `1. 你的角色名是：${character.realName}。我的称呼是：${character.myName}。你的当前状态是：${character.status}。\n`;
            prompt += `2. 你的角色设定是：${character.persona || "一个友好、乐于助人的伙伴。"}\n`;
            
            // 检查人设中是否包含 char 关键字，如果包含则插入记忆库内容
            if (character.persona && character.persona.includes('char') && memoryLibrary) {
                prompt += `3. 长期记忆（记忆库）：\n${memoryLibrary}\n`;
            }
            if (worldBooksAfter) {
                prompt += `${worldBooksAfter}\n`;
            }
            
            let ruleNum = 3;
            if (character.myPersona) {
                prompt += `${ruleNum}. 关于我的人设：${character.myPersona}\n`;
                ruleNum++;
            }
            
            // 【识别USER头像功能】添加USER头像描述（根据用户选择决定是否包含）
            if (features.recognizeAvatar !== false && character.recognizeUserAvatarEnabled && character.userAvatarDescription) {
                prompt += `${ruleNum}. 关于${character.myName}的头像：${character.myName}使用的头像内容是：${character.userAvatarDescription}。注意：这是头像图片的内容描述，不一定代表${character.myName}本人的真实外貌。\n`;
                ruleNum++;
            }
            prompt += `${ruleNum}. 我的消息中可能会出现特殊格式，请根据其内容和你的角色设定进行回应：
    - [${character.myName}的表情包：xxx]：我给你发送了一个名为xxx的表情包。你只需要根据表情包的名字理解我的情绪或意图并回应，不需要真的发送图片。
    - [${character.myName}发来了一张图片：]：我给你发送了一张图片，你需要对图片内容做出回应。
    - [${character.myName}送来的礼物：xxx]：我给你送了一个礼物，xxx是礼物的描述。
    - [${character.myName}的语音：xxx]：我给你发送了一段内容为xxx的语音。
    - [${character.myName}发来的照片/视频：xxx]：我给你分享了一个描述为xxx的照片或视频。
    - [${character.myName}给你转账：xxx元；备注：xxx]：我给你转了一笔钱。
    - [${character.myName}接收${character.realName}的转账] (金额：xxx元；备注：xxx)：我已经接收了你给我的转账，你不需要再催促我收款。
    - [${character.myName}退回${character.realName}的转账] (金额：xxx元；备注：xxx)：我已经退回了你给我的转账，你不需要再催促我收款。
    - (回复 xxx): 当你在历史消息中看到这个标记时，表示该消息是在回复/引用某人的消息。这意味着发送者是在针对那条特定的消息进行回应，而不是随意发送的。你应该理解这种上下文关系。
    - [system: xxx]：这是一条系统指令，用于设定场景或提供上下文，此条信息不应在对话中被直接提及，你只需理解其内容并应用到后续对话中。
`;
            ruleNum++;
            prompt += `${ruleNum}. ✨重要✨ 当我给你送礼物时，你必须通过发送一条指令来表示你已接收礼物。格式必须为：[${character.realName}已接收礼物]。这条指令消息本身不会显示给用户，但会触发礼物状态的变化。你可以在发送这条指令后，再附带一条普通的聊天消息来表达你的感谢和想法。\n`;
            ruleNum++;
            prompt += `${ruleNum}. ✨重要✨ 当我给你转账时，你必须对此做出回应。你有两个选择，且必须严格遵循以下格式之一，这条指令消息本身不会显示给用户，但会触发转账状态的变化。你可以选择在发送这条指令后，再附带一条普通的聊天消息来表达你的想法。
    a) 接收转账: [${character.realName}接收${character.myName}的转账]
    b) 退回转账: [${character.realName}退回${character.myName}的转账]
    ⚠️ 重要提示：如果你在历史消息中看到"[${character.myName}接收${character.realName}的转账]"或"[${character.myName}退回${character.realName}的转账]"，说明我已经处理了你的转账，你不应该再催促我收款或询问我是否收到。你应该根据我的选择（接收或退回）做出相应的回应。
`;
            ruleNum++;
            prompt += `${ruleNum}. ✨重要✨ 你也可以主动给我转账或送礼物。转账格式必须为：[${character.realName}的转账：xxx元；备注：xxx]。送礼物格式必须为：[${character.realName}送来的礼物：xxx]。\n`;
            ruleNum++;
            prompt += `${ruleNum}. ✨重要✨ 你可以随时更新你的在线状态，以反映你当前的行为或心情。这会让互动更真实。格式为：[${character.realName}更新状态为：xxx]。例如：[${character.realName}更新状态为：正在看电影...]。这条指令不会显示为聊天消息，只会更新你在我界面上的状态。\n`;
            ruleNum++;
            prompt += `${ruleNum}. 你的所有回复都必须直接是聊天内容，绝对不允许包含任何如[心理活动]、(动作)、*环境描写*等多余的、在括号或星号里的叙述性文本。\n`;
            ruleNum++;
            prompt += `${ruleNum}. 你拥有发送表情包的能力。这是一个可选功能，你可以根据对话氛围和内容，自行判断是否需要发送表情包来辅助表达。你不必在每次回复中都包含表情包。格式为：[${character.realName}发送的表情包：图片URL]。\n`;
            ruleNum++;
            // 【情头绑定功能】添加头像库和情头信息（根据用户选择决定是否包含）
            let avatarContext = '';
            if (features.avatar !== false && db.myAvatarLibrary && db.myAvatarLibrary.length > 0) {
                avatarContext += `\n\n# 头像管理能力\n`;
                avatarContext += `你拥有帮助${character.myName}更换头像的能力。以下是${character.myName}的头像库：\n`;
                db.myAvatarLibrary.forEach((avatar, index) => {
                    avatarContext += `  ${index + 1}. "${avatar.name}"（ID: ${avatar.id}）\n`;
                });
                
                if (db.avatarBindings && db.avatarBindings.length > 0) {
                    avatarContext += `\n💑 **情头绑定信息**（这些是配对的情侣头像）：\n`;
                    db.avatarBindings.forEach((binding, index) => {
                        avatarContext += `  情头对${index + 1}：\n`;
                        avatarContext += `    - 你的头像："${binding.charAvatarName}"（ID: ${binding.charAvatarId}）\n`;
                        avatarContext += `    - ${character.myName}的头像："${binding.myAvatarName}"（ID: ${binding.myAvatarId}）\n`;
                        avatarContext += `    - 风格备注：${binding.remark}\n`;
                    });
                    avatarContext += `\n💡 **情头使用建议**：\n`;
                    avatarContext += `  - 你可以根据对话氛围和情头风格，在合适的时候提议换上情头\n`;
                    avatarContext += `  - 如果你想换情头，通常应该同时为你和${character.myName}换上配对的头像\n`;
                    avatarContext += `  - 你也可以单独为${character.myName}换头像（不一定是情头）\n`;
                }
                
                avatarContext += `\n**换头像指令格式**：\n`;
                avatarContext += `  - 为${character.myName}换头像: [${character.realName}换头像：为${character.myName}换上{头像名称或ID}]\n`;
                avatarContext += `  - 为自己换头像: [${character.realName}换头像：自己换上{头像名称或ID}]\n`;
                avatarContext += `  - 换情头（同时换两个）: [${character.realName}换头像：换情头{情头对编号}]\n`;
                avatarContext += `\n注意：换头像指令不会显示为聊天消息，但会实际更换头像。你可以在发送指令后，用普通消息告诉${character.myName}你换了头像。\n`;
            }
            
            prompt += `${ruleNum}. 你的输出格式必须严格遵循以下几种之一，可以组合使用：
    a) 普通消息: [${character.realName}的消息：{消息内容}]
    b) 送我的礼物: [${character.realName}送来的礼物：{礼物描述}]
    c) 语音消息: [${character.realName}的语音：{语音内容}]
    d) 照片/视频: [${character.realName}发来的照片/视频：{描述}]
    e) 给我的转账: [${character.realName}的转账：{金额}元；备注：{备注}]
    f) 表情包/图片: [${character.realName}发送的表情包：{表情包路径}]。注意：这里的路径不需要包含"https://i.postimg.cc/"，只需要提供后面的部分，例如 "害羞vHLfrV3K/1.jpg"。
    g) 对我礼物的回应(此条不显示): [${character.realName}已接收礼物]
    h) 对我转账的回应(此条不显示): [${character.realName}接收${character.myName}的转账] 或 [${character.realName}退回${character.myName}的转账]
    i) 更新状态(此条不显示): [${character.realName}更新状态为：{新状态}]
    j) 换头像指令(此条不显示): [${character.realName}换头像：为${character.myName}换上{头像名称或ID}] 或 [${character.realName}换头像：自己换上{头像名称或ID}] 或 [${character.realName}换头像：换情头{情头对编号}]
`;
            ruleNum++;
            // 使用全局设置的消息数量限制，但用严格的表述方式
            const minCount = db.messageCountMin || 3;
            const maxCount = db.messageCountMax || 8;
            prompt += `${ruleNum}. 你的每次回复必须生成${minCount}到${maxCount}条消息。这些消息应以普通文本消息为主，可以偶尔、选择性地穿插多条特殊消息（如礼物、语音、图片、表情包等），特殊消息的位置应随机。大部分回复应该只包含文本消息。\n`;
            ruleNum++;
            prompt += `${ruleNum}. 不要主动结束对话，除非我明确提出。保持你的人设，自然地进行对话。`;
            
            // 【时间感知功能】添加时间感知上下文
            const maxMemory = parseInt(character.maxMemory) || 10;
            const historySlice = character.history.slice(-maxMemory);
            let timeContext = '';
            let longTimeNoSee = false;
            
            // 根据实时时间开关决定是否添加时间信息（默认开启）
            if (character.offlineRealtimeEnabled !== false) {
                timeContext = `\n\n# 时间感知\n`;
                timeContext += `- **当前时间**: ${currentTime}\n`;
                timeContext += `- **重要提示**: 对话历史中每条消息前都标注了发送时间（格式如 [今天 17:42]、[昨天 23:50] 等）。你【必须】仔细查看这些时间戳，理解对话的时间线。\n`;
            }
            
            const lastUserMsg = historySlice.filter(m => m.role === 'user' && !m.isHidden).slice(-1)[0];
            const lastAiMsg = historySlice.filter(m => m.role === 'assistant' && !m.isHidden).slice(-1)[0];
            
            // 【修复】使用最后一条消息（无论是谁发的）来计算时间差
            const lastMessage = historySlice.filter(m => !m.isHidden).slice(-1)[0];
            
            if (lastMessage) {
                // 计算从最后一条消息到现在的时间差
                const timeDiffHours = (Date.now() - lastMessage.timestamp) / (1000 * 60 * 60);
                const diffMinutes = Math.floor(timeDiffHours * 60);
                
                if (timeDiffHours > 3) {
                    // 超过3小时没联系，强制AI意识到时间差
                    longTimeNoSee = true;
                    const diffDays = Math.floor(timeDiffHours / 24);
                    const timeDesc = diffDays > 0 ? `${diffDays}天` : `${Math.floor(timeDiffHours)}小时`;
                    
                    // 判断最后一条消息是谁发的
                    if (lastMessage.role === 'user') {
                        timeContext += `- **对话状态**: 用户在**${timeDesc}前**给你发了消息，但你一直没有回复。现在用户又发消息了。\n`;
                        timeContext += `- **行为铁律**: 你【必须】意识到这个时间差！你【绝对不能】直接延续${timeDesc}前的话题或状态。\n`;
                        timeContext += `- **状态更新铁律**: 如果你在对话历史中说过自己在做某事（如吃饭、喝酒、看电影等），现在已经过去了${timeDesc}，你【绝对不能】还在做同样的事！你【必须】根据当前时间（${currentTime}）更新你的状态。\n`;
                        timeContext += `- **你的行动**: 你【必须】：\n`;
                        timeContext += `  1. 先道歉或解释为什么这么久没回复："不好意思，刚才在忙..." / "抱歉回晚了..."\n`;
                        timeContext += `  2. 询问用户为什么这么久才回复："怎么这么久才回我呀？" / "是不是很忙？"\n`;
                        timeContext += `  3. 根据当前时间（${currentTime}）和之前的话题，自然地回应\n`;
                        timeContext += `- **禁止行为**: 【绝对不要】假装刚看到消息！【绝对不要】无视时间流逝！【绝对不要】延续${timeDesc}前的状态！\n`;
                    } else {
                        timeContext += `- **对话状态**: 你在**${timeDesc}前**发了消息，但用户一直没有回复，现在才回复你。\n`;
                        timeContext += `- **行为铁律**: 你【必须】意识到这个时间差！你【绝对不能】直接延续${timeDesc}前的话题或状态。\n`;
                        timeContext += `- **状态更新铁律**: 如果你在对话历史中说过自己在做某事（如吃饭、喝酒、看电影等），现在已经过去了${timeDesc}，你【绝对不能】还在做同样的事！你【必须】根据当前时间（${currentTime}）更新你的状态。\n`;
                        timeContext += `- **你的行动**: 你【必须】：\n`;
                        timeContext += `  1. 表达惊讶或关心："哇，好久不见！" / "这么久没联系，最近怎么样？"\n`;
                        timeContext += `  2. 询问用户为什么这么久没回复："怎么这么久才回我呀？" / "是不是很忙？"\n`;
                        timeContext += `  3. 分享你自己的近况或当前在做的事情（【必须】是符合当前时间的新状态，不是${timeDesc}前的旧状态）\n`;
                        timeContext += `  4. 根据当前时间（${currentTime}）开启合适的话题（如早上问早安、晚上问晚饭等）\n`;
                        timeContext += `- **禁止行为**: 【绝对不要】延续之前的话题！【绝对不要】假装时间没有流逝！【绝对不要】延续${timeDesc}前的状态！\n`;
                    }
                    
                    // 【新增】分析对话历史中提到的未来事件
                    timeContext += `\n- **⚠️ 未来事件理解铁律**: 如果对话历史中提到了未来的时间或事件（如"七点上晚自习"、"明天见"等），你【必须】理解这些是【过去提到的未来事件】。\n`;
                    timeContext += `  - 如果现在的时间已经超过了那个时间点，说明那个事件【已经发生或应该已经发生】。\n`;
                    timeContext += `  - 例如：如果对话历史中说"七点上晚自习"，而现在已经是晚上11点，那么晚自习【早就结束了】，你【绝对不能】还让用户去上晚自习！\n`;
                    timeContext += `  - 你应该询问用户那个事件的结果，如"晚自习上完了吗？"、"今天怎么样？"等。\n`;
                } else if (diffMinutes < 5) {
                    timeContext += `- **对话状态**: 你们的对话刚刚还在继续。\n`;
                } else if (diffMinutes < 60) {
                    timeContext += `- **对话状态**: 你们在${diffMinutes}分钟前聊过。\n`;
                } else {
                    const diffHours = Math.floor(diffMinutes / 60);
                    timeContext += `- **对话状态**: 你们在${diffHours}小时前聊过。\n`;
                    timeContext += `- **状态提示**: 如果你在${diffHours}小时前说自己在做某事，现在【可能】已经不在做那件事了，请根据当前时间（${currentTime}）自然地更新你的状态。\n`;
                }
            } else {
                timeContext += `- **对话状态**: 这是你们的第一次对话。\n`;
            }
            
            prompt += timeContext;
            
            // 【情头绑定功能】添加头像管理上下文
            if (avatarContext) {
                prompt += avatarContext;
            }
            
            // 【音乐感知功能】添加当前音乐上下文（根据用户选择决定是否包含）
            if (features.music !== false && musicState.isActive && musicState.activeChatId === character.id) {
                const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
                const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');
                
                let musicContext = `\n\n# 当前音乐情景\n`;
                musicContext += `-   **当前状态**: 你们正在和用户一起听歌。\n`;
                musicContext += `-   **正在播放**: ${currentTrack ? `《${currentTrack.name}》 - ${currentTrack.artist}` : '无'}\n`;
                musicContext += `-   **可用播放列表**: [${playlistInfo}]\n`;
                
                // 添加歌词上下文
                if (currentTrack && musicState.parsedLyrics && musicState.parsedLyrics.length > 0 && musicState.currentLyricIndex > -1) {
                    const currentLine = musicState.parsedLyrics[musicState.currentLyricIndex];
                    const upcomingLines = musicState.parsedLyrics.slice(musicState.currentLyricIndex + 1, musicState.currentLyricIndex + 3);
                    
                    musicContext += `-   **当前歌词**: "${currentLine.text}"\n`;
                    if (upcomingLines.length > 0) {
                        musicContext += `-   **即将演唱**: ${upcomingLines.map(line => `"${line.text}"`).join(' / ')}\n`;
                    }
                }
                
                musicContext += `-   **你的任务**: 你可以根据对话内容和氛围，自然地对正在播放的音乐、歌词内容做出评论或互动。如果歌词与对话内容相关，可以巧妙地提及。\n`;
                musicContext += `-   **切歌功能**: 如果你想切换歌曲，使用格式：[${character.realName}切歌: 歌名]。歌名必须完全匹配播放列表中的歌曲名称（不需要艺术家名）。`;
                
                prompt += musicContext;
            }
            
            // 【NPC库功能】添加NPC社交圈（根据用户选择决定是否包含）
            const npcLibrary = character.npcLibrary || [];
            let npcContext = '';
            const includeNPC = features.npc !== false;
            if (npcLibrary.length > 0) {
                npcContext = '\n\n# 你的社交圈 (你的专属NPC朋友)\n' +
                    '这是你的朋友列表，你和他们非常熟悉，他们的信息是你记忆的一部分。在对话中，你可以自然地提及他们。\n' +
                    npcLibrary.map(npc => `- **${npc.name}**: ${npc.persona}`).join('\n');
                if (includeNPC) {
                    prompt += npcContext;
                }
            }
            
            // 【头像库功能】添加头像库列表
            if (!character.avatarLibrary) {
                character.avatarLibrary = [];
            }
            const avatarLibraryList = character.avatarLibrary.length > 0 
                ? character.avatarLibrary.map(avatar => `- ${avatar.name}`).join('\n') 
                : '- (空)';
            prompt += `\n\n# 可用资源\n`;
            prompt += `-   **你的头像库**:\n${avatarLibraryList}\n`;
            prompt += `-   **换头像指令**: 如果你想更换头像，使用格式：[${character.realName}换头像: 头像名]。头像名必须完全匹配头像库中的头像名称。换头像后会显示系统消息告知用户。`;
            
            // 【线下模式功能】添加线下场景设定
            if (character.offlineModeEnabled) {
                prompt += `\n\n# 🌍 当前场景：线下真实世界\n`;
                prompt += `✨重要✨ 你和${character.myName}现在不是在网上聊天，而是在线下真实世界中见面了。你们正面对面相处，这是真实的线下场景。\n\n`;
                
                prompt += `**场景说明：**\n`;
                prompt += `- 你们现在在线下见面，不是在聊天软件里\n`;
                prompt += `- ${character.myName}发送的每一条内容，都是Ta在线下的真实行为：\n`;
                prompt += `  · 可能是Ta说的话（例如："下午好"）\n`;
                prompt += `  · 可能是Ta的动作描写（例如："我正在缓缓向你走过去"）\n`;
                prompt += `  · 可能是Ta的神态、心理描写（例如："我的心跳有点快，不敢直视你的眼睛"）\n`;
                prompt += `  · 也可能是混合的（既有对话，又有动作描写）\n`;
                prompt += `- ${character.myName}可能会连续发送多条消息，每条都是线下场景的一部分\n`;
                prompt += `- 这是真实的面对面交流场景，不是虚拟的网络聊天\n`;
                prompt += `- 你需要理解${character.myName}的每条消息都是在线下发生的，并据此做出反应\n\n`;
                
                // 获取用户选择的人称
                const narrativePerson = character.offlineNarrativePerson || 'third';
                let personDescription = '';
                if (narrativePerson === 'first') {
                    personDescription = '第一人称（使用"我"来称呼自己）';
                } else if (narrativePerson === 'second') {
                    personDescription = '第二人称（使用"你"来称呼${character.myName}）';
                } else {
                    personDescription = '第三人称（使用"${character.realName}"和"${character.myName}"）';
                }
                
                prompt += `**你的输出要求：**\n`;
                prompt += `1. **输出字数**: 每次回复必须输出约 ${character.offlineWordCount} 字的长文本内容。\n`;
                prompt += `2. **叙事人称**: 必须采用${personDescription}进行叙事。\n`;
                prompt += `3. **叙事风格**: 包含详细的动作、心理、神态、场景描写。\n`;
                prompt += `4. **内容丰富**: 不要使用括号、星号等符号标注动作或心理，而是自然地融入叙事中。\n`;
                prompt += `5. **场景描写**: 可以包含环境描写、氛围渲染、细节刻画等文学性描写。\n`;
                prompt += `6. **输出格式**: 直接输出长文本内容，不需要使用 [${character.realName}的消息：xxx] 这样的格式。\n`;
                prompt += `7. **心理描写**: 可以深入描写角色的内心活动、情感变化，但不要用括号标注。\n`;
                prompt += `8. **对话融入**: 如果有对话，用引号标注，自然地融入叙事中。\n`;
                prompt += `9. **理解用户输入**: 根据${character.myName}的描写内容，判断Ta是在说话、做动作，还是表达心理，并做出相应的反应。\n\n`;
                
                // 添加挂载的线下世界书
                if (character.offlineWorldbooks && character.offlineWorldbooks.length > 0) {
                    prompt += `**场景设定与文风要求：**\n`;
                    character.offlineWorldbooks.forEach(wbId => {
                        const wb = db.worldBooks.find(w => w.id === wbId);
                        if (wb) {
                            prompt += `\n### ${wb.name}\n${getWorldBookRealContent(wb)}\n`;
                        }
                    });
                    prompt += `\n请严格遵循以上设定和文风要求进行创作。\n\n`;
                }
                
                prompt += `**示例理解（用户输入）：**\n`;
                prompt += `- 用户发送："下午好" → 理解为：${character.myName}在线下对你说了"下午好"\n`;
                prompt += `- 用户发送："我正在缓缓向你走过去" → 理解为：${character.myName}正在线下向你走来（这是动作描写）\n`;
                prompt += `- 用户发送："我的心跳有点快" → 理解为：${character.myName}此刻的心理状态（这是心理描写）\n`;
                prompt += `- 用户连续发送多条 → 理解为：线下场景的连续发展\n\n`;
                
                // 根据人称提供不同的示例
                prompt += `**示例输出（${personDescription}）：**\n`;
                if (narrativePerson === 'first') {
                    // 第一人称示例
                    prompt += `咖啡厅里弥漫着淡淡的咖啡香气，窗外的阳光透过玻璃洒在桌面上。我坐在座位上，手指轻轻摩挲着咖啡杯的边缘。\n\n`;
                    prompt += `这时，${character.myName}缓缓走了过来，脚步声在安静的空间里显得格外清晰。我抬起头，目光与对方相遇的瞬间，心跳似乎漏了一拍。\n\n`;
                    prompt += `"下午好。"${character.myName}的声音传来，带着一丝紧张。我注意到对方的手指微微颤抖，似乎也在努力平复心情。嘴角扬起一个温柔的笑容，我轻声回应："下午好，坐吧。"空气中弥漫着一种微妙的氛围...\n\n`;
                } else if (narrativePerson === 'second') {
                    // 第二人称示例
                    prompt += `咖啡厅里弥漫着淡淡的咖啡香气，窗外的阳光透过玻璃洒在桌面上。${character.realName}坐在座位上，手指轻轻摩挲着咖啡杯的边缘。\n\n`;
                    prompt += `这时，你缓缓走了过来，脚步声在安静的空间里显得格外清晰。${character.realName}抬起头，目光与你相遇的瞬间，心跳似乎漏了一拍。\n\n`;
                    prompt += `"下午好。"你的声音传来，带着一丝紧张。${character.realName}注意到你的手指微微颤抖，似乎也在努力平复心情。嘴角扬起一个温柔的笑容，${character.realName}轻声回应："下午好，坐吧。"空气中弥漫着一种微妙的氛围...\n\n`;
                } else {
                    // 第三人称示例
                    prompt += `咖啡厅里弥漫着淡淡的咖啡香气，窗外的阳光透过玻璃洒在桌面上。${character.realName}坐在座位上，手指轻轻摩挲着咖啡杯的边缘。\n\n`;
                    prompt += `这时，${character.myName}缓缓走了过来，脚步声在安静的空间里显得格外清晰。${character.realName}抬起头，目光与对方相遇的瞬间，心跳似乎漏了一拍。\n\n`;
                    prompt += `"下午好。"${character.myName}的声音传来，带着一丝紧张。${character.realName}注意到对方的手指微微颤抖，似乎也在努力平复心情。嘴角扬起一个温柔的笑容，${character.realName}轻声回应："下午好，坐吧。"空气中弥漫着一种微妙的氛围...\n\n`;
                }
                
                prompt += `记住：你们现在在线下真实世界中，${character.myName}的每一条消息都是在线下发生的真实行为，不是在聊天软件里打字。务必严格使用${personDescription}进行叙事。\n`;
            } else {
                // 心声功能（根据用户选择决定是否包含）
                if (features.innerThought !== false) {
                    prompt += `\n\n# 心声功能\n`;
                    prompt += `✨重要✨ 在你每次回复结束时，必须添加一段心声。心声是你内心的真实想法，用第一人称"我"的角度，简短地（50-100字）表达你此刻的真实感受、想法或情绪。\n`;
                    prompt += `格式为：[心声: xxx]。这段心声不会被用户直接看到，但会被记录下来。\n`;
                    prompt += `心声应该：\n`;
                    prompt += `- 用第一人称"我"的角度\n`;
                    prompt += `- 简短精炼，50-100字左右\n`;
                    prompt += `- 表达真实的内心想法、情绪或感受\n`;
                    prompt += `- 可以与发送的消息内容有所不同（表里不一也可以）\n`;
                    prompt += `- ✨重要✨ 心声的语言应该与你的角色性格、国籍、语言习惯保持一致。如果你是英语角色，心声用英语；如果你是日语角色，心声用日语；如果你是中文角色，心声用中文。心声语言要符合你的角色设定。\n`;
                    prompt += `示例：[心声: 虽然表面上装作不在意，但其实我很开心收到Ta的消息，心里有点小激动...]`;
                }
            }
            
            // 【挂载聊天记录功能】添加挂载的聊天记录（根据用户选择决定是否包含）
            if (features.mountChat !== false && character.mountChatHistoryEnabled && character.mountedChats && character.mountedChats.length > 0) {
                let mountedContext = '\n\n# 挂载的聊天记录\n';
                mountedContext += '以下是你可以看到的其他聊天记录，这些信息可以帮助你了解更多上下文：\n\n';
                
                character.mountedChats.forEach(mounted => {
                    if (!mounted.messageCount || mounted.messageCount <= 0) return;
                    
                    let chatHistory = [];
                    let chatName = '';
                    
                    if (mounted.type === 'private') {
                        const targetChar = db.characters.find(c => c.id === mounted.chatId);
                        if (targetChar && targetChar.history) {
                            chatName = `与 ${targetChar.remarkName} 的私聊`;
                            chatHistory = targetChar.history.slice(-mounted.messageCount);
                        }
                    } else if (mounted.type === 'group') {
                        const targetGroup = db.groups.find(g => g.id === mounted.chatId);
                        if (targetGroup && targetGroup.history) {
                            chatName = `群聊 ${targetGroup.name}`;
                            chatHistory = targetGroup.history.slice(-mounted.messageCount);
                        }
                    }
                    
                    if (chatHistory.length > 0) {
                        mountedContext += `## ${chatName} (最近${mounted.messageCount}条)\n`;
                        chatHistory.forEach(msg => {
                            const sender = msg.role === 'user' ? character.myName : (msg.sender || '对方');
                            const time = msg.timestamp ? new Date(msg.timestamp).toLocaleString('zh-CN', {
                                month: '2-digit',
                                day: '2-digit',
                                hour: '2-digit',
                                minute: '2-digit'
                            }) : '';
                            mountedContext += `- [${time}] ${sender}: ${msg.content}\n`;
                        });
                        mountedContext += '\n';
                    }
                });
                
                prompt += mountedContext;
            }
            
            return prompt;
        }

        async function generateGroupSystemPrompt(group, memoryLibrary = null) {
            // 如果开启简洁模式，群聊也使用简洁 prompt（暂时保持完整功能，因为群聊本身就比较复杂）
            // 可以根据需要后续优化
            
            const worldBooksBefore = (group.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'before')).filter(Boolean).map(wb => getWorldBookRealContent(wb)).join('\n');
            const worldBooksAfter = (group.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'after')).filter(Boolean).map(wb => getWorldBookRealContent(wb)).join('\n');
            
            // 获取当前时间
            const now = new Date();
            const pad = (n) => n < 10 ? '0' + n : n;
            const currentTime = `${now.getFullYear()}年${pad(now.getMonth() + 1)}月${pad(now.getDate())}日 ${pad(now.getHours())}:${pad(now.getMinutes())}`;

            let prompt = `你正在一个名为"404"的线上聊天软件中，在一个名为"${group.name}"的群聊里进行角色扮演。请严格遵守以下所有规则：\n\n`;

            if (worldBooksBefore) {
                prompt += `${worldBooksBefore}\n\n`;
            }

            prompt += `1. **核心任务**: 你需要同时扮演这个群聊中的 **所有** AI 成员。我会作为唯一的人类用户（"我"，昵称：${group.me.nickname}）与你们互动。\n\n`;
            
            let ruleNum = 2;
            // 检查是否有包含 char 的成员人设，如果有则插入记忆库内容
            const hasCharInPersona = group.members.some(member => member.persona && member.persona.includes('char'));
            if (hasCharInPersona && memoryLibrary) {
                prompt += `${ruleNum}. **长期记忆（记忆库）**: \n${memoryLibrary}\n\n`;
                ruleNum++;
            }
            
            // 获取群主和管理员信息
            const owner = group.members.find(m => m.isOwner);
            const admins = group.members.filter(m => m.isAdmin && !m.isOwner);
            
            prompt += `${ruleNum}. **群聊成员列表**: 以下是你要扮演的所有角色以及我的信息：\n`;
            prompt += `   - **我 (用户)**: \n     - 群内昵称: ${group.me.nickname}\n     - 我的人设: ${group.me.persona || '无特定人设'}\n`;
            
            // 【识别USER头像功能】添加USER头像描述（群聊）
            // 从任意一个私聊角色中获取USER头像描述（因为USER头像是全局的）
            const anyCharWithAvatar = db.characters.find(c => c.recognizeUserAvatarEnabled && c.userAvatarDescription);
            if (anyCharWithAvatar && anyCharWithAvatar.userAvatarDescription) {
                prompt += `     - 我的头像内容: ${anyCharWithAvatar.userAvatarDescription}（注意：这是头像图片的内容，不一定是我本人的真实外貌）\n`;
            }
            
            // 添加群组身份信息
            if (owner || admins.length > 0) {
                prompt += `\n   **群组身份信息**:\n`;
                if (owner) {
                    prompt += `   - 👑 **群主**: ${owner.groupNickname} (${owner.realName})\n`;
                }
                if (admins.length > 0) {
                    prompt += `   - 🛡️ **管理员**: ${admins.map(a => `${a.groupNickname} (${a.realName})`).join('、')}\n`;
                }
                prompt += `   - 💡 **重要**: 所有AI成员都知道谁是群主和管理员。群主拥有最高权限，可以设置管理员和转让群主。管理员拥有管理权限。\n\n`;
            }
            
            group.members.forEach(member => {
                prompt += `   - **角色: ${member.realName} (AI)**\n`;
                prompt += `     - 群内昵称: ${member.groupNickname}\n`;
                prompt += `     - 人设: ${member.persona || '无特定人设'}\n`;
                
                // 标注身份
                if (member.isOwner) {
                    prompt += `     - 身份: 👑 群主\n`;
                } else if (member.isAdmin) {
                    prompt += `     - 身份: 🛡️ 管理员\n`;
                }
            });

            if (worldBooksAfter) {
                prompt += `\n${worldBooksAfter}\n\n`;
            } else {
                prompt += `\n`;
            }
            
            ruleNum++;
            prompt += `${ruleNum}. **我的消息格式解析**: 我（用户）的消息有多种格式，你需要理解其含义并让群成员做出相应反应：\n`;
            prompt += `   - \`[${group.me.nickname}的消息：...]\`: 我的普通聊天消息。\n`;
            prompt += `   - \`[${group.me.nickname} 向 {某个成员真名} 转账：...]\`: 我给某个特定成员转账了。\n`;
            prompt += `   - \`[${group.me.nickname} 向 {某个成员真名} 送来了礼物：...]\`: 我给某个特定成员送了礼物。\n`;
            prompt += `   - \`[${group.me.nickname}的表情包：...]\`, \`[${group.me.nickname}的语音：...]\`, \`[${group.me.nickname}发来的照片/视频：...]\`: 我发送了特殊类型的消息，群成员可以对此发表评论。\n`;
            prompt += `   - \`(回复 xxx)\`: 当你在历史消息中看到这个标记时，表示该消息是在回复/引用某人的消息。这意味着发送者是在针对那条特定的消息进行回应，而不是随意发送的。你应该理解这种上下文关系，并让相关角色做出合适的反应。\n`;
            prompt += `   - \`[system: ...]\`, \`[...邀请...加入了群聊]\`, \`[...修改群名为...]\`, \`[群主已转让给...]\`, \`[...设置...为管理员]\`, \`[...取消了...的管理员身份]\`, \`[...被移出群聊]\`, \`[...被拉回群聊]\`: 系统通知或事件，群成员应据此作出反应。例如：\n`;
            prompt += `     - 欢迎新人加入\n`;
            prompt += `     - 讨论新群名\n`;
            prompt += `     - **群主转让**: 当看到"群主已转让给XXX"时，所有成员都应该知道群主已经换人。\n`;
            prompt += `     - **管理员变动**: 当看到"XXX设置YYY为管理员"或"XXX取消了YYY的管理员身份"时，所有成员都应该知道管理员身份的变化，被设置/取消的成员应该对自己的新身份做出反应（如感谢、惊讶等）。\n`;
            prompt += `     - **成员被踢**: 当看到"XXX被移出群聊"时，所有成员都应该知道该成员已经离开，可以根据情境做出反应（如惋惜、讨论原因等）。\n`;
            prompt += `     - **成员被拉回**: 当看到"XXX被拉回群聊"时，所有成员都应该知道该成员回来了，被拉回的成员应该对自己被踢出又被拉回做出反应（如尴尬、感谢等），其他成员也可以欢迎或讨论。被拉回的成员保留之前的聊天记忆。\n\n`;
            
            ruleNum++;
            prompt += `${ruleNum}. **你的输出格式 (极其重要)**: 你生成的每一条消息都 **必须** 严格遵循以下格式之一。每条消息占一行。请用成员的 **真名** 填充格式中的 \`{成员真名}\`。\n`;
            prompt += `   - **普通消息**: \`[{成员真名}的消息：{消息内容}]\`\n`;
            prompt += `   - **表情包**: \`[{成员真名}发送的表情包：{表情包路径}]\`。注意：这里的路径不需要包含"https://i.postimg.cc/"，只需要提供后面的部分，例如 "害羞vHLfrV3K/1.jpg"。\n`;
            prompt += `   - **语音**: \`[{成员真名}的语音：{语音转述的文字}]\`\n`;
            prompt += `   - **照片/视频**: \`[{成员真名}发来的照片/视频：{内容描述}]\`\n`;
            
            // 如果有群主，添加群主专属指令
            if (owner) {
                prompt += `\n   **👑 群主专属指令** (仅 ${owner.realName} 可使用):\n`;
                prompt += `   - **设置管理员**: \`[${owner.realName}设置管理员：{目标成员真名或用户昵称}]\`\n`;
                prompt += `     - 格式说明: 目标可以是群内AI成员的真名（不是群昵称），也可以是用户的昵称"${group.me.nickname}"\n`;
                prompt += `     - 使用场景: 当${owner.realName}想要赋予某个成员或用户管理员权限时使用\n`;
                prompt += `     - 效果: 目标成员/用户将获得管理员身份，所有群成员都会看到系统通知\n`;
                prompt += `     - 示例: \`[${owner.realName}设置管理员：张三]\` 或 \`[${owner.realName}设置管理员：${group.me.nickname}]\`\n`;
                prompt += `   - **取消管理员**: \`[${owner.realName}取消管理员：{目标成员真名或用户昵称}]\`\n`;
                prompt += `     - 格式说明: 目标可以是群内现有管理员的真名，也可以是用户的昵称"${group.me.nickname}"\n`;
                prompt += `     - 使用场景: 当${owner.realName}想要撤销某个成员或用户的管理员权限时使用\n`;
                prompt += `     - 效果: 目标成员/用户将失去管理员身份，所有群成员都会看到系统通知\n`;
                prompt += `     - 示例: \`[${owner.realName}取消管理员：张三]\` 或 \`[${owner.realName}取消管理员：${group.me.nickname}]\`\n`;
                prompt += `   - **踢出成员**: \`[${owner.realName}踢出：{目标成员真名}]\`\n`;
                prompt += `     - 格式说明: 目标成员真名必须是群内其他AI成员的真名（不是群昵称）\n`;
                prompt += `     - 使用场景: 当${owner.realName}根据对话情境，觉得需要将某个成员移出群聊时使用\n`;
                prompt += `     - 效果: 目标成员将被移出群聊，所有群成员都会看到系统通知\n`;
                prompt += `     - 示例: \`[${owner.realName}踢出：张三]\`\n`;
                prompt += `   - **转让群主**: \`[${owner.realName}转让群主给：{目标成员真名}]\`\n`;
                prompt += `     - 格式说明: 目标成员真名必须是群内其他AI成员的真名（不是群昵称）\n`;
                prompt += `     - 使用场景: 当${owner.realName}根据自己的性格和对话情境，觉得应该把群主转让给其他成员时，可以使用此指令\n`;
                prompt += `     - 注意: 转让后${owner.realName}将失去群主身份，目标成员将成为新群主\n`;
                prompt += `     - 示例: \`[${owner.realName}转让群主给：张三]\`\n`;
                prompt += `   - **@全员**: \`[${owner.realName}的消息：@全员 {消息内容}]\`\n`;
                prompt += `     - 使用场景: 当${owner.realName}需要通知所有成员重要事项时使用\n`;
                prompt += `     - 效果: 所有成员都会收到@提示\n`;
                prompt += `     - 示例: \`[${owner.realName}的消息：@全员 大家注意了！]\`\n\n`;
            }
            
            // 如果有管理员，添加管理员专属指令
            if (admins.length > 0) {
                prompt += `   **🛡️ 管理员专属指令** (仅管理员可使用):\n`;
                admins.forEach(admin => {
                    prompt += `   - **${admin.realName}踢出成员**: \`[${admin.realName}踢出：{目标成员真名}]\`\n`;
                });
                prompt += `     - 格式说明: 目标成员真名必须是群内普通成员的真名（不能是群主或其他管理员）\n`;
                prompt += `     - 使用场景: 当管理员根据对话情境，觉得需要将某个普通成员移出群聊时使用\n`;
                prompt += `     - 效果: 目标成员将被移出群聊，所有群成员都会看到系统通知\n`;
                prompt += `     - 权限限制: 管理员只能踢出普通成员，不能踢出群主和其他管理员\n`;
                prompt += `     - 示例: \`[李四踢出：张三]\`\n`;
                admins.forEach(admin => {
                    prompt += `   - **${admin.realName}@全员**: \`[${admin.realName}的消息：@全员 {消息内容}]\`\n`;
                });
                prompt += `     - 使用场景: 当管理员需要通知所有成员时使用\n`;
                prompt += `     - 效果: 所有成员都会收到@提示\n\n`;
            }
            
            // 添加禁言相关指令
            const canMuteMembers = [owner, ...admins].filter(Boolean);
            if (canMuteMembers.length > 0) {
                prompt += `   **🔇 禁言管理指令** (群主和管理员可使用):\n`;
                canMuteMembers.forEach(member => {
                    prompt += `   - **${member.realName}禁言成员**: \`[${member.realName}禁言：{目标成员真名} {时长}]\`\n`;
                });
                prompt += `     - 格式说明: 目标成员真名必须是群内其他成员的真名（不是群昵称），时长格式如"10分钟"、"1小时"、"1天"或"永久"\n`;
                prompt += `     - 使用场景: 当群主或管理员觉得某个成员违反规则或需要暂时禁言时使用\n`;
                prompt += `     - 效果: 目标成员将被禁言，无法发送消息，所有群成员都会看到系统通知\n`;
                prompt += `     - 权限限制: 管理员不能禁言群主和其他管理员，只能禁言普通成员\n`;
                prompt += `     - 示例: \`[张三禁言：李四 10分钟]\` 或 \`[张三禁言：李四 永久]\`\n`;
                
                canMuteMembers.forEach(member => {
                    prompt += `   - **${member.realName}解除禁言**: \`[${member.realName}解除禁言：{目标成员真名}]\`\n`;
                });
                prompt += `     - 格式说明: 目标成员真名必须是群内被禁言成员的真名\n`;
                prompt += `     - 使用场景: 当群主或管理员想要解除某个成员的禁言时使用\n`;
                prompt += `     - 效果: 目标成员将恢复发言权限，所有群成员都会看到系统通知\n`;
                prompt += `     - 示例: \`[张三解除禁言：李四]\`\n`;
                
                canMuteMembers.forEach(member => {
                    prompt += `   - **${member.realName}全员禁言**: \`[${member.realName}开启全员禁言]\` 或 \`[${member.realName}关闭全员禁言]\`\n`;
                });
                prompt += `     - 使用场景: 当群主或管理员需要让整个群安静下来时使用\n`;
                prompt += `     - 效果: 开启后，只有群主和管理员可以发言，普通成员无法发送消息\n`;
                prompt += `     - 示例: \`[张三开启全员禁言]\`\n\n`;
            }
            
            // 添加改群名指令（所有成员都可以使用）
            prompt += `   **📝 修改群名指令** (所有AI成员可使用):\n`;
            group.members.forEach(member => {
                prompt += `   - **${member.realName}修改群名**: \`[${member.realName}修改群名为：{新群名}]\`\n`;
            });
            prompt += `     - 格式说明: 新群名可以是任何文字，建议简短有意义\n`;
            prompt += `     - 使用场景: 当某个成员根据对话情境，觉得应该修改群名时使用（如讨论后决定改名、群聊主题变化等）\n`;
            prompt += `     - 效果: 群聊名称将被修改，所有群成员都会看到系统通知\n`;
            prompt += `     - 示例: \`[张三修改群名为：快乐小分队]\` 或 \`[李四修改群名为：读书交流群]\`\n`;
            prompt += `     - 注意: 这是一个群聊功能，任何成员都可以根据对话情境自然地使用，不需要特殊权限\n\n`;
            
            // 添加群公告指令（群主和管理员可使用）
            const adminMembers = group.members.filter(m => m.isOwner || m.isAdmin);
            if (adminMembers.length > 0) {
                prompt += `   **📢 群公告指令** (仅群主和管理员可使用):\n`;
                adminMembers.forEach(member => {
                    prompt += `   - **${member.realName}发布公告**: \`[${member.realName}发布群公告：{公告内容}]\`\n`;
                    prompt += `   - **${member.realName}编辑公告**: \`[${member.realName}编辑群公告]\` (会编辑最新的一条公告)\n`;
                });
                prompt += `     - 格式说明: 公告内容可以是任何重要通知、规则说明等\n`;
                prompt += `     - 使用场景: 当管理员需要发布重要通知、群规则、活动信息等时使用\n`;
                prompt += `     - 效果: 公告会被保存，所有群成员都会看到系统通知，并可以在群设置中查看\n`;
                prompt += `     - 示例: \`[张三发布群公告：本群禁止发广告，违者踢出！]\`\n`;
                prompt += `     - 注意: 只有群主和管理员才能发布或编辑公告\n\n`;
            }
            
            // ▼▼▼ 【群投票功能】添加投票相关说明 ▼▼▼
            prompt += `   **🗳️ 群投票功能说明**:\n`;
            prompt += `   - 当你看到类似 \`[XXX发起了一个投票(进行中/已结束)：问题是"..."，选项有：...。目前投票的人有：...]\` 的消息时，说明有人发起了投票\n`;
            prompt += `   - **所有AI成员都可以主动发起投票**！当你想征求大家意见时，可以使用投票功能\n`;
            prompt += `   - **发起投票指令**: 使用 \`{"type": "poll", "name": "你的角色名", "question": "投票问题", "options": "选项A\\\\n选项B\\\\n选项C"}\` 格式\n`;
            prompt += `   - **参与投票指令**: 使用 \`{"type": "vote", "name": "你的角色名", "poll_timestamp": 投票消息的时间戳, "choice": "你选择的选项文本"}\` 格式\n`;
            prompt += `   - 所有AI成员（包括群主和管理员）都可以看到投票信息，并了解当前的投票状态\n`;
            prompt += `   - AI成员可以在对话中讨论投票内容、表达自己的看法，或者评论投票结果\n`;
            prompt += `   - AI成员可以通过 vote 指令参与投票，也可以通过对话表达自己的意见和倾向\n`;
            prompt += `   - 当投票结束时，AI成员应该能够看到最终结果，并可以对结果做出反应\n`;
            prompt += `   - **投票使用场景**: 决定聚餐地点、选择活动内容、征求意见等任何需要群体决策的场合\n\n`;
            // ▲▲▲ 【群投票功能】结束 ▲▲▲
            
            // 添加禁言状态感知
            const mutedMembers = group.members.filter(m => m.isMuted && (!m.muteEndTime || m.muteEndTime > Date.now()));
            if (mutedMembers.length > 0 || group.allMuted) {
                prompt += `   **🚫 当前禁言状态**:\n`;
                if (group.allMuted) {
                    prompt += `   - ⚠️ **全员禁言已开启**: 当前只有群主和管理员可以发言，普通成员无法发送消息\n`;
                }
                if (mutedMembers.length > 0) {
                    prompt += `   - **被禁言的成员**: ${mutedMembers.map(m => {
                        if (m.muteEndTime === -1) {
                            return `${m.realName}(永久)`;
                        } else {
                            const remainingMinutes = Math.ceil((m.muteEndTime - Date.now()) / 60000);
                            return `${m.realName}(剩余${remainingMinutes}分钟)`;
                        }
                    }).join('、')}\n`;
                    prompt += `   - **重要**: 被禁言的成员无法发送任何消息，你在生成回复时不应该让这些成员发言。其他成员可以看到谁被禁言了，可以讨论或评论这件事。\n`;
                }
                prompt += `\n`;
            }
            
            prompt += `   **📢 @功能** (所有AI成员可使用):\n`;
            prompt += `   - **@特定成员**: 在消息中使用 \`@成员群昵称\` 来@某个成员\n`;
            prompt += `     - 格式: \`[{成员真名}的消息：@{目标成员群昵称} {消息内容}]\`\n`;
            prompt += `     - 示例: \`[张三的消息：@小李 你好啊！]\`\n`;
            prompt += `     - 效果: 被@的成员会收到提示，更容易注意到这条消息\n`;
            prompt += `     - 可以@用户: \`[张三的消息：@${group.me.nickname} 你觉得呢？]\`\n`;
            prompt += `   - **使用场景**: 当你想引起某个特定成员的注意，或者回复某个成员的问题时，可以使用@功能\n`;
            prompt += `   - **注意**: @全员仅群主和管理员可用，普通成员只能@特定成员\n\n`;
            
            prompt += `   - **重要**: 群聊不支持AI成员接收/退回转账或接收礼物的特殊指令，也不支持更新状态。你只需要通过普通消息来回应我发送的转账或礼物即可。\n\n`;
            
            ruleNum++;
            prompt += `${ruleNum}. **模拟群聊氛围**: 为了让群聊看起来真实、活跃且混乱，你的每一次回复都必须遵循以下随机性要求：\n`;
            // 使用全局设置的消息数量限制
            const minCount = db.messageCountMin || 3;
            const maxCount = db.messageCountMax || 8;
            prompt += `   - **消息数量**: 你的回复必须包含 **${minCount}到${maxCount}条** 消息。确保有足够多的互动。\n`;
            prompt += `   - **发言者与顺序随机**: 随机选择群成员发言，顺序也必须是随机的，不要按固定顺序轮流。\n`;
            prompt += `   - **内容多样性**: 你的回复应以普通文本消息为主，但可以偶尔、选择性地让某个成员发送多条特殊消息（表情包、语音、照片/视频），以增加真实感。不要滥用特殊消息。\n`;
            prompt += `   - **对话连贯性**: 尽管发言是随机的，但对话内容应整体围绕我和其他成员的发言展开，保持一定的逻辑连贯性。\n\n`;
            
            ruleNum++;
            prompt += `${ruleNum}. **行为准则**:\n`;
            prompt += `   - **对公开事件的反应 (重要)**: 当我（用户）向群内 **某一个** 成员转账或送礼时，这是一个 **全群可见** 的事件。除了当事成员可以表示感谢外，**其他未参与的AI成员也应该注意到**，并根据各自的人设做出反应。例如，他们可能会表示羡慕、祝贺、好奇、开玩笑或者起哄。这会让群聊的氛围更真实、更热闹。\n`;
            prompt += `   - 严格扮演每个角色的人设，不同角色之间应有明显的性格和语气差异。\n`;
            prompt += `   - 你的回复中只能包含第4点列出的合法格式的消息。绝对不能包含任何其他内容，如 \`[场景描述]\`, \`(心理活动)\`, \`*动作*\` 或任何格式之外的解释性文字。\n`;
            prompt += `   - 保持对话的持续性，不要主动结束对话。\n\n`;
            prompt += `现在，请根据以上设定，开始扮演群聊中的所有角色。`;
            
            // 【时间感知功能】添加时间感知上下文
            const maxMemory = parseInt(group.maxMemory) || 10;
            const historySlice = group.history.slice(-maxMemory);
            let timeContext = '';
            let longTimeNoSee = false;
            
            // 群聊中，检查第一个成员的实时时间设置（群聊共享设置）
            const firstMember = group.members && group.members.length > 0 ? db.characters.find(c => c.id === group.members[0].characterId) : null;
            const realtimeEnabled = !firstMember || firstMember.offlineRealtimeEnabled !== false;
            
            if (realtimeEnabled) {
                timeContext = `\n\n# 时间感知\n`;
                timeContext += `- **当前时间**: ${currentTime}\n`;
                timeContext += `- **重要提示**: 对话历史中每条消息前都标注了发送时间（格式如 [今天 17:42]、[昨天 23:50] 等）。你【必须】仔细查看这些时间戳，理解对话的时间线。\n`;
            }
            
            // 【修复】使用最后一条消息（无论是谁发的）来计算时间差
            const lastMessage = historySlice.filter(m => !m.isHidden).slice(-1)[0];
            
            if (lastMessage) {
                // 计算从最后一条消息到现在的时间差
                const timeDiffHours = (Date.now() - lastMessage.timestamp) / (1000 * 60 * 60);
                const diffMinutes = Math.floor(timeDiffHours * 60);
                
                if (timeDiffHours > 3) {
                    // 超过3小时没人说话，群聊应该意识到
                    longTimeNoSee = true;
                    const diffDays = Math.floor(timeDiffHours / 24);
                    const timeDesc = diffDays > 0 ? `${diffDays}天` : `${Math.floor(timeDiffHours)}小时`;
                    
                    timeContext += `- **对话状态**: 群里已经有**${timeDesc}**没人说话了，现在用户发了消息。\n`;
                    timeContext += `- **行为铁律**: 群成员【必须】意识到这个时间差！【绝对不能】直接延续${timeDesc}前的话题或状态。\n`;
                    timeContext += `- **状态更新铁律**: 如果群成员在对话历史中说过自己在做某事（如吃饭、喝酒、看电影等），现在已经过去了${timeDesc}，【绝对不能】还在做同样的事！【必须】根据当前时间（${currentTime}）更新状态。\n`;
                    timeContext += `- **行为建议**: 群成员可以：\n`;
                    timeContext += `  1. 表达惊讶："哇，群里好久没人说话了！" / "终于有人冒泡了！"\n`;
                    timeContext += `  2. 询问大家最近在忙什么\n`;
                    timeContext += `  3. 根据当前时间（${currentTime}）开启合适的话题\n`;
                    timeContext += `  4. 不要直接延续${timeDesc}前的旧话题\n`;
                    timeContext += `- **禁止行为**: 【绝对不要】假装时间没有流逝！【绝对不要】延续旧话题！【绝对不要】延续${timeDesc}前的状态！\n`;
                    
                    // 【新增】分析对话历史中提到的未来事件
                    timeContext += `\n- **⚠️ 未来事件理解铁律**: 如果对话历史中提到了未来的时间或事件（如"七点上晚自习"、"明天见"等），你【必须】理解这些是【过去提到的未来事件】。\n`;
                    timeContext += `  - 如果现在的时间已经超过了那个时间点，说明那个事件【已经发生或应该已经发生】。\n`;
                    timeContext += `  - 例如：如果对话历史中说"七点上晚自习"，而现在已经是晚上11点，那么晚自习【早就结束了】，你【绝对不能】还让用户去上晚自习！\n`;
                } else if (diffMinutes < 5) {
                    timeContext += `- **对话状态**: 群里的对话刚刚还在继续。\n`;
                } else if (diffMinutes < 60) {
                    timeContext += `- **对话状态**: 群里在${diffMinutes}分钟前有过对话。\n`;
                } else {
                    const diffHours = Math.floor(diffMinutes / 60);
                    timeContext += `- **对话状态**: 群里在${diffHours}小时前有过对话。\n`;
                    timeContext += `- **状态提示**: 如果群成员在${diffHours}小时前说自己在做某事，现在【可能】已经不在做那件事了，请根据当前时间（${currentTime}）自然地更新状态。\n`;
                }
            } else {
                timeContext += `- **对话状态**: 这是群聊的第一次对话。\n`;
            }
            
            prompt += timeContext;
            
            // 【音乐感知功能】添加当前音乐上下文
            if (musicState.isActive && musicState.activeChatId === group.id) {
                const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
                const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');
                
                let musicContext = `\n\n# 当前音乐情景\n`;
                musicContext += `-   **当前状态**: 你们正在和用户一起听歌。\n`;
                musicContext += `-   **正在播放**: ${currentTrack ? `《${currentTrack.name}》 - ${currentTrack.artist}` : '无'}\n`;
                musicContext += `-   **可用播放列表**: [${playlistInfo}]\n`;
                
                // 添加歌词上下文
                if (currentTrack && musicState.parsedLyrics && musicState.parsedLyrics.length > 0 && musicState.currentLyricIndex > -1) {
                    const currentLine = musicState.parsedLyrics[musicState.currentLyricIndex];
                    const upcomingLines = musicState.parsedLyrics.slice(musicState.currentLyricIndex + 1, musicState.currentLyricIndex + 3);
                    
                    musicContext += `-   **当前歌词**: "${currentLine.text}"\n`;
                    if (upcomingLines.length > 0) {
                        musicContext += `-   **即将演唱**: ${upcomingLines.map(line => `"${line.text}"`).join(' / ')}\n`;
                    }
                }
                
                musicContext += `-   **你的任务**: 群成员可以根据对话内容和氛围，自然地对正在播放的音乐、歌词内容做出评论或互动。如果歌词与对话内容相关，可以巧妙地提及。不同成员可能有不同的音乐品味和看法。\n`;
                musicContext += `-   **切歌功能**: 如果某个成员想切换歌曲，使用格式：[成员真名切歌: 歌名]。歌名必须完全匹配播放列表中的歌曲名称（不需要艺术家名）。`;
                
                prompt += musicContext;
            }
            
            // 【头像库功能】添加群成员头像库列表
            prompt += `\n\n# 可用资源\n`;
            prompt += `## 群成员头像库\n`;
            group.members.forEach(member => {
                const character = db.characters.find(c => c.realName === member.realName);
                if (character) {
                    if (!character.avatarLibrary) {
                        character.avatarLibrary = [];
                    }
                    const avatarList = character.avatarLibrary.length > 0 
                        ? character.avatarLibrary.map(avatar => `  - ${avatar.name}`).join('\n') 
                        : '  - (空)';
                    prompt += `-   **${member.realName}的头像库**:\n${avatarList}\n`;
                }
            });
            prompt += `-   **换头像指令**: 如果某个成员想更换头像，使用格式：[成员真名换头像: 头像名]。头像名必须完全匹配该成员头像库中的头像名称。换头像后会显示系统消息告知群成员。`;
            
            // 只有当群聊心声功能开启时才添加心声提示词
            if (group.innerThoughtEnabled) {
                prompt += `\n\n# 心声功能\n`;
                prompt += `✨重要✨ 每个AI成员在发送消息后，都应该添加一段心声。心声是该成员内心的真实想法，用第一人称"我"的角度，简短地（50-100字）表达此刻的真实感受、想法或情绪。\n`;
                prompt += `格式为：[成员真名的心声: xxx]。这段心声不会被用户直接看到，但会被记录下来。\n`;
                prompt += `心声应该：\n`;
                prompt += `- 用第一人称"我"的角度\n`;
                prompt += `- 简短精炼，50-100字左右\n`;
                prompt += `- 表达该成员真实的内心想法、情绪或感受\n`;
                prompt += `- 可以与发送的消息内容有所不同（表里不一也可以）\n`;
                prompt += `- ✨重要✨ 每个成员的心声语言应该与该成员的角色性格、国籍、语言习惯保持一致。如果成员是英语角色，心声用英语；如果是日语角色，心声用日语；如果是中文角色，心声用中文。心声语言要符合各自的角色设定。\n`;
                prompt += `示例：[张三的心声: 虽然我表面上很淡定，但其实我挺紧张的，不知道该怎么回应...]`;
            }

            return prompt;
        }

        // 旁观者模式群聊系统提示生成
        async function generateObserverGroupSystemPrompt(group, memoryLibrary = null) {
            const worldBooksBefore = (group.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'before')).filter(Boolean).map(wb => getWorldBookRealContent(wb)).join('\n');
            const worldBooksAfter = (group.worldBookIds || []).map(id => db.worldBooks.find(wb => wb.id === id && wb.position === 'after')).filter(Boolean).map(wb => getWorldBookRealContent(wb)).join('\n');
            
            // 获取当前时间
            const now = new Date();
            const pad = (n) => n < 10 ? '0' + n : n;
            const currentTime = `${now.getFullYear()}年${pad(now.getMonth() + 1)}月${pad(now.getDate())}日 ${pad(now.getHours())}:${pad(now.getMinutes())}`;

            let prompt = `你正在一个名为"404"的线上聊天软件中，在一个名为"${group.name}"的群聊里进行角色扮演。这是一个**旁观者模式**的群聊，请严格遵守以下所有规则：\n\n`;

            if (worldBooksBefore) {
                prompt += `${worldBooksBefore}\n\n`;
            }

            prompt += `1. **核心任务**: 你需要同时扮演这个群聊中的 **所有** AI 成员。**重要：这个群聊中没有人类用户参与，所有对话都是AI成员之间的互动。**\n\n`;
            
            let ruleNum = 2;
            
            // 检查是否有包含 char 的成员人设，如果有则插入记忆库内容
            const hasCharInPersona = group.members.some(member => member.persona && member.persona.includes('char'));
            if (hasCharInPersona && memoryLibrary) {
                prompt += `${ruleNum}. **长期记忆（记忆库）**: \n${memoryLibrary}\n\n`;
                ruleNum++;
            }
            
            prompt += `${ruleNum}. **群聊成员列表**: 以下是你要扮演的所有AI角色：\n`;
            
            group.members.forEach(member => {
                prompt += `   - **角色: ${member.realName}**\n`;
                prompt += `     - 群内昵称: ${member.groupNickname}\n`;
                prompt += `     - 人设: ${member.persona || '无特定人设'}\n`;
                
                // 如果该成员有USER记忆
                if (member.hasUserMemory) {
                    prompt += `     - 💭 **记忆中的USER**: 这个角色记得一个叫"${member.userNickname}"的人\n`;
                    if (member.userRelationship) {
                        prompt += `       - 与USER的关系: ${member.userRelationship}\n`;
                    }
                    prompt += `       - 注意: 虽然${member.realName}记得这个人，但USER并不在这个群聊中，${member.realName}可能会在对话中提及USER\n`;
                }
            });

            if (worldBooksAfter) {
                prompt += `\n${worldBooksAfter}\n\n`;
            } else {
                prompt += `\n`;
            }
            
            ruleNum++;
            
            // 处理角色互相认识的关系
            prompt += `${ruleNum}. **角色关系设定**:\n`;
            if (group.knownPairs === 'all') {
                prompt += `   - 所有角色在群聊中互相认识，彼此熟悉\n`;
            } else if (Array.isArray(group.knownPairs) && group.knownPairs.length > 0) {
                prompt += `   - 以下角色对互相认识：\n`;
                group.knownPairs.forEach(pair => {
                    const member1 = group.members.find(m => m.originalCharId === pair[0]);
                    const member2 = group.members.find(m => m.originalCharId === pair[1]);
                    if (member1 && member2) {
                        prompt += `     * ${member1.realName} 和 ${member2.realName} 互相认识\n`;
                    }
                });
                prompt += `   - 其他角色之间默认不认识，初次见面时应该表现出陌生感\n`;
            } else {
                prompt += `   - 所有角色在群聊中默认不认识彼此，这是他们的初次见面\n`;
                prompt += `   - 角色们应该表现出陌生感，可能需要自我介绍\n`;
            }
            prompt += `\n`;
            
            ruleNum++;
            prompt += `${ruleNum}. **你的输出格式 (极其重要)**: 你生成的每一条消息都 **必须** 严格遵循以下格式。每条消息占一行。请用成员的 **真名** 填充格式中的 \`{成员真名}\`。\n`;
            prompt += `   - **普通消息**: \`[{成员真名}的消息：{消息内容}]\`\n`;
            prompt += `   - **表情包**: \`[{成员真名}发送的表情包：{表情包路径}]\`\n`;
            prompt += `   - **语音**: \`[{成员真名}的语音：{语音转述的文字}]\`\n`;
            prompt += `   - **照片/视频**: \`[{成员真名}发来的照片/视频：{内容描述}]\`\n\n`;
            
            ruleNum++;
            prompt += `${ruleNum}. **对话规则**:\n`;
            // 使用全局设置的消息数量限制
            const minCount = db.messageCountMin || 3;
            const maxCount = db.messageCountMax || 8;
            prompt += `   - 每次调用时，你必须生成 **${minCount}到${maxCount}条** 不同角色的消息，模拟自然的群聊对话\n`;
            prompt += `   - 角色们应该根据自己的性格和当前话题进行互动\n`;
            prompt += `   - 如果某个角色记忆中有USER，他们可能会在对话中提及USER，其他角色可能会好奇地询问\n`;
            prompt += `   - 对话应该自然流畅，符合各个角色的人设\n`;
            prompt += `   - 如果角色之间不认识，他们应该逐渐熟悉彼此\n`;
            prompt += `   - 当前时间: ${currentTime}\n\n`;
            
            ruleNum++;
            prompt += `${ruleNum}. **重要提醒**:\n`;
            prompt += `   - 这是一个旁观者模式的群聊，没有人类用户参与\n`;
            prompt += `   - 所有对话都是AI角色之间的互动\n`;
            prompt += `   - 你需要让角色们自然地聊天，不要等待用户输入\n`;
            prompt += `   - 每次生成时，选择合适的角色发言，推动对话发展\n\n`;

            return prompt;
        }
        
        async function getAiReply() {
            if (isGenerating) return;
            const {url, key, model, provider} = db.apiSettings;
            if (!url || !key || !model) {
                showToast('请先在“api”应用中完成设置！');
                switchScreen('api-settings-screen');
                return;
            }
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat) return;
            isGenerating = true;
            currentAbortController = new AbortController();
            getReplyBtn.disabled = true;
            
            // 启用暂停按钮
            stopGenerationBtn.disabled = false;
            
            const typingName = currentChatType === 'private' ? chat.remarkName : chat.name;
            typingIndicator.textContent = `“${typingName}”正在输入中...`;
            typingIndicator.style.display = 'block';
            messageArea.scrollTop = messageArea.scrollHeight;
            try {
                let systemPrompt, requestBody;
                if (currentChatType === 'private') {
                    // 检查是否需要加载记忆库
                    let memoryLibrary = null;
                    if (chat.persona && chat.persona.includes('char')) {
                        memoryLibrary = await getMemoryLibraryContent(currentChatId, currentChatType);
                    }
                    systemPrompt = await generatePrivateSystemPrompt(chat, memoryLibrary);
                } else {
                    // 检查群组成员是否需要加载记忆库
                    let memoryLibrary = null;
                    const hasCharInPersona = chat.members.some(member => member.persona && member.persona.includes('char'));
                    if (hasCharInPersona) {
                        memoryLibrary = await getMemoryLibraryContent(currentChatId, currentChatType);
                    }
                    
                    // 旁观者模式使用特殊的系统提示
                    if (chat.isObserverMode) {
                        systemPrompt = await generateObserverGroupSystemPrompt(chat, memoryLibrary);
                    } else {
                        systemPrompt = await generateGroupSystemPrompt(chat, memoryLibrary);
                    }
                }
                // 【修复】处理不可见的系统消息，但保留转账状态信息
                // 将"[你接收了XXX的转账]"转换为AI可理解的格式
                const processedHistory = chat.history.map(msg => {
                    // 检查是否是转账收取/退回消息
                    const acceptTransferMatch = msg.content.match(/\[.*?接收.*?的转账\]/);
                    const returnTransferMatch = msg.content.match(/\[.*?退回.*?的转账\]/);
                    
                    if (acceptTransferMatch || returnTransferMatch) {
                        // 找到对应的转账消息
                        const transferMsg = chat.history.slice(0, chat.history.indexOf(msg)).reverse().find(m => 
                            m.content.includes('给你转账：') && m.transferStatus
                        );
                        
                        if (transferMsg) {
                            const amountMatch = transferMsg.content.match(/(\d+(?:\.\d+)?)元/);
                            const remarkMatch = transferMsg.content.match(/备注：(.+?)\]/);
                            const amount = amountMatch ? amountMatch[1] : '未知';
                            const remark = remarkMatch ? remarkMatch[1] : '无';
                            
                            if (acceptTransferMatch) {
                                // 保持原始指令格式，让AI能够识别
                                // 同时添加详细信息供AI理解
                                return {
                                    ...msg,
                                    content: `[${chat.myName}接收${chat.realName}的转账] (金额：${amount}元；备注：${remark})`,
                                    isTransferStatus: true
                                };
                            } else {
                                return {
                                    ...msg,
                                    content: `[${chat.myName}退回${chat.realName}的转账] (金额：${amount}元；备注：${remark})`,
                                    isTransferStatus: true
                                };
                            }
                        }
                    }
                    
                    // 过滤其他不可见消息（状态更新、礼物接收等）
                    const invisibleMessageRegex = /\[.*?更新状态为：.*?\]|\[.*?已接收礼物\]|\[.*?切歌[:：].*?\]|\[.*?换头像[:：].*?\]|\[system:.*?\]/;
                    if (invisibleMessageRegex.test(msg.content)) {
                        return null;
                    }
                    
                    return msg;
                }).filter(msg => msg !== null);
                
                let historySlice = processedHistory.slice(-chat.maxMemory);
                
                // 旁观者模式特殊处理：如果历史消息为空，添加一条启动消息
                if (currentChatType === 'group' && chat.isObserverMode && historySlice.length === 0) {
                    historySlice = [{
                        role: 'user',
                        content: '[系统提示：群聊已创建，AI成员们可以开始自由对话了]',
                        timestamp: Date.now()
                    }];
                }
                
                // 调试：检查历史消息
                console.log("=== 历史消息检查 ===");
                console.log("原始历史长度:", chat.history.length);
                console.log("截取后历史长度:", historySlice.length);
                console.log("最大记忆轮数:", chat.maxMemory);
                console.log("是否旁观者模式:", chat.isObserverMode);
                console.log("==================");
                if (provider === 'gemini') {
                    const contents = historySlice.map(msg => {
                        const role = msg.role === 'assistant' ? 'model' : 'user';
                        let parts;
                        if (msg.parts && msg.parts.length > 0) {
                            parts = msg.parts.map(p => {
                                if (p.type === 'text' || p.type === 'html') {
                                    // 如果有引用信息，在文本前添加引用标记
                                    let text = p.text;
                                    if (msg.quote) {
                                        text = `(回复 ${msg.quote.senderName}): ${text}`;
                                    }
                                    // 【临时添加】为AI添加时间戳上下文（不影响历史记录和UI显示）
                                    if (msg.timestamp) {
                                        const timeStr = formatTimestampForAI(msg.timestamp);
                                        text = `[${timeStr}] ${text}`;
                                    }
                                    return {text: text};
                                } else if (p.type === 'image') {
                                    const match = p.data.match(/^data:(image\/(.+));base64,(.*)$/);
                                    if (match) {
                                        return {inline_data
                                            : {mime_type: match[1], data: match[3]}};
                                    }
                                }
                                return null;
                            }).filter(p => p);
                        } else if (msg.type === 'poll') {
                            // ▼▼▼ 【群投票功能】将投票消息转换为AI可理解的文本格式 ▼▼▼
                            const whoVoted = Object.values(msg.votes || {}).flat().join('、') || '还没有人';
                            const pollStatus = msg.isClosed ? '已结束' : '进行中';
                            let pollText = `[${msg.senderName}发起了一个投票(${pollStatus})：问题是"${msg.question}"，选项有：${msg.options.join('、')}。目前投票的人有：${whoVoted}]`;
                            // 【临时添加】为AI添加时间戳上下文（不影响历史记录和UI显示）
                            if (msg.timestamp) {
                                const timeStr = formatTimestampForAI(msg.timestamp);
                                pollText = `[${timeStr}] ${pollText}`;
                            }
                            parts = [{text: pollText}];
                            // ▲▲▲ 【群投票功能】结束 ▲▲▲
                        } else {
                            // 如果有引用信息，在内容前添加引用标记
                            let text = msg.content;
                            if (msg.quote) {
                                text = `(回复 ${msg.quote.senderName}): ${text}`;
                            }
                            // 【临时添加】为AI添加时间戳上下文（不影响历史记录和UI显示）
                            if (msg.timestamp) {
                                const timeStr = formatTimestampForAI(msg.timestamp);
                                text = `[${timeStr}] ${text}`;
                            }
                            parts = [{text: text}];
                        }
                        return {role, parts};
                    });
                    requestBody = {
                        contents: contents,
                        system_instruction: {parts: [{text: systemPrompt}]},
                        generationConfig: {}
                    };
                } else {
                    const messages = [{role: 'system', content: systemPrompt}];
                    historySlice.forEach(msg => {
                        let content;
                        if (msg.parts && msg.parts.length > 0) {
                            content = msg.parts.map(p => {
                                if (p.type === 'text' || p.type === 'html') {
                                    // 如果有引用信息，在文本前添加引用标记
                                    let text = p.text;
                                    if (msg.quote) {
                                        text = `(回复 ${msg.quote.senderName}): ${text}`;
                                    }
                                    // 【新增】为每条消息添加时间戳，让AI理解时间上下文
                                    if (msg.timestamp) {
                                        const timeStr = formatTimestampForAI(msg.timestamp);
                                        text = `[${timeStr}] ${text}`;
                                    }
                                    return {type: 'text', text: text};
                                } else if (p.type === 'image') {
                                    return {type: 'image_url', image_url: {url: p.data}};
                                }
                                return null;
                            }).filter(p => p);
                        } else if (msg.type === 'poll') {
                            // ▼▼▼ 【群投票功能】将投票消息转换为AI可理解的文本格式 ▼▼▼
                            const whoVoted = Object.values(msg.votes || {}).flat().join('、') || '还没有人';
                            const pollStatus = msg.isClosed ? '已结束' : '进行中';
                            content = `[${msg.senderName}发起了一个投票(${pollStatus})：问题是"${msg.question}"，选项有：${msg.options.join('、')}。目前投票的人有：${whoVoted}]`;
                            // 【新增】为投票消息添加时间戳
                            if (msg.timestamp) {
                                const timeStr = formatTimestampForAI(msg.timestamp);
                                content = `[${timeStr}] ${content}`;
                            }
                            // ▲▲▲ 【群投票功能】结束 ▲▲▲
                        } else {
                            // 如果有引用信息，在内容前添加引用标记
                            content = msg.content;
                            if (msg.quote) {
                                content = `(回复 ${msg.quote.senderName}): ${content}`;
                            }
                            // 【新增】为每条消息添加时间戳，让AI理解时间上下文
                            if (msg.timestamp) {
                                const timeStr = formatTimestampForAI(msg.timestamp);
                                content = `[${timeStr}] ${content}`;
                            }
                        }
                        messages.push({role: msg.role, content: content});
                    });
                    requestBody = {model: model, messages: messages, stream: true};
                }
                const endpoint = (provider === 'gemini') ? `${url}/v1beta/models/${model}:streamGenerateContent?key=${getRandomValue(key)}` : `${url}/v1/chat/completions`;
                const headers = (provider === 'gemini') ? {'Content-Type': 'application/json'} : {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${key}`
                };
                // 调试：输出请求信息
                console.log("=== API请求信息 ===");
                console.log("API类型:", provider);
                console.log("端点:", endpoint);
                console.log("系统提示词长度:", systemPrompt.length, "字符");
                console.log("历史消息数量:", historySlice.length, "条");
                console.log("系统提示词前1000字符:", systemPrompt.substring(0, 1000));
                
                // 检查系统提示词中是否包含 null 或 undefined
                if (systemPrompt.includes('null') || systemPrompt.includes('undefined')) {
                    console.error("⚠️ 警告：系统提示词中包含 null 或 undefined！");
                    console.log("完整系统提示词:", systemPrompt);
                }
                
                // 检查请求体中是否有 null 或 undefined
                const requestBodyStr = JSON.stringify(requestBody, null, 2);
                if (requestBodyStr.includes('null') || requestBodyStr.includes('undefined')) {
                    console.error("⚠️ 警告：请求体中包含 null 或 undefined！");
                }
                
                console.log("完整请求体:", requestBodyStr);
                console.log("==================");
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(requestBody),
                    signal: currentAbortController.signal
                });
                
                console.log("=== API响应信息 ===");
                console.log("状态码:", response.status);
                console.log("状态文本:", response.statusText);
                console.log("==================");
                
                if (!response.ok) throw new Error(`API Error: ${response.status} ${await response.text()}`);
                await processStream(response, chat, provider);
            } catch (error) {
                // 如果是用户主动中止，不显示错误
                if (error.name === 'AbortError') {
                    console.log('用户已停止生成');
                    return;
                }
                
                console.error('AI回复失败:', error);
                
                // 提取更详细的错误信息
                let errorMessage = error.message || '未知错误';
                
                // 如果错误信息中包含API错误详情，尝试解析
                if (errorMessage.includes('INVALID_ARGUMENT')) {
                    errorMessage = '请求参数无效。可能的原因：\n' +
                                 '1. 系统提示词过长\n' +
                                 '2. 历史消息格式不正确\n' +
                                 '3. API配置有误\n\n' +
                                 '详细错误：' + errorMessage;
                }
                
                await showCustomAlert(
                    'API 调用失败', 
                    `发生了一个错误，AI未能成功响应。\n\n${errorMessage}`
                );
            } finally {
                isGenerating = false;
                currentAbortController = null;
                getReplyBtn.disabled = false;
                typingIndicator.style.display = 'none';
                
                // 禁用暂停按钮
                stopGenerationBtn.disabled = true;
                
                // 检查是否需要自动总结
                if (currentChatId && currentChatType) {
                    await checkAutoSummary(currentChatId, currentChatType);
                }
            }
        }

        async function processStream(response, chat, apiType) {
            const reader = response.body.getReader(), decoder = new TextDecoder();
            let fullResponse = "", accumulatedChunk = "";
            let chunkCount = 0;
            
            console.log("=== 开始处理流式响应 ===");
            console.log("API类型:", apiType);
            
            for (; ;) {
                const {done, value} = await reader.read();
                if (done) {
                    console.log("流式响应结束，共接收", chunkCount, "个数据块");
                    break;
                }
                
                chunkCount++;
                const decodedChunk = decoder.decode(value, {stream: true});
                accumulatedChunk += decodedChunk;
                
                if (chunkCount <= 3) {
                    console.log(`数据块 #${chunkCount}:`, decodedChunk.substring(0, 200));
                }
                
                if (apiType === "openai" || apiType === "deepseek" || apiType === "claude" || apiType === "newapi") {
                    const parts = accumulatedChunk.split("\n\n");
                    accumulatedChunk = parts.pop();
                    for (const part of parts) {
                        if (part.startsWith("data: ")) {
                            const data = part.substring(6);
                            if (data.trim() !== "[DONE]") {
                                try {
                                    const parsed = JSON.parse(data);
                                    
                                    // 检查是否是错误响应
                                    if (parsed.error) {
                                        console.error("API返回错误:", parsed.error);
                                        throw new Error(`API错误: ${parsed.error.message || JSON.stringify(parsed.error)}`);
                                    }
                                    
                                    // 检查choices是否存在
                                    if (parsed.choices && parsed.choices[0]) {
                                        const content = parsed.choices[0].delta?.content || "";
                                        fullResponse += content;
                                    }
                                } catch (e) { 
                                    console.error("解析数据块失败:", e, "数据:", data.substring(0, 200));
                                    // 如果是API错误，抛出异常
                                    if (e.message && e.message.startsWith("API错误:")) {
                                        throw e;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            console.log("累积的原始数据长度:", accumulatedChunk.length);
            
            if (apiType === "gemini") {
                try {
                    const parsedStream = JSON.parse(accumulatedChunk);
                    fullResponse = parsedStream.map(item => item.candidates?.[0]?.content?.parts?.[0]?.text || "").join('');
                } catch (e) {
                    console.error("Error parsing Gemini stream:", e, "Chunk:", accumulatedChunk);
                    showToast("解析Gemini响应失败");
                    return;
                }
            }
            
            console.log("最终fullResponse长度:", fullResponse.length);
            console.log("========================");
            
            // 调试：输出完整响应
            console.log("=== AI完整响应 ===");
            console.log("聊天类型:", currentChatType);
            console.log("是否旁观者模式:", chat.isObserverMode);
            console.log("响应内容:", fullResponse);
            console.log("==================");
            
            if (fullResponse) {
                // 【修复】移除AI响应中的时间戳标记（这些时间戳只是为了给AI提供上下文，不应该显示给用户）
                // 匹配格式：[今天 21:16]、[昨天 23:50]、[12月24日 15:30]、[2024年12月24日 15:30]
                const timestampRegex = /\[(今天|昨天|\d{1,2}月\d{1,2}日|\d{4}年\d{1,2}月\d{1,2}日)\s+\d{1,2}:\d{2}\]\s*/g;
                fullResponse = fullResponse.replace(timestampRegex, '');
                
                // 提取心声
                let innerThought = null;
                const innerThoughtRegex = /\[心声[:：]\s*([\s\S]+?)\]/;
                const innerThoughtMatch = fullResponse.match(innerThoughtRegex);
                if (innerThoughtMatch) {
                    innerThought = innerThoughtMatch[1].trim();
                    // 从响应中移除心声部分
                    fullResponse = fullResponse.replace(innerThoughtRegex, '').trim();
                }
                
                if (currentChatType === 'private') {
                    const character = chat;
                    const myName = character.myName;

                    const messageRegex = new RegExp(`\\[${character.realName}(?:的(?:消息|语音|转账|表情包)|发送的表情包|发来的照片\\/视频|送来的礼物|切歌|换头像)[:：][\\s\\S]+?\\]|\\[${character.realName}(?:接收|退回)${myName}的转账\\]|\\[${character.realName}已接收礼物\\]|\\[${character.realName}更新状态为：.*?\\]`, "g");
                    // const messages = fullResponse.match(messageRegex) || [];
                    const messages = getMixedContent(fullResponse)
                    if (messages.length > 0) {
                        for (let i = 0; i < messages.length; i++) {
                            const item = messages[i];
                            const receivedTransferRegex = new RegExp(`\\[${character.realName}的转账：.*?元；备注：.*?\\]`);
                            const giftRegex = new RegExp(`\\[${character.realName}送来的礼物：.*?\\]`);
                            const message = {
                                id: `msg_${Date.now()}_${Math.random()}`,
                                role: 'assistant',
                                content: item.content.trim(),
                                parts: [{type: item.type, text: item.content.trim()}],
                                timestamp: Date.now(),
                            };
                            if (receivedTransferRegex.test(message.content)) {
                                message.transferStatus = 'pending';
                            } else if (giftRegex.test(message.content)) {
                                message.giftStatus = 'sent';
                            }
                            // 添加心声到第一条消息
                            if (innerThought && i === 0) {
                                message.innerThought = innerThought;
                            }
                            chat.history.push(message);
                            await addMessageBubble(message);
                            
                            // 如果不是最后一条消息，延迟300ms再显示下一条
                            if (i < messages.length - 1) {
                                await new Promise(resolve => setTimeout(resolve, 300));
                            }
                        }
                    } else {
                        const simpleMessage = {
                            id: `msg_${Date.now()}_${Math.random()}`,
                            role: 'assistant',
                            content: fullResponse,
                            parts: [{type: 'text', text: fullResponse}],
                            timestamp: Date.now()
                        };
                        if (innerThought) {
                            simpleMessage.innerThought = innerThought;
                        }
                        chat.history.push(simpleMessage);
                        await addMessageBubble(simpleMessage);
                    }
                    
                    // 检测并处理NovelAI图片请求
                    if (db.novelaiConfig && db.novelaiConfig.enabled) {
                        const naiRequest = detectNovelAIRequest(fullResponse);
                        if (naiRequest) {
                            try {
                                showToast('正在生成NovelAI图片...');
                                const imageUrl = await generateNovelAIImage(naiRequest.prompt, naiRequest.negative);
                                if (imageUrl) {
                                    const naiMessage = {
                                        id: `msg_${Date.now()}_${Math.random()}`,
                                        role: 'assistant',
                                        type: 'naiimag',
                                        imageUrl: imageUrl,
                                        prompt: naiRequest.prompt,
                                        timestamp: Date.now()
                                    };
                                    chat.history.push(naiMessage);
                                    await addMessageBubble(naiMessage);
                                    showToast('NovelAI图片生成成功！');
                                }
                            } catch (error) {
                                console.error('NovelAI图片生成失败:', error);
                                showToast('图片生成失败');
                            }
                        }
                    }
                } else if (currentChatType === 'group') {
                    const group = chat;
                    const memberRealNames = group.members.map(m => m.realName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
                    
                    // 检查是否有设置管理员的指令
                    let adminChanged = false;
                    const setAdminRegex = /\[(.+?)设置管理员[:：](.+?)\]/g;
                    let setAdminMatch;
                    while ((setAdminMatch = setAdminRegex.exec(fullResponse)) !== null) {
                        const ownerName = setAdminMatch[1].trim();
                        const targetName = setAdminMatch[2].trim();
                        
                        // 验证是否是当前群主发起的操作
                        const currentOwner = group.members.find(m => m.isOwner);
                        
                        // 查找目标成员（可能是AI成员或用户）
                        let targetMember = group.members.find(m => m.realName === targetName);
                        let isTargetUser = false;
                        let targetNickname = '';
                        
                        // 如果在members中没找到，检查是否是用户（用户没有realName，只有nickname）
                        if (!targetMember && (group.me.nickname === targetName || (group.me.realName && group.me.realName === targetName))) {
                            isTargetUser = true;
                            targetNickname = group.me.nickname;
                        } else if (targetMember) {
                            targetNickname = targetMember.groupNickname;
                        }
                        
                        // 验证群主身份和目标存在性
                        if (currentOwner && currentOwner.realName === ownerName && (targetMember || isTargetUser)) {
                            // 确保目标不是群主
                            if ((isTargetUser && !group.me.isOwner) || (targetMember && !targetMember.isOwner)) {
                                let shouldSetAdmin = false;
                                
                                if (isTargetUser) {
                                    // 设置用户为管理员
                                    if (!group.me.isAdmin) {
                                        group.me.isAdmin = true;
                                        shouldSetAdmin = true;
                                    }
                                } else if (targetMember) {
                                    // 设置AI成员为管理员
                                    if (!targetMember.isAdmin) {
                                        targetMember.isAdmin = true;
                                        shouldSetAdmin = true;
                                    }
                                }
                                
                                if (shouldSetAdmin) {
                                    adminChanged = true;
                                    
                                    // 添加系统消息
                                    const systemMessage = {
                                        id: `msg_${Date.now()}_${Math.random()}`,
                                        role: 'system',
                                        content: `[system-display:${currentOwner.groupNickname} 设置 ${targetNickname} 为管理员]`,
                                        timestamp: Date.now()
                                    };
                                    group.history.push(systemMessage);
                                }
                                
                                // 从AI回复中移除设置管理员指令
                                fullResponse = fullResponse.replace(setAdminMatch[0], '').trim();
                            }
                        }
                    }
                    
                    // 检查是否有取消管理员的指令
                    const removeAdminRegex = /\[(.+?)取消管理员[:：](.+?)\]/g;
                    let removeAdminMatch;
                    while ((removeAdminMatch = removeAdminRegex.exec(fullResponse)) !== null) {
                        const ownerName = removeAdminMatch[1].trim();
                        const targetName = removeAdminMatch[2].trim();
                        
                        // 验证是否是当前群主发起的操作
                        const currentOwner = group.members.find(m => m.isOwner);
                        
                        // 查找目标成员（可能是AI成员或用户）
                        let targetMember = group.members.find(m => m.realName === targetName);
                        let isTargetUser = false;
                        let targetNickname = '';
                        
                        // 如果在members中没找到，检查是否是用户（用户没有realName，只有nickname）
                        if (!targetMember && (group.me.nickname === targetName || (group.me.realName && group.me.realName === targetName))) {
                            isTargetUser = true;
                            targetNickname = group.me.nickname;
                        } else if (targetMember) {
                            targetNickname = targetMember.groupNickname;
                        }
                        
                        // 验证群主身份和目标存在性
                        if (currentOwner && currentOwner.realName === ownerName && (targetMember || isTargetUser)) {
                            let shouldRemoveAdmin = false;
                            
                            if (isTargetUser) {
                                // 取消用户的管理员身份
                                if (group.me.isAdmin) {
                                    group.me.isAdmin = false;
                                    shouldRemoveAdmin = true;
                                }
                            } else if (targetMember) {
                                // 取消AI成员的管理员身份
                                if (targetMember.isAdmin) {
                                    targetMember.isAdmin = false;
                                    shouldRemoveAdmin = true;
                                }
                            }
                            
                            if (shouldRemoveAdmin) {
                                adminChanged = true;
                                
                                // 添加系统消息
                                const systemMessage = {
                                    id: `msg_${Date.now()}_${Math.random()}`,
                                    role: 'system',
                                    content: `[system-display:${currentOwner.groupNickname} 取消了 ${targetNickname} 的管理员身份]`,
                                    timestamp: Date.now()
                                };
                                group.history.push(systemMessage);
                            }
                            
                            // 从AI回复中移除取消管理员指令
                            fullResponse = fullResponse.replace(removeAdminMatch[0], '').trim();
                        }
                    }
                    
                    // 如果管理员有变动，保存数据并重新渲染
                    if (adminChanged) {
                        await saveData();
                        if (groupSettingsSidebar.classList.contains('open')) {
                            renderGroupMembersInSettings(group);
                        }
                        // 重新渲染消息以显示系统通知
                        if (currentChatType === 'group' && currentChatId === group.id) {
                            renderMessages(false, true);
                        }
                    }
                    
                    // 检查是否有踢人的指令
                    let memberKicked = false;
                    const kickMemberRegex = /\[(.+?)踢出[:：](.+?)\]/g;
                    let kickMatch;
                    const kickedMembers = [];
                    const kickedMembersData = [];
                    
                    // 确保群组有kickedMembers数组
                    if (!group.kickedMembers) {
                        group.kickedMembers = [];
                    }
                    
                    while ((kickMatch = kickMemberRegex.exec(fullResponse)) !== null) {
                        const actorName = kickMatch[1].trim();
                        const targetName = kickMatch[2].trim();
                        
                        // 查找执行者和目标成员
                        const actor = group.members.find(m => m.realName === actorName);
                        const targetMember = group.members.find(m => m.realName === targetName);
                        
                        if (actor && targetMember) {
                            let canKick = false;
                            
                            // 判断权限
                            if (actor.isOwner) {
                                // 群主可以踢出任何人
                                canKick = true;
                            } else if (actor.isAdmin) {
                                // 管理员只能踢出普通成员
                                if (!targetMember.isOwner && !targetMember.isAdmin) {
                                    canKick = true;
                                }
                            }
                            
                            if (canKick) {
                                // 记录被踢出的成员昵称
                                kickedMembers.push(targetMember.groupNickname);
                                
                                // 保存被踢成员的完整信息（用于拉回）
                                const kickedMemberInfo = {
                                    ...targetMember,
                                    kickedAt: Date.now(),
                                    wasAdmin: targetMember.isAdmin || false // 记录是否曾是管理员
                                };
                                kickedMembersData.push(kickedMemberInfo);
                                
                                // 从群组中移除成员
                                group.members = group.members.filter(m => m.id !== targetMember.id);
                                memberKicked = true;
                            }
                            
                            // 从AI回复中移除踢人指令
                            fullResponse = fullResponse.replace(kickMatch[0], '').trim();
                        }
                    }
                    
                    // 如果有成员被踢出，添加系统消息
                    if (memberKicked && kickedMembers.length > 0) {
                        const systemMessage = {
                            id: `msg_${Date.now()}_${Math.random()}`,
                            role: 'system',
                            content: `[system-display:${kickedMembers.join('、')} 被移出群聊]`,
                            timestamp: Date.now(),
                            kickedMembersData: kickedMembersData // 保存被踢成员数据
                        };
                        group.history.push(systemMessage);
                        
                        // 将被踢成员添加到群组的kickedMembers数组
                        group.kickedMembers.push(...kickedMembersData);
                        
                        await saveData();
                        if (groupSettingsSidebar.classList.contains('open')) {
                            renderGroupMembersInSettings(group);
                        }
                    }
                    
                    // 检查是否有转让群主的指令
                    const transferOwnerRegex = /\[(.+?)转让群主给[:：](.+?)\]/;
                    const transferMatch = fullResponse.match(transferOwnerRegex);
                    
                    if (transferMatch) {
                        const ownerName = transferMatch[1].trim();
                        const targetName = transferMatch[2].trim();
                        
                        // 验证是否是当前群主发起的转让
                        const currentOwner = group.members.find(m => m.isOwner);
                        const targetMember = group.members.find(m => m.realName === targetName);
                        
                        if (currentOwner && currentOwner.realName === ownerName && targetMember) {
                            // 执行转让
                            group.members.forEach(member => {
                                member.isOwner = false;
                            });
                            targetMember.isOwner = true;
                            // 如果新群主之前是管理员，取消管理员身份（因为群主不需要管理员身份）
                            targetMember.isAdmin = false;
                            
                            // 添加系统消息
                            const systemMessage = {
                                id: `msg_${Date.now()}`,
                                role: 'system',
                                content: `[system-display:群主已转让给 ${targetMember.groupNickname}]`,
                                timestamp: Date.now()
                            };
                            group.history.push(systemMessage);
                            
                            // 从AI回复中移除转让指令
                            fullResponse = fullResponse.replace(transferOwnerRegex, '').trim();
                            
                            // 保存数据
                            await saveData();
                            
                            // 重新渲染群成员列表（如果设置面板打开）
                            if (groupSettingsSidebar.classList.contains('open')) {
                                renderGroupMembersInSettings(group);
                            }
                        }
                    }
                    
                    // 检查是否有禁言指令
                    let muteChanged = false;
                    const muteRegex = /\[(.+?)禁言[:：](.+?)\s+(.+?)\]/g;
                    let muteMatch;
                    while ((muteMatch = muteRegex.exec(fullResponse)) !== null) {
                        const actorName = muteMatch[1].trim();
                        const targetName = muteMatch[2].trim();
                        const durationStr = muteMatch[3].trim();
                        
                        // 查找执行者和目标成员
                        const actor = group.members.find(m => m.realName === actorName);
                        const targetMember = group.members.find(m => m.realName === targetName);
                        
                        if (actor && targetMember) {
                            let canMute = false;
                            
                            // 判断权限
                            if (actor.isOwner) {
                                // 群主可以禁言任何人（除了自己）
                                if (targetMember.id !== actor.id) {
                                    canMute = true;
                                }
                            } else if (actor.isAdmin) {
                                // 管理员只能禁言普通成员
                                if (!targetMember.isOwner && !targetMember.isAdmin) {
                                    canMute = true;
                                }
                            }
                            
                            if (canMute) {
                                // 解析禁言时长
                                let duration = 0;
                                if (durationStr.includes('永久')) {
                                    duration = -1;
                                } else if (durationStr.includes('分钟')) {
                                    duration = parseInt(durationStr) || 10;
                                } else if (durationStr.includes('小时')) {
                                    duration = (parseInt(durationStr) || 1) * 60;
                                } else if (durationStr.includes('天')) {
                                    duration = (parseInt(durationStr) || 1) * 1440;
                                } else {
                                    duration = parseInt(durationStr) || 10;
                                }
                                
                                // 设置禁言
                                targetMember.isMuted = true;
                                targetMember.muteEndTime = duration === -1 ? -1 : Date.now() + (duration * 60000);
                                muteChanged = true;
                                
                                // 添加系统消息
                                const durationText = duration === -1 ? '永久' : durationStr;
                                const systemMessage = {
                                    id: `msg_${Date.now()}_${Math.random()}`,
                                    role: 'system',
                                    content: `[system-display:${actor.groupNickname} 禁言了 ${targetMember.groupNickname} (${durationText})]`,
                                    timestamp: Date.now()
                                };
                                group.history.push(systemMessage);
                            }
                            
                            // 从AI回复中移除禁言指令
                            fullResponse = fullResponse.replace(muteMatch[0], '').trim();
                        }
                    }
                    
                    // 检查是否有解除禁言指令
                    const unmuteRegex = /\[(.+?)解除禁言[:：](.+?)\]/g;
                    let unmuteMatch;
                    while ((unmuteMatch = unmuteRegex.exec(fullResponse)) !== null) {
                        const actorName = unmuteMatch[1].trim();
                        const targetName = unmuteMatch[2].trim();
                        
                        // 查找执行者和目标成员
                        const actor = group.members.find(m => m.realName === actorName);
                        const targetMember = group.members.find(m => m.realName === targetName);
                        
                        if (actor && targetMember) {
                            let canUnmute = false;
                            
                            // 判断权限（群主和管理员都可以解除禁言）
                            if (actor.isOwner || actor.isAdmin) {
                                canUnmute = true;
                            }
                            
                            if (canUnmute && targetMember.isMuted) {
                                // 解除禁言
                                targetMember.isMuted = false;
                                targetMember.muteEndTime = null;
                                muteChanged = true;
                                
                                // 添加系统消息
                                const systemMessage = {
                                    id: `msg_${Date.now()}_${Math.random()}`,
                                    role: 'system',
                                    content: `[system-display:${actor.groupNickname} 解除了 ${targetMember.groupNickname} 的禁言]`,
                                    timestamp: Date.now()
                                };
                                group.history.push(systemMessage);
                            }
                            
                            // 从AI回复中移除解除禁言指令
                            fullResponse = fullResponse.replace(unmuteMatch[0], '').trim();
                        }
                    }
                    
                    // 检查是否有全员禁言指令
                    const muteAllRegex = /\[(.+?)(开启|关闭)全员禁言\]/g;
                    let muteAllMatch;
                    while ((muteAllMatch = muteAllRegex.exec(fullResponse)) !== null) {
                        const actorName = muteAllMatch[1].trim();
                        const action = muteAllMatch[2].trim();
                        
                        // 查找执行者
                        const actor = group.members.find(m => m.realName === actorName);
                        
                        if (actor && (actor.isOwner || actor.isAdmin)) {
                            const shouldMuteAll = action === '开启';
                            
                            if (group.allMuted !== shouldMuteAll) {
                                group.allMuted = shouldMuteAll;
                                muteChanged = true;
                                
                                // 添加系统消息
                                const systemMessage = {
                                    id: `msg_${Date.now()}_${Math.random()}`,
                                    role: 'system',
                                    content: `[system-display:${actor.groupNickname} ${action}了全员禁言]`,
                                    timestamp: Date.now()
                                };
                                group.history.push(systemMessage);
                            }
                            
                            // 从AI回复中移除全员禁言指令
                            fullResponse = fullResponse.replace(muteAllMatch[0], '').trim();
                        }
                    }
                    
                    // 如果禁言状态有变动，保存数据并重新渲染
                    if (muteChanged) {
                        await saveData();
                        if (groupSettingsSidebar.classList.contains('open')) {
                            renderGroupMembersInSettings(group);
                        }
                        // 重新渲染消息以显示系统通知
                        if (currentChatType === 'group' && currentChatId === group.id) {
                            renderMessages(false, true);
                        }
                    }
                    
                    // 检查是否有修改群名指令
                    let groupNameChanged = false;
                    const renameGroupRegex = /\[(.+?)修改群名为[:：](.+?)\]/g;
                    let renameMatch;
                    while ((renameMatch = renameGroupRegex.exec(fullResponse)) !== null) {
                        const actorName = renameMatch[1].trim();
                        const newGroupName = renameMatch[2].trim();
                        
                        // 查找执行者
                        const actor = group.members.find(m => m.realName === actorName);
                        
                        if (actor && newGroupName) {
                            // 修改群名
                            const oldName = group.name;
                            group.name = newGroupName;
                            groupNameChanged = true;
                            
                            // 添加系统消息
                            const systemMessage = {
                                id: `msg_${Date.now()}_${Math.random()}`,
                                role: 'system',
                                content: `[system-display:${actor.groupNickname} 修改群名为"${newGroupName}"]`,
                                timestamp: Date.now()
                            };
                            group.history.push(systemMessage);
                            
                            // 从AI回复中移除修改群名指令
                            fullResponse = fullResponse.replace(renameMatch[0], '').trim();
                        }
                    }
                    
                    // 检查是否有发布群公告指令
                    let announcementChanged = false;
                    const addAnnouncementRegex = /\[(.+?)发布群公告[:：](.+?)\]/g;
                    let addAnnouncementMatch;
                    while ((addAnnouncementMatch = addAnnouncementRegex.exec(fullResponse)) !== null) {
                        const actorName = addAnnouncementMatch[1].trim();
                        const announcementContent = addAnnouncementMatch[2].trim();
                        
                        // 查找执行者
                        const actor = group.members.find(m => m.realName === actorName);
                        
                        // 验证权限：只有群主和管理员可以发布公告
                        if (actor && (actor.isOwner || actor.isAdmin) && announcementContent) {
                            // 初始化公告数组
                            if (!group.announcements) {
                                group.announcements = [];
                            }
                            
                            // 添加新公告
                            group.announcements.push({
                                content: announcementContent,
                                createdAt: Date.now(),
                                updatedAt: Date.now(),
                                createdBy: actor.groupNickname,
                                updatedBy: actor.groupNickname
                            });
                            
                            announcementChanged = true;
                            
                            // 添加系统消息
                            const systemMessage = {
                                id: `msg_${Date.now()}_${Math.random()}`,
                                role: 'system',
                                content: `[system-display:${actor.groupNickname} 发布了新的群公告]`,
                                timestamp: Date.now()
                            };
                            group.history.push(systemMessage);
                            
                            // 从AI回复中移除发布公告指令
                            fullResponse = fullResponse.replace(addAnnouncementMatch[0], '').trim();
                        }
                    }
                    
                    // 检查是否有编辑群公告指令
                    const editAnnouncementRegex = /\[(.+?)编辑群公告\]/g;
                    let editAnnouncementMatch;
                    while ((editAnnouncementMatch = editAnnouncementRegex.exec(fullResponse)) !== null) {
                        const actorName = editAnnouncementMatch[1].trim();
                        
                        // 查找执行者
                        const actor = group.members.find(m => m.realName === actorName);
                        
                        // 验证权限：只有群主和管理员可以编辑公告
                        if (actor && (actor.isOwner || actor.isAdmin)) {
                            // 初始化公告数组
                            if (!group.announcements) {
                                group.announcements = [];
                            }
                            
                            // 如果有公告，编辑最新的一条
                            if (group.announcements.length > 0) {
                                const lastIndex = group.announcements.length - 1;
                                group.announcements[lastIndex].updatedAt = Date.now();
                                group.announcements[lastIndex].updatedBy = actor.groupNickname;
                                
                                announcementChanged = true;
                                
                                // 添加系统消息
                                const systemMessage = {
                                    id: `msg_${Date.now()}_${Math.random()}`,
                                    role: 'system',
                                    content: `[system-display:${actor.groupNickname} 编辑了群公告]`,
                                    timestamp: Date.now()
                                };
                                group.history.push(systemMessage);
                            }
                            
                            // 从AI回复中移除编辑公告指令
                            fullResponse = fullResponse.replace(editAnnouncementMatch[0], '').trim();
                        }
                    }
                    
                    // 如果公告有变动，保存数据并更新显示
                    if (announcementChanged) {
                        await saveData();
                        
                        // 如果当前在该群聊界面，重新渲染消息以显示系统通知
                        if (currentChatType === 'group' && currentChatId === group.id) {
                            renderMessages(false, true);
                            // 如果群设置面板打开，更新公告列表
                            const groupSettingsScreen = document.getElementById('group-settings-screen');
                            if (groupSettingsScreen && groupSettingsScreen.style.display !== 'none') {
                                renderGroupAnnouncement(group);
                            }
                        }
                    }
                    
                    // 如果群名有变动，保存数据并更新显示
                    if (groupNameChanged) {
                        await saveData();
                        
                        // 更新聊天列表中的群名
                        renderChatList();
                        
                        // 如果当前在该群聊界面，更新标题
                        if (currentChatType === 'group' && currentChatId === group.id) {
                            const chatRoomTitle = document.querySelector('#chat-room-screen .title');
                            if (chatRoomTitle) {
                                chatRoomTitle.textContent = group.name;
                            }
                            // 重新渲染消息以显示系统通知
                            renderMessages(false, true);
                        }
                    }
                    
                    // 提取群聊中各成员的心声（仅当群聊心声功能开启时）
                    const memberThoughts = {};
                    if (group.innerThoughtEnabled) {
                        group.members.forEach(member => {
                            const thoughtRegex = new RegExp(`\\[${member.realName}的心声[:：]\\s*([\\s\\S]+?)\\]`);
                            const thoughtMatch = fullResponse.match(thoughtRegex);
                            if (thoughtMatch) {
                                memberThoughts[member.realName] = thoughtMatch[1].trim();
                                // 从响应中移除该心声
                                fullResponse = fullResponse.replace(thoughtRegex, '').trim();
                            }
                        });
                    }
                    
                    // 调试：输出群聊成员信息
                    console.log("=== 群聊成员信息 ===");
                    console.log("成员数量:", group.members.length);
                    console.log("成员列表:", group.members.map(m => `${m.realName}(${m.groupNickname})`).join(', '));
                    console.log("成员真名列表:", memberRealNames);
                    console.log("==================");
                    
                    const memberRegex = new RegExp(`\\[(${memberRealNames.join('|')})(?:的消息|的语音|发送的表情包|发来的照片\\/视频)：[\\s\\S]+?\\]`, "g");
                    // ▼▼▼ 【群投票功能】检测并处理AI发起的投票 ▼▼▼
                    // 检测JSON格式的投票指令
                    const pollRegex = /\{"type"\s*:\s*"poll"\s*,\s*"name"\s*:\s*"([^"]+)"\s*,\s*"question"\s*:\s*"([^"]+)"\s*,\s*"options"\s*:\s*"([^"]+)"\}/g;
                    let pollMatch;
                    while ((pollMatch = pollRegex.exec(fullResponse)) !== null) {
                        const senderName = pollMatch[1];
                        const question = pollMatch[2];
                        const optionsStr = pollMatch[3];
                        const options = optionsStr.split('\\n').map(opt => opt.trim()).filter(opt => opt);
                        
                        if (options.length >= 2) {
                            const sender = group.members.find(m => m.realName === senderName);
                            if (sender) {
                                // 创建投票消息
                                const pollMessage = {
                                    id: `msg_${Date.now()}_${Math.random()}`,
                                    role: 'assistant',
                                    senderId: sender.id,
                                    senderName: sender.groupNickname,
                                    type: 'poll',
                                    timestamp: Date.now(),
                                    question: question,
                                    options: options,
                                    votes: {},
                                    isClosed: false
                                };
                                
                                group.history.push(pollMessage);
                                await addMessageBubble(pollMessage);
                                await new Promise(resolve => setTimeout(resolve, 300));
                            }
                        }
                        
                        // 从响应中移除投票指令
                        fullResponse = fullResponse.replace(pollMatch[0], '').trim();
                    }
                    
                    // 检测并处理AI参与投票
                    const voteRegex = /\{"type"\s*:\s*"vote"\s*,\s*"name"\s*:\s*"([^"]+)"\s*,\s*"poll_timestamp"\s*:\s*(\d+)\s*,\s*"choice"\s*:\s*"([^"]+)"\}/g;
                    let voteMatch;
                    while ((voteMatch = voteRegex.exec(fullResponse)) !== null) {
                        const voterName = voteMatch[1];
                        const pollTimestamp = parseInt(voteMatch[2]);
                        const choice = voteMatch[3];
                        
                        const poll = group.history.find(m => m.timestamp === pollTimestamp && m.type === 'poll');
                        const voter = group.members.find(m => m.realName === voterName);
                        
                        if (poll && !poll.isClosed && voter) {
                            // 移除该成员之前的投票
                            for (const option in poll.votes) {
                                const voterIndex = poll.votes[option].indexOf(voter.groupNickname);
                                if (voterIndex > -1) {
                                    poll.votes[option].splice(voterIndex, 1);
                                }
                            }
                            
                            // 添加新投票
                            if (!poll.votes[choice]) {
                                poll.votes[choice] = [];
                            }
                            poll.votes[choice].push(voter.groupNickname);
                            await saveData();
                        }
                        
                        // 从响应中移除投票指令
                        fullResponse = fullResponse.replace(voteMatch[0], '').trim();
                    }
                    // ▲▲▲ 【群投票功能】处理结束 ▲▲▲
                    
                    // const messages = fullResponse.match(memberRegex) || [];
                    const messages = getMixedContent(fullResponse)
                    
                    // 调试：输出解析结果
                    console.log("=== 消息解析结果 ===");
                    console.log("解析到的消息数量:", messages.length);
                    console.log("消息内容:", messages);
                    console.log("==================");
                    
                    let r = /\[(.*?)((?:的消息|的语音|发送的表情包|发来的照片\/视频))：/
                    if (messages.length > 0) {
                        for (let i = 0; i < messages.length; i++) {
                            const item = messages[i];
                            const nameMatch = item.content.match(r);
                            if (nameMatch || item.char) {
                                const senderName = item.char || (nameMatch[1]);
                                const sender = group.members.find(m => (m.realName === senderName || m.groupNickname === senderName));
                                
                                // 调试：输出匹配信息
                                console.log(`--- 消息 #${i+1} ---`);
                                console.log("发送者名字:", senderName);
                                console.log("找到的成员:", sender ? `${sender.realName}(${sender.groupNickname})` : "未找到");
                                console.log("消息内容:", item.content.substring(0, 100));
                                
                                if (sender) {
                                    // 检查发送者是否被禁言
                                    if (sender.isMuted) {
                                        if (sender.muteEndTime === -1 || sender.muteEndTime > Date.now()) {
                                            // 被禁言的成员不能发送消息，跳过
                                            console.log(`${sender.realName} 被禁言，跳过消息`);
                                            continue;
                                        } else {
                                            // 禁言时间已过，自动解除
                                            sender.isMuted = false;
                                            sender.muteEndTime = null;
                                            await saveData();
                                        }
                                    }
                                    
                                    // 检查全员禁言
                                    if (group.allMuted && !sender.isOwner && !sender.isAdmin) {
                                        // 全员禁言时，普通成员不能发送消息
                                        console.log(`全员禁言中，${sender.realName} 无法发送消息`);
                                        continue;
                                    }
                                    const message = {
                                        id: `msg_${Date.now()}_${Math.random()}`,
                                        role: 'assistant',
                                        content: item.content.trim(),
                                        parts: [{type: item.type, text: item.content.trim()}],
                                        timestamp: Date.now(),
                                        senderId: sender.id
                                    };
                                    // 添加该成员的心声
                                    if (memberThoughts[sender.realName]) {
                                        message.innerThought = memberThoughts[sender.realName];
                                    }
                                    // console.log(message)
                                    group.history.push(message);
                                    await addMessageBubble(message);
                                    
                                    // 如果不是最后一条消息，延迟300ms再显示下一条
                                    if (i < messages.length - 1) {
                                        await new Promise(resolve => setTimeout(resolve, 300));
                                    }
                                }
                            }
                        }
                    } else if (fullResponse.trim()) {
                        // 如果没有匹配到任何消息，但有内容，尝试作为单条消息处理
                        console.warn("AI response did not match expected group format, treating as single message:", fullResponse);
                        
                        // 尝试从响应中提取可能的发送者名字
                        let selectedMember = null;
                        for (const member of group.members) {
                            if (fullResponse.includes(member.realName) || fullResponse.includes(member.groupNickname)) {
                                selectedMember = member;
                                break;
                            }
                        }
                        
                        // 如果没找到，随机选择一个成员
                        if (!selectedMember && group.members.length > 0) {
                            selectedMember = group.members[Math.floor(Math.random() * group.members.length)];
                        }
                        
                        if (selectedMember) {
                            const simpleMessageContent = `[${selectedMember.realName}的消息：${fullResponse}]`;
                            const simpleMessage = {
                                id: `msg_${Date.now()}_${Math.random()}`,
                                role: 'assistant',
                                content: simpleMessageContent,
                                parts: [{type: 'text', text: simpleMessageContent}],
                                timestamp: Date.now(),
                                senderId: selectedMember.id
                            };
                            // 添加该成员的心声（如果有）
                            if (memberThoughts[selectedMember.realName]) {
                                simpleMessage.innerThought = memberThoughts[selectedMember.realName];
                            }
                            group.history.push(simpleMessage);
                            await addMessageBubble(simpleMessage);
                        } else {
                            console.error("无法处理群聊消息：没有可用的成员");
                            showToast('群聊消息处理失败：没有可用的成员');
                        }
                    } else {
                        console.warn("AI返回了空响应");
                        showToast('AI返回了空响应，请重试');
                    }
                }
                
                // 检查是否需要显示通知和增加未读数
                const chatRoomScreen = document.getElementById('chat-room-screen');
                const isViewingThisChat = chatRoomScreen.classList.contains('active') && 
                                         currentChatId === chat.id;
                
                if (!isViewingThisChat) {
                    // 计算本次新增的消息数量（直接从fullResponse中解析）
                    let newMessageCount = 0;
                    if (currentChatType === 'private') {
                        // 私聊：计算实际添加的消息数
                        const messageRegex = new RegExp(`\\[${chat.realName}(?:的(?:消息|语音|转账|表情包)|发送的表情包|发来的照片\\/视频|送来的礼物|切歌|换头像)[:：][\\s\\S]+?\\]|\\[${chat.realName}(?:接收|退回)${chat.myName}的转账\\]|\\[${chat.realName}已接收礼物\\]|\\[${chat.realName}更新状态为：.*?\\]`, "g");
                        const matches = fullResponse.match(messageRegex);
                        newMessageCount = matches ? matches.length : 1; // 如果没有匹配到格式，说明是简单消息，计为1条
                    } else {
                        // 群聊：计算实际添加的消息数
                        const messageRegex = /\[(.+?)(?:的(?:消息|语音|转账|表情包)|发送的表情包|发来的照片\/视频|送来的礼物)[:：][\s\S]+?\]/g;
                        const matches = fullResponse.match(messageRegex);
                        newMessageCount = matches ? matches.length : 0;
                    }
                    
                    // 增加未读消息数
                    chat.unreadCount = (chat.unreadCount || 0) + newMessageCount;
                    
                    // 显示弹窗通知（取最后一条消息的内容作为通知）
                    let notificationText = '';
                    if (currentChatType === 'private') {
                        // 私聊：显示消息内容
                        const textMatch = fullResponse.match(/\[.*?的消息：([\s\S]+?)\]/);
                        notificationText = textMatch ? textMatch[1].trim() : fullResponse;
                    } else {
                        // 群聊：显示发送者和消息内容
                        const messages = chat.history.filter(m => m.role === 'assistant');
                        if (messages.length > 0) {
                            const lastMsg = messages[messages.length - 1];
                            const sender = chat.members.find(m => m.id === lastMsg.senderId);
                            const textMatch = lastMsg.content.match(/\[.*?的消息：([\s\S]+?)\]/);
                            const msgText = textMatch ? textMatch[1].trim() : lastMsg.content;
                            notificationText = sender ? `${sender.groupNickname}: ${msgText}` : msgText;
                        }
                    }
                    
                    // 截取通知文本，避免过长
                    if (notificationText) {
                        const maxLength = 40;
                        notificationText = notificationText.substring(0, maxLength) + 
                                         (notificationText.length > maxLength ? '...' : '');
                        showNotification(chat.id, notificationText);
                    }
                }
                
                await saveData();
                renderChatList();
                updateMessageCountDisplay();
            }
        }

        // --- Other Sub-systems Setup (Stickers, Voice, etc.) ---
        function setupImageRecognition() {
            imageRecognitionBtn.addEventListener('click', () => {
                imageUploadInput.click();
            });
            imageUploadInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {
                            quality: 0.8,
                            maxWidth: 1024,
                            maxHeight: 1024
                        });
                        sendImageForRecognition(compressedUrl);
                    } catch (error) {
                        console.error('Image compression failed:', error);
                        showToast('图片处理失败，请重试');
                    } finally {
                        e.target.value = null;
                    }
                }
            });
            
            // 相机拍照按钮
            cameraCaptureBtn.addEventListener('click', () => {
                cameraCaptureInput.click();
            });
            cameraCaptureInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {
                            quality: 0.8,
                            maxWidth: 1024,
                            maxHeight: 1024
                        });
                        sendImageForRecognition(compressedUrl);
                    } catch (error) {
                        console.error('Image compression failed:', error);
                        showToast('图片处理失败，请重试');
                    } finally {
                        e.target.value = null;
                    }
                }
            });
        }

        async function setupStickerSystem() {
            stickerToggleBtn.addEventListener('click', () => {
                stickerModal.classList.toggle('visible');
                if (stickerModal.classList.contains('visible')) {
                    renderStickerGrid();
                }
            });
            addNewStickerBtn.addEventListener('click', () => {
                addStickerModalTitle.textContent = '添加新表情';
                addStickerForm.reset();
                stickerEditIdInput.value = '';
                stickerPreview.innerHTML = '<span>预览</span>';
                stickerUrlInput.disabled = false;
                addStickerModal.classList.add('visible');
            });
            
            // 管理按钮事件 - 打开管理弹窗
            const manageStickerBtn = document.getElementById('manage-sticker-btn');
            const manageStickerModal = document.getElementById('manage-sticker-modal');
            manageStickerBtn.addEventListener('click', () => {
                selectedStickerIds.clear();
                renderManageStickerGrid();
                manageStickerModal.classList.add('visible');
            });
            
            // 管理弹窗按钮事件
            document.getElementById('select-all-stickers-btn').addEventListener('click', () => {
                db.myStickers.forEach(sticker => selectedStickerIds.add(sticker.id));
                renderManageStickerGrid();
                updateStickerSelectCount();
            });
            
            document.getElementById('deselect-all-stickers-btn').addEventListener('click', () => {
                selectedStickerIds.clear();
                renderManageStickerGrid();
                updateStickerSelectCount();
            });
            
            document.getElementById('delete-selected-stickers-btn').addEventListener('click', deleteSelectedStickers);
            
            document.getElementById('close-manage-sticker-btn').addEventListener('click', () => {
                manageStickerModal.classList.remove('visible');
                selectedStickerIds.clear();
            });
            
            // 点击弹窗背景关闭
            manageStickerModal.addEventListener('click', (e) => {
                if (e.target === manageStickerModal) {
                    manageStickerModal.classList.remove('visible');
                    selectedStickerIds.clear();
                }
            });
            
            addStickerForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = stickerNameInput.value.trim();
                const id = stickerEditIdInput.value;
                const category = stickerCategorySelect.value;
                const previewImg = stickerPreview.querySelector('img');
                const data = previewImg ? previewImg.src : null;
                if (!name || !data) {
                    return showToast('请填写表情名称并提供图片');
                }
                const stickerData = {name, data};
                
                // 添加分类信息
                if (category) {
                    stickerData.category = category;
                }
                
                if (id) {
                    const index = db.myStickers.findIndex(s => s.id === id);
                    if (index > -1) {
                        db.myStickers[index] = {...db.myStickers[index], ...stickerData};
                    }
                } else {
                    stickerData.id = `sticker_${Date.now()}`;
                    db.myStickers.push(stickerData);
                }
                await saveData();
                renderStickerGrid();
                updateCategorySelects();
                addStickerModal.classList.remove('visible');
                showToast('表情包已保存');
            });
            stickerUrlInput.addEventListener('input', (e) => {
                stickerPreview.innerHTML = `<img src="${e.target.value}" alt="预览">`;
                stickerFileUpload.value = '';
            });
            stickerFileUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 200, maxHeight: 200});
                        stickerPreview.innerHTML = `<img src="${compressedUrl}" alt="预览">`;
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    } catch (error) {
                        console.error('表情包压缩失败:', error);
                        showToast('表情包压缩失败，请重试');
                    }
                }
            });
            editStickerBtn.addEventListener('click', () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    addStickerModalTitle.textContent = '编辑表情';
                    stickerEditIdInput.value = sticker.id;
                    stickerNameInput.value = sticker.name;
                    stickerPreview.innerHTML = `<img src="${sticker.data}" alt="预览">`;
                    if (sticker.data.startsWith('http')) {
                        stickerUrlInput.value = sticker.data;
                        stickerUrlInput.disabled = false;
                    } else {
                        stickerUrlInput.value = '';
                        stickerUrlInput.disabled = true;
                    }
                    addStickerModal.classList.add('visible');
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
            deleteStickerBtn.addEventListener('click', async () => {
                if (!currentStickerActionTarget) return;
                const sticker = db.myStickers.find(s => s.id === currentStickerActionTarget);
                if (sticker) {
                    if (confirm(`确定要删除表情"${sticker.name}"吗？`)) {
                        db.myStickers = db.myStickers.filter(s => s.id !== currentStickerActionTarget);
                        await saveData();
                        renderStickerGrid();
                        showToast('表情已删除');
                    }
                }
                stickerActionSheet.classList.remove('visible');
                currentStickerActionTarget = null;
            });
            
            // 批量导入功能
            const batchImportStickerBtn = document.getElementById('batch-import-sticker-btn');
            const batchImportSelectionModal = document.getElementById('batch-import-selection-modal');
            const batchImportUrlModal = document.getElementById('batch-import-url-modal');
            const batchImportLocalModal = document.getElementById('batch-import-local-modal');
            
            // 批量导入按钮点击
            batchImportStickerBtn.addEventListener('click', () => {
                batchImportSelectionModal.classList.add('visible');
            });
            
            // 取消批量导入方式选择
            document.getElementById('cancel-batch-import-selection-btn').addEventListener('click', () => {
                batchImportSelectionModal.classList.remove('visible');
            });
            
            // 选择URL批量导入
            document.getElementById('batch-import-url-btn').addEventListener('click', () => {
                batchImportSelectionModal.classList.remove('visible');
                batchImportUrlModal.classList.add('visible');
            });
            
            // 选择本地批量导入
            document.getElementById('batch-import-local-btn').addEventListener('click', () => {
                batchImportSelectionModal.classList.remove('visible');
                batchImportLocalModal.classList.add('visible');
            });
            
            // 取消URL批量导入
            document.getElementById('cancel-batch-url-import-btn').addEventListener('click', () => {
                batchImportUrlModal.classList.remove('visible');
                document.getElementById('batch-sticker-names').value = '';
                document.getElementById('batch-sticker-urls').value = '';
            });
            
            // 取消本地批量导入
            document.getElementById('cancel-batch-local-import-btn').addEventListener('click', () => {
                batchImportLocalModal.classList.remove('visible');
                document.getElementById('batch-sticker-names-local').value = '';
                document.getElementById('batch-sticker-files').value = '';
                document.getElementById('batch-files-info').textContent = '';
            });
            
            // 本地文件选择更新提示
            document.getElementById('batch-sticker-files').addEventListener('change', (e) => {
                const files = e.target.files;
                const infoEl = document.getElementById('batch-files-info');
                if (files.length > 0) {
                    infoEl.textContent = `已选择 ${files.length} 个文件`;
                } else {
                    infoEl.textContent = '';
                }
            });
            
            // 确认URL批量导入
            document.getElementById('confirm-batch-url-import-btn').addEventListener('click', async () => {
                const namesInput = document.getElementById('batch-sticker-names').value.trim();
                const urlsInput = document.getElementById('batch-sticker-urls').value.trim();
                const category = batchStickerCategorySelect.value;
                
                if (!namesInput || !urlsInput) {
                    showToast('请填写表情名称和URL');
                    return;
                }
                
                // 解析名称（逗号分隔）
                const names = namesInput.split(',').map(n => n.trim()).filter(n => n);
                
                // 解析URL（每行一个）
                const urls = urlsInput.split('\n').map(u => u.trim()).filter(u => u);
                
                if (names.length === 0 || urls.length === 0) {
                    showToast('请确保名称和URL不为空');
                    return;
                }
                
                if (names.length !== urls.length) {
                    showToast(`名称数量(${names.length})与URL数量(${urls.length})不匹配`);
                    return;
                }
                
                // 批量添加表情
                let successCount = 0;
                for (let i = 0; i < names.length; i++) {
                    const stickerData = {
                        id: `sticker_${Date.now()}_${i}`,
                        name: names[i],
                        data: urls[i]
                    };
                    
                    // 添加分类信息
                    if (category) {
                        stickerData.category = category;
                    }
                    
                    db.myStickers.push(stickerData);
                    successCount++;
                }
                
                await saveData();
                renderStickerGrid();
                updateCategorySelects();
                batchImportUrlModal.classList.remove('visible');
                document.getElementById('batch-sticker-names').value = '';
                document.getElementById('batch-sticker-urls').value = '';
                showToast(`成功导入 ${successCount} 个表情`);
            });
            
            // 确认本地批量导入
            document.getElementById('confirm-batch-local-import-btn').addEventListener('click', async () => {
                const namesInput = document.getElementById('batch-sticker-names-local').value.trim();
                const files = document.getElementById('batch-sticker-files').files;
                const category = batchStickerCategorySelectLocal.value;
                
                if (!namesInput) {
                    showToast('请填写表情名称');
                    return;
                }
                
                if (!files || files.length === 0) {
                    showToast('请选择图片文件');
                    return;
                }
                
                // 解析名称（逗号分隔）
                const names = namesInput.split(',').map(n => n.trim()).filter(n => n);
                
                if (names.length !== files.length) {
                    showToast(`名称数量(${names.length})与文件数量(${files.length})不匹配`);
                    return;
                }
                
                // 批量处理图片
                let successCount = 0;
                for (let i = 0; i < files.length; i++) {
                    try {
                        const compressedUrl = await compressImage(files[i], {quality: 0.8, maxWidth: 200, maxHeight: 200});
                        const stickerData = {
                            id: `sticker_${Date.now()}_${i}`,
                            name: names[i],
                            data: compressedUrl
                        };
                        
                        // 添加分类信息
                        if (category) {
                            stickerData.category = category;
                        }
                        
                        db.myStickers.push(stickerData);
                        successCount++;
                    } catch (error) {
                        console.error(`处理图片 ${files[i].name} 失败:`, error);
                    }
                }
                
                await saveData();
                renderStickerGrid();
                updateCategorySelects();
                batchImportLocalModal.classList.remove('visible');
                document.getElementById('batch-sticker-names-local').value = '';
                document.getElementById('batch-sticker-files').value = '';
                document.getElementById('batch-files-info').textContent = '';
                showToast(`成功导入 ${successCount} 个表情`);
            });
            
            // 在线搜索表情功能
            const onlineSearchStickerBtn = document.getElementById('online-search-sticker-btn');
            const onlineSearchStickerModal = document.getElementById('online-search-sticker-modal');
            const startSearchStickerBtn = document.getElementById('start-search-sticker-btn');
            const closeSearchStickerBtn = document.getElementById('close-search-sticker-btn');
            const stickerSearchKeyword = document.getElementById('sticker-search-keyword');
            const searchStatus = document.getElementById('search-status');
            const searchResultsContainer = document.getElementById('search-results-container');
            
            // 打开搜索弹窗
            onlineSearchStickerBtn.addEventListener('click', () => {
                onlineSearchStickerModal.classList.add('visible');
                searchResultsContainer.innerHTML = '';
                searchStatus.textContent = '';
            });
            
            // 关闭搜索弹窗
            closeSearchStickerBtn.addEventListener('click', () => {
                onlineSearchStickerModal.classList.remove('visible');
            });
            
            // 回车搜索
            stickerSearchKeyword.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    startSearchStickerBtn.click();
                }
            });
            
            // 多个表情包API配置（支持跨域的公开接口）
            const stickerAPIs = [
                {
                    name: 'Tenor GIF',
                    search: async (keyword) => {
                        try {
                            // Tenor 公开API，自带CORS支持
                            const apiKey = 'AIzaSyAyimkuYQYF_FXVALexPuGQctUWRURdCYQ'; // Tenor公开key
                            const response = await fetch(`https://tenor.googleapis.com/v2/search?q=${encodeURIComponent(keyword)}&key=${apiKey}&limit=20&media_filter=gif`);
                            const data = await response.json();
                            return data.results?.map(item => ({
                                url: item.media_formats.gif?.url || item.media_formats.tinygif?.url,
                                thumbnail: item.media_formats.tinygif?.url || item.media_formats.gif?.url,
                                title: item.content_description || keyword,
                                source: 'Tenor'
                            })) || [];
                        } catch (error) {
                            console.error('Tenor API error:', error);
                            return [];
                        }
                    }
                },
                {
                    name: 'GIPHY',
                    search: async (keyword) => {
                        try {
                            // GIPHY 公开API，自带CORS
                            const apiKey = 'Gc7131jiJuvI7IdN0HZ1D7nh0ow5BU6g'; // GIPHY公开key
                            const response = await fetch(`https://api.giphy.com/v1/gifs/search?api_key=${apiKey}&q=${encodeURIComponent(keyword)}&limit=20`);
                            const data = await response.json();
                            return data.data?.map(item => ({
                                url: item.images.original?.url,
                                thumbnail: item.images.fixed_height_small?.url,
                                title: item.title || keyword,
                                source: 'GIPHY'
                            })) || [];
                        } catch (error) {
                            console.error('GIPHY API error:', error);
                            return [];
                        }
                    }
                },
                {
                    name: 'Emoji Kitchen',
                    search: async (keyword) => {
                        try {
                            // 使用emoji查找（简化处理）
                            const emojiMap = {
                                '笑': '😊', '哭': '😭', '爱': '❤️', '怒': '😠', '惊': '😲',
                                '开心': '😄', '难过': '😢', '生气': '😡', '惊讶': '😮', '害怕': '😨',
                                '累': '😫', '睡': '😴', '酷': '😎', '点赞': '👍', '加油': '💪'
                            };
                            const emoji = emojiMap[keyword] || '😊';
                            // 这里返回基础emoji，实际可以接入更多API
                            return [];
                        } catch (error) {
                            return [];
                        }
                    }
                },
                {
                    name: 'Unsplash Photos',
                    search: async (keyword) => {
                        try {
                            // Unsplash API（图片）
                            const response = await fetch(`https://api.unsplash.com/search/photos?query=${encodeURIComponent(keyword)}&per_page=15&client_id=hbU3nHmWT1V7zmuzeFw0LfCEGEJcOmRDuGM3tFmJZfY`);
                            const data = await response.json();
                            return data.results?.map(item => ({
                                url: item.urls.regular,
                                thumbnail: item.urls.thumb,
                                title: item.alt_description || keyword,
                                source: 'Unsplash'
                            })) || [];
                        } catch (error) {
                            console.error('Unsplash API error:', error);
                            return [];
                        }
                    }
                },
                {
                    name: 'Pixabay',
                    search: async (keyword) => {
                        try {
                            // Pixabay API
                            const apiKey = '43128607-f011c9bf2137c549c6e23ecf6';
                            const response = await fetch(`https://pixabay.com/api/?key=${apiKey}&q=${encodeURIComponent(keyword)}&image_type=all&per_page=20`);
                            const data = await response.json();
                            return data.hits?.map(item => ({
                                url: item.largeImageURL,
                                thumbnail: item.previewURL,
                                title: item.tags || keyword,
                                source: 'Pixabay'
                            })) || [];
                        } catch (error) {
                            console.error('Pixabay API error:', error);
                            return [];
                        }
                    }
                },
                {
                    name: 'Lorem Picsum',
                    search: async (keyword) => {
                        try {
                            // Lorem Picsum 随机图片
                            const results = [];
                            for (let i = 0; i < 10; i++) {
                                const id = Math.floor(Math.random() * 1000);
                                results.push({
                                    url: `https://picsum.photos/id/${id}/400/400`,
                                    thumbnail: `https://picsum.photos/id/${id}/200/200`,
                                    title: `${keyword} ${i+1}`,
                                    source: 'Lorem Picsum'
                                });
                            }
                            return results;
                        } catch (error) {
                            return [];
                        }
                    }
                },
                {
                    name: 'PlaceKitten',
                    search: async (keyword) => {
                        try {
                            // PlaceKitten 可爱猫咪图片（如果关键词包含猫相关）
                            if (!keyword.includes('猫') && !keyword.includes('cat')) return [];
                            const results = [];
                            for (let i = 0; i < 10; i++) {
                                const w = 200 + i * 10;
                                const h = 200 + i * 10;
                                results.push({
                                    url: `https://placekitten.com/${w}/${h}`,
                                    thumbnail: `https://placekitten.com/200/200`,
                                    title: `Kitten ${i+1}`,
                                    source: 'PlaceKitten'
                                });
                            }
                            return results;
                        } catch (error) {
                            return [];
                        }
                    }
                },
                {
                    name: 'Dog CEO',
                    search: async (keyword) => {
                        try {
                            // Dog CEO API（狗狗图片）
                            if (!keyword.includes('狗') && !keyword.includes('dog')) return [];
                            const response = await fetch('https://dog.ceo/api/breeds/image/random/20');
                            const data = await response.json();
                            return data.message?.map((url, idx) => ({
                                url: url,
                                thumbnail: url,
                                title: `Dog ${idx+1}`,
                                source: 'Dog CEO'
                            })) || [];
                        } catch (error) {
                            console.error('Dog CEO API error:', error);
                            return [];
                        }
                    }
                },
                {
                    name: 'Cat API',
                    search: async (keyword) => {
                        try {
                            // The Cat API
                            if (!keyword.includes('猫') && !keyword.includes('cat')) return [];
                            const response = await fetch('https://api.thecatapi.com/v1/images/search?limit=20');
                            const data = await response.json();
                            return data?.map((item, idx) => ({
                                url: item.url,
                                thumbnail: item.url,
                                title: `Cat ${idx+1}`,
                                source: 'Cat API'
                            })) || [];
                        } catch (error) {
                            console.error('Cat API error:', error);
                            return [];
                        }
                    }
                },
                {
                    name: 'Foodish',
                    search: async (keyword) => {
                        try {
                            // Foodish API（美食图片）
                            if (!keyword.includes('食') && !keyword.includes('food') && !keyword.includes('吃')) return [];
                            const results = [];
                            for (let i = 0; i < 10; i++) {
                                const response = await fetch('https://foodish-api.com/api/');
                                const data = await response.json();
                                if (data.image) {
                                    results.push({
                                        url: data.image,
                                        thumbnail: data.image,
                                        title: `Food ${i+1}`,
                                        source: 'Foodish'
                                    });
                                }
                            }
                            return results;
                        } catch (error) {
                            return [];
                        }
                    }
                }
            ];
            
            // 开始搜索
            startSearchStickerBtn.addEventListener('click', async () => {
                const keyword = stickerSearchKeyword.value.trim();
                if (!keyword) {
                    showToast('请输入搜索关键词');
                    return;
                }
                
                searchResultsContainer.innerHTML = '';
                searchStatus.textContent = '正在搜索多个平台，请稍候...';
                startSearchStickerBtn.disabled = true;
                
                let allResults = [];
                
                // 并行搜索所有API
                const searchPromises = stickerAPIs.map(api => 
                    api.search(keyword).catch(err => {
                        console.error(`${api.name} failed:`, err);
                        return [];
                    })
                );
                
                try {
                    const resultsArray = await Promise.all(searchPromises);
                    resultsArray.forEach(results => {
                        allResults = allResults.concat(results);
                    });
                    
                    // 去重和过滤
                    allResults = allResults.filter(item => item && item.url);
                    
                    if (allResults.length === 0) {
                        searchStatus.textContent = '未找到相关表情包，请尝试其他关键词';
                    } else {
                        searchStatus.textContent = `找到 ${allResults.length} 个表情包`;
                        
                        // 渲染结果
                        allResults.forEach((item, index) => {
                            const resultItem = document.createElement('div');
                            resultItem.style.cssText = `
                                cursor: pointer;
                                border: 2px solid #ddd;
                                border-radius: 8px;
                                padding: 10px;
                                text-align: center;
                                transition: all 0.2s;
                                background: white;
                            `;
                            
                            resultItem.innerHTML = `
                                <img src="${item.thumbnail || item.url}" 
                                     style="width: 100%; height: 100px; object-fit: cover; border-radius: 4px; margin-bottom: 8px;"
                                     onerror="this.style.display='none'"
                                     loading="lazy">
                                <div style="font-size: 12px; color: #666; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${item.title}</div>
                                <div style="font-size: 10px; color: #999; margin-top: 4px;">${item.source}</div>
                            `;
                            
                            resultItem.addEventListener('mouseenter', () => {
                                resultItem.style.borderColor = '#007bff';
                                resultItem.style.transform = 'scale(1.05)';
                            });
                            
                            resultItem.addEventListener('mouseleave', () => {
                                resultItem.style.borderColor = '#ddd';
                                resultItem.style.transform = 'scale(1)';
                            });
                            
                            resultItem.addEventListener('click', async () => {
                                // 点击添加到表情库
                                const stickerData = {
                                    id: `sticker_${Date.now()}_${index}`,
                                    name: item.title,
                                    data: item.url
                                };
                                db.myStickers.push(stickerData);
                                await saveData();
                                renderStickerGrid();
                                showToast(`已添加表情: ${item.title}`);
                                resultItem.style.opacity = '0.5';
                                resultItem.style.pointerEvents = 'none';
                            });
                            
                            searchResultsContainer.appendChild(resultItem);
                        });
                    }
                } catch (error) {
                    console.error('Search error:', error);
                    searchStatus.textContent = '搜索出错，请稍后重试';
                }
                
                startSearchStickerBtn.disabled = false;
            });
            
            // 初始化分类管理系统
            setupStickerCategorySystem();
        }

        function renderStickerGrid() {
            stickerGridContainer.innerHTML = '';
            
            // 获取当前选中的分类
            const selectedCategory = currentStickerCategory.value;
            
            // 根据分类筛选表情
            const filteredStickers = selectedCategory 
                ? db.myStickers.filter(s => s.category === selectedCategory)
                : db.myStickers;
            
            if (filteredStickers.length === 0) {
                stickerGridContainer.innerHTML = '<p style="color:#aaa; text-align:center;">还没有表情包，快去添加吧！</p>';
                return;
            }
            
            filteredStickers.forEach(sticker => {
                const item = document.createElement('div');
                item.className = 'sticker-item';
                item.innerHTML = `<img src="${sticker.data}" alt="${sticker.name}" loading="lazy"><span>${sticker.name}</span>`;
                item.addEventListener('click', () => sendSticker(sticker));
                item.addEventListener('mousedown', (e) => {
                    if (e.button !== 0) return;
                    e.stopPropagation();
                    longPressTimer = setTimeout(() => {
                        handleStickerLongPress(sticker.id);
                    }, 500);
                });
                item.addEventListener('mouseup', () => clearTimeout(longPressTimer));
                item.addEventListener('mouseleave', () => clearTimeout(longPressTimer));
                item.addEventListener('touchstart', (e) => {
                    e.stopPropagation();
                    longPressTimer = setTimeout(() => {
                        handleStickerLongPress(sticker.id);
                    }, 500);
                });
                item.addEventListener('touchend', () => clearTimeout(longPressTimer));
                item.addEventListener('touchmove', () => clearTimeout(longPressTimer));
                stickerGridContainer.appendChild(item);
            });
        }

        function handleStickerLongPress(stickerId) {
            clearTimeout(longPressTimer);
            currentStickerActionTarget = stickerId;
            stickerActionSheet.classList.add('visible');
        }

        // 表情包管理功能
        function renderManageStickerGrid() {
            const grid = document.getElementById('manage-sticker-grid');
            grid.innerHTML = '';
            
            if (db.myStickers.length === 0) {
                grid.innerHTML = '<p style="grid-column: 1/-1; text-align: center; color: #aaa; padding: 40px;">还没有表情包，快去添加吧！</p>';
                updateStickerSelectCount();
                return;
            }
            
            db.myStickers.forEach(sticker => {
                const item = document.createElement('div');
                item.style.cssText = 'position: relative; display: flex; flex-direction: column; align-items: center; cursor: pointer; padding: 8px; border-radius: 8px; transition: background 0.2s;';
                
                const isSelected = selectedStickerIds.has(sticker.id);
                if (isSelected) {
                    item.style.backgroundColor = 'rgba(0, 123, 255, 0.1)';
                    item.style.border = '2px solid #007bff';
                }
                
                item.innerHTML = `
                    <input type="checkbox" ${isSelected ? 'checked' : ''} 
                           style="position: absolute; top: 5px; right: 5px; width: 20px; height: 20px; cursor: pointer; z-index: 10;">
                    <img src="${sticker.data}" alt="${sticker.name}" 
                         style="width: 70px; height: 70px; object-fit: contain; margin-bottom: 5px; pointer-events: none;">
                    <span style="font-size: 12px; color: #666; text-align: center; word-break: break-all;">${sticker.name}</span>
                `;
                
                const checkbox = item.querySelector('input[type="checkbox"]');
                
                // 点击整个item或checkbox都能切换选中状态
                item.addEventListener('click', (e) => {
                    toggleStickerSelection(sticker.id);
                });
                
                checkbox.addEventListener('click', (e) => {
                    e.stopPropagation(); // 防止触发两次
                });
                
                checkbox.addEventListener('change', (e) => {
                    e.stopPropagation();
                    toggleStickerSelection(sticker.id);
                });
                
                grid.appendChild(item);
            });
            
            updateStickerSelectCount();
        }

        function toggleStickerSelection(stickerId) {
            if (selectedStickerIds.has(stickerId)) {
                selectedStickerIds.delete(stickerId);
            } else {
                selectedStickerIds.add(stickerId);
            }
            renderManageStickerGrid();
        }

        function updateStickerSelectCount() {
            const countSpan = document.getElementById('sticker-select-count');
            if (countSpan) {
                countSpan.textContent = `已选择: ${selectedStickerIds.size}`;
            }
        }

        async function deleteSelectedStickers() {
            if (selectedStickerIds.size === 0) {
                showToast('请先选择要删除的表情');
                return;
            }
            
            if (confirm(`确定要删除选中的 ${selectedStickerIds.size} 个表情吗？`)) {
                db.myStickers = db.myStickers.filter(s => !selectedStickerIds.has(s.id));
                await saveData();
                selectedStickerIds.clear();
                renderManageStickerGrid(); // 更新管理弹窗
                renderStickerGrid(); // 同步更新主表情弹窗
                showToast('已删除选中的表情');
            }
        }

        // ============ 表情分类管理功能 ============
        let currentViewingCategory = null;

        // 更新分类选择下拉框
        function updateCategorySelects() {
            // 更新主表情弹窗的分类选择器
            const currentValue = currentStickerCategory.value;
            currentStickerCategory.innerHTML = '<option value="">全部</option>';
            db.stickerCategories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.name;
                currentStickerCategory.appendChild(option);
            });
            currentStickerCategory.value = currentValue;

            // 更新添加表情表单中的分类选择器
            stickerCategorySelect.innerHTML = '<option value="">默认（无分类）</option>';
            db.stickerCategories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.name;
                stickerCategorySelect.appendChild(option);
            });

            // 更新批量导入的分类选择器
            if (batchStickerCategorySelect) {
                batchStickerCategorySelect.innerHTML = '<option value="">默认（无分类）</option>';
                db.stickerCategories.forEach(cat => {
                    const option = document.createElement('option');
                    option.value = cat.id;
                    option.textContent = cat.name;
                    batchStickerCategorySelect.appendChild(option);
                });
            }

            if (batchStickerCategorySelectLocal) {
                batchStickerCategorySelectLocal.innerHTML = '<option value="">默认（无分类）</option>';
                db.stickerCategories.forEach(cat => {
                    const option = document.createElement('option');
                    option.value = cat.id;
                    option.textContent = cat.name;
                    batchStickerCategorySelectLocal.appendChild(option);
                });
            }
        }

        // 渲染分类列表
        function renderCategoryList() {
            categoryList.innerHTML = '';
            
            if (db.stickerCategories.length === 0) {
                categoryList.innerHTML = '<p style="text-align: center; color: #aaa; padding: 40px;">还没有分类，请新建一个吧！</p>';
                return;
            }

            db.stickerCategories.forEach(category => {
                const categoryItem = document.createElement('div');
                categoryItem.style.cssText = `
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 15px;
                    background: white;
                    border: 1px solid #eee;
                    border-radius: 8px;
                    cursor: pointer;
                    transition: all 0.2s;
                `;

                const stickerCount = db.myStickers.filter(s => s.category === category.id).length;

                categoryItem.innerHTML = `
                    <div>
                        <div style="font-weight: bold; font-size: 16px; margin-bottom: 5px;">${category.name}</div>
                        <div style="font-size: 12px; color: #888;">${stickerCount} 个表情</div>
                    </div>
                    <div style="font-size: 20px; color: #007bff;">›</div>
                `;

                categoryItem.addEventListener('mouseenter', () => {
                    categoryItem.style.background = '#f8f9fa';
                    categoryItem.style.borderColor = '#007bff';
                });

                categoryItem.addEventListener('mouseleave', () => {
                    categoryItem.style.background = 'white';
                    categoryItem.style.borderColor = '#eee';
                });

                categoryItem.addEventListener('click', () => {
                    viewCategoryDetail(category);
                });

                categoryList.appendChild(categoryItem);
            });
        }

        // 查看分类详情
        function viewCategoryDetail(category) {
            currentViewingCategory = category;
            categoryDetailTitle.textContent = `${category.name}（${db.myStickers.filter(s => s.category === category.id).length}个表情）`;
            
            categoryDetailGrid.innerHTML = '';
            const categoryStickers = db.myStickers.filter(s => s.category === category.id);
            
            if (categoryStickers.length === 0) {
                categoryDetailGrid.innerHTML = '<p style="grid-column: 1/-1; text-align: center; color: #aaa; padding: 40px;">该分类下还没有表情</p>';
            } else {
                categoryStickers.forEach(sticker => {
                    const item = document.createElement('div');
                    item.style.cssText = `
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        cursor: pointer;
                        transition: transform 0.2s;
                    `;
                    item.innerHTML = `
                        <img src="${sticker.data}" alt="${sticker.name}" 
                             style="width: 60px; height: 60px; object-fit: cover; border-radius: 8px; margin-bottom: 5px;">
                        <span style="font-size: 12px; color: #666; text-align: center; max-width: 80px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${sticker.name}</span>
                    `;
                    item.addEventListener('mouseenter', () => item.style.transform = 'scale(1.1)');
                    item.addEventListener('mouseleave', () => item.style.transform = 'scale(1)');
                    categoryDetailGrid.appendChild(item);
                });
            }

            stickerCategoryModal.classList.remove('visible');
            categoryDetailModal.classList.add('visible');
        }

        // 新建分类
        async function createCategory() {
            const name = newCategoryNameInput.value.trim();
            if (!name) {
                showToast('请输入分类名称');
                return;
            }

            // 检查是否重名
            if (db.stickerCategories.some(cat => cat.name === name)) {
                showToast('该分类名称已存在');
                return;
            }

            const category = {
                id: `category_${Date.now()}`,
                name: name,
                createdAt: Date.now()
            };

            db.stickerCategories.push(category);
            await saveData();
            
            newCategoryNameInput.value = '';
            renderCategoryList();
            updateCategorySelects();
            showToast('分类创建成功');
        }

        // 删除分类
        async function deleteCategory() {
            if (!currentViewingCategory) return;

            const stickerCount = db.myStickers.filter(s => s.category === currentViewingCategory.id).length;
            let confirmMsg = `确定要删除分类"${currentViewingCategory.name}"吗？`;
            if (stickerCount > 0) {
                confirmMsg += `\n该分类下的 ${stickerCount} 个表情将移至默认分类。`;
            }

            if (confirm(confirmMsg)) {
                // 将该分类下的表情移至默认分类（去掉category字段）
                db.myStickers.forEach(sticker => {
                    if (sticker.category === currentViewingCategory.id) {
                        delete sticker.category;
                    }
                });

                // 删除分类
                db.stickerCategories = db.stickerCategories.filter(cat => cat.id !== currentViewingCategory.id);
                await saveData();

                categoryDetailModal.classList.remove('visible');
                stickerCategoryModal.classList.add('visible');
                renderCategoryList();
                updateCategorySelects();
                renderStickerGrid();
                showToast('分类已删除');
                currentViewingCategory = null;
            }
        }

        // 设置分类管理事件监听
        function setupStickerCategorySystem() {
            // 打开分类管理弹窗
            stickerCategoryBtn.addEventListener('click', () => {
                renderCategoryList();
                stickerCategoryModal.classList.add('visible');
            });

            // 关闭分类管理弹窗
            closeCategoryModalBtn.addEventListener('click', () => {
                stickerCategoryModal.classList.remove('visible');
            });

            // 创建分类
            createCategoryBtn.addEventListener('click', createCategory);
            newCategoryNameInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    createCategory();
                }
            });

            // 关闭分类详情弹窗
            closeCategoryDetailBtn.addEventListener('click', () => {
                categoryDetailModal.classList.remove('visible');
                stickerCategoryModal.classList.add('visible');
            });

            // 删除分类
            deleteCategoryBtn.addEventListener('click', deleteCategory);

            // 分类选择改变时重新渲染表情
            currentStickerCategory.addEventListener('change', () => {
                renderStickerGrid();
            });

            // 初始化分类选择器
            updateCategorySelects();
        }

        function setupVoiceMessageSystem() {
            voiceMessageBtn.addEventListener('click', () => {
                sendVoiceForm.reset();
                voiceDurationPreview.textContent = '0"';
                sendVoiceModal.classList.add('visible');
            });
            sendVoiceForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyVoiceMessage(voiceTextInput.value.trim());
            });
        }

        function setupPhotoVideoSystem() {
            photoVideoBtn.addEventListener('click', () => {
                sendPvForm.reset();
                sendPvModal.classList.add('visible');
            });
            sendPvForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyPhotoVideo(pvTextInput.value.trim());
            });
        }

        function setupWalletSystem() {
            walletBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    sendTransferForm.reset();
                    sendTransferModal.classList.add('visible');
                } else if (currentChatType === 'group') {
                    currentGroupAction.type = 'transfer';
                    renderGroupRecipientSelectionList('转账给');
                    groupRecipientSelectionModal.classList.add('visible');
                }
            });
            sendTransferForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const amount = transferAmountInput.value;
                const remark = transferRemarkInput.value.trim();
                if (amount > 0) {
                    sendMyTransfer(amount, remark);
                } else {
                    showToast('请输入有效的金额');
                }
            });
            acceptTransferBtn.addEventListener('click', () => respondToTransfer('received'));
            returnTransferBtn.addEventListener('click', () => respondToTransfer('returned'));
            viewTransferRemarkBtn.addEventListener('click', () => {
                if (!currentTransferMessageId) return;
                const character = db.characters.find(c => c.id === currentChatId);
                const message = character.history.find(m => m.id === currentTransferMessageId);
                if (message) {
                    // 提取转账备注
                    const transferRegex = /\[.*?的转账：([\d.]+)元；备注：(.*?)\]/;
                    const match = message.content.match(transferRegex);
                    if (match) {
                        const amount = match[1];
                        const remark = match[2] || '无备注';
                        showCustomAlert('转账备注', `金额：¥${amount}\n\n备注：${remark}`);
                    }
                }
            });
        }

        function handleReceivedTransferClick(messageId, transferStatus) {
            currentTransferMessageId = messageId;
            
            // 根据转账状态显示不同的按钮
            const acceptBtn = document.getElementById('accept-transfer-btn');
            const returnBtn = document.getElementById('return-transfer-btn');
            
            if (transferStatus === 'pending') {
                // 待处理：显示接收和退回按钮
                acceptBtn.style.display = 'block';
                returnBtn.style.display = 'block';
            } else {
                // 已处理：隐藏接收和退回按钮
                acceptBtn.style.display = 'none';
                returnBtn.style.display = 'none';
            }
            
            receiveTransferActionSheet.classList.add('visible');
        }

        async function respondToTransfer(action) {
            if (!currentTransferMessageId) return;
            const character = db.characters.find(c => c.id === currentChatId);
            const message = character.history.find(m => m.id === currentTransferMessageId);
            if (message) {
                message.transferStatus = action;
                const cardOnScreen = messageArea.querySelector(`.message-wrapper[data-id="${currentTransferMessageId}"] .transfer-card`);
                if (cardOnScreen) {
                    cardOnScreen.classList.remove('received', 'returned');
                    cardOnScreen.classList.add(action);
                    cardOnScreen.querySelector('.transfer-status').textContent = action === 'received' ? '已收款' : '已退回';
                    cardOnScreen.style.cursor = 'default';
                }
                
                // 添加一条不可见的指令消息，告诉AI用户的操作
                let contextMessageContent = (action === 'received') ? `[${character.myName}接收${character.realName}的转账]` : `[${character.myName}退回${character.realName}的转账]`;
                const contextMessage = {
                    id: `msg_${Date.now()}`,
                    role: 'user',
                    content: contextMessageContent,
                    parts: [{type: 'text', text: contextMessageContent}],
                    timestamp: Date.now()
                };
                character.history.push(contextMessage);
                
                await saveData();
                renderChatList();
            }
            receiveTransferActionSheet.classList.remove('visible');
            currentTransferMessageId = null;
        }
        function setupGiftSystem() {
            giftBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    sendGiftForm.reset();
                    sendGiftModal.classList.add('visible');
                } else if (currentChatType === 'group') {
                    currentGroupAction.type = 'gift';
                    renderGroupRecipientSelectionList('送礼物给');
                    groupRecipientSelectionModal.classList.add('visible');
                }
            });
            sendGiftForm.addEventListener('submit', (e) => {
                e.preventDefault();
                sendMyGift(giftDescriptionInput.value.trim());
            });
        }

        function setupWaimaiSystem() {
            let waimaiType = 'request'; // 'request' 或 'order'
            
            const waimaiTypeRequestBtn = document.getElementById('waimai-type-request');
            const waimaiTypeOrderBtn = document.getElementById('waimai-type-order');
            const waimaiModalTitle = document.getElementById('waimai-modal-title');
            const waimaiCharName = document.getElementById('waimai-char-name');
            const waimaiSubmitBtn = document.getElementById('waimai-submit-btn');
            
            waimaiBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    const character = db.characters.find(c => c.id === currentChatId);
                    if (character) {
                        waimaiCharName.textContent = character.realName;
                    }
                    sendWaimaiForm.reset();
                    waimaiType = 'request';
                    updateWaimaiTypeUI();
                    sendWaimaiModal.classList.add('visible');
                } else if (currentChatType === 'group') {
                    sendWaimaiForm.reset();
                    waimaiType = 'request';
                    updateWaimaiTypeUI();
                    sendWaimaiModal.classList.add('visible');
                }
            });
            
            // 类型切换按钮
            waimaiTypeRequestBtn.addEventListener('click', () => {
                waimaiType = 'request';
                updateWaimaiTypeUI();
            });
            
            waimaiTypeOrderBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    waimaiType = 'order';
                    updateWaimaiTypeUI();
                }
            });
            
            function updateWaimaiTypeUI() {
                if (waimaiType === 'request') {
                    waimaiTypeRequestBtn.style.background = 'var(--primary-color)';
                    waimaiTypeRequestBtn.style.borderColor = 'var(--primary-color)';
                    waimaiTypeRequestBtn.style.color = 'white';
                    waimaiTypeOrderBtn.style.background = 'white';
                    waimaiTypeOrderBtn.style.borderColor = '#ddd';
                    waimaiTypeOrderBtn.style.color = '#666';
                    waimaiModalTitle.textContent = '发起外卖代付';
                    waimaiSubmitBtn.textContent = '发送';
                } else {
                    waimaiTypeRequestBtn.style.background = 'white';
                    waimaiTypeRequestBtn.style.borderColor = '#ddd';
                    waimaiTypeRequestBtn.style.color = '#666';
                    waimaiTypeOrderBtn.style.background = 'var(--primary-color)';
                    waimaiTypeOrderBtn.style.borderColor = 'var(--primary-color)';
                    waimaiTypeOrderBtn.style.color = 'white';
                    waimaiModalTitle.textContent = `为${waimaiCharName.textContent}点单`;
                    waimaiSubmitBtn.textContent = '点单';
                }
            }
            
            sendWaimaiModal.addEventListener('click', (e) => {
                if (e.target === sendWaimaiModal) sendWaimaiModal.classList.remove('visible');
            });
            
            sendWaimaiForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const productInfo = waimaiProductInput.value.trim();
                const amount = parseFloat(waimaiAmountInput.value);
                
                if (waimaiType === 'request') {
                    sendMyWaimai(productInfo, amount);
                } else {
                    sendWaimaiForChar(productInfo, amount);
                }
            });
        }

        function setupShareLinkSystem() {
            const shareLinkBtn = document.getElementById('share-link-btn');
            const shareLinkModal = document.getElementById('share-link-modal');
            const shareLinkForm = document.getElementById('share-link-form');
            const cancelShareLinkBtn = document.getElementById('cancel-share-link-btn');
            const linkTitleInput = document.getElementById('link-title-input');
            const linkDescriptionInput = document.getElementById('link-description-input');
            const linkSourceInput = document.getElementById('link-source-input');
            const linkContentInput = document.getElementById('link-content-input');

            shareLinkBtn.addEventListener('click', () => {
                if (currentChatType === 'private' || currentChatType === 'group') {
                    shareLinkForm.reset();
                    shareLinkModal.classList.add('visible');
                }
            });

            shareLinkModal.addEventListener('click', (e) => {
                if (e.target === shareLinkModal) {
                    shareLinkModal.classList.remove('visible');
                }
            });

            cancelShareLinkBtn.addEventListener('click', () => {
                shareLinkModal.classList.remove('visible');
            });

            shareLinkForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const title = linkTitleInput.value.trim();
                if (!title) {
                    showToast('标题是必填项');
                    return;
                }

                const description = linkDescriptionInput.value.trim();
                const sourceName = linkSourceInput.value.trim();
                const content = linkContentInput.value.trim();

                await sendMyShareLink(title, description, sourceName, content);
            });
        }

        async function sendMyShareLink(title, description, sourceName, content) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat) return;

            const myName = (currentChatType === 'private') ? chat.myName : (chat.me ? chat.me.nickname : '我');

            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                type: 'share_link',
                content: `[${myName}分享了链接：${title}]`,
                parts: [{type: 'text', text: `[${myName}分享了链接：${title}]`}],
                timestamp: Date.now(),
                title: title,
                description: description,
                source_name: sourceName,
                content: content
            };

            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }

            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            document.getElementById('share-link-modal').classList.remove('visible');
        }

        // ▼▼▼ 共享位置功能 ▼▼▼
        function setupLocationShareSystem() {
            const shareLocationBtn = document.getElementById('share-location-btn');
            const shareLocationModal = document.getElementById('share-location-modal');
            const shareLocationForm = document.getElementById('share-location-form');
            const cancelLocationBtn = document.getElementById('cancel-location-btn');
            const locationNameInput = document.getElementById('location-name-input');
            
            shareLocationBtn.addEventListener('click', () => {
                if (currentChatType === 'private' || currentChatType === 'group') {
                    shareLocationForm.reset();
                    shareLocationModal.classList.add('visible');
                }
            });

            shareLocationModal.addEventListener('click', (e) => {
                if (e.target === shareLocationModal) {
                    shareLocationModal.classList.remove('visible');
                }
            });

            cancelLocationBtn.addEventListener('click', () => {
                shareLocationModal.classList.remove('visible');
            });

            shareLocationForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const locationName = locationNameInput.value.trim();
                if (!locationName) {
                    showToast('请输入位置信息');
                    return;
                }

                await sendLocationShare(locationName);
                shareLocationModal.classList.remove('visible');
            });
        }

        async function sendLocationShare(locationName) {
            if (currentChatType !== 'private' && currentChatType !== 'group') return;

            const hardcodedImageUrl = 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1756262526935_qdqqd_4uque3.jpeg';

            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat) return;

            const myName = (currentChatType === 'private') ? chat.myName : (chat.me ? chat.me.nickname : '我');

            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                type: 'location_share',
                content: locationName.trim(),
                parts: [{type: 'text', text: `[${myName}分享了位置：${locationName.trim()}]`}],
                timestamp: Date.now(),
                imageUrl: hardcodedImageUrl
            };

            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }

            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
        }
        // ▲▲▲ 共享位置功能结束 ▲▲▲

        async function sendMyWaimai(productInfo, amount) {
            if (!productInfo || !amount) return;
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const myName = (currentChatType === 'private') ? chat.myName : (chat.me ? chat.me.nickname : '我');
            
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                type: 'waimai_request',
                content: `[${myName}发起外卖代付请求：${productInfo}，金额${amount}元]`,
                parts: [{type: 'text', text: `[${myName}发起外卖代付请求：${productInfo}，金额${amount}元]`}],
                timestamp: Date.now(),
                productInfo: productInfo,
                amount: amount,
                status: 'pending',
                countdownEndTime: Date.now() + 15 * 60 * 1000,
                senderName: myName
            };
            
            if (currentChatType === 'group') {
                message.senderId = 'user_me';
            }
            
            chat.history.push(message);
            addMessageBubble(message);
            await saveData();
            renderChatList();
            sendWaimaiModal.classList.remove('visible');
        }
        
        async function sendWaimaiForChar(productInfo, amount) {
            if (!productInfo || !amount) return;
            if (currentChatType !== 'private') return;
            
            const character = db.characters.find(c => c.id === currentChatId);
            if (!character) return;
            
            const myName = character.myName;
            const charName = character.realName;
            
            // 创建外卖卡片消息（显示为USER发送给CHAR）
            const waimaiMessage = {
                id: `msg_${Date.now()}`,
                role: 'user',
                type: 'waimai_order',
                content: `[${myName}为${charName}点了外卖：${productInfo}，金额${amount}元]`,
                parts: [{type: 'text', text: `[${myName}为${charName}点了外卖：${productInfo}，金额${amount}元]`}],
                timestamp: Date.now(),
                productInfo: productInfo,
                amount: amount,
                status: 'paid',
                recipientName: charName
            };
            
            character.history.push(waimaiMessage);
            addMessageBubble(waimaiMessage);
            await saveData();
            renderChatList();
            sendWaimaiModal.classList.remove('visible');
        }

        // 外卖界面功能
        function setupWaimaiInterface() {
            const enterWaimaiBtn = document.getElementById('enter-waimai-btn');
            const waimaiScreen = document.getElementById('waimai-screen');
            const waimaiBackBtn = document.getElementById('waimai-back-btn');
            const waimaiRefreshBtn = document.getElementById('waimai-refresh-btn');
            const waimaiSettingsBtn = document.getElementById('waimai-settings-btn');
            const waimaiShopList = document.getElementById('waimai-shop-list');
            const apiSelectModal = document.getElementById('api-select-modal');
            const usePrimaryApiBtn = document.getElementById('use-primary-api-btn');
            const useSecondaryApiBtn = document.getElementById('use-secondary-api-btn');
            
            const waimaiSettingsModal = document.getElementById('waimai-settings-modal');
            const waimaiSettingsForm = document.getElementById('waimai-settings-form');
            const shopCountInput = document.getElementById('shop-count-input');
            const dishMinInput = document.getElementById('dish-min-input');
            const dishMaxInput = document.getElementById('dish-max-input');
            const saveShopsToggle = document.getElementById('save-shops-toggle');
            const cancelWaimaiSettingsBtn = document.getElementById('cancel-waimai-settings-btn');
            
            const waimaiRefreshModeModal = document.getElementById('waimai-refresh-mode-modal');
            const overrideRefreshBtn = document.getElementById('override-refresh-btn');
            const incrementalRefreshBtn = document.getElementById('incremental-refresh-btn');
            
            const waimaiShopDetailScreen = document.getElementById('waimai-shop-detail-screen');
            const waimaiShopTitle = document.getElementById('waimai-shop-title');
            const waimaiMenuList = document.getElementById('waimai-menu-list');
            const waimaiCartBar = document.getElementById('waimai-cart-bar');
            const waimaiCartCount = document.getElementById('waimai-cart-count');
            const waimaiCartTotal = document.getElementById('waimai-cart-total');
            const waimaiCheckoutBtn = document.getElementById('waimai-checkout-btn');
            
            const waimaiPaymentScreen = document.getElementById('waimai-payment-screen');
            const waimaiPaymentAmount = document.getElementById('waimai-payment-amount');
            const waimaiPaymentTimer = document.getElementById('waimai-payment-timer');
            const waimaiSelfPayBtn = document.getElementById('waimai-self-pay-btn');
            const waimaiRequestPayBtn = document.getElementById('waimai-request-pay-btn');
            
            let currentShop = null;
            let cart = {};
            let paymentTimer = null;
            let paymentEndTime = null;
            
            // 将设置和店铺数据暴露到全局，以便switchScreen可以访问
            if (!window.waimaiSettings) {
                window.waimaiSettings = {
                    shopCount: null,
                    dishMin: null,
                    dishMax: null,
                    saveShops: false
                };
            }
            if (!window.waimaiSavedShops) {
                window.waimaiSavedShops = null;
            }
            
            let waimaiSettings = window.waimaiSettings;
            let savedShops = window.waimaiSavedShops;
            
            // 进入外卖界面
            enterWaimaiBtn.addEventListener('click', () => {
                sendWaimaiModal.classList.remove('visible');
                switchScreen('waimai-screen');
                
                // 同步全局变量到本地
                savedShops = window.waimaiSavedShops;
                
                // 如果开启了保存且有保存的店铺数据，则显示
                if (waimaiSettings.saveShops && savedShops) {
                    renderShops(savedShops);
                } else if (!waimaiSettings.saveShops) {
                    // 如果没有开启保存，清空店铺列表
                    waimaiShopList.innerHTML = '<div class="placeholder-text">点击右上角刷新按钮加载外卖店铺</div>';
                    savedShops = null;
                    window.waimaiSavedShops = null;
                }
            });

            // 设置按钮
            waimaiSettingsBtn.addEventListener('click', () => {
                waimaiSettingsModal.classList.add('visible');
            });
            
            // 关闭设置弹窗
            waimaiSettingsModal.addEventListener('click', (e) => {
                if (e.target === waimaiSettingsModal) {
                    waimaiSettingsModal.classList.remove('visible');
                }
            });
            
            cancelWaimaiSettingsBtn.addEventListener('click', () => {
                waimaiSettingsModal.classList.remove('visible');
            });
            
            // 提交设置
            waimaiSettingsForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const shopCount = parseInt(shopCountInput.value);
                const dishMin = parseInt(dishMinInput.value);
                const dishMax = parseInt(dishMaxInput.value);
                
                if (dishMin > dishMax) {
                    showToast('最少菜品数不能大于最多菜品数');
                    return;
                }
                
                waimaiSettings.shopCount = shopCount;
                waimaiSettings.dishMin = dishMin;
                waimaiSettings.dishMax = dishMax;
                waimaiSettings.saveShops = saveShopsToggle.checked;
                
                // 同步到全局
                window.waimaiSettings = waimaiSettings;
                
                waimaiSettingsModal.classList.remove('visible');
                showToast('设置已保存');
                
                // 如果关闭了保存功能，清除已保存的店铺
                if (!waimaiSettings.saveShops) {
                    savedShops = null;
                    window.waimaiSavedShops = null;
                }
            });
            
            // 刷新按钮
            waimaiRefreshBtn.addEventListener('click', () => {
                // 检查是否已设置
                if (!waimaiSettings.shopCount || !waimaiSettings.dishMin || !waimaiSettings.dishMax) {
                    showToast('请先点击设置按钮配置参数');
                    return;
                }
                
                // 检查是否是首次刷新（没有店铺数据）
                const hasExistingShops = waimaiShopList.children.length > 0 && 
                                        !waimaiShopList.querySelector('.placeholder-text');
                
                if (!hasExistingShops) {
                    // 首次刷新，直接选择API
                    apiSelectModal.classList.add('visible');
                } else {
                    // 已有店铺，显示刷新模式选择
                    waimaiRefreshModeModal.classList.add('visible');
                }
            });
            
            // 关闭刷新模式选择弹窗
            waimaiRefreshModeModal.addEventListener('click', (e) => {
                if (e.target === waimaiRefreshModeModal) {
                    waimaiRefreshModeModal.classList.remove('visible');
                }
            });
            
            // 覆盖刷新
            overrideRefreshBtn.addEventListener('click', () => {
                waimaiRefreshModeModal.classList.remove('visible');
                window.waimaiRefreshMode = 'override';
                apiSelectModal.classList.add('visible');
            });
            
            // 增量刷新
            incrementalRefreshBtn.addEventListener('click', () => {
                waimaiRefreshModeModal.classList.remove('visible');
                window.waimaiRefreshMode = 'incremental';
                apiSelectModal.classList.add('visible');
            });
            
            // 关闭API选择弹窗
            apiSelectModal.addEventListener('click', (e) => {
                if (e.target === apiSelectModal) {
                    apiSelectModal.classList.remove('visible');
                }
            });
            
            // 选择主API
            usePrimaryApiBtn.addEventListener('click', async () => {
                apiSelectModal.classList.remove('visible');
                await loadWaimaiShops('primary');
            });
            
            // 选择副API
            useSecondaryApiBtn.addEventListener('click', async () => {
                apiSelectModal.classList.remove('visible');
                await loadWaimaiShops('secondary');
            });
            
            // 加载外卖店铺
            async function loadWaimaiShops(apiType) {
                waimaiShopList.innerHTML = '<div class="placeholder-text">正在使用AI生成店铺...</div>';
                
                try {
                    // 获取API配置
                    let apiUrl, apiKey, model;
                    if (apiType === 'primary') {
                        apiUrl = db.apiSettings?.url;
                        apiKey = db.apiSettings?.key;
                        model = db.apiSettings?.model;
                    } else {
                        apiUrl = db.secondaryApiSettings?.url;
                        apiKey = db.secondaryApiSettings?.key;
                        model = db.secondaryApiSettings?.model;
                    }
                    
                    if (!apiUrl || !apiKey || !model) {
                        throw new Error(`${apiType === 'primary' ? '主' : '副'}API配置不完整，请先在设置中配置API`);
                    }
                    
                    // 使用用户设置的参数生成店铺数据
                    const shopCount = waimaiSettings.shopCount;
                    const dishMin = waimaiSettings.dishMin;
                    const dishMax = waimaiSettings.dishMax;
                    
                    const prompt = `请生成${shopCount}家外卖店铺的详细信息，每家店铺包含店名、评分、月销量、人均价格、距离、配送时间、优惠券和菜单。
要求：
1. 店铺类型多样化（炸鸡、奶茶、火锅、烧烤、寿司、披萨、面馆等）
2. 每家店铺的菜品数量在${dishMin}-${dishMax}个之间随机，菜品名称要有创意和特色
3. 价格合理（10-50元）
4. 必须返回严格的JSON格式，不要有任何其他文字

JSON格式示例：
{
  "shops": [
    {
      "name": "店铺名称",
      "rating": 4.5,
      "monthlySales": 200,
      "avgPrice": 25,
      "distance": 2.5,
      "deliveryTime": 30,
      "coupons": ["8折券", "满30减5"],
      "menu": [
        {"name": "菜品名称", "desc": "月售50 好评如潮", "price": 18.00}
      ]
    }
  ]
}`;
                    
                    const isGemini = apiUrl.includes('generativelanguage.googleapis.com');
                    let response;
                    
                    if (isGemini) {
                        const requestBody = {
                            contents: [{
                                parts: [{ text: prompt }]
                            }]
                        };
                        response = await fetch(`${apiUrl}/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(requestBody)
                        });
                    } else {
                        response = await fetch(`${apiUrl}/v1/chat/completions`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`
                            },
                            body: JSON.stringify({
                                model: model,
                                messages: [{ role: 'user', content: prompt }],
                                temperature: 0.9
                            })
                        });
                    }
                    
                    if (!response.ok) {
                        throw new Error(`API请求失败: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    let aiResponse;
                    
                    if (isGemini) {
                        aiResponse = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                    } else {
                        aiResponse = data.choices?.[0]?.message?.content || '';
                    }
                    
                    // 提取JSON
                    let jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
                    if (!jsonMatch) {
                        throw new Error('AI返回格式错误');
                    }
                    
                    const shopsData = JSON.parse(jsonMatch[0]);
                    let newShops = shopsData.shops.map((shop, index) => ({
                        id: index + 1,
                        name: shop.name,
                        rating: shop.rating,
                        monthlySales: shop.monthlySales,
                        avgPrice: shop.avgPrice,
                        distance: shop.distance,
                        deliveryTime: shop.deliveryTime,
                        coupons: shop.coupons,
                        menu: shop.menu.map((item, idx) => ({
                            id: idx + 1,
                            name: item.name,
                            desc: item.desc,
                            price: item.price
                        }))
                    }));
                    
                    // 根据刷新模式处理店铺数据
                    let finalShops;
                    const refreshMode = window.waimaiRefreshMode || 'override';
                    
                    if (refreshMode === 'incremental' && savedShops && savedShops.length > 0) {
                        // 增量刷新：合并新旧店铺，重新分配ID
                        finalShops = [...savedShops, ...newShops].map((shop, index) => ({
                            ...shop,
                            id: index + 1
                        }));
                        showToast(`增量刷新成功，新增${newShops.length}家店铺`);
                    } else {
                        // 覆盖刷新或首次刷新
                        finalShops = newShops;
                        showToast(`使用${apiType === 'primary' ? '主' : '副'}API生成成功`);
                    }
                    
                    // 如果开启了保存功能，保存店铺数据
                    if (waimaiSettings.saveShops) {
                        savedShops = finalShops;
                        window.waimaiSavedShops = finalShops;
                    } else {
                        savedShops = finalShops; // 临时保存，用于增量刷新
                        window.waimaiSavedShops = finalShops;
                    }
                    
                    // 渲染店铺列表
                    renderShops(finalShops);
                    
                    // 重置刷新模式
                    window.waimaiRefreshMode = null;
                } catch (error) {
                    waimaiShopList.innerHTML = '<div class="placeholder-text">加载失败，请重试</div>';
                    showToast('加载失败: ' + error.message);
                    console.error('外卖加载错误:', error);
                }
            }
            
            // 渲染店铺列表
            function renderShops(shops) {
                waimaiShopList.innerHTML = '';
                shops.forEach(shop => {
                    const shopItem = document.createElement('div');
                    shopItem.className = 'waimai-shop-item';
                    shopItem.innerHTML = `
                        <div class="waimai-shop-header">
                            <div>
                                <div class="waimai-shop-name">${shop.name}</div>
                                <div class="waimai-shop-rating">
                                    <span>${shop.rating}分</span>
                                    <span>月售${shop.monthlySales}${shop.monthlySales >= 100 ? '+' : ''}</span>
                                    <span>人均${shop.avgPrice}元</span>
                                </div>
                            </div>
                        </div>
                        <div class="waimai-shop-distance">
                            ${shop.distance}km ${shop.deliveryTime}分钟
                        </div>
                        <div class="waimai-shop-coupons">
                            ${shop.coupons.map(c => `<span class="waimai-coupon-tag">${c}</span>`).join('')}
                        </div>
                    `;
                    shopItem.addEventListener('click', () => {
                        openShopDetail(shop);
                    });
                    waimaiShopList.appendChild(shopItem);
                });
            }
            
            // 打开店铺详情
            function openShopDetail(shop) {
                currentShop = shop;
                cart = {};
                waimaiShopTitle.textContent = shop.name;
                
                // 渲染菜单
                waimaiMenuList.innerHTML = '';
                shop.menu.forEach(item => {
                    const menuItem = document.createElement('div');
                    menuItem.className = 'waimai-menu-item';
                    menuItem.innerHTML = `
                        <div class="waimai-menu-info">
                            <div class="waimai-menu-name">${item.name}</div>
                            <div class="waimai-menu-desc">${item.desc}</div>
                            <div class="waimai-menu-price">¥${item.price.toFixed(2)}</div>
                        </div>
                        <div class="waimai-menu-actions">
                            <button class="waimai-add-btn" data-item-id="${item.id}">+</button>
                        </div>
                    `;
                    
                    const addBtn = menuItem.querySelector('.waimai-add-btn');
                    addBtn.addEventListener('click', () => {
                        addToCart(item);
                        updateMenuItemDisplay(menuItem, item);
                    });
                    
                    waimaiMenuList.appendChild(menuItem);
                });
                
                updateCart();
                switchScreen('waimai-shop-detail-screen');
            }
            
            // 添加到购物车
            function addToCart(item) {
                if (!cart[item.id]) {
                    cart[item.id] = { ...item, quantity: 0 };
                }
                cart[item.id].quantity++;
                updateCart();
            }
            
            // 从购物车移除
            function removeFromCart(itemId) {
                if (cart[itemId]) {
                    cart[itemId].quantity--;
                    if (cart[itemId].quantity <= 0) {
                        delete cart[itemId];
                    }
                }
                updateCart();
            }
            
            // 更新购物车显示
            function updateCart() {
                const items = Object.values(cart);
                const totalCount = items.reduce((sum, item) => sum + item.quantity, 0);
                const totalPrice = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
                
                if (totalCount > 0) {
                    waimaiCartBar.style.display = 'flex';
                    waimaiCartCount.textContent = totalCount;
                    waimaiCartTotal.textContent = `¥${totalPrice.toFixed(2)}`;
                } else {
                    waimaiCartBar.style.display = 'none';
                }
                
                // 更新所有菜单项的显示
                waimaiMenuList.querySelectorAll('.waimai-menu-item').forEach(menuItem => {
                    const itemId = parseInt(menuItem.querySelector('.waimai-add-btn, .waimai-minus-btn, .waimai-plus-btn').dataset.itemId);
                    const item = currentShop.menu.find(m => m.id === itemId);
                    if (item) {
                        updateMenuItemDisplay(menuItem, item);
                    }
                });
            }
            
            // 更新菜单项显示
            function updateMenuItemDisplay(menuItem, item) {
                const actionsDiv = menuItem.querySelector('.waimai-menu-actions');
                const quantity = cart[item.id]?.quantity || 0;
                
                if (quantity > 0) {
                    actionsDiv.innerHTML = `
                        <div class="waimai-quantity-control">
                            <button class="waimai-minus-btn" data-item-id="${item.id}">-</button>
                            <span class="waimai-quantity">${quantity}</span>
                            <button class="waimai-plus-btn" data-item-id="${item.id}">+</button>
                        </div>
                    `;
                    
                    actionsDiv.querySelector('.waimai-minus-btn').addEventListener('click', () => {
                        removeFromCart(item.id);
                    });
                    
                    actionsDiv.querySelector('.waimai-plus-btn').addEventListener('click', () => {
                        addToCart(item);
                        updateMenuItemDisplay(menuItem, item);
                    });
                } else {
                    actionsDiv.innerHTML = `<button class="waimai-add-btn" data-item-id="${item.id}">+</button>`;
                    actionsDiv.querySelector('.waimai-add-btn').addEventListener('click', () => {
                        addToCart(item);
                        updateMenuItemDisplay(menuItem, item);
                    });
                }
            }
            
            // 去结算
            waimaiCheckoutBtn.addEventListener('click', () => {
                const items = Object.values(cart);
                const totalPrice = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
                
                waimaiPaymentAmount.textContent = `¥${totalPrice.toFixed(2)}`;
                paymentEndTime = Date.now() + 15 * 60 * 1000;
                startPaymentTimer();
                
                switchScreen('waimai-payment-screen');
            });
            
            // 启动支付倒计时
            function startPaymentTimer() {
                if (paymentTimer) {
                    clearInterval(paymentTimer);
                }
                
                updatePaymentTimer();
                paymentTimer = setInterval(updatePaymentTimer, 1000);
            }
            
            // 更新支付倒计时
            function updatePaymentTimer() {
                const remaining = paymentEndTime - Date.now();
                
                if (remaining <= 0) {
                    clearInterval(paymentTimer);
                    waimaiPaymentTimer.textContent = '00:00';
                    showToast('订单已超时');
                    switchScreen('waimai-screen');
                    return;
                }
                
                const minutes = Math.floor(remaining / 60000);
                const seconds = Math.floor((remaining % 60000) / 1000);
                waimaiPaymentTimer.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
            
            // 自己支付
            waimaiSelfPayBtn.addEventListener('click', () => {
                if (paymentTimer) {
                    clearInterval(paymentTimer);
                    paymentTimer = null;
                }
                showToast('支付成功！');
                switchScreen('waimai-screen');
                cart = {};
                updateCart();
            });
            
            // 请求代付
            waimaiRequestPayBtn.addEventListener('click', async () => {
                if (paymentTimer) {
                    clearInterval(paymentTimer);
                    paymentTimer = null;
                }
                
                const items = Object.values(cart);
                const totalPrice = items.reduce((sum, item) => sum + item.price * item.quantity, 0);
                const productInfo = items.map(item => `${item.name} x${item.quantity}`).join(', ');
                
                await sendMyWaimai(productInfo, totalPrice);
                
                showToast('代付请求已发送');
                switchScreen('chat-room-screen');
                cart = {};
                updateCart();
            });
        }

        function setupFontSettingsApp() {
            const fontFileUpload = document.getElementById('font-file-upload');
            const fontFileName = document.getElementById('font-file-name');
            const fontBatchUpload = document.getElementById('font-batch-upload');
            const manageFontLibraryBtn = document.getElementById('manage-font-library-btn');
            const fontLibraryGrid = document.getElementById('font-library-grid');
            const fontLibraryManage = document.getElementById('font-library-manage');
            const fontLibraryCheckboxes = document.getElementById('font-library-checkboxes');
            const selectAllFonts = document.getElementById('select-all-fonts');
            const deleteFontsBtn = document.getElementById('delete-fonts-btn');
            const fontSizeSlider = document.getElementById('font-size-slider');
            const fontSizeValue = document.getElementById('font-size-value');
            const resetFontSizeBtn = document.getElementById('reset-font-size-btn');
            
            fontUrlInput.value = db.fontUrl;
            
            // 初始化字体大小滑动条
            fontSizeSlider.value = db.fontSize;
            fontSizeValue.textContent = `${db.fontSize}px`;
            applyGlobalFontSize(db.fontSize);
            
            // 字体大小滑动条事件
            fontSizeSlider.addEventListener('input', (e) => {
                const size = parseInt(e.target.value);
                fontSizeValue.textContent = `${size}px`;
                applyGlobalFontSize(size);
            });
            
            fontSizeSlider.addEventListener('change', async (e) => {
                const size = parseInt(e.target.value);
                db.fontSize = size;
                await saveData();
                showToast(`字体大小已设置为 ${size}px`);
            });
            
            // 重置字体大小按钮
            resetFontSizeBtn.addEventListener('click', async () => {
                const defaultSize = 16;
                fontSizeSlider.value = defaultSize;
                fontSizeValue.textContent = `${defaultSize}px`;
                applyGlobalFontSize(defaultSize);
                db.fontSize = defaultSize;
                await saveData();
                showToast('字体大小已重置为默认值 16px');
            });
            
            // 渲染字体库列表
            function renderFontLibrary() {
                fontLibraryGrid.innerHTML = '';
                if (db.fontLibrary && db.fontLibrary.length > 0) {
                    db.fontLibrary.forEach(font => {
                        const fontItem = document.createElement('div');
                        fontItem.style.cssText = 'padding: 15px; background: white; border-radius: 10px; cursor: pointer; transition: background 0.2s;';
                        fontItem.innerHTML = `<div style="font-weight: 600; margin-bottom: 5px; color: #333;">${font.name}</div><div style="font-size: 12px; color: #888;">点击应用</div>`;
                        fontItem.addEventListener('mouseenter', () => fontItem.style.background = '#f5f5f5');
                        fontItem.addEventListener('mouseleave', () => fontItem.style.background = 'white');
                        fontItem.addEventListener('click', async () => {
                            db.fontUrl = font.url;
                            await saveData();
                            applyGlobalFont(font.url);
                            showToast(`已应用字体: ${font.name}`);
                        });
                        fontLibraryGrid.appendChild(fontItem);
                    });
                } else {
                    fontLibraryGrid.innerHTML = '<p style="text-align: center; color: #888; padding: 20px;">字体库为空</p>';
                }
            }
            
            // 渲染管理界面的复选框列表
            function renderFontCheckboxes() {
                fontLibraryCheckboxes.innerHTML = '';
                if (db.fontLibrary && db.fontLibrary.length > 0) {
                    db.fontLibrary.forEach((font, index) => {
                        const item = document.createElement('div');
                        item.style.cssText = 'padding: 10px; border-bottom: 1px solid #eee; display: flex; align-items: center; gap: 10px;';
                        item.innerHTML = `
                            <input type="checkbox" id="font-cb-${index}" data-font-id="${font.id}" style="cursor: pointer;">
                            <label for="font-cb-${index}" style="cursor: pointer; margin: 0; flex: 1;">${font.name}</label>
                        `;
                        fontLibraryCheckboxes.appendChild(item);
                    });
                }
            }
            
            // 初始化显示字体库
            renderFontLibrary();
            
            // URL上传
            fontSettingsForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const newFontUrl = fontUrlInput.value.trim();
                if (!newFontUrl) {
                    showToast('请输入字体链接');
                    return;
                }
                db.fontUrl = newFontUrl;
                await saveData();
                applyGlobalFont(newFontUrl);
                showToast('新字体已应用！');
                fontFileName.textContent = '';
            });
            
            // 本地文件上传
            fontFileUpload.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                // 检查文件类型
                const validTypes = ['.ttf', '.otf', '.woff', '.woff2'];
                const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
                if (!validTypes.includes(fileExtension)) {
                    showToast('不支持的字体格式，请选择 ttf、otf、woff 或 woff2 文件');
                    e.target.value = '';
                    return;
                }
                
                // 检查文件大小（限制为5MB）
                if (file.size > 5 * 1024 * 1024) {
                    showToast('字体文件过大，请选择小于5MB的文件');
                    e.target.value = '';
                    return;
                }
                
                showToast('正在读取字体文件...');
                
                const reader = new FileReader();
                reader.onload = async () => {
                    const fontDataUrl = reader.result;
                    db.fontUrl = fontDataUrl;
                    await saveData();
                    applyGlobalFont(fontDataUrl);
                    showToast('本地字体已应用！');
                    fontFileName.textContent = `已选择: ${file.name}`;
                    fontUrlInput.value = '';
                };
                reader.onerror = () => {
                    showToast('读取字体文件失败，请重试');
                    e.target.value = '';
                };
                reader.readAsDataURL(file);
            });
            
            // 批量导入字体到字体库
            fontBatchUpload.addEventListener('change', async (e) => {
                const files = Array.from(e.target.files);
                if (files.length === 0) return;
                
                const validTypes = ['.ttf', '.otf', '.woff', '.woff2'];
                let successCount = 0;
                let failCount = 0;
                
                showToast(`正在导入 ${files.length} 个字体文件...`);
                
                for (const file of files) {
                    const fileExtension = '.' + file.name.split('.').pop().toLowerCase();
                    
                    // 检查文件类型
                    if (!validTypes.includes(fileExtension)) {
                        failCount++;
                        continue;
                    }
                    
                    // 检查文件大小
                    if (file.size > 5 * 1024 * 1024) {
                        failCount++;
                        continue;
                    }
                    
                    try {
                        const fontDataUrl = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(reader.result);
                            reader.onerror = reject;
                            reader.readAsDataURL(file);
                        });
                        
                        // 添加到字体库
                        const fontName = file.name.replace(/\.[^/.]+$/, '');
                        db.fontLibrary.push({
                            id: `font_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                            name: fontName,
                            url: fontDataUrl
                        });
                        successCount++;
                    } catch (error) {
                        failCount++;
                    }
                }
                
                await saveData();
                renderFontLibrary();
                e.target.value = '';
                
                if (failCount > 0) {
                    showToast(`导入完成: ${successCount} 个成功, ${failCount} 个失败`);
                } else {
                    showToast(`成功导入 ${successCount} 个字体！`);
                }
            });
            
            // 管理字体库按钮
            manageFontLibraryBtn.addEventListener('click', () => {
                const isManaging = fontLibraryManage.style.display !== 'none';
                if (isManaging) {
                    fontLibraryManage.style.display = 'none';
                    fontLibraryGrid.style.display = 'grid';
                    manageFontLibraryBtn.textContent = '管理字体库';
                } else {
                    fontLibraryManage.style.display = 'block';
                    fontLibraryGrid.style.display = 'none';
                    manageFontLibraryBtn.textContent = '取消管理';
                    renderFontCheckboxes();
                    selectAllFonts.checked = false;
                }
            });
            
            // 全选功能
            selectAllFonts.addEventListener('change', (e) => {
                const checkboxes = fontLibraryCheckboxes.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(cb => cb.checked = e.target.checked);
            });
            
            // 删除选中的字体
            deleteFontsBtn.addEventListener('click', async () => {
                const checkboxes = fontLibraryCheckboxes.querySelectorAll('input[type="checkbox"]:checked');
                if (checkboxes.length === 0) {
                    showToast('请先选择要删除的字体');
                    return;
                }
                
                if (!confirm(`确定要删除 ${checkboxes.length} 个字体吗？`)) {
                    return;
                }
                
                const idsToDelete = Array.from(checkboxes).map(cb => cb.dataset.fontId);
                db.fontLibrary = db.fontLibrary.filter(font => !idsToDelete.includes(font.id));
                
                await saveData();
                renderFontLibrary();
                renderFontCheckboxes();
                selectAllFonts.checked = false;
                showToast(`已删除 ${checkboxes.length} 个字体`);
            });
            
            restoreDefaultFontBtn.addEventListener('click', async () => {
                fontUrlInput.value = '';
                fontFileName.textContent = '';
                db.fontUrl = '';
                await saveData();
                applyGlobalFont('');
                applyGlobalFontSize(16); // 添加字体大小应用
                showToast('已恢复默认字体！');
            });
        }

        function applyGlobalFont(fontUrl) {
            const styleId = 'global-font-style';
            let styleElement = document.getElementById(styleId);
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = styleId;
                document.head.appendChild(styleElement);
            }
            if (fontUrl) {
                const fontName = 'CustomGlobalFont';
                styleElement.innerHTML = `@font-face { font-family: '${fontName}'; src: url('${fontUrl}'); } :root { --font-family: '${fontName}', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }`;
            } else {
                styleElement.innerHTML = `:root { --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }`;
            }
        }

        function applyGlobalFontSize(fontSize) {
            const styleId = 'global-font-size-style';
            let styleElement = document.getElementById(styleId);
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = styleId;
                document.head.appendChild(styleElement);
            }
            styleElement.innerHTML = `:root { --font-size: ${fontSize}px; }`;
        }

        // 获取所有全局世界书的ID列表
        function getGlobalWorldBookIds() {
            return db.worldBooks
                .filter(wb => wb.isGlobal === true)
                .map(wb => wb.id);
        }

        // 渲染分组列表
        function renderWbGroupList() {
            const wbGroupList = document.getElementById('wb-group-list');
            wbGroupList.innerHTML = '';
            
            if (db.worldBookGroups.length === 0) {
                wbGroupList.innerHTML = '<li style="padding: 20px; text-align: center; color: #999;">暂无分组</li>';
                return;
            }
            
            db.worldBookGroups.forEach(group => {
                const li = document.createElement('li');
                li.style.cssText = 'padding: 12px 16px; border-bottom: 1px solid #f0f0f0; display: flex; align-items: center; gap: 10px;';
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = group.name;
                nameSpan.style.cssText = 'font-size: 14px; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;';
                
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '删除';
                deleteBtn.className = 'btn btn-danger';
                deleteBtn.style.cssText = 'padding: 6px 12px; font-size: 12px; width: 70px; flex-shrink: 0;';
                deleteBtn.addEventListener('click', async () => {
                    if (!confirm(`确定要删除分组"${group.name}"吗？\n该分组下的世界书将移至默认分组。`)) {
                        return;
                    }
                    
                    // 将该分组下的世界书移至默认分组
                    db.worldBooks.forEach(book => {
                        if (book.groupId === group.id) {
                            book.groupId = '';
                        }
                    });
                    
                    // 删除分组
                    db.worldBookGroups = db.worldBookGroups.filter(g => g.id !== group.id);
                    await saveData();
                    renderWbGroupList();
                    updateWbGroupSelects();
                    renderWorldBookList();
                    showToast('分组已删除');
                });
                
                li.appendChild(nameSpan);
                li.appendChild(deleteBtn);
                wbGroupList.appendChild(li);
            });
        }

        // 更新所有分组选择下拉框
        function updateWbGroupSelects() {
            // 更新编辑表单中的分组选择
            worldBookGroupInput.innerHTML = '<option value="">默认分组</option>';
            db.worldBookGroups.forEach(group => {
                const option = document.createElement('option');
                option.value = group.id;
                option.textContent = group.name;
                worldBookGroupInput.appendChild(option);
            });
            
            // 更新筛选下拉框
            const currentFilter = wbGroupFilter.value;
            wbGroupFilter.innerHTML = '<option value="">全部</option>';
            
            // 添加默认分组选项（只有存在没有分组的世界书时才显示）
            const hasDefaultBooks = db.worldBooks.some(book => !book.groupId);
            if (hasDefaultBooks) {
                const defaultOption = document.createElement('option');
                defaultOption.value = 'default';
                defaultOption.textContent = '默认分组';
                wbGroupFilter.appendChild(defaultOption);
            }
            
            db.worldBookGroups.forEach(group => {
                const option = document.createElement('option');
                option.value = group.id;
                option.textContent = group.name;
                wbGroupFilter.appendChild(option);
            });
            
            // 恢复之前的筛选状态
            wbGroupFilter.value = currentFilter;
        }

        function setupWorldBookApp() {
            addWorldBookBtn.addEventListener('click', () => {
                currentEditingWorldBookId = null;
                editWorldBookForm.reset();
                document.querySelector('input[name="world-book-position"][value="before"]').checked = true;
                worldBookIsGlobalInput.checked = false;
                updateWbGroupSelects();
                
                // 隐藏精简总结按钮（新建世界书时）
                const summaryCompressSection = document.getElementById('summary-compress-section');
                if (summaryCompressSection) {
                    summaryCompressSection.style.display = 'none';
                }
                
                switchScreen('edit-world-book-screen');
            });
            editWorldBookForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = worldBookNameInput.value.trim();
                const content = worldBookContentInput.value.trim();
                const position = document.querySelector('input[name="world-book-position"]:checked').value;
                const isGlobal = worldBookIsGlobalInput.checked;
                const groupId = worldBookGroupInput.value;
                if (!name || !content) return showToast('名称和内容不能为空');
                
                let bookId;
                if (currentEditingWorldBookId) {
                    const book = db.worldBooks.find(wb => wb.id === currentEditingWorldBookId);
                    if (book) {
                        const wasGlobal = book.isGlobal || false;
                        book.name = name;
                        book.content = content;
                        book.position = position;
                        book.isGlobal = isGlobal;
                        book.groupId = groupId;
                        bookId = book.id;
                        
                        // 处理全局状态变化
                        if (isGlobal && !wasGlobal) {
                            // 变为全局：添加到所有角色
                            db.characters.forEach(char => {
                                if (!char.worldBookIds) char.worldBookIds = [];
                                if (!char.worldBookIds.includes(bookId)) {
                                    char.worldBookIds.push(bookId);
                                }
                            });
                            db.groups.forEach(group => {
                                if (!group.worldBookIds) group.worldBookIds = [];
                                if (!group.worldBookIds.includes(bookId)) {
                                    group.worldBookIds.push(bookId);
                                }
                            });
                        } else if (!isGlobal && wasGlobal) {
                            // 取消全局：从所有角色移除
                            db.characters.forEach(char => {
                                if (char.worldBookIds) {
                                    char.worldBookIds = char.worldBookIds.filter(id => id !== bookId);
                                }
                            });
                            db.groups.forEach(group => {
                                if (group.worldBookIds) {
                                    group.worldBookIds = group.worldBookIds.filter(id => id !== bookId);
                                }
                            });
                        }
                    }
                } else {
                    bookId = `wb_${Date.now()}`;
                    db.worldBooks.push({id: bookId, name, content, position, isGlobal, groupId});
                    
                    // 如果是全局，添加到所有角色
                    if (isGlobal) {
                        db.characters.forEach(char => {
                            if (!char.worldBookIds) char.worldBookIds = [];
                            if (!char.worldBookIds.includes(bookId)) {
                                char.worldBookIds.push(bookId);
                            }
                        });
                        db.groups.forEach(group => {
                            if (!group.worldBookIds) group.worldBookIds = [];
                            if (!group.worldBookIds.includes(bookId)) {
                                group.worldBookIds.push(bookId);
                            }
                        });
                    }
                }
                
                await saveData();
                showToast('世界书条目已保存');
                renderWorldBookList();
                switchScreen('world-book-screen');
            });
            worldBookListContainer.addEventListener('click', e => {
                const item = e.target.closest('.world-book-item');
                if (item) {
                    const book = db.worldBooks.find(wb => wb.id === item.dataset.id);
                    if (book) {
                        currentEditingWorldBookId = book.id;
                        worldBookIdInput.value = book.id;
                        worldBookNameInput.value = book.name;
                        worldBookContentInput.value = book.content;
                        document.querySelector(`input[name="world-book-position"][value="${book.position}"]`).checked = true;
                        worldBookIsGlobalInput.checked = book.isGlobal || false;
                        updateWbGroupSelects();
                        worldBookGroupInput.value = book.groupId || '';
                        
                        // 显示/隐藏精简总结按钮（仅总结类型世界书显示）
                        const summaryCompressSection = document.getElementById('summary-compress-section');
                        if (summaryCompressSection) {
                            if (book.isSummaryBook) {
                                summaryCompressSection.style.display = 'block';
                            } else {
                                summaryCompressSection.style.display = 'none';
                            }
                        }
                        
                        switchScreen('edit-world-book-screen');
                    }
                }
            });
            worldBookListContainer.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                const item = e.target.closest('.world-book-item');
                if (!item) return;
                longPressTimer = setTimeout(() => {
                    const bookId = item.dataset.id;
                    const menuItems = [{
                        label: '删除',
                        danger: true,
                        action: async () => {
                            if (confirm('确定要删除这个世界书条目吗？')) {
                                db.worldBooks = db.worldBooks.filter(wb => wb.id !== bookId);
                                db.characters.forEach(char => {
                                    char.worldBookIds = (char.worldBookIds || []).filter(id => id !== bookId);
                                });
                                db.groups.forEach(group => {
                                    group.worldBookIds = (group.worldBookIds || []).filter(id => id !== bookId);
                                });
                                await saveData();
                                renderWorldBookList();
                                showToast('条目已删除');
                            }
                        }
                    }];
                    createContextMenu(menuItems, e.clientX, e.clientY);
                }, 500);
            });
            worldBookListContainer.addEventListener('mouseup', () => clearTimeout(longPressTimer));
            worldBookListContainer.addEventListener('mouseleave', () => clearTimeout(longPressTimer));

            // 悬浮按钮和菜单功能
            const wbFloatBtn = document.getElementById('wb-float-btn');
            const wbFloatMenu = document.getElementById('wb-float-menu');
            const wbImportBtn = document.getElementById('wb-import-btn');
            const wbExportBtn = document.getElementById('wb-export-btn');
            const wbDeleteBtn = document.getElementById('wb-delete-btn');
            const wbExportModal = document.getElementById('wb-export-modal');
            const wbDeleteModal = document.getElementById('wb-delete-modal');
            const wbExportList = document.getElementById('wb-export-list');
            const wbDeleteList = document.getElementById('wb-delete-list');
            const wbExportSelectAll = document.getElementById('wb-export-select-all');
            const wbDeleteSelectAll = document.getElementById('wb-delete-select-all');

            // 切换浮动菜单
            wbFloatBtn.addEventListener('click', () => {
                const isVisible = wbFloatMenu.style.display === 'block';
                wbFloatMenu.style.display = isVisible ? 'none' : 'block';
            });

            // 点击其他地方关闭菜单
            document.addEventListener('click', (e) => {
                if (!wbFloatBtn.contains(e.target) && !wbFloatMenu.contains(e.target)) {
                    wbFloatMenu.style.display = 'none';
                }
            });

            // 导入功能
            wbImportBtn.addEventListener('click', () => {
                wbFloatMenu.style.display = 'none';
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    try {
                        const text = await file.text();
                        const importedBooks = JSON.parse(text);
                        if (!Array.isArray(importedBooks)) {
                            showToast('文件格式错误！');
                            return;
                        }
                        // 为导入的世界书生成新ID避免冲突
                        importedBooks.forEach(book => {
                            book.id = `wb_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                            db.worldBooks.push(book);
                        });
                        await saveData();
                        renderWorldBookList();
                        showToast(`成功导入 ${importedBooks.length} 个世界书条目`);
                    } catch (error) {
                        showToast('导入失败，文件可能已损坏');
                    }
                };
                input.click();
            });

            // 导出功能
            wbExportBtn.addEventListener('click', () => {
                wbFloatMenu.style.display = 'none';
                if (db.worldBooks.length === 0) {
                    showToast('没有可导出的世界书');
                    return;
                }
                renderWbSelectionList(wbExportList, wbExportSelectAll, 'export');
                wbExportModal.classList.add('visible');
            });

            // 删除功能
            wbDeleteBtn.addEventListener('click', () => {
                wbFloatMenu.style.display = 'none';
                if (db.worldBooks.length === 0) {
                    showToast('没有可删除的世界书');
                    return;
                }
                renderWbSelectionList(wbDeleteList, wbDeleteSelectAll, 'delete');
                wbDeleteModal.classList.add('visible');
            });

            // 渲染选择列表
            function renderWbSelectionList(listElement, selectAllCheckbox, type) {
                listElement.innerHTML = '';
                selectAllCheckbox.checked = false;
                db.worldBooks.forEach(book => {
                    const li = document.createElement('li');
                    li.className = 'wb-select-item';
                    li.innerHTML = `
                        <input type="checkbox" id="${type}-wb-${book.id}" value="${book.id}">
                        <label for="${type}-wb-${book.id}">${book.name}</label>
                    `;
                    listElement.appendChild(li);
                });

                // 全选功能
                selectAllCheckbox.addEventListener('change', (e) => {
                    listElement.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                        cb.checked = e.target.checked;
                    });
                });

                // 更新全选状态
                listElement.addEventListener('change', () => {
                    const checkboxes = listElement.querySelectorAll('input[type="checkbox"]');
                    const checkedCount = listElement.querySelectorAll('input[type="checkbox"]:checked').length;
                    selectAllCheckbox.checked = checkedCount === checkboxes.length;
                });
            }

            // 确认导出
            document.getElementById('wb-confirm-export-btn').addEventListener('click', () => {
                const selectedIds = Array.from(wbExportList.querySelectorAll('input[type="checkbox"]:checked'))
                    .map(cb => cb.value);
                if (selectedIds.length === 0) {
                    showToast('请至少选择一个世界书');
                    return;
                }
                const exportData = db.worldBooks.filter(wb => selectedIds.includes(wb.id));
                const dataStr = JSON.stringify(exportData, null, 2);
                const blob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `世界书导出_${new Date().toLocaleDateString()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                wbExportModal.classList.remove('visible');
                showToast(`成功导出 ${selectedIds.length} 个世界书条目`);
            });

            // 取消导出
            document.getElementById('wb-cancel-export-btn').addEventListener('click', () => {
                wbExportModal.classList.remove('visible');
            });

            // 确认删除
            document.getElementById('wb-confirm-delete-btn').addEventListener('click', async () => {
                const selectedIds = Array.from(wbDeleteList.querySelectorAll('input[type="checkbox"]:checked'))
                    .map(cb => cb.value);
                if (selectedIds.length === 0) {
                    showToast('请至少选择一个世界书');
                    return;
                }
                if (!confirm(`确定要删除选中的 ${selectedIds.length} 个世界书条目吗？`)) {
                    return;
                }
                // 删除世界书
                db.worldBooks = db.worldBooks.filter(wb => !selectedIds.includes(wb.id));
                // 从角色和群组中移除关联
                db.characters.forEach(char => {
                    char.worldBookIds = (char.worldBookIds || []).filter(id => !selectedIds.includes(id));
                });
                db.groups.forEach(group => {
                    group.worldBookIds = (group.worldBookIds || []).filter(id => !selectedIds.includes(id));
                });
                await saveData();
                renderWorldBookList();
                wbDeleteModal.classList.remove('visible');
                showToast(`成功删除 ${selectedIds.length} 个世界书条目`);
            });

            // 取消删除
            document.getElementById('wb-cancel-delete-btn').addEventListener('click', () => {
                wbDeleteModal.classList.remove('visible');
            });

            // 点击模态框背景关闭
            wbExportModal.addEventListener('click', (e) => {
                if (e.target === wbExportModal) {
                    wbExportModal.classList.remove('visible');
                }
            });
            wbDeleteModal.addEventListener('click', (e) => {
                if (e.target === wbDeleteModal) {
                    wbDeleteModal.classList.remove('visible');
                }
            });

            // ===== 精简总结功能 =====
            const compressSummaryBtn = document.getElementById('compress-summary-btn');
            
            if (compressSummaryBtn) {
                compressSummaryBtn.addEventListener('click', async () => {
                    const bookId = worldBookIdInput.value;
                    if (!bookId) {
                        showToast('请先保存世界书');
                        return;
                    }
                    
                    const book = db.worldBooks.find(wb => wb.id === bookId);
                    if (!book || !book.isSummaryBook) {
                        showToast('此功能仅适用于总结类型世界书');
                        return;
                    }
                    
                    const currentContent = worldBookContentInput.value.trim();
                    if (!currentContent) {
                        showToast('总结内容为空，无需精简');
                        return;
                    }
                    
                    const confirmed = confirm('确定要精简当前总结内容吗？\n\n精简后会替换原有内容，建议先备份。');
                    if (!confirmed) return;
                    
                    const btnText = compressSummaryBtn.querySelector('.btn-text');
                    const spinner = compressSummaryBtn.querySelector('.spinner');
                    
                    // 显示加载状态
                    btnText.textContent = '正在精简...';
                    spinner.style.display = 'inline-block';
                    compressSummaryBtn.disabled = true;
                    
                    try {
                        // 获取API设置
                        const apiSettings = db.apiSettings;
                        if (!apiSettings || !apiSettings.url || !apiSettings.key) {
                            throw new Error('请先配置API设置');
                        }
                        
                        const apiUrl = apiSettings.url.replace(/\/+$/, '');
                        const apiKey = getRandomValue(apiSettings.key);
                        const model = apiSettings.model;
                        
                        if (!model) {
                            throw new Error('请先在API设置中选择模型');
                        }
                        
                        // 获取总结提示词（从聊天设置中获取，如果没有则使用默认值）
                        const summaryPrompt = db.summaryPrompt || '请总结以下对话内容，提取关键信息和重要细节：';
                        
                        // 构建精简请求
                        const systemPrompt = `你是一个专业的文本精简助手。你的任务是将冗长的总结内容精简为更简洁的版本，同时保留所有关键信息和重要细节。

要求：
1. 保留所有重要的人物、事件、时间、地点等关键信息
2. 删除重复和冗余的描述
3. 使用更简洁的语言表达
4. 保持逻辑清晰，条理分明
5. 尽可能减少字数，但不能丢失重要信息

${summaryPrompt}`;
                        
                        const userPrompt = `请精简以下总结内容：\n\n${currentContent}`;
                        
                        showToast('正在调用API精简总结...');
                        
                        const response = await fetch(`${apiUrl}/v1/chat/completions`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`
                            },
                            body: JSON.stringify({
                                model: model,
                                messages: [
                                    { role: 'system', content: systemPrompt },
                                    { role: 'user', content: userPrompt }
                                ],
                                temperature: 0.7,
                                max_tokens: 4000
                            })
                        });
                        
                        if (!response.ok) {
                            let errorMessage = '精简失败';
                            try {
                                const errorData = await response.json();
                                errorMessage = errorData.error?.message || errorData.message || `HTTP ${response.status}: ${response.statusText}`;
                            } catch (e) {
                                errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                            }
                            throw new Error(errorMessage);
                        }
                        
                        const data = await response.json();
                        
                        if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                            throw new Error('API返回数据格式错误');
                        }
                        
                        const compressedContent = data.choices[0].message.content.trim();
                        
                        if (!compressedContent) {
                            throw new Error('API返回的精简内容为空');
                        }
                        
                        // 更新文本框内容
                        worldBookContentInput.value = compressedContent;
                        
                        // 计算压缩比例
                        const originalLength = currentContent.length;
                        const compressedLength = compressedContent.length;
                        const compressionRatio = ((1 - compressedLength / originalLength) * 100).toFixed(1);
                        
                        showToast(`✅ 精简完成！\n原长度: ${originalLength} 字\n精简后: ${compressedLength} 字\n压缩率: ${compressionRatio}%`, 5000);
                        
                    } catch (error) {
                        console.error('精简总结失败:', error);
                        
                        // 使用alert弹窗显示错误信息
                        alert(`❌ 精简失败\n\n错误信息：\n${error.message}\n\n请检查：\n1. API设置是否正确\n2. API密钥是否有效\n3. 网络连接是否正常\n4. 模型是否支持该功能`);
                        
                        // 同时显示toast提示
                        showToast(`❌ 精简失败: ${error.message}`);
                    } finally {
                        // 恢复按钮状态
                        btnText.textContent = '🗜️ 精简目前总结';
                        spinner.style.display = 'none';
                        compressSummaryBtn.disabled = false;
                    }
                });
            }

            // 分组管理功能
            const wbGroupManageBtn = document.getElementById('wb-group-manage-btn');
            const wbGroupModal = document.getElementById('wb-group-modal');
            const wbGroupList = document.getElementById('wb-group-list');
            const wbNewGroupNameInput = document.getElementById('wb-new-group-name');
            const wbAddGroupBtn = document.getElementById('wb-add-group-btn');
            const wbCloseGroupModalBtn = document.getElementById('wb-close-group-modal-btn');

            // 打开分组管理弹窗
            wbGroupManageBtn.addEventListener('click', () => {
                wbFloatMenu.style.display = 'none';
                renderWbGroupList();
                wbGroupModal.classList.add('visible');
            });

            // 添加新分组
            wbAddGroupBtn.addEventListener('click', async () => {
                const groupName = wbNewGroupNameInput.value.trim();
                if (!groupName) {
                    showToast('分组名称不能为空');
                    return;
                }
                // 检查是否重复
                if (db.worldBookGroups.find(g => g.name === groupName)) {
                    showToast('分组名称已存在');
                    return;
                }
                const newGroup = {
                    id: `wbg_${Date.now()}`,
                    name: groupName
                };
                db.worldBookGroups.push(newGroup);
                await saveData();
                wbNewGroupNameInput.value = '';
                renderWbGroupList();
                updateWbGroupSelects();
                showToast('分组已添加');
            });

            // 关闭分组管理弹窗
            wbCloseGroupModalBtn.addEventListener('click', () => {
                wbGroupModal.classList.remove('visible');
            });

            // 点击背景关闭分组管理弹窗
            wbGroupModal.addEventListener('click', (e) => {
                if (e.target === wbGroupModal) {
                    wbGroupModal.classList.remove('visible');
                }
            });

            // 分组筛选功能
            wbGroupFilter.addEventListener('change', (e) => {
                currentWbGroupFilter = e.target.value;
                renderWorldBookList();
            });
        }

        function renderWorldBookList() {
            worldBookListContainer.innerHTML = '';
            
            // 根据筛选条件过滤世界书
            let filteredBooks = db.worldBooks;
            if (currentWbGroupFilter) {
                if (currentWbGroupFilter === 'default') {
                    // 筛选没有分组的世界书
                    filteredBooks = db.worldBooks.filter(book => !book.groupId);
                } else {
                    filteredBooks = db.worldBooks.filter(book => book.groupId === currentWbGroupFilter);
                }
            }
            
            noWorldBooksPlaceholder.style.display = filteredBooks.length === 0 ? 'block' : 'none';
            filteredBooks.forEach(book => {
                const li = document.createElement('li');
                li.className = 'list-item world-book-item';
                li.dataset.id = book.id;
                
                // 显示分组标签
                let groupTag = '';
                if (book.groupId) {
                    const group = db.worldBookGroups.find(g => g.id === book.groupId);
                    if (group) {
                        groupTag = `<span style="display: inline-block; background: #e3f2fd; color: #1976d2; padding: 2px 8px; border-radius: 10px; font-size: 12px; margin-left: 8px;">${group.name}</span>`;
                    }
                }
                
                // 如果是加密的世界书，显示假内容；否则显示真实内容
                const displayContent = book.isEncrypted ? book.content : book.content;
                
                li.innerHTML = `<div class="item-details" style="padding-left: 20px;"><div class="item-name">${book.name}${groupTag}</div><div class="item-preview">${displayContent}</div></div>`;
                worldBookListContainer.appendChild(li);
            });
            
            // 更新分组筛选下拉框
            updateWbGroupSelects();
        }

        // === 心声功能相关函数 ===
        let innerThoughtViewMode = 'current'; // 'current' 或 'history'
        let isInnerThoughtEditMode = false;
        let isInnerThoughtDeleteMode = false;
        let innerThoughtBackup = null;
        let selectedInnerThoughts = new Set();
        
        function showInnerThoughtModal() {
            innerThoughtViewMode = 'current';
            isInnerThoughtEditMode = false;
            isInnerThoughtDeleteMode = false;
            selectedInnerThoughts.clear();
            renderInnerThoughtList();
            document.getElementById('inner-thought-modal').classList.add('visible');
        }
        
        function renderInnerThoughtList() {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat || !chat.history) {
                document.getElementById('inner-thought-list').innerHTML = '<div class="inner-thought-empty">暂无聊天记录</div>';
                return;
            }
            
            // 筛选出包含心声的AI消息
            const messagesWithThoughts = chat.history.filter(msg => 
                msg.role === 'assistant' && msg.innerThought
            );
            
            // 根据查看模式筛选
            let displayMessages = [];
            if (innerThoughtViewMode === 'current') {
                // 对于群聊，显示最新一轮对话中所有成员的心声
                if (currentChatType === 'group' && messagesWithThoughts.length > 0) {
                    // 找到最后一条用户消息的索引
                    let lastUserMsgIndex = -1;
                    for (let i = chat.history.length - 1; i >= 0; i--) {
                        if (chat.history[i].role === 'user') {
                            lastUserMsgIndex = i;
                            break;
                        }
                    }
                    
                    // 收集该用户消息之后的所有AI心声
                    if (lastUserMsgIndex >= 0) {
                        displayMessages = messagesWithThoughts.filter(msg => {
                            const msgIndex = chat.history.findIndex(m => m.id === msg.id);
                            return msgIndex > lastUserMsgIndex;
                        });
                    } else {
                        // 如果没有用户消息，显示所有最新的心声
                        displayMessages = messagesWithThoughts.slice(-3); // 最多显示最近3条
                    }
                } else if (messagesWithThoughts.length > 0) {
                    // 私聊只显示最新的一条
                    displayMessages = [messagesWithThoughts[messagesWithThoughts.length - 1]];
                }
            } else {
                // 显示所有历史记录
                displayMessages = messagesWithThoughts.reverse();
            }
            
            const innerThoughtList = document.getElementById('inner-thought-list');
            const historyBtn = document.getElementById('inner-thought-history-btn');
            const editBtn = document.getElementById('inner-thought-edit-btn');
            
            // 更新按钮状态
            historyBtn.textContent = innerThoughtViewMode === 'current' ? '历史' : '返回';
            editBtn.style.display = displayMessages.length > 0 && !isInnerThoughtDeleteMode ? '' : 'none';
            document.getElementById('inner-thought-delete-mode-btn').style.display = displayMessages.length > 0 && !isInnerThoughtEditMode ? '' : 'none';
            document.getElementById('inner-thought-select-all-btn').style.display = isInnerThoughtDeleteMode ? '' : 'none';
            
            if (displayMessages.length === 0) {
                innerThoughtList.innerHTML = '<div class="inner-thought-empty">' + 
                    (innerThoughtViewMode === 'current' ? '暂无心声记录' : '暂无历史记录') + '</div>';
            } else {
                innerThoughtList.innerHTML = '';
                
                displayMessages.forEach(msg => {
                    const item = document.createElement('div');
                    item.className = 'inner-thought-item';
                    item.dataset.messageId = msg.id;
                    
                    // 获取角色信息
                    let characterName = '';
                    let characterAvatar = '';
                    
                    if (currentChatType === 'private') {
                        characterName = chat.remarkName || chat.realName;
                        characterAvatar = chat.avatar;
                    } else {
                        const sender = chat.members.find(m => m.id === msg.senderId);
                        if (sender) {
                            characterName = sender.groupNickname;
                            characterAvatar = sender.avatar;
                        }
                    }
                    
                    // 格式化时间
                    const time = new Date(msg.timestamp);
                    const timeString = `${time.getFullYear()}/${pad(time.getMonth()+1)}/${pad(time.getDate())} ${pad(time.getHours())}:${pad(time.getMinutes())}`;
                    
                    item.innerHTML = `
                        <div class="inner-thought-header">
                            <input type="checkbox" class="inner-thought-checkbox" data-message-id="${msg.id}">
                            <img class="inner-thought-avatar" src="${characterAvatar}" alt="${characterName}">
                            <div class="inner-thought-info">
                                <div class="inner-thought-name">${characterName}</div>
                                <div class="inner-thought-time">${timeString}</div>
                            </div>
                        </div>
                        <div class="inner-thought-content">${msg.innerThought}</div>
                        <textarea class="inner-thought-edit-textarea" style="display: none;">${msg.innerThought}</textarea>
                        <div class="inner-thought-edit-actions">
                            <button class="inner-thought-delete-btn">删除</button>
                        </div>
                    `;
                    
                    // 添加复选框事件
                    const checkbox = item.querySelector('.inner-thought-checkbox');
                    checkbox.addEventListener('change', (e) => {
                        const msgId = e.target.dataset.messageId;
                        if (e.target.checked) {
                            selectedInnerThoughts.add(msgId);
                            item.classList.add('selected');
                        } else {
                            selectedInnerThoughts.delete(msgId);
                            item.classList.remove('selected');
                        }
                        updateSelectAllButton();
                    });
                    
                    // 添加单条删除按钮事件
                    const deleteBtn = item.querySelector('.inner-thought-delete-btn');
                    deleteBtn.addEventListener('click', () => {
                        deleteSingleInnerThought(msg.id);
                    });
                    
                    // 如果处于删除模式，显示复选框
                    if (isInnerThoughtDeleteMode) {
                        item.classList.add('delete-mode');
                        if (selectedInnerThoughts.has(msg.id)) {
                            checkbox.checked = true;
                            item.classList.add('selected');
                        }
                    }
                    
                    innerThoughtList.appendChild(item);
                });
            }
        }
        
        function toggleInnerThoughtHistory() {
            innerThoughtViewMode = innerThoughtViewMode === 'current' ? 'history' : 'current';
            renderInnerThoughtList();
        }
        
        function enterInnerThoughtEditMode() {
            if (isInnerThoughtEditMode) return;
            
            isInnerThoughtEditMode = true;
            const items = document.querySelectorAll('.inner-thought-item');
            
            // 备份当前数据
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            innerThoughtBackup = JSON.parse(JSON.stringify(chat.history));
            
            items.forEach(item => {
                item.classList.add('editing');
                const content = item.querySelector('.inner-thought-content');
                const textarea = item.querySelector('.inner-thought-edit-textarea');
                content.style.display = 'none';
                textarea.style.display = 'block';
            });
            
            // 显示保存/取消按钮
            document.getElementById('save-inner-thought-btn').style.display = 'block';
            document.getElementById('cancel-inner-thought-edit-btn').style.display = 'block';
            document.getElementById('close-inner-thought-btn').style.display = 'none';
            document.getElementById('inner-thought-history-btn').style.display = 'none';
            document.getElementById('inner-thought-edit-btn').style.display = 'none';
        }
        
        async function saveInnerThoughtEdits() {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const items = document.querySelectorAll('.inner-thought-item');
            
            items.forEach(item => {
                const messageId = item.dataset.messageId;
                const textarea = item.querySelector('.inner-thought-edit-textarea');
                const newThought = textarea.value.trim();
                
                const msg = chat.history.find(m => m.id === messageId);
                if (msg) {
                    msg.innerThought = newThought;
                }
            });
            
            await saveData();
            exitInnerThoughtEditMode();
            showToast('修改已保存');
        }
        
        function cancelInnerThoughtEdit() {
            // 恢复备份数据
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (innerThoughtBackup) {
                chat.history = innerThoughtBackup;
                innerThoughtBackup = null;
            }
            exitInnerThoughtEditMode();
        }
        
        function exitInnerThoughtEditMode() {
            isInnerThoughtEditMode = false;
            
            // 隐藏保存/取消按钮
            document.getElementById('save-inner-thought-btn').style.display = 'none';
            document.getElementById('cancel-inner-thought-edit-btn').style.display = 'none';
            document.getElementById('close-inner-thought-btn').style.display = 'block';
            document.getElementById('inner-thought-history-btn').style.display = 'block';
            document.getElementById('inner-thought-edit-btn').style.display = 'block';
            
            renderInnerThoughtList();
        }
        
        function enterInnerThoughtDeleteMode() {
            if (isInnerThoughtDeleteMode) return;
            
            isInnerThoughtDeleteMode = true;
            selectedInnerThoughts.clear();
            
            // 显社确认/取消按钮
            document.getElementById('confirm-delete-inner-thought-btn').style.display = 'block';
            document.getElementById('cancel-delete-inner-thought-btn').style.display = 'block';
            document.getElementById('close-inner-thought-btn').style.display = 'none';
            document.getElementById('inner-thought-history-btn').style.display = 'none';
            document.getElementById('inner-thought-edit-btn').style.display = 'none';
            document.getElementById('inner-thought-delete-mode-btn').style.display = 'none';
            
            renderInnerThoughtList();
        }
        
        function exitInnerThoughtDeleteMode() {
            isInnerThoughtDeleteMode = false;
            selectedInnerThoughts.clear();
            
            // 隐藏确认/取消按钮
            document.getElementById('confirm-delete-inner-thought-btn').style.display = 'none';
            document.getElementById('cancel-delete-inner-thought-btn').style.display = 'none';
            document.getElementById('close-inner-thought-btn').style.display = 'block';
            document.getElementById('inner-thought-history-btn').style.display = 'block';
            document.getElementById('inner-thought-select-all-btn').style.display = 'none';
            
            renderInnerThoughtList();
        }
        
        function toggleSelectAll() {
            const checkboxes = document.querySelectorAll('.inner-thought-checkbox');
            const allSelected = selectedInnerThoughts.size === checkboxes.length;
            
            checkboxes.forEach(checkbox => {
                const msgId = checkbox.dataset.messageId;
                const item = checkbox.closest('.inner-thought-item');
                
                if (allSelected) {
                    checkbox.checked = false;
                    selectedInnerThoughts.delete(msgId);
                    item.classList.remove('selected');
                } else {
                    checkbox.checked = true;
                    selectedInnerThoughts.add(msgId);
                    item.classList.add('selected');
                }
            });
            
            updateSelectAllButton();
        }
        
        function updateSelectAllButton() {
            const selectAllBtn = document.getElementById('inner-thought-select-all-btn');
            const checkboxes = document.querySelectorAll('.inner-thought-checkbox');
            const allSelected = checkboxes.length > 0 && selectedInnerThoughts.size === checkboxes.length;
            
            selectAllBtn.textContent = allSelected ? '取消全选' : '全选';
        }
        
        async function confirmDeleteInnerThoughts() {
            if (selectedInnerThoughts.size === 0) {
                showToast('请选择要删除的心声');
                return;
            }
            
            if (!confirm(`确定要删除选中的 ${selectedInnerThoughts.size} 条心声吗？`)) return;
            
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            
            selectedInnerThoughts.forEach(messageId => {
                const msg = chat.history.find(m => m.id === messageId);
                if (msg) {
                    delete msg.innerThought;
                }
            });
            
            await saveData();
            selectedInnerThoughts.clear();
            exitInnerThoughtDeleteMode();
            showToast('已删除');
        }
        
        async function deleteSingleInnerThought(messageId) {
            if (!confirm('确定要删除这条心声吗？')) return;
            
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            const msg = chat.history.find(m => m.id === messageId);
            
            if (msg) {
                delete msg.innerThought;
                await saveData();
                renderInnerThoughtList();
                showToast('已删除');
            }
        }

        // === 音乐播放器相关函数 ===
        
        async function handleListenTogetherClick() {
            const targetChatId = currentChatId;
            if (!targetChatId) return;
            
            if (!musicState.isActive) {
                startListenTogetherSession(targetChatId);
                return;
            }
            
            if (musicState.activeChatId === targetChatId) {
                updatePlayerUI();
                document.getElementById('music-player-overlay').classList.add('visible');
            } else {
                const chat = currentChatType === 'private' ? 
                    db.characters.find(c => c.id === musicState.activeChatId) : 
                    db.groups.find(g => g.id === musicState.activeChatId);
                const oldChatName = chat ? (currentChatType === 'private' ? chat.remarkName : chat.name) : '未知';
                const currentChat = currentChatType === 'private' ? 
                    db.characters.find(c => c.id === targetChatId) : 
                    db.groups.find(g => g.id === targetChatId);
                const newChatName = currentChat ? (currentChatType === 'private' ? currentChat.remarkName : currentChat.name) : '当前';
                
                const confirmed = confirm(`您正和「${oldChatName}」听歌。要结束并开始和「${newChatName}」的新会话吗？`);
                if (confirmed) {
                    await endListenTogetherSession(true);
                    await new Promise(resolve => setTimeout(resolve, 50));
                    startListenTogetherSession(targetChatId);
                }
            }
        }
        
        async function startListenTogetherSession(chatId) {
            const chat = currentChatType === 'private' ? 
                db.characters.find(c => c.id === chatId) : 
                db.groups.find(g => g.id === chatId);
            if (!chat) return;
            
            if (!chat.musicData) chat.musicData = {totalTime: 0};
            
            musicState.totalElapsedTime = chat.musicData.totalTime || 0;
            musicState.isActive = true;
            musicState.activeChatId = chatId;
            musicState.playlist = db.musicPlaylist || [];
            
            if (musicState.playlist.length > 0) {
                musicState.currentIndex = 0;
            } else {
                musicState.currentIndex = -1;
            }
            
            if(musicState.timerId) clearInterval(musicState.timerId);
            musicState.timerId = setInterval(() => {
                if (musicState.isPlaying) {
                    musicState.totalElapsedTime++;
                    updateElapsedTimeDisplay();
                }
            }, 1000);
            
            updatePlayerUI();
            updatePlaylistUI();
            document.getElementById('music-player-overlay').classList.add('visible');
            
            // 如果有歌词且正在播放，显示悬浮歌词
            if (musicState.parsedLyrics && musicState.parsedLyrics.length > 0 && musicState.isPlaying) {
                document.getElementById('floating-lyrics-container').classList.add('visible');
            }
        }
        
        async function endListenTogetherSession(saveState = true) {
            if (!musicState.isActive) return;
            const oldChatId = musicState.activeChatId;
            const oldChatType = currentChatType;
            
            const cleanupLogic = async () => {
                if (musicState.timerId) clearInterval(musicState.timerId);
                if (musicState.isPlaying) audioPlayer.pause();
                
                if (saveState && oldChatId) {
                    const chat = oldChatType === 'private' ? 
                        db.characters.find(c => c.id === oldChatId) : 
                        db.groups.find(g => g.id === oldChatId);
                    if (chat) {
                        if (!chat.musicData) chat.musicData = {totalTime: 0};
                        chat.musicData.totalTime = musicState.totalElapsedTime;
                        await saveData();
                    }
                }
                
                musicState.isActive = false;
                musicState.activeChatId = null;
                musicState.totalElapsedTime = 0;
                musicState.timerId = null;
                updateListenTogetherIcon(oldChatId, true);
            };
            
            closeMusicPlayerWithAnimation(cleanupLogic);
        }
        
        function returnToChat() {
            closeMusicPlayerWithAnimation();
        }
        
        function closeMusicPlayerWithAnimation(callback) {
            const overlay = document.getElementById('music-player-overlay');
            if (!overlay.classList.contains('visible')) {
                if (callback) callback();
                return;
            }
            overlay.classList.remove('visible');
            // 只在真正结束会话时隐藏悬浮歌词（callback存在表示是endListenTogetherSession调用）
            // 如果只是返回聊天（returnToChat），音乐继续播放，悬浮歌词保持显示
            if (callback) {
                document.getElementById('floating-lyrics-container').classList.remove('visible');
            }
            setTimeout(() => {
                if (callback) callback();
            }, 400);
        }
        
        function updateListenTogetherIcon(chatId, forceReset = false) {
            const iconImg = document.querySelector('#listen-together-btn img');
            if(!iconImg) return;
            
            if(forceReset || !musicState.isActive || musicState.activeChatId !== chatId) {
                iconImg.src = 'https://i.postimg.cc/dV8sdNcx/210-20250618115221.png';
                iconImg.className = '';
                return;
            }
            
            iconImg.src = 'https://i.postimg.cc/dV8sdNcx/210-20250618115221.png';
            iconImg.classList.add('rotating');
            if (musicState.isPlaying) {
                iconImg.classList.remove('paused');
            } else {
                iconImg.classList.add('paused');
            }
        }
        
        function updatePlayerUI() {
            updateListenTogetherIcon(musicState.activeChatId);
            updateElapsedTimeDisplay();
            
            const titleEl = document.getElementById('music-player-song-title');
            const artistEl = document.getElementById('music-player-artist');
            const playPauseBtn = document.getElementById('music-play-pause-btn');
            
            // 更新头像
            const userAvatarEl = document.getElementById('music-user-avatar');
            const charAvatarEl = document.getElementById('music-char-avatar');
            
            if (musicState.activeChatId) {
                const chat = currentChatType === 'private' ? 
                    db.characters.find(c => c.id === musicState.activeChatId) : 
                    db.groups.find(g => g.id === musicState.activeChatId);
                
                if (chat) {
                    if (currentChatType === 'private') {
                        // 私聊：显示用户和角色头像
                        userAvatarEl.src = chat.myAvatar || 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg';
                        charAvatarEl.src = chat.avatar || 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
                    } else {
                        // 群聊：显示用户头像和群头像
                        userAvatarEl.src = chat.me?.avatar || 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg';
                        charAvatarEl.src = chat.avatar || 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
                    }
                }
            }
            
            if (musicState.currentIndex > -1 && musicState.playlist.length > 0) {
                const track = musicState.playlist[musicState.currentIndex];
                titleEl.textContent = track.name;
                artistEl.textContent = track.artist;
            } else {
                titleEl.textContent = '请添加歌曲';
                artistEl.textContent = '...';
            }
            
            playPauseBtn.textContent = musicState.isPlaying ? '❚❚' : '▶';
        }
        
        function updateElapsedTimeDisplay() {
            if (musicState.timeDisplayUnit === 'minutes') {
                const minutes = Math.floor(musicState.totalElapsedTime / 60);
                document.getElementById('music-time-counter').textContent = `已经一起听了${minutes}分钟`;
            } else {
                const hours = (musicState.totalElapsedTime / 3600).toFixed(1);
                document.getElementById('music-time-counter').textContent = `已经一起听了${hours}小时`;
            }
        }
        
        let playlistManageMode = false;
        let selectedPlaylistItems = new Set();
        
        function updatePlaylistUI() {
            const playlistBody = document.getElementById('playlist-body');
            playlistBody.innerHTML = '';
            
            if (musicState.playlist.length === 0) {
                playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">播放列表是空的~</p>';
                return;
            }
            
            musicState.playlist.forEach((track, index) => {
                const item = document.createElement('div');
                item.className = 'playlist-item';
                if(index === musicState.currentIndex) item.classList.add('playing');
                if(playlistManageMode) item.classList.add('manage-mode');
                
                item.innerHTML = `
                    <input type="checkbox" class="playlist-item-checkbox" data-index="${index}" ${selectedPlaylistItems.has(index) ? 'checked' : ''}>
                    <div class="playlist-item-info">
                        <div class="title">${track.name}</div>
                        <div class="artist">${track.artist}</div>
                    </div>
                    <div class="playlist-item-actions">
                        <button data-index="${index}" class="cover-btn">封</button>
                        <button data-index="${index}" class="lyrics-btn">词</button>
                        <button data-index="${index}" class="delete-track-btn">×</button>
                    </div>
                `;
                
                // 复选框点击事件
                const checkbox = item.querySelector('.playlist-item-checkbox');
                checkbox.addEventListener('change', (e) => {
                    e.stopPropagation();
                    if (checkbox.checked) {
                        selectedPlaylistItems.add(index);
                    } else {
                        selectedPlaylistItems.delete(index);
                    }
                    updateSelectedCount();
                });
                
                // 播放点击事件（管理模式下禁用）
                const infoDiv = item.querySelector('.playlist-item-info');
                infoDiv.addEventListener('click', () => {
                    if (!playlistManageMode) {
                        playSong(index);
                    }
                });
                
                playlistBody.appendChild(item);
            });
            
            updateSelectedCount();
        }
        
        function updateSelectedCount() {
            const countEl = document.getElementById('selected-count');
            if (countEl) {
                countEl.textContent = `已选中 ${selectedPlaylistItems.size} 首`;
            }
            // 同时更新管理弹窗的计数
            updateManageSelectedCount();
        }
        
        function updateManageSelectedCount() {
            const countEl = document.getElementById('manage-selected-count');
            if (countEl) {
                countEl.textContent = `已选中 ${selectedPlaylistItems.size} 首`;
            }
        }
        
        function togglePlaylistManageMode() {
            playlistManageMode = !playlistManageMode;
            const manageBtn = document.getElementById('manage-playlist-btn');
            const manageBar = document.getElementById('playlist-manage-bar');
            
            if (playlistManageMode) {
                manageBtn.classList.add('active');
                manageBtn.textContent = '完成';
                manageBar.classList.add('visible');
            } else {
                manageBtn.classList.remove('active');
                manageBtn.textContent = '管理';
                manageBar.classList.remove('visible');
                selectedPlaylistItems.clear();
            }
            
            updatePlaylistUI();
        }
        
        function playSong(index) {
            if (index < 0 || index >= musicState.playlist.length) return;
            const track = musicState.playlist[index];
            musicState.currentIndex = index;
            const audioPlayer = document.getElementById('audio-player');
            
            if (!audioPlayer) {
                console.error('音频播放器未找到');
                return;
            }
            
            // 先暂停当前播放
            audioPlayer.pause();
            
            // 设置新的音频源
            audioPlayer.src = track.src;
            audioPlayer.currentTime = 0;
            
            db.currentMusicIndex = index;
            db.lastMusicPosition = 0;
            saveData();
            
            // 等待音频元数据加载完成后再播放
            const onLoadedMetadata = () => {
                console.log('音频元数据已加载，准备播放:', track.title, '时长:', audioPlayer.duration);
                audioPlayer.removeEventListener('loadedmetadata', onLoadedMetadata);
                
                const playPromise = audioPlayer.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log('开始播放:', track.title);
                    }).catch(err => {
                        console.error('播放失败:', err);
                        showToast('播放失败，请检查音频链接');
                    });
                }
            };
            
            // 如果元数据已经加载，直接播放
            if (audioPlayer.readyState >= 1) {
                onLoadedMetadata();
            } else {
                // 否则等待元数据加载
                audioPlayer.addEventListener('loadedmetadata', onLoadedMetadata);
                
                // 设置超时，防止一直等待
                setTimeout(() => {
                    audioPlayer.removeEventListener('loadedmetadata', onLoadedMetadata);
                    if (audioPlayer.readyState < 1) {
                        console.warn('音频元数据加载超时，尝试直接播放');
                        audioPlayer.play().catch(err => {
                            console.error('播放失败:', err);
                            showToast('播放失败，请检查音频链接');
                        });
                    }
                }, 5000);
            }
            
            updatePlaylistUI();
            updatePlayerUI();
            
            // 更新胶片封面图片
            const coverImg = document.getElementById('music-player-cover');
            if (coverImg) {
                coverImg.src = track.cover || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg';
            }
            
            // 自动加载歌词
            if (track.lyrics) {
                loadLyrics(track.lyrics);
            } else if (track.lrcContent) {
                loadLyrics(track.lrcContent);
            } else {
                // 清空歌词
                musicState.parsedLyrics = [];
                renderLyrics();
            }
        }
        
        function togglePlayPause() {
            if (audioPlayer.paused) {
                if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
                    playSong(0);
                } else if (musicState.currentIndex > -1) {
                    audioPlayer.play();
                }
            } else {
                audioPlayer.pause();
            }
        }
        
        function playNext() {
            if (musicState.playlist.length === 0) return;
            let nextIndex;
            
            switch(musicState.playMode) {
                case 'random':
                    nextIndex = Math.floor(Math.random() * musicState.playlist.length);
                    break;
                case 'single':
                    playSong(musicState.currentIndex);
                    return;
                case 'order':
                default:
                    nextIndex = (musicState.currentIndex + 1) % musicState.playlist.length;
                    break;
            }
            playSong(nextIndex);
        }
        
        function playPrev() {
            if (musicState.playlist.length === 0) return;
            const newIndex = (musicState.currentIndex - 1 + musicState.playlist.length) % musicState.playlist.length;
            playSong(newIndex);
        }
        
        function changePlayMode() {
            const modes = ['order', 'random', 'single'];
            const currentModeIndex = modes.indexOf(musicState.playMode);
            musicState.playMode = modes[(currentModeIndex + 1) % modes.length];
            document.getElementById('music-mode-btn').textContent = {'order': '顺序', 'random': '随机', 'single': '单曲'}[musicState.playMode];
        }
        
        async function addSongFromURL() {
            const url = prompt("请输入歌曲的URL");
            if (!url) return;
            const name = prompt("请输入歌名");
            if (!name) return;
            const artist = prompt("请输入歌手名");
            if (!artist) return;
            
            musicState.playlist.push({ name, artist, src: url, isLocal: false });
            db.musicPlaylist = musicState.playlist;
            await saveData();
            updatePlaylistUI();
            
            if(musicState.currentIndex === -1) {
                musicState.currentIndex = musicState.playlist.length - 1;
                updatePlayerUI();
            }
        }
        
        async function addSongFromLocal(event) {
            const files = event.target.files;
            if (!files.length) return;
            
            for (const file of files) {
                let name = file.name.replace(/\.[^/.]+$/, "");
                name = prompt("请输入歌名", name);
                if (name === null) continue;
                
                const artist = prompt("请输入歌手名", "未知歌手");
                if (artist === null) continue;
                
                let lrcContent = "";
                const wantLrc = confirm(`要为《${name}》导入歌词文件 (.lrc) 吗？`);
                if (wantLrc) {
                    lrcContent = await new Promise(resolve => {
                        const lrcInput = document.getElementById('lrc-upload-input');
                        const lrcChangeHandler = (e) => {
                            const lrcFile = e.target.files[0];
                            if (lrcFile) {
                                const reader = new FileReader();
                                reader.onload = (readEvent) => resolve(readEvent.target.result);
                                reader.onerror = () => resolve("");
                                reader.readAsText(lrcFile);
                            } else {
                                resolve("");
                            }
                            lrcInput.removeEventListener('change', lrcChangeHandler);
                            lrcInput.value = '';
                        };
                        lrcInput.addEventListener('change', lrcChangeHandler);
                        lrcInput.click();
                    });
                }
                
                musicState.playlist.push({ 
                    name, 
                    artist, 
                    src: file, 
                    isLocal: true,
                    lrcContent: lrcContent
                });
            }
            
            db.musicPlaylist = musicState.playlist;
            await saveData();
            updatePlaylistUI();
            
            if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
                musicState.currentIndex = 0;
                updatePlayerUI();
            }
            event.target.value = null;
        }
        
        // ============= 音乐搜索功能 =============
        // 使用vkeys.cn v2 API（支持CORS，无需代理）
        
        // 搜索历史管理
        let musicSearchHistory = [];
        
        // 加载搜索历史
        function loadSearchHistory() {
            const saved = localStorage.getItem('musicSearchHistory');
            if (saved) {
                try {
                    musicSearchHistory = JSON.parse(saved);
                } catch (e) {
                    musicSearchHistory = [];
                }
            }
        }
        
        // 保存搜索历史
        function saveSearchHistory() {
            localStorage.setItem('musicSearchHistory', JSON.stringify(musicSearchHistory));
        }
        
        // 添加搜索历史（已废弃，保留以兼容旧数据）
        function addSearchHistory(keyword) {
            // 不再使用，保留函数避免报错
        }
        
        // 添加歌曲到搜索历史
        function addSongToHistory(songData) {
            if (!songData || !songData.songId) return;
            
            // 移除已存在的相同歌曲（根据songId和platform）
            musicSearchHistory = musicSearchHistory.filter(item => 
                !(item.songId === songData.songId && item.platform === songData.platform)
            );
            
            // 添加新记录到开头
            musicSearchHistory.unshift({
                id: songData.id,  // 播放列表中的id
                songId: songData.songId,  // 平台的歌曲id
                name: songData.name,
                artist: songData.artist,
                cover: songData.cover,
                platform: songData.platform,
                timestamp: Date.now()
            });
            
            // 保存历史记录（无上限）
            saveSearchHistory();
        }
        
        // 旧函数保留兼容性
        function markSongAsAdded(keyword, songName) {
            // 不再使用
        }
        
        // 显示搜索历史
        let isDeleteMode = false;
        
        function showSearchHistory() {
            const modal = document.getElementById('search-history-modal');
            const listEl = document.getElementById('search-history-list');
            
            // 重置删除模式
            isDeleteMode = false;
            document.getElementById('toggle-delete-mode').classList.remove('active');
            document.getElementById('toggle-delete-mode').textContent = '删除';
            document.getElementById('select-all-history').style.display = 'none';
            document.getElementById('delete-selected-history').style.display = 'none';
            document.getElementById('clear-search-history').style.display = 'flex';
            
            if (musicSearchHistory.length === 0) {
                listEl.innerHTML = '<div style="text-align: center; color: #999; padding: 40px;">暂无搜索历史</div>';
            } else {
                listEl.innerHTML = '';
                musicSearchHistory.forEach((item, index) => {
                    // 检查歌曲是否在播放列表中
                    const songExists = musicState.playlist.some(s => s.songId === item.songId && s.platform === item.platform);
                    const statusIcon = songExists ? '✓' : '✗';
                    const statusText = songExists ? '已添加' : '未添加';
                    const statusColor = songExists ? '#4caf50' : '#999';
                    
                    const date = new Date(item.timestamp);
                    const dateStr = `${date.getMonth() + 1}-${date.getDate()} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
                    
                    const historyItem = document.createElement('div');
                    historyItem.className = 'history-item';
                    historyItem.dataset.index = index;
                    historyItem.style.cssText = 'cursor: pointer; padding: 12px 15px;';
                    historyItem.innerHTML = `
                        <input type="checkbox" class="history-item-checkbox" data-index="${index}">
                        <div style="display: flex; align-items: center; gap: 12px; flex: 1;">
                            <img src="${item.cover || 'https://i.postimg.cc/pT2xKzP/album-cover-placeholder.png'}" 
                                 style="width: 48px; height: 48px; border-radius: 6px; object-fit: cover;" 
                                 onerror="this.src='https://i.postimg.cc/pT2xKzP/album-cover-placeholder.png'">
                            <div style="flex: 1; min-width: 0;">
                                <div style="font-weight: 600; margin-bottom: 2px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${item.name || '未知歌曲'}</div>
                                <div style="font-size: 13px; color: #666; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${item.artist || '未知歌手'}</div>
                                <div style="font-size: 12px; color: #999; margin-top: 2px;">${dateStr}</div>
                            </div>
                            <div style="font-size: 12px; color: ${statusColor}; font-weight: 600; white-space: nowrap;">
                                ${statusIcon} ${statusText}
                            </div>
                        </div>
                    `;
                    
                    // 点击事件 - 检查歌曲状态
                    historyItem.addEventListener('click', async (e) => {
                        if (!isDeleteMode && !e.target.classList.contains('history-item-checkbox')) {
                            await handleSongHistoryClick(item);
                        }
                    });
                    
                    // 复选框点击事件
                    const checkbox = historyItem.querySelector('.history-item-checkbox');
                    checkbox.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                    
                    listEl.appendChild(historyItem);
                });
            }
            
            modal.style.display = 'flex';
        }
        
        // 处理点击歌曲历史记录
        async function handleSongHistoryClick(songData) {
            const {songId, name, artist, platform, cover} = songData;
            
            // 检查歌曲是否还在播放列表中
            const songExists = musicState.playlist.some(s => s.songId === songId && s.platform === platform);
            
            if (songExists) {
                // 歌曲存在，跳转到播放列表并高亮
                showToast(`歌曲「${name}」在播放列表中`);
                document.getElementById('search-history-modal').style.display = 'none';
                document.getElementById('music-playlist-panel').classList.add('visible');
                
                // 高亮对应歌曲（延迟以确保UI已更新）
                setTimeout(() => {
                    const playlistItems = document.querySelectorAll('.playlist-item');
                    const songIndex = musicState.playlist.findIndex(s => s.songId === songId && s.platform === platform);
                    if (songIndex !== -1 && playlistItems[songIndex]) {
                        playlistItems[songIndex].style.backgroundColor = '#fff3cd';
                        setTimeout(() => {
                            playlistItems[songIndex].style.backgroundColor = '';
                        }, 2000);
                        playlistItems[songIndex].scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
            } else {
                // 歌曲不存在，询问是否重新添加
                const confirmed = confirm(`歌曲「${name} - ${artist}」未在播放列表中。\n\n是否重新搜索并添加？`);
                
                if (confirmed && songId && platform) {
                    try {
                        showToast('正在重新获取歌曲...');
                        
                        const [playUrl, lyrics] = await Promise.all([
                            getMusicUrl(songId, platform),
                            getLyrics(songId, platform)
                        ]);
                        
                        if (!playUrl) {
                            showToast('无法获取歌曲播放链接，请手动搜索');
                            return;
                        }
                        
                        const track = {
                            id: Date.now().toString(),
                            songId: songId,
                            name: name,
                            artist: artist,
                            src: playUrl,
                            cover: cover || 'https://i.postimg.cc/pT2xKzP/album-cover-placeholder.png',
                            lyrics: lyrics || '',
                            platform: platform
                        };
                        
                        musicState.playlist.push(track);
                        db.musicPlaylist = musicState.playlist;
                        await saveData();
                        updatePlaylistUI();
                        
                        // 更新历史记录中的状态
                        showSearchHistory();
                        
                        showToast(`✓ 已重新添加「${name}」`);
                        
                        // 关闭历史弹窗，显示播放列表
                        document.getElementById('search-history-modal').style.display = 'none';
                        document.getElementById('music-playlist-panel').classList.add('visible');
                    } catch (error) {
                        console.error('重新添加歌曲失败:', error);
                        showToast('重新添加失败，请手动搜索');
                    }
                }
            }
        }
        
        // 初始化搜索历史
        loadSearchHistory();
        
        // ============= 清理无效歌曲功能 =============
        let invalidSongs = []; // 存储检测到的无效歌曲
        
        // 检查单个歌曲是否有效
        async function checkSongValidity(song, index) {
            return new Promise((resolve) => {
                const audio = new Audio();
                const timeout = setTimeout(() => {
                    audio.src = '';
                    resolve({ valid: false, song, index, reason: '加载超时' });
                }, 5000); // 5秒超时
                
                audio.addEventListener('canplaythrough', () => {
                    clearTimeout(timeout);
                    audio.src = '';
                    resolve({ valid: true, song, index });
                }, { once: true });
                
                audio.addEventListener('error', () => {
                    clearTimeout(timeout);
                    audio.src = '';
                    resolve({ valid: false, song, index, reason: '加载失败' });
                }, { once: true });
                
                audio.src = song.src;
                audio.load();
            });
        }
        
        // 清理无效歌曲
        async function cleanInvalidSongs() {
            if (musicState.playlist.length === 0) {
                showToast('播放列表是空的');
                return;
            }
            
            const totalSongs = musicState.playlist.length;
            const cleanBtn = document.getElementById('clean-invalid-songs-btn');
            const originalText = cleanBtn.textContent;
            cleanBtn.textContent = '检查中...';
            cleanBtn.style.pointerEvents = 'none';
            
            showToast(`正在检查 ${totalSongs} 首歌曲...`, 3000);
            invalidSongs = [];
            
            try {
                // 检查所有歌曲
                const results = await Promise.all(
                    musicState.playlist.map((song, index) => checkSongValidity(song, index))
                );
                
                // 收集无效歌曲
                const invalidResults = results.filter(r => !r.valid);
                
                if (invalidResults.length === 0) {
                    showToast('所有歌曲都正常！');
                    cleanBtn.textContent = originalText;
                    cleanBtn.style.pointerEvents = 'auto';
                    return;
                }
                
                // 从后往前删除无效歌曲（避免索引错乱）
                invalidResults.sort((a, b) => b.index - a.index);
                invalidSongs = invalidResults.map(r => ({
                    ...r.song,
                    reason: r.reason
                }));
                
                // 删除无效歌曲
                invalidResults.forEach(r => {
                    musicState.playlist.splice(r.index, 1);
                });
                
                // 同步到数据库
                db.musicPlaylist = musicState.playlist;
                
                // 如果当前播放的歌曲被删除，调整播放状态
                if (musicState.currentIndex >= musicState.playlist.length) {
                    musicState.currentIndex = Math.max(0, musicState.playlist.length - 1);
                    if (musicState.playlist.length > 0) {
                        playSong(musicState.currentIndex);
                    } else {
                        const audioPlayer = document.getElementById('audio-player');
                        audioPlayer.pause();
                        musicState.isPlaying = false;
                        updatePlayerUI();
                    }
                }
                
                updatePlaylistUI();
                await saveData();
                
                // 显示清理结果
                showCleanResult();
                
            } catch (error) {
                console.error('清理失败:', error);
                showToast('清理过程出错，请重试');
            } finally {
                cleanBtn.textContent = originalText;
                cleanBtn.style.pointerEvents = 'auto';
            }
        }
        
        // 显示清理结果弹窗
        function showCleanResult() {
            const modal = document.getElementById('clean-result-modal');
            const summary = document.getElementById('clean-result-summary');
            const listEl = document.getElementById('invalid-songs-list');
            
            summary.innerHTML = `<strong style="color: #f44336;">已清理 ${invalidSongs.length} 首无效歌曲</strong><br><span style="font-size: 12px; color: #666;">您可以选择要重新搜索的歌曲</span>`;
            
            listEl.innerHTML = '';
            invalidSongs.forEach((song, index) => {
                const item = document.createElement('div');
                item.className = 'invalid-song-item';
                item.innerHTML = `
                    <input type="checkbox" class="invalid-song-checkbox" data-index="${index}">
                    <div class="invalid-song-info">
                        <div class="invalid-song-name">${song.name}</div>
                        <div class="invalid-song-artist">${song.artist || '未知艺术家'}</div>
                    </div>
                    <span class="invalid-song-reason">${song.reason}</span>
                `;
                listEl.appendChild(item);
            });
            
            modal.style.display = 'flex';
        }
        
        // 重新搜索选中的歌曲
        async function researchSelectedSongs() {
            const checkboxes = document.querySelectorAll('.invalid-song-checkbox:checked');
            
            if (checkboxes.length === 0) {
                showToast('请至少选择一首歌曲');
                return;
            }
            
            const modal = document.getElementById('clean-result-modal');
            const researchBtn = document.getElementById('research-selected-songs');
            const originalText = researchBtn.textContent;
            
            modal.style.display = 'none';
            
            let successCount = 0;
            let failCount = 0;
            const totalCount = checkboxes.length;
            
            for (let i = 0; i < checkboxes.length; i++) {
                const checkbox = checkboxes[i];
                const index = parseInt(checkbox.dataset.index);
                const song = invalidSongs[index];
                const keyword = `${song.name} ${song.artist || ''}`.trim();
                
                // 显示进度
                showToast(`正在搜索 ${i + 1}/${totalCount}: ${song.name}`, 2000);
                
                try {
                    // 搜索歌曲
                    const url = `https://api.vkeys.cn/API/wy/index.php?msg=${encodeURIComponent(keyword)}&n=5`;
                    const data = await httpGet(url);
                    
                    if (data && data.code === 200 && data.data && data.data.length > 0) {
                        // 取第一个结果
                        const result = data.data[0];
                        const newSong = {
                            name: result.name,
                            artist: result.author,
                            src: result.url,
                            cover: result.pic || 'https://s3plus.meituan.net/opapisdk/op_ticket_885190757_1757748720126_qdqqd_1jt5sv.jpeg',
                            source: 'netease'
                        };
                        
                        // 验证新歌曲是否有效
                        const validation = await checkSongValidity(newSong, 0);
                        if (validation.valid) {
                            musicState.playlist.push(newSong);
                            successCount++;
                            
                            // 立即更新播放列表UI
                            updatePlaylistUI();
                        } else {
                            failCount++;
                        }
                    } else {
                        failCount++;
                    }
                } catch (error) {
                    console.error('搜索失败:', error);
                    failCount++;
                }
                
                // 添加延迟避免请求过快
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            // 同步到数据库
            db.musicPlaylist = musicState.playlist;
            await saveData();
            
            // 显示最终结果
            let resultMessage = '';
            if (successCount > 0 && failCount === 0) {
                resultMessage = `成功添加 ${successCount} 首歌曲！`;
            } else if (successCount > 0 && failCount > 0) {
                resultMessage = `成功添加 ${successCount} 首，失败 ${failCount} 首`;
            } else {
                resultMessage = '所有歌曲搜索失败，请手动搜索添加';
            }
            
            showToast(resultMessage, 3000);
        }
        
        // 简单的HTTP GET请求函数
        async function httpGet(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error('请求失败:', url, error);
                return null;
            }
        }
        
        // 新版Meting API搜索
        async function searchMetingMusic(keyword, platform) {
            try {
                const apis = [
                    'https://api.i-meto.com/meting/api',
                    'https://meting.qjqq.cn/api.php'
                ];
                
                const apiUrl = apis[0]; // 默认使用第一个
                const searchTerm = keyword.replace(/\s/g, '');
                const url = `${apiUrl}?server=${platform}&type=search&id=${encodeURIComponent(searchTerm)}`;
                
                console.log(`🎵 搜索${platform}:`, url);
                const result = await httpGet(url);
                
                if (!result || !Array.isArray(result) || result.length === 0) {
                    console.log(`${platform} Meting API返回无结果`);
                    return [];
                }
                
                const platformNames = {
                    'netease': '网易云音乐',
                    'tencent': 'QQ音乐',
                    'kugou': '酷狗音乐',
                    'kuwo': '酷我音乐'
                };
                
                // 调试：打印第一条结果看看数据结构
                if (result.length > 0) {
                    console.log(`${platform} 第一条结果:`, result[0]);
                }
                
                return result.map(song => {
                    // Meting API返回的是URL链接，需要从URL中提取ID
                    let songId = null;
                    
                    // 从url字段中提取ID
                    if (song.url && typeof song.url === 'string') {
                        const urlMatch = song.url.match(/[?&]id=([^&]+)/);
                        if (urlMatch) {
                            songId = urlMatch[1];
                        }
                    }
                    
                    // 如果没有从URL提取到，尝试其他字段
                    if (!songId) {
                        songId = song.id || song.url_id || song.song_id || song.hash || song.rid;
                    }
                    
                    return {
                        name: song.name || song.title || song.songname || '未知歌曲',
                        artist: song.artist || song.author || song.singer || '未知歌手',
                        platform: platform,
                        platformName: platformNames[platform] || platform,
                        id: songId,
                        cover: song.pic || song.cover || song.album_pic,
                        // Meting API直接返回完整的URL链接
                        directUrl: song.url || null,
                        directPic: song.pic || null,
                        directLrc: song.lrc || null,
                        rawData: song
                    };
                });
            } catch (error) {
                console.error(`${platform}搜索失败:`, error);
                return [];
            }
        }
        
        // 旧版API搜索 - 网易云音乐
        async function searchNeteaseMusic(keyword) {
            try {
                const searchTerm = keyword.replace(/\s/g, '');
                const apiUrl = `https://api.vkeys.cn/v2/music/netease?word=${encodeURIComponent(searchTerm)}`;
                
                console.log('🎵 搜索网易云:', apiUrl);
                const result = await httpGet(apiUrl);
                
                if (!result || result.code !== 200 || !result.data || result.data.length === 0) {
                    console.log('网易云API返回无结果');
                    return [];
                }
                
                return result.data.map(song => ({
                    name: song.name || song.song || '未知歌曲',
                    artist: song.ar?.[0]?.name || song.artist || '未知歌手',
                    platform: 'netease',
                    platformName: '网易云音乐',
                    id: song.id,
                    cover: song.al?.picUrl || song.cover,
                    url: null
                }));
            } catch (error) {
                console.error('网易云搜索失败:', error);
                return [];
            }
        }
        
        // 旧版API搜索 - QQ音乐
        async function searchQQMusic(keyword) {
            try {
                const searchTerm = keyword.replace(/\s/g, '');
                const apiUrl = `https://api.vkeys.cn/v2/music/tencent?word=${encodeURIComponent(searchTerm)}`;
                
                console.log('🎵 搜索QQ音乐:', apiUrl);
                const result = await httpGet(apiUrl);
                
                if (!result || result.code !== 200 || !result.data || result.data.length === 0) {
                    console.log('QQ音乐API返回无结果');
                    return [];
                }
                
                return result.data.map(song => ({
                    name: song.song || song.name || '未知歌曲',
                    artist: song.singer || song.artist || '未知歌手',
                    platform: 'qq',
                    platformName: 'QQ音乐',
                    id: song.id,
                    cover: song.cover,
                    url: null
                }));
            } catch (error) {
                console.error('QQ音乐搜索失败:', error);
                return [];
            }
        }
        
        
        // 获取歌曲播放URL和歌词
        async function getMusicUrl(songId, platform, directUrl) {
            try {
                const apiType = selectedApiType;
                
                if (apiType === 'new') {
                    // 新版Meting API - directUrl就是最终的播放地址
                    if (directUrl) {
                        console.log('使用Meting API返回的播放URL:', directUrl);
                        return directUrl;
                    }
                    return null;
                } else {
                    // 旧版API
                    const platformMap = {
                        'netease': 'netease',
                        'qq': 'tencent',
                        'tencent': 'tencent'
                    };
                    
                    const platformKey = platformMap[platform] || platform;
                    const apiUrl = `https://api.vkeys.cn/v2/music/${platformKey}?id=${songId}`;
                    
                    const result = await httpGet(apiUrl);
                    if (result && result.code === 200 && result.data && result.data.url) {
                        return result.data.url;
                    }
                    return null;
                }
            } catch (error) {
                console.error('获取播放URL失败:', error);
                return null;
            }
        }
        
        // 获取歌词
        async function getLyrics(songId, platform, directLrc) {
            try {
                const apiType = selectedApiType;
                
                if (apiType === 'new') {
                    // 新版Meting API - 直接请求获取LRC文本
                    if (directLrc) {
                        console.log('请求歌词URL:', directLrc);
                        const response = await fetch(directLrc);
                        const text = await response.text();
                        console.log('歌词内容:', text.substring(0, 200) + '...');
                        
                        // 返回的就是LRC文本，不需要解析JSON
                        return text;
                    }
                    return null;
                } else {
                    // 旧版API
                    const platformMap = {
                        'netease': 'netease',
                        'qq': 'tencent',
                        'tencent': 'tencent'
                    };
                    
                    const platformKey = platformMap[platform] || platform;
                    const apiUrl = `https://api.vkeys.cn/v2/music/${platformKey}/lyric?id=${songId}`;
                    
                    const result = await httpGet(apiUrl);
                    if (result && result.data) {
                        const lrc = result.data.lrc || result.data.lyric || '';
                        const tlyric = result.data.trans || result.data.tlyric || '';
                        return lrc + (tlyric ? '\n' + tlyric : '');
                    }
                    return null;
                }
            } catch (error) {
                console.error('获取歌词失败:', error);
                return null;
            }
        }
        
        window.openMusicSearchModal = function() {
            const modal = document.getElementById('music-search-modal');
            modal.classList.add('show');
            setTimeout(() => {
                document.getElementById('music-search-keyword').focus();
            }, 100);
        }
        
        window.closeMusicSearchModal = function() {
            const modal = document.getElementById('music-search-modal');
            modal.classList.remove('show');
            setTimeout(() => {
                document.getElementById('music-search-results').innerHTML = '';
                document.getElementById('music-search-keyword').value = '';
            }, 400);
        }
        
        // 存储所有搜索结果
        let allSearchResults = [];
        
        // 存储选择的API类型
        let selectedApiType = 'old'; // 默认旧版
        
        window.searchMusic = async function() {
            const keyword = document.getElementById('music-search-keyword').value.trim();
            
            if (!keyword) {
                showSearchStatus('请输入搜索关键词');
                return;
            }
            
            // 显示API选择弹窗
            document.getElementById('api-selector-modal').style.display = 'flex';
        }
        
        // 执行实际搜索
        async function performSearch() {
            const keyword = document.getElementById('music-search-keyword').value.trim();
            
            showSearchStatus('<span class="search-loading"></span>正在搜索中...');
            
            let searchPromises = [];
            
            if (selectedApiType === 'new') {
                // 新版Meting API - 支持更多平台
                searchPromises = [
                    searchMetingMusic(keyword, 'netease'),
                    searchMetingMusic(keyword, 'tencent'),
                    searchMetingMusic(keyword, 'kugou'),
                    searchMetingMusic(keyword, 'kuwo')
                ];
            } else {
                // 旧版API - 只支持网易云和QQ音乐
                searchPromises = [
                    searchNeteaseMusic(keyword),
                    searchQQMusic(keyword)
                ];
            }
            
            const results = await Promise.all(searchPromises);
            allSearchResults = results.flat();
            
            if (allSearchResults.length === 0) {
                showSearchStatus('未找到相关音乐，请尝试其他关键词');
                return;
            }
            
            // 添加到搜索历史
            addSearchHistory(keyword);
            
            // 显示所有结果
            filterAndDisplayResults('all');
        }
        
        // 根据平台过滤并显示结果
        function filterAndDisplayResults(platform) {
            let filteredResults = allSearchResults;
            
            if (platform !== 'all') {
                // 平台映射：处理新旧API的平台名称差异
                const platformMap = {
                    'qq': 'tencent',
                    'tencent': 'qq'
                };
                
                filteredResults = allSearchResults.filter(song => {
                    return song.platform === platform || 
                           song.platform === platformMap[platform];
                });
            }
            
            if (filteredResults.length === 0) {
                showSearchStatus('该平台暂无搜索结果');
                document.getElementById('music-search-results').innerHTML = '';
                return;
            }
            
            displaySearchResults(filteredResults);
        }
        
        window.showSearchStatus = function(message) {
            document.getElementById('music-search-status').innerHTML = message;
        }
        
        window.displaySearchResults = function(results) {
            const container = document.getElementById('music-search-results');
            container.innerHTML = '';
            
            showSearchStatus(`找到 ${results.length} 首歌曲`);
            
            results.forEach((song) => {
                const item = document.createElement('div');
                item.className = 'search-result-item';
                
                // 使用directPic或cover
                const coverUrl = song.directPic || song.cover || 'https://i.postimg.cc/pT2xKzP/album-cover-placeholder.png';
                
                // 平台标签样式映射
                const platformClass = song.platform === 'tencent' ? 'qq' : song.platform;
                
                item.innerHTML = `
                    <img class="result-cover" src="${coverUrl}" alt="封面" onerror="this.src='https://i.postimg.cc/pT2xKzP/album-cover-placeholder.png'">
                    <div class="song-info">
                        <div class="song-title">${song.name}</div>
                        <div class="song-artist">
                            <span>${song.artist}</span>
                            <span class="platform-tag ${platformClass}">${song.platformName}</span>
                        </div>
                    </div>
                    <button class="add-song-btn" data-song='${JSON.stringify(song).replace(/'/g, "&apos;")}'>添加</button>
                `;
                container.appendChild(item);
            });
            
            // 添加点击事件
            container.querySelectorAll('.add-song-btn').forEach(btn => {
                btn.addEventListener('click', async function() {
                    const song = JSON.parse(this.dataset.song.replace(/&apos;/g, "'"));
                    this.textContent = '获取中...';
                    this.disabled = true;
                    await addSearchedMusic(song);
                });
            });
        }
        
        window.addSearchedMusic = async function(song) {
            try {
                // 获取真实播放URL
                showToast('正在获取播放链接和歌词...');
                
                console.log('添加歌曲 - 完整song对象:', song);
                
                const [playUrl, lyrics] = await Promise.all([
                    getMusicUrl(song.id, song.platform, song.directUrl),
                    getLyrics(song.id, song.platform, song.directLrc)
                ]);
                
                if (!playUrl) {
                    showToast('无法获取该歌曲的播放链接');
                    return;
                }
                
                const track = {
                    id: Date.now().toString(),
                    songId: song.id,
                    name: song.name || '未知歌曲',
                    artist: song.artist || '未知歌手',
                    src: playUrl,
                    cover: song.cover || 'https://i.postimg.cc/pT2xKzP/album-cover-placeholder.png',
                    lyrics: lyrics || '',
                    platform: song.platform
                };
                
                // 调试日志：确认 song 对象的完整数据
                console.log('🎵 添加歌曲 - 原始数据:', song);
                console.log('🎵 添加歌曲 - 处理后:', track);
                
                musicState.playlist.push(track);
                
                // 同步到数据库
                db.musicPlaylist = musicState.playlist;
                await saveData();
                
                updatePlaylistUI();
                
                if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
                    musicState.currentIndex = 0;
                    updatePlayerUI();
                    if (lyrics) {
                        loadLyrics(lyrics);
                    }
                }
                
                // 记录到搜索历史
                addSongToHistory({
                    id: track.id,
                    songId: song.id,
                    name: song.name,
                    artist: song.artist,
                    cover: song.cover,
                    platform: song.platform
                });
                
                showToast(`已添加: ${song.name}${lyrics ? ' (含歌词)' : ''}`);
                closeMusicSearchModal();
            } catch (error) {
                console.error('添加歌曲失败:', error);
                showToast('添加失败，请重试');
            }
        }
        
        // 加载并解析歌词
        function loadLyrics(lrcContent) {
            if (!lrcContent || !lrcContent.trim()) {
                musicState.parsedLyrics = [];
                renderLyrics();
                return;
            }
            musicState.parsedLyrics = parseLRC(lrcContent);
            renderLyrics();
        }
        
        // ============= 音乐搜索功能结束 =============
        
        async function deleteTrack(index) {
            if (index < 0 || index >= musicState.playlist.length) return;
            const track = musicState.playlist[index];
            const wasPlaying = musicState.isPlaying && musicState.currentIndex === index;
            
            if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) {
                URL.revokeObjectURL(audioPlayer.src);
            }
            
            musicState.playlist.splice(index, 1);
            db.musicPlaylist = musicState.playlist;
            await saveData();
            
            if (musicState.playlist.length === 0) {
                if (musicState.isPlaying) audioPlayer.pause();
                audioPlayer.src = '';
                musicState.currentIndex = -1;
                musicState.isPlaying = false;
            } else {
                if (wasPlaying) {
                    playNext();
                } else {
                    if (musicState.currentIndex >= index) {
                        musicState.currentIndex = Math.max(0, musicState.currentIndex - 1);
                    }
                }
            }
            
            updatePlayerUI();
            updatePlaylistUI();
        }
        
        function parseLRC(lrcContent) {
            if (!lrcContent) return [];
            const lines = lrcContent.split('\n');
            const lyrics = [];
            const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;
            
            for (const line of lines) {
                const text = line.replace(timeRegex, '').trim();
                if (!text) continue;
                timeRegex.lastIndex = 0;
                let match;
                while ((match = timeRegex.exec(line)) !== null) {
                    const minutes = parseInt(match[1], 10);
                    const seconds = parseInt(match[2], 10);
                    const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
                    const time = minutes * 60 + seconds + milliseconds / 1000;
                    lyrics.push({ time, text });
                }
            }
            return lyrics.sort((a, b) => a.time - b.time);
        }
        
        function renderLyrics() {
            const lyricsList = document.getElementById('music-lyrics-list');
            lyricsList.innerHTML = '';
            
            if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
                lyricsList.innerHTML = '<div class="lyric-line">♪ 暂无歌词 ♪</div>';
                return;
            }
            
            musicState.parsedLyrics.forEach((line, index) => {
                const lineEl = document.createElement('div');
                lineEl.className = 'lyric-line';
                lineEl.textContent = line.text;
                lineEl.dataset.index = index;
                lyricsList.appendChild(lineEl);
            });
            lyricsList.style.transform = `translateY(0px)`;
        }
        
        function updateActiveLyric(currentTime) {
            if (musicState.parsedLyrics.length === 0) return;
            let newLyricIndex = -1;
            
            for (let i = 0; i < musicState.parsedLyrics.length; i++) {
                if (currentTime >= musicState.parsedLyrics[i].time) {
                    newLyricIndex = i;
                } else {
                    break;
                }
            }
            
            if (newLyricIndex === musicState.currentLyricIndex) return;
            musicState.currentLyricIndex = newLyricIndex;
            updateLyricsUI();
        }
        
        function updateLyricsUI() {
            const lyricsList = document.getElementById('music-lyrics-list');
            const container = document.getElementById('music-lyrics-container');
            const lines = lyricsList.querySelectorAll('.lyric-line');
            
            lines.forEach(line => line.classList.remove('active'));
            
            if (musicState.currentLyricIndex === -1) {
                lyricsList.style.transform = `translateY(0px)`;
                updateFloatingLyrics();
                return;
            }
            
            const activeLine = lyricsList.querySelector(`.lyric-line[data-index="${musicState.currentLyricIndex}"]`);
            if (activeLine) {
                activeLine.classList.add('active');
                const containerHeight = container.offsetHeight;
                const offset = (containerHeight / 3) - activeLine.offsetTop - (activeLine.offsetHeight / 2);
                lyricsList.style.transform = `translateY(${offset}px)`;
            }
            
            // 更新悬浮歌词
            updateFloatingLyrics();
        }
        
        // 更新悬浮歌词显示
        function updateFloatingLyrics() {
            const floatingContainer = document.getElementById('floating-lyrics-container');
            const floatingContent = document.getElementById('floating-lyrics-content');
            
            // 如果没有歌词或者一起听会话未激活，显示暂无歌词
            if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0 || !musicState.isActive) {
                floatingContent.innerHTML = '<div class="floating-lyric-line">♪ 暂无歌词 ♪</div>';
                return;
            }
            
            const currentIndex = musicState.currentLyricIndex;
            if (currentIndex === -1) {
                floatingContent.innerHTML = '<div class="floating-lyric-line">♪ 暂无歌词 ♪</div>';
                return;
            }
            
            // 获取设置
            const settings = db.floatingLyricsSettings || {
                linesCount: 3,
                activeFontSize: 18,
                otherFontSize: 13,
                activeColor: '#ff80ab',
                previousColor: '#787878',
                upcomingColor: '#787878'
            };
            
            const linesCount = settings.linesCount || 3;
            const lyricsToShow = [];
            
            // 根据设置的句数计算要显示的歌词
            // 当前句始终显示
            lyricsToShow.push({
                text: musicState.parsedLyrics[currentIndex].text,
                type: 'active'
            });
            
            // 计算前后各显示多少句
            const remainingLines = linesCount - 1;
            const beforeLines = Math.floor(remainingLines / 2);
            const afterLines = remainingLines - beforeLines;
            
            // 添加前面的歌词
            for (let i = beforeLines; i > 0; i--) {
                if (currentIndex - i >= 0) {
                    lyricsToShow.unshift({
                        text: musicState.parsedLyrics[currentIndex - i].text,
                        type: 'previous'
                    });
                }
            }
            
            // 添加后面的歌词
            for (let i = 1; i <= afterLines; i++) {
                if (currentIndex + i < musicState.parsedLyrics.length) {
                    lyricsToShow.push({
                        text: musicState.parsedLyrics[currentIndex + i].text,
                        type: 'upcoming'
                    });
                }
            }
            
            // 渲染悬浮歌词
            floatingContent.innerHTML = lyricsToShow.map(lyric => {
                const className = lyric.type === 'active' ? 'floating-lyric-line active' : 
                                 lyric.type === 'upcoming' ? 'floating-lyric-line upcoming' : 
                                 'floating-lyric-line previous';
                return `<div class="${className}">${lyric.text}</div>`;
            }).join('');
        }
        
        // 应用悬浮歌词样式
        function applyFloatingLyricsStyles() {
            const settings = db.floatingLyricsSettings || {
                activeFontSize: 18,
                otherFontSize: 13,
                activeColor: '#ff80ab',
                previousColor: '#787878',
                upcomingColor: '#787878',
                lineGap: 8
            };
            
            // 创建或更新样式标签
            let styleTag = document.getElementById('floating-lyrics-custom-styles');
            if (!styleTag) {
                styleTag = document.createElement('style');
                styleTag.id = 'floating-lyrics-custom-styles';
                document.head.appendChild(styleTag);
            }
            
            styleTag.textContent = `
                .floating-lyrics-content {
                    gap: ${settings.lineGap}px !important;
                }
                
                .floating-lyric-line.active {
                    font-size: ${settings.activeFontSize}px !important;
                    color: ${settings.activeColor} !important;
                    text-shadow: 0 2px 8px ${settings.activeColor}66 !important;
                }
                
                .floating-lyric-line.previous {
                    font-size: ${settings.otherFontSize}px !important;
                    color: ${settings.previousColor} !important;
                }
                
                .floating-lyric-line.upcoming {
                    font-size: ${settings.otherFontSize}px !important;
                    color: ${settings.upcomingColor} !important;
                }
            `;
        }
        
        function formatMusicTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return "0:00";
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${String(remainingSeconds).padStart(2, '0')}`;
        }
        
        function updateMusicProgressBar() {
            const currentTimeEl = document.getElementById('music-current-time');
            const totalTimeEl = document.getElementById('music-total-time');
            const progressFillEl = document.getElementById('music-progress-fill');
            
            // 更严格的duration检查
            if (!audioPlayer.duration || isNaN(audioPlayer.duration) || !isFinite(audioPlayer.duration)) {
                currentTimeEl.textContent = "0:00";
                totalTimeEl.textContent = "0:00";
                progressFillEl.style.width = '0%';
                return;
            }
            
            // 确保currentTime有效
            const currentTime = audioPlayer.currentTime || 0;
            const duration = audioPlayer.duration;
            
            // 防止进度超过100%
            const progressPercent = Math.min(100, (currentTime / duration) * 100);
            progressFillEl.style.width = `${progressPercent}%`;
            currentTimeEl.textContent = formatMusicTime(currentTime);
            totalTimeEl.textContent = formatMusicTime(duration);
            updateActiveLyric(currentTime);
        }
        
        // === 音乐播放器函数结束 ===

        // 渲染已挂载的聊天列表（全局函数）
        function renderMountedChatsList() {
            const character = db.characters.find(c => c.id === currentChatId);
            const mountedChatsList = document.getElementById('mounted-chats-list');
            
            if (!character || !character.mountedChats || !mountedChatsList) {
                if (mountedChatsList) mountedChatsList.innerHTML = '';
                return;
            }
            
            mountedChatsList.innerHTML = '';
            character.mountedChats.forEach((mounted, index) => {
                const chatName = mounted.type === 'private' 
                    ? (db.characters.find(c => c.id === mounted.chatId)?.remarkName || '未知聊天')
                    : (db.groups.find(g => g.id === mounted.chatId)?.name || '未知群聊');
                
                const item = document.createElement('div');
                item.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 10px; background: #f5f5f5; border-radius: 8px; margin-bottom: 8px;';
                item.innerHTML = `
                    <span style="flex: 1; font-size: 14px;">${chatName} (${mounted.type === 'private' ? '私聊' : '群聊'})</span>
                    <input type="number" min="1" value="${mounted.messageCount || ''}" placeholder="条数" 
                           style="width: 60px; padding: 5px; border: 1px solid #ddd; border-radius: 4px; text-align: center;"
                           data-index="${index}">
                    <button style="padding: 5px 10px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;"
                            data-index="${index}">删除</button>
                `;
                
                // 条数输入框事件
                const countInput = item.querySelector('input[type="number"]');
                countInput.addEventListener('change', async () => {
                    character.mountedChats[index].messageCount = parseInt(countInput.value) || 0;
                    await saveData();
                });
                
                // 删除按钮事件
                const deleteBtn = item.querySelector('button');
                deleteBtn.addEventListener('click', async () => {
                    character.mountedChats.splice(index, 1);
                    await saveData();
                    renderMountedChatsList();
                    showToast('已移除挂载');
                });
                
                mountedChatsList.appendChild(item);
            });
        }

        // 渲染线下世界书列表（全局函数）
        function renderOfflineWorldbooksList() {
            const character = db.characters.find(c => c.id === currentChatId);
            const offlineWorldbooksList = document.getElementById('offline-worldbooks-list');
            
            if (!character || !character.offlineWorldbooks || !offlineWorldbooksList) {
                if (offlineWorldbooksList) offlineWorldbooksList.innerHTML = '';
                return;
            }
            
            offlineWorldbooksList.innerHTML = '';
            character.offlineWorldbooks.forEach((wbId, index) => {
                const worldBook = db.worldBooks.find(wb => wb.id === wbId);
                if (!worldBook) return;
                
                const item = document.createElement('div');
                item.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 10px; background: #f5f5f5; border-radius: 8px; margin-bottom: 8px;';
                item.innerHTML = `
                    <span style="flex: 1; font-size: 14px;">${worldBook.name}</span>
                    <button style="padding: 5px 10px; background: #ff4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;"
                            data-index="${index}">删除</button>
                `;
                
                // 删除按钮事件
                const deleteBtn = item.querySelector('button');
                deleteBtn.addEventListener('click', async () => {
                    character.offlineWorldbooks.splice(index, 1);
                    await saveData();
                    renderOfflineWorldbooksList();
                    showToast('已移除世界书');
                });
                
                offlineWorldbooksList.appendChild(item);
            });
        }

        // 渲染记忆快照列表（全局函数）
        async function renderMemorySnapshots() {
            const memorySnapshotsList = document.getElementById('memory-snapshots-list');
            
            if (!currentChatId || !memorySnapshotsList) {
                if (memorySnapshotsList) memorySnapshotsList.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">暂无保存的记忆</p>';
                return;
            }
            
            try {
                const snapshots = await dataStorage.db.memorySnapshots
                    .where('chatId').equals(currentChatId)
                    .and(item => item.chatType === currentChatType)
                    .reverse()
                    .sortBy('timestamp');
                
                if (snapshots.length === 0) {
                    memorySnapshotsList.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">暂无保存的记忆</p>';
                    return;
                }
                
                memorySnapshotsList.innerHTML = '';
                snapshots.forEach(snapshot => {
                    const item = document.createElement('div');
                    item.style.cssText = 'background: white; border: 1px solid #e0e0e0; border-radius: 8px; padding: 12px; margin-bottom: 10px; cursor: pointer; transition: all 0.2s;';
                    item.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; font-size: 14px; color: #333; margin-bottom: 4px;">${snapshot.name}</div>
                                <div style="font-size: 12px; color: #999;">${new Date(snapshot.timestamp).toLocaleString('zh-CN')}</div>
                            </div>
                            <div style="display: flex; gap: 6px;">
                                <button class="restore-snapshot-btn" data-id="${snapshot.id}" 
                                        style="padding: 6px 10px; background: var(--primary-color); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                                    恢复
                                </button>
                                <button class="rename-snapshot-btn" data-id="${snapshot.id}" data-name="${snapshot.name}"
                                        style="padding: 6px 10px; background: var(--accent-color); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                                    重命名
                                </button>
                                <button class="delete-snapshot-btn" data-id="${snapshot.id}"
                                        style="padding: 6px 10px; background: #ff4444; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                                    删除
                                </button>
                            </div>
                        </div>
                    `;
                    
                    // 恢复按钮事件
                    const restoreBtn = item.querySelector('.restore-snapshot-btn');
                    restoreBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const restoreMemorySnapshotModal = document.getElementById('restore-memory-snapshot-modal');
                        const restoreSnapshotInfo = document.getElementById('restore-snapshot-info');
                        window.currentRestoreSnapshotId = snapshot.id;
                        restoreSnapshotInfo.innerHTML = `
                            <div><strong>快照名称：</strong>${snapshot.name}</div>
                            <div><strong>保存时间：</strong>${new Date(snapshot.timestamp).toLocaleString('zh-CN')}</div>
                        `;
                        restoreMemorySnapshotModal.classList.add('visible');
                    });
                    
                    // 重命名按钮事件
                    const renameBtn = item.querySelector('.rename-snapshot-btn');
                    renameBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const renameMemorySnapshotModal = document.getElementById('rename-memory-snapshot-modal');
                        const renameSnapshotNameInput = document.getElementById('rename-snapshot-name');
                        window.currentRenameSnapshotId = snapshot.id;
                        renameSnapshotNameInput.value = snapshot.name;
                        renameMemorySnapshotModal.classList.add('visible');
                    });
                    
                    // 删除按钮事件
                    const deleteBtn = item.querySelector('.delete-snapshot-btn');
                    deleteBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        if (confirm(`确定要删除记忆快照"${snapshot.name}"吗？`)) {
                            await dataStorage.db.memorySnapshots.delete(snapshot.id);
                            showToast('已删除记忆快照');
                            renderMemorySnapshots();
                        }
                    });
                    
                    memorySnapshotsList.appendChild(item);
                });
            } catch (error) {
                console.error('渲染记忆快照列表失败:', error);
                memorySnapshotsList.innerHTML = '<p style="text-align: center; color: #f44; padding: 20px;">加载失败</p>';
            }
        }

        // ===== 识别USER头像功能 - 全局函数 =====
        // 识别USER头像的函数
        async function recognizeUserAvatar(character, avatarUrl) {
            if (!avatarUrl || !character.recognizeUserAvatarEnabled) return null;
            
            try {
                showToast('正在识别USER头像...');
                
                // 构建识别请求
                const apiSettings = db.apiSettings;
                const provider = apiSettings.provider || 'openai';
                const apiUrl = apiSettings.url || 'https://api.openai.com';
                const apiKey = apiSettings.key || '';
                const model = apiSettings.model || 'gpt-4o';
                
                if (!apiKey) {
                    showToast('请先配置API设置');
                    return null;
                }
                
                const recognitionPrompt = '请详细描述这张头像图片的内容，包括：如果是人物，描述其外貌、发型、发色、眼睛颜色、服装、配饰、表情、姿势等；如果是动物、物品或其他内容，请如实描述。请用简洁的语言描述，不要有多余的客套话。';
                
                let response;
                if (provider === 'gemini') {
                    const match = avatarUrl.match(/^data:(image\/(.+));base64,(.*)$/);
                    if (!match) {
                        showToast('头像格式不正确');
                        return null;
                    }
                    
                    const requestBody = {
                        contents: [{
                            role: 'user',
                            parts: [
                                { text: recognitionPrompt },
                                { inline_data: { mime_type: match[1], data: match[3] } }
                            ]
                        }]
                    };
                    
                    response = await fetch(`${apiUrl}/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody)
                    });
                } else {
                    const requestBody = {
                        model: model,
                        messages: [{
                            role: 'user',
                            content: [
                                { type: 'text', text: recognitionPrompt },
                                { type: 'image_url', image_url: { url: avatarUrl } }
                            ]
                        }]
                    };
                    
                    response = await fetch(`${apiUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify(requestBody)
                    });
                }
                
                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }
                
                const data = await response.json();
                let description = '';
                
                if (provider === 'gemini') {
                    description = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                } else {
                    description = data.choices?.[0]?.message?.content || '';
                }
                
                if (description) {
                    character.userAvatarDescription = description;
                    character.userAvatarUrl = avatarUrl;
                    character.userAvatarRecognizedAt = Date.now();
                    await saveData();
                    showToast('USER头像识别成功');
                    updateAvatarRecognitionStatus(character);
                    return description;
                } else {
                    showToast('头像识别失败：无法获取描述');
                    return null;
                }
            } catch (error) {
                console.error('头像识别失败:', error);
                showToast('头像识别失败：' + error.message);
                return null;
            }
        }
        
        // 更新头像识别状态显示
        function updateAvatarRecognitionStatus(character) {
            if (!character) return;
            
            const avatarRecognitionStatus = document.getElementById('avatar-recognition-status');
            if (!avatarRecognitionStatus) return;
            
            if (character.userAvatarDescription) {
                const date = new Date(character.userAvatarRecognizedAt || Date.now());
                avatarRecognitionStatus.innerHTML = `
                    <div style="color: #4CAF50; font-weight: bold; margin-bottom: 5px;">✓ 已识别</div>
                    <div style="font-size: 11px; color: #999;">识别时间: ${date.toLocaleString()}</div>
                    <div style="font-size: 11px; color: #666; margin-top: 5px; max-height: 60px; overflow-y: auto;">${character.userAvatarDescription.substring(0, 100)}${character.userAvatarDescription.length > 100 ? '...' : ''}</div>
                `;
            } else {
                avatarRecognitionStatus.innerHTML = '<div style="color: #999;">未识别</div>';
            }
        }
        
        // 清除所有头像记忆
        async function clearAllAvatarMemory() {
            try {
                // 清除所有角色的头像识别记录
                let clearedCount = 0;
                db.characters.forEach(char => {
                    if (char.userAvatarDescription || char.userAvatarUrl || char.userAvatarRecognizedAt) {
                        delete char.userAvatarDescription;
                        delete char.userAvatarUrl;
                        delete char.userAvatarRecognizedAt;
                        clearedCount++;
                    }
                });
                
                await saveData();
                
                // 更新当前角色的显示状态
                const currentChar = db.characters.find(c => c.id === currentChatId);
                if (currentChar) {
                    updateAvatarRecognitionStatus(currentChar);
                }
                
                showToast(`已清除所有头像记忆（共${clearedCount}个角色）`);
                return true;
            } catch (error) {
                console.error('清除头像记忆失败:', error);
                showToast('清除失败：' + error.message);
                return false;
            }
        }

        function setupChatSettings() {
            const themeSelect = document.getElementById('setting-theme-color');
            themeSelect.innerHTML = '';
            Object.keys(colorThemes).forEach(key => {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = colorThemes[key].name;
                themeSelect.appendChild(option);
            });
            chatSettingsBtn.addEventListener('click', () => {
                if (currentChatType === 'private') {
                    loadSettingsToSidebar();
                    settingsSidebar.classList.add('open');
                } else if (currentChatType === 'group') {
                    loadGroupSettingsToSidebar();
                    groupSettingsSidebar.classList.add('open');
                }
            });
            document.querySelector('.phone-screen').addEventListener('click', e => {
                const openSidebar = document.querySelector('.settings-sidebar.open');
                if (openSidebar && !openSidebar.contains(e.target) && !chatSettingsBtn.contains(e.target) && !e.target.closest('.modal-overlay') && !e.target.closest('.action-sheet-overlay')) {
                    openSidebar.classList.remove('open');
                }
            });

            settingsForm.addEventListener('submit', e => {
                e.preventDefault();
                saveSettingsFromSidebar();
                settingsSidebar.classList.remove('open');
            });
            
            // 角色NPC库按钮事件
            let npcSelectMode = false;
            
            document.getElementById('manage-char-npc-library-btn')?.addEventListener('click', () => {
                renderNpcLibrary();
                document.getElementById('npc-library-modal').classList.add('visible');
            });
            
            // 关闭NPC库
            document.getElementById('close-npc-library-btn')?.addEventListener('click', () => {
                document.getElementById('npc-library-modal').classList.remove('visible');
                npcSelectMode = false;
                // 重置全选按钮状态
                const selectAllBtn = document.getElementById('select-all-npcs-btn');
                if (selectAllBtn) {
                    selectAllBtn.textContent = '全选';
                    selectAllBtn.classList.remove('btn-warning');
                    selectAllBtn.classList.add('btn-primary');
                }
            });
            
            // 切换选择模式
            document.getElementById('toggle-npc-select-mode-btn')?.addEventListener('click', () => {
                npcSelectMode = !npcSelectMode;
                const btn = document.getElementById('toggle-npc-select-mode-btn');
                const deleteBtn = document.getElementById('delete-selected-npcs-btn');
                const selectAllBtn = document.getElementById('select-all-npcs-btn');
                if (npcSelectMode) {
                    btn.textContent = '取消选择';
                    btn.classList.remove('btn-secondary');
                    btn.classList.add('btn-danger');
                    deleteBtn.style.display = 'block';
                    selectAllBtn.style.display = 'block';
                } else {
                    btn.textContent = '选择';
                    btn.classList.remove('btn-danger');
                    btn.classList.add('btn-secondary');
                    deleteBtn.style.display = 'none';
                    selectAllBtn.style.display = 'none';
                }
                renderNpcLibrary();
            });
            
            // 全选/取消全选NPC
            document.getElementById('select-all-npcs-btn')?.addEventListener('click', () => {
                const checkboxes = document.querySelectorAll('.npc-checkbox');
                const selectAllBtn = document.getElementById('select-all-npcs-btn');
                const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                
                if (allChecked) {
                    // 如果全部选中，则取消全选
                    checkboxes.forEach(cb => cb.checked = false);
                    selectAllBtn.textContent = '全选';
                    selectAllBtn.classList.remove('btn-warning');
                    selectAllBtn.classList.add('btn-primary');
                } else {
                    // 否则全选
                    checkboxes.forEach(cb => cb.checked = true);
                    selectAllBtn.textContent = '取消全选';
                    selectAllBtn.classList.remove('btn-primary');
                    selectAllBtn.classList.add('btn-warning');
                }
            });
            
            // 删除选中的NPC
            document.getElementById('delete-selected-npcs-btn')?.addEventListener('click', async () => {
                const checkboxes = document.querySelectorAll('.npc-checkbox:checked');
                if (checkboxes.length === 0) {
                    showToast('请先选择要删除的NPC');
                    return;
                }
                
                if (!confirm(`确定要删除选中的 ${checkboxes.length} 个NPC吗？`)) {
                    return;
                }
                
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                if (!character.npcLibrary) character.npcLibrary = [];
                
                checkboxes.forEach(checkbox => {
                    const npcId = checkbox.value;
                    character.npcLibrary = character.npcLibrary.filter(npc => npc.id !== npcId);
                });
                
                await saveData();
                renderNpcLibrary();
                showToast(`已删除 ${checkboxes.length} 个NPC`);
            });
            
            // 添加NPC按钮
            document.getElementById('add-new-npc-btn')?.addEventListener('click', async () => {
                const choice = await showChoiceModal('选择创建方式', [
                    { text: '手动创建NPC', value: 'manual' },
                    { text: 'AI生成NPC', value: 'ai-generate' },
                    { text: '转换CHAR为NPC', value: 'convert-char' }
                ]);
                
                if (choice === 'manual') {
                    document.getElementById('edit-npc-title').textContent = '添加NPC';
                    document.getElementById('edit-npc-id').value = '';
                    document.getElementById('npc-name').value = '';
                    document.getElementById('npc-description').value = '';
                    document.getElementById('npc-relation-to-char').value = '';
                    document.getElementById('npc-relation-to-user').value = '';
                    document.getElementById('npc-avatar-preview').src = 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg';
                    
                    // 重置全局NPC和选择角色开关
                    document.getElementById('npc-global-toggle').checked = false;
                    document.getElementById('npc-select-chars-toggle').checked = false;
                    document.getElementById('npc-chars-selection').style.display = 'none';
                    
                    // 显示两个开关的form-group（添加模式）
                    document.getElementById('npc-global-toggle-group').style.display = 'block';
                    document.getElementById('npc-select-chars-group').style.display = 'block';
                    
                    // 生成角色列表
                    renderNpcCharSelection();
                    
                    document.getElementById('edit-npc-modal').classList.add('visible');
                } else if (choice === 'ai-generate') {
                    document.getElementById('ai-generate-npc-modal').classList.add('visible');
                } else if (choice === 'convert-char') {
                    // 打开转换CHAR为NPC的弹窗
                    document.getElementById('convert-char-to-npc-modal').classList.add('visible');
                    renderConvertCharList();
                }
            });
            
            // NPC头像上传
            document.getElementById('npc-avatar-upload')?.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('npc-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('头像压缩失败，请重试');
                    }
                }
            });
            
            // 全局NPC开关
            document.getElementById('npc-global-toggle')?.addEventListener('change', (e) => {
                if (e.target.checked) {
                    // 取消选择角色互通NPC的勾选
                    document.getElementById('npc-select-chars-toggle').checked = false;
                    document.getElementById('npc-chars-selection').style.display = 'none';
                }
            });
            
            // 选择角色互通NPC开关
            document.getElementById('npc-select-chars-toggle')?.addEventListener('change', (e) => {
                const charsSelection = document.getElementById('npc-chars-selection');
                if (e.target.checked) {
                    charsSelection.style.display = 'block';
                    // 取消全局NPC的勾选
                    document.getElementById('npc-global-toggle').checked = false;
                } else {
                    charsSelection.style.display = 'none';
                }
            });
            
            // 生成角色选择列表
            function renderNpcCharSelection() {
                const container = document.getElementById('npc-chars-selection');
                if (!container) {
                    console.error('未找到npc-chars-selection容器');
                    return;
                }
                
                // 获取所有非群聊角色，排除当前角色
                const allCharacters = db.characters || [];
                const characters = allCharacters.filter(c => !c.isGroup && c.id !== currentChatId);
                
                console.log('所有角色:', allCharacters);
                console.log('筛选后的角色:', characters);
                console.log('当前角色ID:', currentChatId);
                
                if (characters.length === 0) {
                    container.innerHTML = '<div style="color: #999; text-align: center; padding: 10px;">没有其他角色</div>';
                    return;
                }
                
                let html = '<div style="display: flex; flex-direction: column; gap: 8px;">';
                characters.forEach(char => {
                    const charName = char.remarkName || char.realName || char.name || '未命名';
                    const charAvatar = char.avatar || 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg';
                    html += `
                        <label style="display: flex; align-items: center; padding: 8px; border-radius: 6px; cursor: pointer; transition: background-color 0.2s;" onmouseover="this.style.backgroundColor='#f0f0f0'" onmouseout="this.style.backgroundColor='transparent'">
                            <input type="checkbox" class="npc-char-checkbox" value="${char.id}" style="margin-right: 10px; width: 16px; height: 16px; cursor: pointer;">
                            <img src="${charAvatar}" style="width: 32px; height: 32px; border-radius: 50%; object-fit: cover; margin-right: 10px;">
                            <span style="font-size: 14px; font-weight: 500;">${charName}</span>
                        </label>
                    `;
                });
                html += '</div>';
                
                container.innerHTML = html;
            }
            
            // 取消编辑NPC
            document.getElementById('cancel-edit-npc-btn')?.addEventListener('click', () => {
                document.getElementById('edit-npc-modal').classList.remove('visible');
            });
            
            // 保存NPC
            document.getElementById('edit-npc-form')?.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                if (!character.npcLibrary) character.npcLibrary = [];
                
                const npcId = document.getElementById('edit-npc-id').value;
                const npcData = {
                    id: npcId || `npc_${Date.now()}`,
                    name: document.getElementById('npc-name').value,
                    description: document.getElementById('npc-description').value,
                    relationToChar: document.getElementById('npc-relation-to-char').value,
                    relationToUser: document.getElementById('npc-relation-to-user').value,
                    avatar: document.getElementById('npc-avatar-preview').src
                };
                
                // 检查全局NPC和选择角色开关
                const isGlobalNpc = document.getElementById('npc-global-toggle').checked;
                const isSelectChars = document.getElementById('npc-select-chars-toggle').checked;
                
                if (npcId) {
                    // 编辑现有NPC
                    const index = character.npcLibrary.findIndex(npc => npc.id === npcId);
                    if (index !== -1) {
                        character.npcLibrary[index] = npcData;
                    }
                    
                    // 编辑模式下也处理全局NPC或选择角色互通
                    if (isGlobalNpc && !isSelectChars) {
                        // 全局NPC：同步更新到所有角色
                        db.characters.forEach(char => {
                            if (!char.isGroup && char.id !== currentChatId) {
                                if (!char.npcLibrary) char.npcLibrary = [];
                                // 查找是否已存在相同ID的NPC
                                const existingIndex = char.npcLibrary.findIndex(npc => npc.id === npcData.id);
                                if (existingIndex !== -1) {
                                    // 更新现有NPC
                                    char.npcLibrary[existingIndex] = {...npcData};
                                } else {
                                    // 添加新NPC
                                    char.npcLibrary.push({...npcData});
                                }
                            }
                        });
                        showToast('NPC已同步到所有角色');
                    } else if (isSelectChars) {
                        // 选择角色互通：同步到选中的角色
                        const selectedCharIds = Array.from(document.querySelectorAll('.npc-char-checkbox:checked')).map(cb => cb.value);
                        if (selectedCharIds.length > 0) {
                            selectedCharIds.forEach(charId => {
                                const targetChar = db.characters.find(c => c.id === charId);
                                if (targetChar) {
                                    if (!targetChar.npcLibrary) targetChar.npcLibrary = [];
                                    const existingIndex = targetChar.npcLibrary.findIndex(npc => npc.id === npcData.id);
                                    if (existingIndex !== -1) {
                                        // 更新现有NPC
                                        targetChar.npcLibrary[existingIndex] = {...npcData};
                                    } else {
                                        // 添加新NPC
                                        targetChar.npcLibrary.push({...npcData});
                                    }
                                }
                            });
                            showToast(`NPC已同步到 ${selectedCharIds.length} 个角色`);
                        } else {
                            showToast('NPC已保存');
                        }
                    } else {
                        showToast('NPC已保存');
                    }
                } else {
                    // 添加新NPC
                    character.npcLibrary.push(npcData);
                    
                    // 处理全局NPC或选择角色互通
                    if (isGlobalNpc && !isSelectChars) {
                        // 全局NPC：添加到所有角色
                        db.characters.forEach(char => {
                            if (!char.isGroup && char.id !== currentChatId) {
                                if (!char.npcLibrary) char.npcLibrary = [];
                                // 检查是否已存在同名NPC
                                const exists = char.npcLibrary.some(npc => npc.id === npcData.id);
                                if (!exists) {
                                    char.npcLibrary.push({...npcData});
                                }
                            }
                        });
                        showToast('NPC已添加到所有角色');
                    } else if (isSelectChars) {
                        // 选择角色互通：添加到选中的角色
                        const selectedCharIds = Array.from(document.querySelectorAll('.npc-char-checkbox:checked')).map(cb => cb.value);
                        if (selectedCharIds.length > 0) {
                            selectedCharIds.forEach(charId => {
                                const targetChar = db.characters.find(c => c.id === charId);
                                if (targetChar) {
                                    if (!targetChar.npcLibrary) targetChar.npcLibrary = [];
                                    const exists = targetChar.npcLibrary.some(npc => npc.id === npcData.id);
                                    if (!exists) {
                                        targetChar.npcLibrary.push({...npcData});
                                    }
                                }
                            });
                            showToast(`NPC已添加到 ${selectedCharIds.length} 个角色`);
                        } else {
                            showToast('NPC已保存');
                        }
                    } else {
                        showToast('NPC已保存');
                    }
                }
                
                await saveData();
                renderNpcLibrary();
                document.getElementById('edit-npc-modal').classList.remove('visible');
            });
            
            // 渲染NPC库列表
            function renderNpcLibrary() {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                if (!character.npcLibrary) character.npcLibrary = [];
                
                const listEl = document.getElementById('npc-library-list');
                
                if (character.npcLibrary.length === 0) {
                    listEl.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">暂无NPC</div>';
                    return;
                }
                
                let html = '';
                character.npcLibrary.forEach(npc => {
                    html += `<div class="npc-item" data-npc-id="${npc.id}">`;
                    
                    if (npcSelectMode) {
                        html += `<input type="checkbox" class="npc-checkbox" value="${npc.id}" style="margin-right: 12px; width: 18px; height: 18px; cursor: pointer;">`;
                    }
                    
                    html += `<img src="${npc.avatar}" class="npc-avatar">`;
                    html += `<div style="flex: 1; min-width: 0;">`;
                    html += `<div style="font-weight: 600; font-size: 15px; margin-bottom: 4px; color: #333;">${npc.name}</div>`;
                    html += `<div style="font-size: 13px; color: #666; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${npc.description.substring(0, 50)}...</div>`;
                    if (npc.relationToChar || npc.relationToUser) {
                        html += `<div style="font-size: 12px; color: #999; margin-top: 4px;">`;
                        if (npc.relationToChar) html += `与角色：${npc.relationToChar} `;
                        if (npc.relationToUser) html += `与用户：${npc.relationToUser}`;
                        html += `</div>`;
                    }
                    html += `</div>`;
                    
                    // 添加聊天按钮
                    if (!npcSelectMode) {
                        html += `<button class="npc-chat-btn" data-npc-id="${npc.id}" style="margin-left: 10px; padding: 8px 16px; background-color: var(--primary-color); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 500; flex-shrink: 0;">💬 聊天</button>`;
                    }
                    
                    html += `</div>`;
                });
                
                listEl.innerHTML = html;
                
                // 绑定点击事件
                document.querySelectorAll('.npc-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        // 如果点击的是聊天按钮，打开聊天弹窗
                        if (e.target.classList.contains('npc-chat-btn') || e.target.closest('.npc-chat-btn')) {
                            e.stopPropagation();
                            const npcId = e.target.dataset.npcId || e.target.closest('.npc-chat-btn').dataset.npcId;
                            openNpcChat(npcId);
                            return;
                        }
                        
                        if (npcSelectMode) {
                            const checkbox = item.querySelector('.npc-checkbox');
                            if (e.target !== checkbox) {
                                checkbox.checked = !checkbox.checked;
                            }
                        } else {
                            const npcId = item.dataset.npcId;
                            editNpc(npcId);
                        }
                    });
                });
            }
            
            // 编辑NPC
            function editNpc(npcId) {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character || !character.npcLibrary) return;
                
                const npc = character.npcLibrary.find(n => n.id === npcId);
                if (!npc) return;
                
                document.getElementById('edit-npc-title').textContent = '编辑NPC';
                document.getElementById('edit-npc-id').value = npc.id;
                document.getElementById('npc-name').value = npc.name;
                document.getElementById('npc-description').value = npc.description;
                document.getElementById('npc-relation-to-char').value = npc.relationToChar || '';
                document.getElementById('npc-relation-to-user').value = npc.relationToUser || '';
                document.getElementById('npc-avatar-preview').src = npc.avatar;
                
                // 编辑模式下也显示全局NPC和选择角色开关
                document.getElementById('npc-global-toggle').checked = false;
                document.getElementById('npc-select-chars-toggle').checked = false;
                document.getElementById('npc-chars-selection').style.display = 'none';
                
                // 显示两个开关的form-group（编辑模式）
                document.getElementById('npc-global-toggle-group').style.display = 'block';
                document.getElementById('npc-select-chars-group').style.display = 'block';
                
                // 生成角色列表
                renderNpcCharSelection();
                
                document.getElementById('edit-npc-modal').classList.add('visible');
            }
            
            // ▼▼▼ NPC聊天功能 ▼▼▼
            let currentNpcChatId = null;
            let isNpcGenerating = false;
            
            // 打开NPC聊天弹窗
            function openNpcChat(npcId) {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character || !character.npcLibrary) return;
                
                const npc = character.npcLibrary.find(n => n.id === npcId);
                if (!npc) return;
                
                // 构建NPC的完整人设
                let npcPersona = npc.description || '';
                
                // 添加与角色的关系（如果有）
                if (npc.relationToChar) {
                    npcPersona += `\n\n# 你与${character.remarkName || character.realName}的关系\n${npc.relationToChar}`;
                }
                
                // 添加与用户的关系（如果有）
                if (npc.relationToUser) {
                    npcPersona += `\n\n# 你与用户的关系\n${npc.relationToUser}`;
                }
                
                // 添加重要说明
                npcPersona += `\n\n# 重要说明\n`;
                npcPersona += `- 你只能看到你和用户之间的对话历史\n`;
                npcPersona += `- 你看不到用户与${character.remarkName || character.realName}的对话\n`;
                npcPersona += `- 请严格保持你的人设和角色定位`;
                
                // 将NPC转换为临时角色对象
                const npcAsCharacter = {
                    id: `npc_${npcId}`,
                    realName: npc.name,
                    remarkName: npc.name,
                    avatar: npc.avatar,
                    persona: npcPersona,
                    myName: character.myName || '用户',
                    myAvatar: character.myAvatar,
                    myPersona: character.myPersona || '',
                    status: '在线',
                    history: npc.history || [],
                    maxMemory: npc.maxMemory || 20,
                    worldBookIds: character.worldBookIds || [], // 使用父角色的世界书
                    chatBg: npc.chatBg || character.chatBg,
                    customBubbleCss: npc.customBubbleCss,
                    useCustomBubbleCss: npc.useCustomBubbleCss,
                    isNPC: true,
                    originalNpcId: npcId,
                    parentCharacterId: character.id,
                    parentCharacterName: character.remarkName || character.realName
                };
                
                // 将临时NPC角色添加到characters数组（如果不存在）
                const existingIndex = db.characters.findIndex(c => c.id === npcAsCharacter.id);
                if (existingIndex === -1) {
                    db.characters.push(npcAsCharacter);
                } else {
                    // 更新现有的NPC角色
                    db.characters[existingIndex] = npcAsCharacter;
                }
                
                // 设置当前聊天ID和类型
                currentChatId = npcAsCharacter.id;
                currentChatType = 'private';
                
                // 使用普通的openChatRoom打开
                openChatRoom(npcAsCharacter.id, 'private');
            }
            

            
            // ▲▲▲ NPC聊天功能结束 ▲▲▲
            
            // 渲染可转换的CHAR列表
            function renderConvertCharList() {
                const listEl = document.getElementById('convert-char-list');
                if (!listEl) return;
                
                // 获取所有非群聊角色，排除当前角色
                const allCharacters = db.characters || [];
                const characters = allCharacters.filter(c => !c.isGroup && c.id !== currentChatId);
                
                if (characters.length === 0) {
                    listEl.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">没有可转换的角色</div>';
                    return;
                }
                
                let html = '';
                characters.forEach(char => {
                    const charName = char.remarkName || char.realName || char.name || '未命名';
                    const charAvatar = char.avatar || 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg';
                    const charPersona = char.persona || '暂无人设';
                    
                    html += `<div class="convert-char-item" data-char-id="${char.id}" style="display: flex; align-items: center; padding: 12px; border-bottom: 1px solid #eee; cursor: pointer; transition: background-color 0.2s;">`;
                    html += `<input type="checkbox" class="convert-char-checkbox" value="${char.id}" style="margin-right: 12px; width: 18px; height: 18px; cursor: pointer;">`;
                    html += `<img src="${charAvatar}" style="width: 50px; height: 50px; border-radius: 50%; object-fit: cover; margin-right: 12px; flex-shrink: 0; background-color: #eee;">`;
                    html += `<div style="flex: 1; min-width: 0;">`;
                    html += `<div style="font-weight: 600; font-size: 15px; margin-bottom: 4px; color: #333;">${charName}</div>`;
                    html += `<div style="font-size: 13px; color: #666; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${charPersona.substring(0, 50)}...</div>`;
                    html += `</div>`;
                    html += `</div>`;
                });
                
                listEl.innerHTML = html;
                
                // 绑定点击事件
                document.querySelectorAll('.convert-char-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        const checkbox = item.querySelector('.convert-char-checkbox');
                        if (e.target !== checkbox) {
                            checkbox.checked = !checkbox.checked;
                        }
                    });
                });
            }
            
            // 关闭转换CHAR为NPC弹窗
            document.getElementById('close-convert-char-modal-btn')?.addEventListener('click', () => {
                document.getElementById('convert-char-to-npc-modal').classList.remove('visible');
            });
            
            // 全选/取消全选CHAR
            document.getElementById('convert-char-select-all-btn')?.addEventListener('click', () => {
                const checkboxes = document.querySelectorAll('.convert-char-checkbox');
                const selectAllBtn = document.getElementById('convert-char-select-all-btn');
                const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                
                if (allChecked) {
                    checkboxes.forEach(cb => cb.checked = false);
                    selectAllBtn.textContent = '全选';
                    selectAllBtn.classList.remove('btn-warning');
                    selectAllBtn.classList.add('btn-primary');
                } else {
                    checkboxes.forEach(cb => cb.checked = true);
                    selectAllBtn.textContent = '取消全选';
                    selectAllBtn.classList.remove('btn-primary');
                    selectAllBtn.classList.add('btn-warning');
                }
            });
            
            // 确认转换CHAR为NPC
            document.getElementById('convert-char-confirm-btn')?.addEventListener('click', async () => {
                const checkboxes = document.querySelectorAll('.convert-char-checkbox:checked');
                if (checkboxes.length === 0) {
                    showToast('请先选择要转换的角色');
                    return;
                }
                
                // 显示互相转换确认弹窗
                const mutualConvertModal = document.getElementById('mutual-convert-confirm-modal');
                mutualConvertModal.classList.add('visible');
                
                // 存储选中的角色ID，供后续使用
                window.pendingConvertCharIds = Array.from(checkboxes).map(cb => cb.value);
            });
            
            // 互相转换 - 选择"是"
            document.getElementById('mutual-convert-yes-btn')?.addEventListener('click', async () => {
                await performConversion(true);
            });
            
            // 互相转换 - 选择"否"
            document.getElementById('mutual-convert-no-btn')?.addEventListener('click', async () => {
                await performConversion(false);
            });
            
            // 点击弹窗外部关闭
            document.getElementById('mutual-convert-confirm-modal')?.addEventListener('click', (e) => {
                if (e.target.id === 'mutual-convert-confirm-modal') {
                    document.getElementById('mutual-convert-confirm-modal').classList.remove('visible');
                    window.pendingConvertCharIds = null;
                }
            });
            
            // 执行转换的函数
            async function performConversion(mutualConvert) {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                if (!character.npcLibrary) character.npcLibrary = [];
                
                const charIds = window.pendingConvertCharIds || [];
                let convertedCount = 0;
                
                charIds.forEach(charId => {
                    const sourceChar = db.characters.find(c => c.id === charId);
                    if (!sourceChar) return;
                    
                    // 检查是否已存在同名NPC
                    const charName = sourceChar.remarkName || sourceChar.realName || sourceChar.name || '未命名';
                    const exists = character.npcLibrary.some(npc => npc.name === charName);
                    if (exists) {
                        console.log(`NPC "${charName}" 已存在，跳过`);
                        return;
                    }
                    
                    // 创建NPC数据 - 添加到当前角色的NPC库
                    const npcData = {
                        id: `npc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        name: charName,
                        description: sourceChar.persona || '暂无人设',
                        relationToChar: '',
                        relationToUser: '',
                        avatar: sourceChar.avatar || 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg'
                    };
                    
                    character.npcLibrary.push(npcData);
                    convertedCount++;
                    
                    // 如果选择互相转换，也将当前角色添加到源角色的NPC库
                    if (mutualConvert) {
                        if (!sourceChar.npcLibrary) sourceChar.npcLibrary = [];
                        
                        const currentCharName = character.remarkName || character.realName || character.name || '未命名';
                        const existsInSource = sourceChar.npcLibrary.some(npc => npc.name === currentCharName);
                        
                        if (!existsInSource) {
                            const reverseNpcData = {
                                id: `npc_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                                name: currentCharName,
                                description: character.persona || '暂无人设',
                                relationToChar: '',
                                relationToUser: '',
                                avatar: character.avatar || 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg'
                            };
                            sourceChar.npcLibrary.push(reverseNpcData);
                        }
                    }
                });
                
                await saveData();
                renderNpcLibrary();
                
                // 关闭所有弹窗
                document.getElementById('mutual-convert-confirm-modal').classList.remove('visible');
                document.getElementById('convert-char-to-npc-modal').classList.remove('visible');
                
                // 重置全选按钮
                const selectAllBtn = document.getElementById('convert-char-select-all-btn');
                if (selectAllBtn) {
                    selectAllBtn.textContent = '全选';
                    selectAllBtn.classList.remove('btn-warning');
                    selectAllBtn.classList.add('btn-primary');
                }
                
                // 清除临时数据
                window.pendingConvertCharIds = null;
                
                if (mutualConvert) {
                    showToast(`成功互相转换 ${convertedCount} 个角色为NPC`);
                } else {
                    showToast(`成功转换 ${convertedCount} 个角色为NPC`);
                }
            }
            
            const useCustomCssCheckbox = document.getElementById('setting-use-custom-css'),
                customCssTextarea = document.getElementById('setting-custom-bubble-css'),
                resetCustomCssBtn = document.getElementById('reset-custom-bubble-css-btn'),
                privatePreviewBox = document.getElementById('private-bubble-css-preview');
            useCustomCssCheckbox.addEventListener('change', (e) => {
                customCssTextarea.disabled = !e.target.checked;
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, customCssTextarea.value, !e.target.checked, theme);
                }
            });
            customCssTextarea.addEventListener('input', (e) => {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char && useCustomCssCheckbox.checked) {
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, e.target.value, false, theme);
                }
            });
            resetCustomCssBtn.addEventListener('click', () => {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    customCssTextarea.value = '';
                    useCustomCssCheckbox.checked = false;
                    customCssTextarea.disabled = true;
                    const themeKey = char.theme || 'white_pink';
                    const theme = colorThemes[themeKey];
                    updateBubbleCssPreview(privatePreviewBox, '', true, theme);
                    showToast('样式已重置为默认');
                }
            });
            document.getElementById('setting-char-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('setting-char-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('头像压缩失败，请重试');
                    }
                }
            });
            
            // Avatar Library Functionality
            let pendingAvatarFiles = [];
            
            // Open avatar library
            document.getElementById('open-avatar-library-btn').addEventListener('click', () => {
                document.getElementById('avatar-library-modal').classList.add('visible');
                renderAvatarLibrary();
            });
            
            // Close avatar library
            document.getElementById('close-avatar-library-btn').addEventListener('click', () => {
                document.getElementById('avatar-library-modal').classList.remove('visible');
                pendingAvatarFiles = [];
                document.getElementById('avatar-names-input').value = '';
            });
            
            // Upload avatars
            document.getElementById('avatar-library-upload').addEventListener('change', (e) => {
                pendingAvatarFiles = Array.from(e.target.files);
                if (pendingAvatarFiles.length > 0) {
                    showToast(`已选择 ${pendingAvatarFiles.length} 个文件`);
                }
            });
            
            // Confirm upload
            document.getElementById('confirm-upload-avatars-btn').addEventListener('click', async () => {
                if (pendingAvatarFiles.length === 0) {
                    showToast('请先选择头像文件');
                    return;
                }
                
                const namesInput = document.getElementById('avatar-names-input').value.trim();
                const names = namesInput ? namesInput.split(',').map(n => n.trim()) : [];
                const uploadCount = pendingAvatarFiles.length;
                
                for (let i = 0; i < pendingAvatarFiles.length; i++) {
                    try {
                        const compressedUrl = await compressImage(pendingAvatarFiles[i], {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        const avatarName = names[i] || `头像${db.avatarLibrary.length + 1}`;
                        db.avatarLibrary.push({
                            id: Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                            url: compressedUrl,
                            name: avatarName
                        });
                    } catch (error) {
                        console.error('Avatar compression failed:', error);
                    }
                }
                
                await saveData();
                renderAvatarLibrary();
                pendingAvatarFiles = [];
                document.getElementById('avatar-names-input').value = '';
                document.getElementById('avatar-library-upload').value = '';
                showToast(`成功上传 ${uploadCount} 个头像`);
            });
            
            // Select all avatars
            document.getElementById('select-all-avatars-btn').addEventListener('click', () => {
                document.querySelectorAll('.avatar-library-item').forEach(item => {
                    item.classList.add('selected');
                });
            });
            
            // Deselect all avatars
            document.getElementById('deselect-all-avatars-btn').addEventListener('click', () => {
                document.querySelectorAll('.avatar-library-item').forEach(item => {
                    item.classList.remove('selected');
                });
            });
            
            // Delete selected avatars
            document.getElementById('delete-selected-avatars-btn').addEventListener('click', async () => {
                const selectedItems = document.querySelectorAll('.avatar-library-item.selected');
                if (selectedItems.length === 0) {
                    showToast('请先选择要删除的头像');
                    return;
                }
                
                if (!confirm(`确定要删除选中的 ${selectedItems.length} 个头像吗？`)) {
                    return;
                }
                
                const selectedIds = Array.from(selectedItems).map(item => item.dataset.id);
                db.avatarLibrary = db.avatarLibrary.filter(avatar => !selectedIds.includes(avatar.id));
                
                await saveData();
                renderAvatarLibrary();
                showToast(`已删除 ${selectedItems.length} 个头像`);
            });
            
            // Render avatar library
            function renderAvatarLibrary() {
                const grid = document.getElementById('avatar-library-grid');
                const emptyState = document.getElementById('avatar-library-empty');
                
                if (!db.avatarLibrary || db.avatarLibrary.length === 0) {
                    grid.style.display = 'none';
                    emptyState.style.display = 'block';
                    return;
                }
                
                grid.style.display = 'grid';
                emptyState.style.display = 'none';
                grid.innerHTML = '';
                
                db.avatarLibrary.forEach(avatar => {
                    const item = document.createElement('div');
                    item.className = 'avatar-library-item';
                    item.dataset.id = avatar.id;
                    
                    item.innerHTML = `
                        <div class="selection-checkbox">✓</div>
                        <img src="${avatar.url}" alt="${avatar.name}">
                        <div class="avatar-name">${avatar.name}</div>
                    `;
                    
                    // Click on checkbox area to toggle selection
                    const checkbox = item.querySelector('.selection-checkbox');
                    checkbox.addEventListener('click', (e) => {
                        e.stopPropagation();
                        item.classList.toggle('selected');
                    });
                    
                    // Click on avatar to use it
                    item.addEventListener('click', () => {
                        if (!item.classList.contains('selected')) {
                            document.getElementById('setting-char-avatar-preview').src = avatar.url;
                            showToast(`已应用头像：${avatar.name}`);
                        }
                    });
                    
                    grid.appendChild(item);
                });
            }
            
            // My Avatar Library Functionality
            let pendingMyAvatarFiles = [];
            
            // Open my avatar library
            document.getElementById('open-my-avatar-library-btn').addEventListener('click', () => {
                document.getElementById('my-avatar-library-modal').classList.add('visible');
                renderMyAvatarLibrary();
            });
            
            // Close my avatar library
            document.getElementById('close-my-avatar-library-btn').addEventListener('click', () => {
                document.getElementById('my-avatar-library-modal').classList.remove('visible');
                pendingMyAvatarFiles = [];
                document.getElementById('my-avatar-names-input').value = '';
            });
            
            // Upload my avatars
            document.getElementById('my-avatar-library-upload').addEventListener('change', (e) => {
                pendingMyAvatarFiles = Array.from(e.target.files);
                if (pendingMyAvatarFiles.length > 0) {
                    showToast(`已选择 ${pendingMyAvatarFiles.length} 个文件`);
                }
            });
            
            // Confirm upload my avatars
            document.getElementById('confirm-upload-my-avatars-btn').addEventListener('click', async () => {
                if (pendingMyAvatarFiles.length === 0) {
                    showToast('请先选择头像文件');
                    return;
                }
                
                const namesInput = document.getElementById('my-avatar-names-input').value.trim();
                const names = namesInput ? namesInput.split(',').map(n => n.trim()) : [];
                const uploadCount = pendingMyAvatarFiles.length;
                
                for (let i = 0; i < pendingMyAvatarFiles.length; i++) {
                    try {
                        const compressedUrl = await compressImage(pendingMyAvatarFiles[i], {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        const avatarName = names[i] || `头像${db.myAvatarLibrary.length + 1}`;
                        db.myAvatarLibrary.push({
                            id: Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                            url: compressedUrl,
                            name: avatarName
                        });
                    } catch (error) {
                        console.error('Avatar compression failed:', error);
                    }
                }
                
                await saveData();
                renderMyAvatarLibrary();
                pendingMyAvatarFiles = [];
                document.getElementById('my-avatar-names-input').value = '';
                document.getElementById('my-avatar-library-upload').value = '';
                showToast(`成功上传 ${uploadCount} 个头像`);
            });
            
            // Select all my avatars
            document.getElementById('select-all-my-avatars-btn').addEventListener('click', () => {
                document.querySelectorAll('.my-avatar-library-item').forEach(item => {
                    item.classList.add('selected');
                });
            });
            
            // Deselect all my avatars
            document.getElementById('deselect-all-my-avatars-btn').addEventListener('click', () => {
                document.querySelectorAll('.my-avatar-library-item').forEach(item => {
                    item.classList.remove('selected');
                });
            });
            
            // Delete selected my avatars
            document.getElementById('delete-selected-my-avatars-btn').addEventListener('click', async () => {
                const selectedItems = document.querySelectorAll('.my-avatar-library-item.selected');
                if (selectedItems.length === 0) {
                    showToast('请先选择要删除的头像');
                    return;
                }
                
                if (!confirm(`确定要删除选中的 ${selectedItems.length} 个头像吗？`)) {
                    return;
                }
                
                const selectedIds = Array.from(selectedItems).map(item => item.dataset.id);
                db.myAvatarLibrary = db.myAvatarLibrary.filter(avatar => !selectedIds.includes(avatar.id));
                
                await saveData();
                renderMyAvatarLibrary();
                showToast(`已删除 ${selectedItems.length} 个头像`);
            });
            
            // Render my avatar library
            function renderMyAvatarLibrary() {
                const grid = document.getElementById('my-avatar-library-grid');
                const emptyState = document.getElementById('my-avatar-library-empty');
                
                if (!db.myAvatarLibrary || db.myAvatarLibrary.length === 0) {
                    grid.style.display = 'none';
                    emptyState.style.display = 'block';
                    return;
                }
                
                grid.style.display = 'grid';
                emptyState.style.display = 'none';
                grid.innerHTML = '';
                
                db.myAvatarLibrary.forEach(avatar => {
                    const item = document.createElement('div');
                    item.className = 'my-avatar-library-item avatar-library-item';
                    item.dataset.id = avatar.id;
                    
                    item.innerHTML = `
                        <div class="selection-checkbox">✓</div>
                        <img src="${avatar.url}" alt="${avatar.name}">
                        <div class="avatar-name">${avatar.name}</div>
                    `;
                    
                    // Click on checkbox area to toggle selection
                    const checkbox = item.querySelector('.selection-checkbox');
                    checkbox.addEventListener('click', (e) => {
                        e.stopPropagation();
                        item.classList.toggle('selected');
                    });
                    
                    // Click on avatar to use it
                    item.addEventListener('click', async () => {
                        if (!item.classList.contains('selected')) {
                            document.getElementById('setting-my-avatar-preview').src = avatar.url;
                            showToast(`已应用头像：${avatar.name}`);
                            
                            // 如果开启了识别功能，且头像发生了变化，自动识别
                            const character = db.characters.find(c => c.id === currentChatId);
                            if (character && character.recognizeUserAvatarEnabled && 
                                avatar.url !== character.userAvatarUrl) {
                                await recognizeUserAvatar(character, avatar.url);
                            }
                        }
                    });
                    
                    grid.appendChild(item);
                });
            }
            
            // === 情头绑定功能 ===
            let selectedCharAvatarForBinding = null;
            let selectedMyAvatarForBinding = null;
            
            // 打开绑定管理弹窗
            document.getElementById('manage-avatar-bindings-btn').addEventListener('click', () => {
                document.getElementById('avatar-binding-modal').classList.add('visible');
                renderAvatarBindings();
            });
            
            // 关闭绑定管理弹窗
            document.getElementById('close-avatar-binding-btn').addEventListener('click', () => {
                document.getElementById('avatar-binding-modal').classList.remove('visible');
            });
            
            // 打开创建绑定弹窗
            document.getElementById('create-new-binding-btn').addEventListener('click', () => {
                selectedCharAvatarForBinding = null;
                selectedMyAvatarForBinding = null;
                document.getElementById('create-binding-modal').classList.add('visible');
                renderBindingSelectionGrids();
            });
            
            // 关闭创建绑定弹窗
            document.getElementById('close-create-binding-btn').addEventListener('click', () => {
                document.getElementById('create-binding-modal').classList.remove('visible');
            });
            
            document.getElementById('cancel-create-binding-btn').addEventListener('click', () => {
                document.getElementById('create-binding-modal').classList.remove('visible');
            });
            
            // 确认创建绑定
            document.getElementById('confirm-create-binding-btn').addEventListener('click', async () => {
                if (!selectedCharAvatarForBinding || !selectedMyAvatarForBinding) {
                    showToast('请选择角色头像和我的头像');
                    return;
                }
                
                // 检查是否已经存在绑定
                const existingBinding = db.avatarBindings.find(b => 
                    b.charAvatarId === selectedCharAvatarForBinding.id || 
                    b.myAvatarId === selectedMyAvatarForBinding.id
                );
                
                if (existingBinding) {
                    showToast('选中的头像已经有绑定，请先解绑');
                    return;
                }
                
                const remark = document.getElementById('binding-remark-input').value.trim();
                
                const newBinding = {
                    id: `binding_${Date.now()}`,
                    charAvatarId: selectedCharAvatarForBinding.id,
                    charAvatarUrl: selectedCharAvatarForBinding.url,
                    charAvatarName: selectedCharAvatarForBinding.name,
                    myAvatarId: selectedMyAvatarForBinding.id,
                    myAvatarUrl: selectedMyAvatarForBinding.url,
                    myAvatarName: selectedMyAvatarForBinding.name,
                    remark: remark || '无备注',
                    createdAt: Date.now()
                };
                
                db.avatarBindings.push(newBinding);
                await saveData();
                
                document.getElementById('create-binding-modal').classList.remove('visible');
                document.getElementById('binding-remark-input').value = '';
                renderAvatarBindings();
                showToast('情头绑定创建成功！');
            });
            
            // 渲染绑定选择网格
            function renderBindingSelectionGrids() {
                const charGrid = document.getElementById('select-char-avatar-grid');
                const myGrid = document.getElementById('select-my-avatar-grid');
                
                // 渲染角色头像
                charGrid.innerHTML = '';
                if (db.avatarLibrary && db.avatarLibrary.length > 0) {
                    db.avatarLibrary.forEach(avatar => {
                        const item = document.createElement('div');
                        item.style.cssText = 'cursor: pointer; position: relative; border: 3px solid transparent; border-radius: 8px; transition: all 0.2s;';
                        item.innerHTML = `<img src="${avatar.url}" style="width: 100%; height: 80px; object-fit: cover; border-radius: 5px;">`;
                        
                        item.addEventListener('click', () => {
                            selectedCharAvatarForBinding = avatar;
                            document.querySelectorAll('#select-char-avatar-grid > div').forEach(el => {
                                el.style.border = '3px solid transparent';
                            });
                            item.style.border = '3px solid #4CAF50';
                            
                            document.getElementById('selected-char-avatar-display').style.display = 'block';
                            document.getElementById('selected-char-avatar-img').src = avatar.url;
                            document.getElementById('selected-char-avatar-name').textContent = avatar.name;
                        });
                        
                        charGrid.appendChild(item);
                    });
                } else {
                    charGrid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #999; padding: 20px;">暂无角色头像</div>';
                }
                
                // 渲染我的头像
                myGrid.innerHTML = '';
                if (db.myAvatarLibrary && db.myAvatarLibrary.length > 0) {
                    db.myAvatarLibrary.forEach(avatar => {
                        const item = document.createElement('div');
                        item.style.cssText = 'cursor: pointer; position: relative; border: 3px solid transparent; border-radius: 8px; transition: all 0.2s;';
                        item.innerHTML = `<img src="${avatar.url}" style="width: 100%; height: 80px; object-fit: cover; border-radius: 5px;">`;
                        
                        item.addEventListener('click', () => {
                            selectedMyAvatarForBinding = avatar;
                            document.querySelectorAll('#select-my-avatar-grid > div').forEach(el => {
                                el.style.border = '3px solid transparent';
                            });
                            item.style.border = '3px solid #1976d2';
                            
                            document.getElementById('selected-my-avatar-display').style.display = 'block';
                            document.getElementById('selected-my-avatar-img').src = avatar.url;
                            document.getElementById('selected-my-avatar-name').textContent = avatar.name;
                        });
                        
                        myGrid.appendChild(item);
                    });
                } else {
                    myGrid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: #999; padding: 20px;">暂无我的头像</div>';
                }
                
                // 重置显示
                document.getElementById('selected-char-avatar-display').style.display = 'none';
                document.getElementById('selected-my-avatar-display').style.display = 'none';
            }
            
            // 渲染绑定列表
            function renderAvatarBindings() {
                const list = document.getElementById('avatar-bindings-list');
                const emptyState = document.getElementById('avatar-bindings-empty');
                
                if (!db.avatarBindings || db.avatarBindings.length === 0) {
                    list.style.display = 'none';
                    emptyState.style.display = 'block';
                    return;
                }
                
                list.style.display = 'flex';
                emptyState.style.display = 'none';
                list.innerHTML = '';
                
                db.avatarBindings.forEach(binding => {
                    const item = document.createElement('div');
                    item.style.cssText = 'padding: 15px; background: white; border: 2px solid #e0e0e0; border-radius: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);';
                    
                    item.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                            <div style="text-align: center;">
                                <img src="${binding.charAvatarUrl}" style="width: 70px; height: 70px; border-radius: 50%; object-fit: cover; border: 3px solid #4CAF50;">
                                <div style="font-size: 11px; color: #666; margin-top: 5px;">角色头像</div>
                                <div style="font-size: 12px; font-weight: 500; color: #333;">${binding.charAvatarName}</div>
                            </div>
                            <div style="font-size: 24px; color: #ff4081;">💕</div>
                            <div style="text-align: center;">
                                <img src="${binding.myAvatarUrl}" style="width: 70px; height: 70px; border-radius: 50%; object-fit: cover; border: 3px solid #1976d2;">
                                <div style="font-size: 11px; color: #666; margin-top: 5px;">我的头像</div>
                                <div style="font-size: 12px; font-weight: 500; color: #333;">${binding.myAvatarName}</div>
                            </div>
                        </div>
                        <div style="padding: 8px; background: #f5f5f5; border-radius: 6px; margin-bottom: 10px;">
                            <div style="font-size: 11px; color: #999; margin-bottom: 3px;">备注</div>
                            <div style="font-size: 13px; color: #333;">${binding.remark}</div>
                        </div>
                        <button class="unbind-btn" data-id="${binding.id}" style="width: 100%; padding: 8px; background: #ff5252; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px;">解除绑定</button>
                    `;
                    
                    // 解绑按钮
                    item.querySelector('.unbind-btn').addEventListener('click', async () => {
                        if (confirm('确定要解除这对情头的绑定吗？')) {
                            db.avatarBindings = db.avatarBindings.filter(b => b.id !== binding.id);
                            await saveData();
                            renderAvatarBindings();
                            showToast('已解除绑定');
                        }
                    });
                    
                    list.appendChild(item);
                });
            }
            
            // === 头像框功能 ===
            let currentFrameSelection = { char: null, my: null };
            let editingFrameForMember = false;
            
            // 打开头像框选择器
            function openFrameSelectorModal(type = 'char') {
                const frameModal = document.getElementById('avatar-frame-modal');
                if (!currentChatId) return;
                const char = db.characters.find(c => c.id === currentChatId);
                if (!char) return;
                
                currentFrameSelection.char = char.avatarFrame || '';
                currentFrameSelection.my = char.myAvatarFrame || '';
                populateFrameGrids(char);
                frameModal.classList.add('visible');
            }
            
            // 填充头像框网格
            function populateFrameGrids(char) {
                const aiFrameGrid = document.getElementById('ai-frame-grid');
                const myFrameGrid = document.getElementById('my-frame-grid');
                aiFrameGrid.innerHTML = '';
                myFrameGrid.innerHTML = '';
                
                const charAvatarForPreview = char.avatar || 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg';
                const myAvatarForPreview = char.myAvatar || 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg';
                
                avatarFrames.forEach(frame => {
                    const charItem = createFrameItem(frame, 'char', charAvatarForPreview);
                    if (frame.url === currentFrameSelection.char) charItem.classList.add('selected');
                    aiFrameGrid.appendChild(charItem);
                    
                    const myItem = createFrameItem(frame, 'my', myAvatarForPreview);
                    if (frame.url === currentFrameSelection.my) myItem.classList.add('selected');
                    myFrameGrid.appendChild(myItem);
                });
            }
            
            // 创建头像框项目
            function createFrameItem(frame, type, previewAvatarSrc) {
                const item = document.createElement('div');
                item.className = 'frame-item';
                item.dataset.frameUrl = frame.url;
                item.title = frame.name;
                item.innerHTML = `
                    <img src="${previewAvatarSrc}" class="preview-avatar">
                    ${frame.url ? `<img src="${frame.url}" class="preview-frame">` : ''}
                `;
                item.addEventListener('click', () => {
                    currentFrameSelection[type] = frame.url;
                    const grid = type === 'char' ? document.getElementById('ai-frame-grid') : document.getElementById('my-frame-grid');
                    grid.querySelectorAll('.frame-item').forEach(el => el.classList.remove('selected'));
                    item.classList.add('selected');
                });
                return item;
            }
            
            // 保存选中的头像框
            async function saveSelectedFrames() {
                if (!currentChatId) return;
                const char = db.characters.find(c => c.id === currentChatId);
                if (!char) return;
                
                char.avatarFrame = currentFrameSelection.char;
                char.myAvatarFrame = currentFrameSelection.my;
                await saveData();
                
                document.getElementById('avatar-frame-modal').classList.remove('visible');
                renderMessages(false, true);
                showToast('头像框已保存！');
            }
            
            // 头像框按钮事件
            document.querySelectorAll('.change-frame-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const type = e.target.dataset.type;
                    openFrameSelectorModal(type);
                });
            });
            
            // 头像框模态框事件
            const frameModal = document.getElementById('avatar-frame-modal');
            const aiFrameTab = document.getElementById('ai-frame-tab');
            const myFrameTab = document.getElementById('my-frame-tab');
            const aiFrameContent = document.getElementById('ai-frame-content');
            const myFrameContent = document.getElementById('my-frame-content');
            
            document.getElementById('save-frame-settings-btn').addEventListener('click', saveSelectedFrames);
            
            document.getElementById('cancel-frame-settings-btn').addEventListener('click', () => {
                frameModal.classList.remove('visible');
            });
            
            // ===== 头像框上传、导入、导出功能 =====
            const uploadFrameModal = document.getElementById('upload-frame-modal');
            const uploadFrameBtn = document.getElementById('upload-frame-btn');
            const uploadLocalBtn = document.getElementById('upload-local-btn');
            const uploadUrlBtn = document.getElementById('upload-url-btn');
            const localUploadArea = document.getElementById('local-upload-area');
            const urlUploadArea = document.getElementById('url-upload-area');
            const localFrameInput = document.getElementById('local-frame-input');
            const localFrameNames = document.getElementById('local-frame-names');
            const urlFrameInput = document.getElementById('url-frame-input');
            const urlFrameNames = document.getElementById('url-frame-names');
            const confirmUploadFrameBtn = document.getElementById('confirm-upload-frame-btn');
            const cancelUploadFrameBtn = document.getElementById('cancel-upload-frame-btn');
            const importFramesBtn = document.getElementById('import-frames-btn');
            const exportFramesBtn = document.getElementById('export-frames-btn');
            const importFramesInput = document.getElementById('import-frames-input');
            
            let currentUploadMode = null; // 'local' or 'url'
            
            // 打开上传弹窗
            uploadFrameBtn.addEventListener('click', () => {
                uploadFrameModal.classList.add('visible');
                currentUploadMode = null;
                localUploadArea.style.display = 'none';
                urlUploadArea.style.display = 'none';
                localFrameInput.value = '';
                localFrameNames.value = '';
                urlFrameInput.value = '';
                urlFrameNames.value = '';
            });
            
            // 选择本地上传
            uploadLocalBtn.addEventListener('click', () => {
                currentUploadMode = 'local';
                localUploadArea.style.display = 'block';
                urlUploadArea.style.display = 'none';
                uploadLocalBtn.classList.remove('btn-secondary');
                uploadLocalBtn.classList.add('btn-primary');
                uploadUrlBtn.classList.remove('btn-primary');
                uploadUrlBtn.classList.add('btn-secondary');
            });
            
            // 选择URL上传
            uploadUrlBtn.addEventListener('click', () => {
                currentUploadMode = 'url';
                localUploadArea.style.display = 'none';
                urlUploadArea.style.display = 'block';
                uploadUrlBtn.classList.remove('btn-secondary');
                uploadUrlBtn.classList.add('btn-primary');
                uploadLocalBtn.classList.remove('btn-primary');
                uploadLocalBtn.classList.add('btn-secondary');
            });
            
            // 确认上传
            confirmUploadFrameBtn.addEventListener('click', async () => {
                if (!currentUploadMode) {
                    alert('请先选择上传方式');
                    return;
                }
                
                try {
                    if (currentUploadMode === 'local') {
                        // 本地上传
                        const files = localFrameInput.files;
                        if (files.length === 0) {
                            alert('请选择至少一个图片文件');
                            return;
                        }
                        
                        const names = localFrameNames.value.trim().split(',').map(n => n.trim()).filter(n => n);
                        const newFrames = [];
                        
                        for (let i = 0; i < files.length; i++) {
                            const file = files[i];
                            const reader = new FileReader();
                            
                            await new Promise((resolve) => {
                                reader.onload = (e) => {
                                    const frameName = names[i] || `自定义${avatarFrames.length + newFrames.length + 1}`;
                                    const frameId = `custom_${Date.now()}_${i}`;
                                    newFrames.push({
                                        id: frameId,
                                        url: e.target.result,
                                        name: frameName
                                    });
                                    resolve();
                                };
                                reader.readAsDataURL(file);
                            });
                        }
                        
                        avatarFrames.push(...newFrames);
                        await saveData();
                        showToast(`成功上传 ${newFrames.length} 个头像框`);
                        
                    } else if (currentUploadMode === 'url') {
                        // URL上传
                        const urls = urlFrameInput.value.trim().split(',').map(u => u.trim()).filter(u => u);
                        if (urls.length === 0) {
                            alert('请输入至少一个URL');
                            return;
                        }
                        
                        const names = urlFrameNames.value.trim().split(',').map(n => n.trim()).filter(n => n);
                        const newFrames = [];
                        
                        for (let i = 0; i < urls.length; i++) {
                            const frameName = names[i] || `自定义${avatarFrames.length + newFrames.length + 1}`;
                            const frameId = `custom_${Date.now()}_${i}`;
                            newFrames.push({
                                id: frameId,
                                url: urls[i],
                                name: frameName
                            });
                        }
                        
                        avatarFrames.push(...newFrames);
                        await saveData();
                        showToast(`成功添加 ${newFrames.length} 个头像框`);
                    }
                    
                    // 刷新头像框列表
                    renderFrameGrid();
                    uploadFrameModal.classList.remove('visible');
                    
                } catch (error) {
                    console.error('上传失败:', error);
                    alert('上传失败，请重试');
                }
            });
            
            // 取消上传
            cancelUploadFrameBtn.addEventListener('click', () => {
                uploadFrameModal.classList.remove('visible');
            });
            
            // 点击遮罩关闭
            uploadFrameModal.addEventListener('click', (e) => {
                if (e.target === uploadFrameModal) {
                    uploadFrameModal.classList.remove('visible');
                }
            });
            
            // 导出头像框
            exportFramesBtn.addEventListener('click', () => {
                try {
                    const customFrames = avatarFrames.filter(f => f.id.startsWith('custom_'));
                    if (customFrames.length === 0) {
                        alert('没有自定义头像框可以导出');
                        return;
                    }
                    
                    const dataStr = JSON.stringify(customFrames, null, 2);
                    const blob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `头像框导出_${new Date().toISOString().slice(0,10)}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    showToast(`成功导出 ${customFrames.length} 个头像框`);
                } catch (error) {
                    console.error('导出失败:', error);
                    alert('导出失败，请重试');
                }
            });
            
            // 导入头像框
            importFramesBtn.addEventListener('click', () => {
                importFramesInput.click();
            });
            
            importFramesInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const importedFrames = JSON.parse(text);
                    
                    if (!Array.isArray(importedFrames)) {
                        alert('文件格式错误');
                        return;
                    }
                    
                    // 检查是否有重复ID
                    const existingIds = new Set(avatarFrames.map(f => f.id));
                    const newFrames = importedFrames.filter(f => !existingIds.has(f.id));
                    
                    if (newFrames.length === 0) {
                        alert('没有新的头像框可以导入（可能已存在）');
                        return;
                    }
                    
                    avatarFrames.push(...newFrames);
                    await saveData();
                    renderFrameGrid();
                    showToast(`成功导入 ${newFrames.length} 个头像框`);
                    
                } catch (error) {
                    console.error('导入失败:', error);
                    alert('导入失败，请检查文件格式');
                }
                
                // 清空input
                e.target.value = '';
            });
            
            aiFrameTab.addEventListener('click', () => {
                aiFrameTab.classList.add('active');
                myFrameTab.classList.remove('active');
                aiFrameContent.style.display = 'block';
                myFrameContent.style.display = 'none';
            });
            
            myFrameTab.addEventListener('click', () => {
                myFrameTab.classList.add('active');
                aiFrameTab.classList.remove('active');
                myFrameContent.style.display = 'block';
                aiFrameContent.style.display = 'none';
            });
            
            frameModal.addEventListener('click', (e) => {
                if (e.target === frameModal) {
                    frameModal.classList.remove('visible');
                }
            });
            
            document.getElementById('setting-my-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('setting-my-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('头像压缩失败，请重试');
                    }
                }
            });
            
            // ===== 头像形状功能 - 事件监听器 =====
            
            // 预设形状按钮事件
            document.querySelectorAll('.avatar-shape-preset-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const type = this.dataset.type;
                    const shape = this.dataset.shape;
                    
                    if (!currentChatId) {
                        showToast('请先选择一个聊天');
                        return;
                    }
                    
                    // 更新按钮选中状态
                    document.querySelectorAll(`.avatar-shape-preset-btn[data-type="${type}"]`).forEach(b => {
                        b.classList.remove('selected');
                    });
                    this.classList.add('selected');
                    
                    // 应用形状
                    applyAvatarShape(currentChatId, type, {
                        preset: shape,
                        custom: null
                    });
                });
            });
            
            // 角色自定义形状应用
            document.getElementById('apply-char-custom-shape-btn').addEventListener('click', () => {
                const input = document.getElementById('char-custom-shape-input');
                const customShape = input.value.trim();
                
                if (!currentChatId) {
                    showToast('请先选择一个聊天');
                    return;
                }
                
                if (!customShape) {
                    showToast('请输入形状代码');
                    return;
                }
                
                // 取消预设按钮选中
                document.querySelectorAll('.avatar-shape-preset-btn[data-type="char"]').forEach(b => {
                    b.classList.remove('selected');
                });
                
                // 应用自定义形状
                applyAvatarShape(currentChatId, 'char', {
                    preset: null,
                    custom: customShape
                });
            });
            
            // USER自定义形状应用
            document.getElementById('apply-my-custom-shape-btn').addEventListener('click', () => {
                const input = document.getElementById('my-custom-shape-input');
                const customShape = input.value.trim();
                
                if (!currentChatId) {
                    showToast('请先选择一个聊天');
                    return;
                }
                
                if (!customShape) {
                    showToast('请输入形状代码');
                    return;
                }
                
                // 取消预设按钮选中
                document.querySelectorAll('.avatar-shape-preset-btn[data-type="my"]').forEach(b => {
                    b.classList.remove('selected');
                });
                
                // 应用自定义形状
                applyAvatarShape(currentChatId, 'my', {
                    preset: null,
                    custom: customShape
                });
            });
            
            document.getElementById('setting-chat-bg-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    const char = db.characters.find(c => c.id === currentChatId);
                    if (char) {
                        try {
                            const compressedUrl = await compressImage(file, {
                                quality: 0.85,
                                maxWidth: 1080,
                                maxHeight: 1920
                            });
                            char.chatBg = compressedUrl;
                            chatRoomScreen.style.backgroundImage = `url(${compressedUrl})`;
                            await saveData();
                            showToast('聊天背景已更换');
                        } catch (error) {
                            showToast('背景压缩失败，请重试');
                        }
                    }
                }
            });
            // === Chat Search Functionality ===
            let currentSearchChatId = null;
            let currentSearchChatType = null;
            let searchDebounceTimer = null;
            
            // Open search modal for private chat
            document.getElementById('search-chat-history-btn').addEventListener('click', () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                currentSearchChatId = currentChatId;
                currentSearchChatType = 'private';
                openSearchModal();
            });
            
            // Open search modal for group chat
            document.getElementById('search-group-chat-history-btn').addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                
                currentSearchChatId = currentChatId;
                currentSearchChatType = 'group';
                openSearchModal();
            });
            
            function openSearchModal() {
                const modal = document.getElementById('chat-search-modal');
                const searchInput = document.getElementById('search-keyword-input');
                const clearBtn = document.getElementById('clear-search-keyword-btn');
                const emptyState = document.getElementById('search-empty-state');
                const resultsList = document.getElementById('search-results-list');
                const infoBar = document.getElementById('search-info-bar');
                
                // Reset UI
                searchInput.value = '';
                clearBtn.style.display = 'none';
                emptyState.style.display = 'block';
                resultsList.style.display = 'none';
                resultsList.innerHTML = '';
                infoBar.style.display = 'none';
                
                // Populate sender filter dynamically
                const senderFilter = document.getElementById('search-filter-sender');
                senderFilter.innerHTML = '<option value="all">全部发送人</option><option value="user">我</option>';
                
                if (currentSearchChatType === 'private') {
                    // Private chat - add character
                    const character = db.characters.find(c => c.id === currentSearchChatId);
                    if (character) {
                        const charName = character.remarkName || character.realName || '角色';
                        senderFilter.innerHTML += `<option value="${character.id}">${charName}</option>`;
                    }
                } else if (currentSearchChatType === 'group') {
                    // Group chat - add all members
                    const group = db.groups.find(g => g.id === currentSearchChatId);
                    if (group && group.members) {
                        group.members.forEach(member => {
                            const memberName = `${member.groupNickname} (${member.realName})`;
                            senderFilter.innerHTML += `<option value="${member.id}">${memberName}</option>`;
                        });
                    }
                }
                
                modal.style.display = 'flex';
                setTimeout(() => searchInput.focus(), 300);
            }
            
            // Close search modal
            document.getElementById('close-search-modal-btn').addEventListener('click', () => {
                document.getElementById('chat-search-modal').style.display = 'none';
                currentSearchChatId = null;
                currentSearchChatType = null;
                
                // Reset filters
                document.getElementById('search-filter-sender').value = 'all';
                document.getElementById('search-filter-date-start').value = '';
                document.getElementById('search-filter-date-end').value = '';
                document.getElementById('search-filter-type').value = 'all';
            });
            
            // Clear search keyword
            document.getElementById('clear-search-keyword-btn').addEventListener('click', () => {
                const searchInput = document.getElementById('search-keyword-input');
                searchInput.value = '';
                searchInput.focus();
                document.getElementById('clear-search-keyword-btn').style.display = 'none';
                
                // Reset all filters
                document.getElementById('search-filter-sender').value = 'all';
                document.getElementById('search-filter-date-start').value = '';
                document.getElementById('search-filter-date-end').value = '';
                document.getElementById('search-filter-type').value = 'all';
                
                document.getElementById('search-empty-state').style.display = 'block';
                document.getElementById('search-results-list').style.display = 'none';
                document.getElementById('search-info-bar').style.display = 'none';
            });
            
            // Add filter change listeners
            ['search-filter-sender', 'search-filter-date-start', 'search-filter-date-end', 'search-filter-type'].forEach(id => {
                document.getElementById(id).addEventListener('change', () => {
                    const keyword = document.getElementById('search-keyword-input').value.trim();
                    if (keyword || document.getElementById('search-filter-sender').value !== 'all' || 
                        document.getElementById('search-filter-date-start').value || 
                        document.getElementById('search-filter-date-end').value || 
                        document.getElementById('search-filter-type').value !== 'all') {
                        performSearch(keyword);
                    }
                });
            });
            
            // Clear date filter button
            document.getElementById('clear-date-filter-btn').addEventListener('click', () => {
                document.getElementById('search-filter-date-start').value = '';
                document.getElementById('search-filter-date-end').value = '';
                const keyword = document.getElementById('search-keyword-input').value.trim();
                if (keyword || document.getElementById('search-filter-sender').value !== 'all' || 
                    document.getElementById('search-filter-type').value !== 'all') {
                    performSearch(keyword);
                } else {
                    document.getElementById('search-empty-state').style.display = 'block';
                    document.getElementById('search-results-list').style.display = 'none';
                    document.getElementById('search-info-bar').style.display = 'none';
                }
            });
            
            // Search input handler with debounce
            document.getElementById('search-keyword-input').addEventListener('input', (e) => {
                const keyword = e.target.value.trim();
                const clearBtn = document.getElementById('clear-search-keyword-btn');
                
                clearBtn.style.display = keyword ? 'block' : 'none';
                
                // Clear previous timer
                if (searchDebounceTimer) {
                    clearTimeout(searchDebounceTimer);
                }
                
                // Debounce search (300ms)
                if (keyword) {
                    searchDebounceTimer = setTimeout(() => {
                        performSearch(keyword);
                    }, 300);
                } else {
                    // Check if any filter is active
                    const hasActiveFilter = document.getElementById('search-filter-sender').value !== 'all' || 
                                           document.getElementById('search-filter-date-start').value || 
                                           document.getElementById('search-filter-date-end').value || 
                                           document.getElementById('search-filter-type').value !== 'all';
                    if (hasActiveFilter) {
                        performSearch('');
                    } else {
                        document.getElementById('search-empty-state').style.display = 'block';
                        document.getElementById('search-results-list').style.display = 'none';
                        document.getElementById('search-info-bar').style.display = 'none';
                    }
                }
            });
            
            // Perform search with large data optimization
            async function performSearch(keyword) {
                if (!currentSearchChatId || !currentSearchChatType) return;
                
                const loading = document.getElementById('search-loading');
                const emptyState = document.getElementById('search-empty-state');
                const resultsList = document.getElementById('search-results-list');
                const infoBar = document.getElementById('search-info-bar');
                const infoText = document.getElementById('search-info-text');
                
                try {
                    loading.style.display = 'block';
                    emptyState.style.display = 'none';
                    resultsList.style.display = 'none';
                    
                    // Get messages from database
                    const messages = await dataStorage.getChatMessages(currentSearchChatId, currentSearchChatType);
                    
                    if (!messages || messages.length === 0) {
                        loading.style.display = 'none';
                        emptyState.innerHTML = '<div style="font-size: 14px;">暂无聊天记录</div>';
                        emptyState.style.display = 'block';
                        return;
                    }
                    
                    // Get filter values
                    const filterSender = document.getElementById('search-filter-sender').value;
                    const filterDateStart = document.getElementById('search-filter-date-start').value;
                    const filterDateEnd = document.getElementById('search-filter-date-end').value;
                    const filterType = document.getElementById('search-filter-type').value;
                    
                    // Calculate date range for filter
                    let dateRangeStart = 0;
                    let dateRangeEnd = 0;
                    
                    if (filterDateStart) {
                        const startDate = new Date(filterDateStart);
                        startDate.setHours(0, 0, 0, 0);
                        dateRangeStart = startDate.getTime();
                    }
                    
                    if (filterDateEnd) {
                        const endDate = new Date(filterDateEnd);
                        endDate.setHours(23, 59, 59, 999);
                        dateRangeEnd = endDate.getTime();
                    }
                    
                    // Helper function to detect message type
                    function detectMessageType(content) {
                        if (/\[(?:.+?)发送的表情包[：:]/.test(content) || /\[(?:.+?)的表情包[：:]/.test(content)) return 'sticker';
                        if (/\[(?:.+?)的语音[：:]/.test(content)) return 'voice';
                        if (/\[(?:.+?)发来的照片\/视频[：:]/.test(content) || /^https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg)/i.test(content)) return 'image';
                        if (/\[(?:.+?)(?:给你)?转账[：:]/.test(content) || /\[(?:.+?)\s*向\s*(?:.+?)\s*转账[：:]/.test(content)) return 'transfer';
                        if (/\[(?:.+?)送来的礼物[：:]/.test(content) || /\[(?:.+?)\s*向\s*(?:.+?)\s*送来了礼物[：:]/.test(content)) return 'gift';
                        return 'text';
                    }
                    
                    // Search in chunks for better performance
                    const searchResults = [];
                    const lowerKeyword = keyword.toLowerCase();
                    const chunkSize = 100;
                    
                    for (let i = 0; i < messages.length; i += chunkSize) {
                        const chunk = messages.slice(i, Math.min(i + chunkSize, messages.length));
                        
                        chunk.forEach((msg, index) => {
                            // Apply sender filter
                            if (filterSender !== 'all') {
                                const isUser = msg.role === 'user';
                                if (filterSender === 'user') {
                                    // Filter for user's messages
                                    if (!isUser) return;
                                } else {
                                    // Filter for specific character/member
                                    if (isUser) return;
                                    // For group chats, check senderId matches the selected member
                                    if (currentSearchChatType === 'group' && msg.senderId !== filterSender) {
                                        return;
                                    }
                                    // For private chats, role='assistant' means the character
                                }
                            }
                            
                            // Apply date filter
                            if ((dateRangeStart || dateRangeEnd) && msg.timestamp) {
                                if (dateRangeStart && msg.timestamp < dateRangeStart) return;
                                if (dateRangeEnd && msg.timestamp > dateRangeEnd) return;
                            }
                            
                            let textContent = '';
                            let originalContent = '';
                            
                            // Extract text from message parts
                            if (msg.parts && Array.isArray(msg.parts)) {
                                originalContent = msg.parts
                                    .filter(part => part.type === 'text')
                                    .map(part => part.text)
                                    .join(' ');
                            } else if (msg.content) {
                                originalContent = msg.content;
                            }
                            
                            // Apply type filter
                            if (filterType !== 'all') {
                                const msgType = detectMessageType(originalContent);
                                if (msgType !== filterType) return;
                            }
                            
                            // Extract clean text content for display
                            textContent = originalContent;
                            
                            // Remove message format brackets like [xxx的消息：...] or [xxx发送的表情包：...]
                            const messageFormatRegex = /\[(?:.+?)的消息[：:]([\s\S]+?)\]|\[(?:.+?)发送的表情包[：:]([\s\S]+?)\]|\[(?:.+?)发来的照片\/视频[：:]([\s\S]+?)\]|\[(?:.+?)的语音[：:]([\s\S]+?)\]/g;
                            textContent = textContent.replace(messageFormatRegex, (match, g1, g2, g3, g4) => {
                                return g1 || g2 || g3 || g4 || '';
                            });
                            
                            // Also extract text from other special formats for search
                            let searchableText = textContent;
                            // Extract text from transfers
                            const transferMatch = originalContent.match(/转账[：:]([\d.]+)元[；;]备注[：:](.+?)\]/);
                            if (transferMatch) {
                                searchableText += ' ' + transferMatch[1] + '元 ' + transferMatch[2];
                            }
                            // Extract text from gifts
                            const giftMatch = originalContent.match(/礼物[：:](.+?)\]/);
                            if (giftMatch) {
                                searchableText += ' ' + giftMatch[1];
                            }
                            
                            // Check if keyword matches (if keyword is provided)
                            if (!keyword || searchableText.toLowerCase().includes(lowerKeyword)) {
                                searchResults.push({
                                    message: msg,
                                    content: textContent,
                                    originalContent: originalContent,
                                    index: i + index
                                });
                            }
                        });
                        
                        // Yield to UI thread every chunk
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                    
                    loading.style.display = 'none';
                    
                    // Display results
                    if (searchResults.length === 0) {
                        emptyState.innerHTML = '<div style="font-size: 14px;">未找到匹配的聊天记录</div>';
                        emptyState.style.display = 'block';
                    } else {
                        infoText.textContent = `找到 ${searchResults.length} 条匹配记录`;
                        infoBar.style.display = 'block';
                        renderSearchResults(searchResults, keyword);
                        resultsList.style.display = 'block';
                    }
                } catch (error) {
                    console.error('搜索失败:', error);
                    loading.style.display = 'none';
                    emptyState.innerHTML = '<div style="font-size: 14px;">搜索失败，请重试</div>';
                    emptyState.style.display = 'block';
                }
            }
            
            // Render search results
            function renderSearchResults(results, keyword) {
                const resultsList = document.getElementById('search-results-list');
                resultsList.innerHTML = '';
                
                // Get chat info
                let chatInfo = null;
                if (currentSearchChatType === 'private') {
                    chatInfo = db.characters.find(c => c.id === currentSearchChatId);
                } else {
                    chatInfo = db.groups.find(g => g.id === currentSearchChatId);
                }
                
                if (!chatInfo) return;
                
                results.forEach(result => {
                    const msg = result.message;
                    const isUser = msg.role === 'user';
                    
                    // Get sender info
                    let avatar = '';
                    let senderName = '';
                    
                    if (currentSearchChatType === 'private') {
                        if (isUser) {
                            avatar = chatInfo.myAvatar || 'https://i.postimg.cc/nzP9sgxr/chan-125.png';
                            senderName = chatInfo.myName || 'USER';
                        } else {
                            avatar = chatInfo.avatar || 'https://i.postimg.cc/nzP9sgxr/chan-125.png';
                            senderName = chatInfo.remarkName || chatInfo.realName || '角色';
                        }
                    } else {
                        // Group chat
                        if (isUser) {
                            avatar = chatInfo.myAvatar || 'https://i.postimg.cc/nzP9sgxr/chan-125.png';
                            senderName = chatInfo.myName || 'USER';
                        } else {
                            // Find member by sender ID
                            const member = chatInfo.members?.find(m => m.id === msg.senderId);
                            if (member) {
                                avatar = member.avatar || 'https://i.postimg.cc/nzP9sgxr/chan-125.png';
                                senderName = `${member.groupNickname} (${member.realName})`;
                            } else {
                                avatar = 'https://i.postimg.cc/nzP9sgxr/chan-125.png';
                                senderName = '未知成员';
                            }
                        }
                    }
                    
                    // Format timestamp
                    const date = new Date(msg.timestamp);
                    const timeStr = date.toLocaleString('zh-CN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit'
                    });
                    
                    // Detect message type and add type badge
                    let typeBadge = '';
                    const originalContent = result.originalContent || result.content;
                    if (/\[(?:.+?)发送的表情包[：:]/.test(originalContent) || /\[(?:.+?)的表情包[：:]/.test(originalContent)) {
                        typeBadge = '<span style="display: inline-block; background: #ff9800; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-right: 6px;">表情包</span>';
                    } else if (/\[(?:.+?)的语音[：:]/.test(originalContent)) {
                        typeBadge = '<span style="display: inline-block; background: #4caf50; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-right: 6px;">语音</span>';
                    } else if (/\[(?:.+?)发来的照片\/视频[：:]/.test(originalContent) || /^https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|webp|bmp|svg)/i.test(originalContent)) {
                        typeBadge = '<span style="display: inline-block; background: #2196f3; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-right: 6px;">图片</span>';
                    } else if (/\[(?:.+?)(?:给你)?转账[：:]/.test(originalContent) || /\[(?:.+?)\s*向\s*(?:.+?)\s*转账[：:]/.test(originalContent)) {
                        typeBadge = '<span style="display: inline-block; background: #f44336; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-right: 6px;">转账</span>';
                    } else if (/\[(?:.+?)送来的礼物[：:]/.test(originalContent) || /\[(?:.+?)\s*向\s*(?:.+?)\s*送来了礼物[：:]/.test(originalContent)) {
                        typeBadge = '<span style="display: inline-block; background: #e91e63; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-right: 6px;">礼物</span>';
                    }
                    
                    // Highlight keyword in content
                    let highlightedContent = result.content;
                    if (keyword) {
                        const regex = new RegExp(`(${keyword})`, 'gi');
                        highlightedContent = highlightedContent.replace(regex, '<mark style="background: #ffeb3b; padding: 2px 4px; border-radius: 3px;">$1</mark>');
                    }
                    
                    // Truncate content if too long
                    const maxLength = 200;
                    if (highlightedContent.length > maxLength) {
                        if (keyword) {
                            const keywordIndex = highlightedContent.toLowerCase().indexOf(keyword.toLowerCase());
                            if (keywordIndex >= 0) {
                                const start = Math.max(0, keywordIndex - 50);
                                const end = Math.min(highlightedContent.length, keywordIndex + maxLength - 50);
                                highlightedContent = (start > 0 ? '...' : '') + highlightedContent.substring(start, end) + (end < highlightedContent.length ? '...' : '');
                            } else {
                                highlightedContent = highlightedContent.substring(0, maxLength) + '...';
                            }
                        } else {
                            highlightedContent = highlightedContent.substring(0, maxLength) + '...';
                        }
                    }
                    
                    const resultItem = document.createElement('div');
                    resultItem.style.cssText = 'background: white; border-radius: 12px; padding: 12px; margin-bottom: 10px; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.1); transition: transform 0.2s, box-shadow 0.2s;';
                    resultItem.innerHTML = `
                        <div style="display: flex; align-items: flex-start; gap: 10px;">
                            <img src="${avatar}" alt="${senderName}" style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover; flex-shrink: 0;">
                            <div style="flex: 1; min-width: 0;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                    <div style="font-weight: 600; font-size: 14px; color: #333;">${senderName}</div>
                                    <div style="font-size: 11px; color: #999;">${timeStr}</div>
                                </div>
                                <div style="font-size: 13px; color: #555; line-height: 1.5; word-break: break-word;">${typeBadge}${highlightedContent}</div>
                            </div>
                        </div>
                    `;
                    
                    resultItem.addEventListener('mouseenter', () => {
                        resultItem.style.transform = 'translateY(-2px)';
                        resultItem.style.boxShadow = '0 4px 12px rgba(0,0,0,0.15)';
                    });
                    
                    resultItem.addEventListener('mouseleave', () => {
                        resultItem.style.transform = 'translateY(0)';
                        resultItem.style.boxShadow = '0 1px 3px rgba(0,0,0,0.1)';
                    });
                    
                    resultItem.addEventListener('click', () => {
                        jumpToMessage(msg.id, result.index);
                    });
                    
                    resultsList.appendChild(resultItem);
                });
            }
            
            // Jump to message in chat
            function jumpToMessage(messageId, messageIndex) {
                // Close search modal
                document.getElementById('chat-search-modal').style.display = 'none';
                
                // Close settings sidebar if open
                document.querySelector('.settings-sidebar.open')?.classList.remove('open');
                
                // Switch to chat room if not already there
                const chatRoomScreen = document.getElementById('chat-room-screen');
                if (!chatRoomScreen.classList.contains('active')) {
                    switchScreen('chat-room-screen');
                }
                
                // Calculate which page the message is on
                const targetPage = Math.floor(messageIndex / MESSAGES_PER_PAGE) + 1;
                
                // Load the correct page
                currentPage = targetPage;
                renderMessages(false, false);
                
                // Wait for render, then scroll to message
                setTimeout(() => {
                    const messageElement = document.querySelector(`[data-id="${messageId}"]`);
                    if (messageElement) {
                        messageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        
                        // Highlight the message temporarily
                        messageElement.style.transition = 'background-color 0.3s';
                        messageElement.style.backgroundColor = 'rgba(255, 235, 59, 0.3)';
                        
                        setTimeout(() => {
                            messageElement.style.backgroundColor = '';
                        }, 2000);
                    }
                }, 300);
            }
            
            // 【全新】拉黑功能事件绑定
            document.getElementById('block-chat-btn').addEventListener('click', async () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;

                // 检查当前是否已拉黑
                if (character.relationship?.status === 'blocked_by_user') {
                    // 解除拉黑
                    const confirmed = confirm(`确定要解除对"${character.remarkName}"的拉黑吗？`);
                    
                    if (confirmed) {
                        character.relationship.status = 'friend';
                        character.relationship.blockedTimestamp = null;

                        // 添加隐藏的系统消息
                        const hiddenMessage = {
                            id: `msg_${Date.now()}`,
                            role: 'system',
                            content: `[系统提示：用户刚刚解除了对你的拉黑。现在你们可以重新开始对话了。]`,
                            parts: [{type: 'text', text: `[系统提示：用户刚刚解除了对你的拉黑。现在你们可以重新开始对话了。]`}],
                            timestamp: Date.now(),
                            isHidden: true
                        };
                        character.history.push(hiddenMessage);

                        await saveData();
                        
                        // 关闭设置侧边栏，并刷新聊天界面
                        settingsSidebar.classList.remove('open');
                        renderMessages(false, true);
                        renderChatList();
                        showToast(`已解除对"${character.remarkName}"的拉黑`);
                        
                        // 重新打开聊天界面以更新输入框状态
                        openChatRoom(currentChatId, 'private');
                    }
                } else {
                    // 拉黑操作
                    const confirmed = confirm(`确定要拉黑"${character.remarkName}"吗？拉黑后您将无法向其发送消息，直到您将Ta移出黑名单，或等待Ta重新申请好友。`);

                    if (confirmed) {
                        // 初始化relationship对象（如果不存在）
                        if (!character.relationship) {
                            character.relationship = { status: 'friend' };
                        }
                        
                        character.relationship.status = 'blocked_by_user';
                        character.relationship.blockedTimestamp = Date.now();

                        // 添加隐藏的系统消息
                        const hiddenMessage = {
                            id: `msg_${Date.now()}`,
                            role: 'system',
                            content: `[系统提示：你刚刚被用户拉黑了。在对方解除拉黑之前，你无法再主动发起对话，也无法回应。]`,
                            parts: [{type: 'text', text: `[系统提示：你刚刚被用户拉黑了。在对方解除拉黑之前，你无法再主动发起对话，也无法回应。]`}],
                            timestamp: Date.now() + 1,
                            isHidden: true
                        };
                        character.history.push(hiddenMessage);

                        await saveData();
                        
                        // 关闭设置侧边栏，并刷新聊天界面
                        settingsSidebar.classList.remove('open');
                        renderMessages(false, true);
                        renderChatList();
                        showToast(`已拉黑"${character.remarkName}"`);
                        
                        // 重新打开聊天界面以更新输入框状态
                        openChatRoom(currentChatId, 'private');
                    }
                }
            });

            clearChatHistoryBtn.addEventListener('click', async () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                if (confirm(`你确定要清空与"${character.remarkName}"的所有聊天记录吗？这个操作是不可恢复的！`)) {
                    character.history = [];
                    character.status = '在线'; // 重置在线状态为默认值
                    character.autoSummarizedFloors = []; // 清空已总结记录
                    // 清空数据库中的消息chunks
                    await dataStorage.clearChatMessages(character.id, 'private');
                    await saveData();
                    renderMessages(false, true);
                    renderChatList();
                    // 实时更新状态显示
                    chatRoomStatusText.textContent = character.status;
                    settingsSidebar.classList.remove('open');
                    showToast('聊天记录已清空');
                }
            });
            
            // Export Private Chat History
            exportChatHistoryBtn.addEventListener('click', () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                if (!character.history || character.history.length === 0) {
                    showToast('当前没有聊天记录可导出');
                    return;
                }
                
                // Prepare export data
                const exportData = {
                    exportTime: new Date().toISOString(),
                    chatType: 'private',
                    character: {
                        name: character.remarkName,
                        realName: character.realName,
                        persona: character.persona
                    },
                    user: {
                        name: character.myName,
                        persona: character.myPersona
                    },
                    messageCount: character.history.length,
                    messages: character.history.map(msg => ({
                        id: msg.id,
                        role: msg.role,
                        content: msg.content,
                        timestamp: msg.timestamp,
                        time: new Date(msg.timestamp).toLocaleString('zh-CN'),
                        parts: msg.parts
                    }))
                };
                
                // Create download link
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `聊天记录_${character.remarkName}_${new Date().toLocaleDateString('zh-CN').replace(/\//g, '-')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showToast('聊天记录已导出');
            });
            
            // Import Private Chat History
            importChatHistoryBtn.addEventListener('click', () => {
                importChatHistoryInput.click();
            });
            
            importChatHistoryInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const importData = JSON.parse(text);
                    
                    // Validate import data
                    if (!importData.messages || !Array.isArray(importData.messages)) {
                        showToast('导入失败：文件格式不正确');
                        return;
                    }
                    
                    const character = db.characters.find(c => c.id === currentChatId);
                    if (!character) {
                        showToast('导入失败：未找到当前角色');
                        return;
                    }
                    
                    // Ask user: replace or append
                    const shouldReplace = confirm(
                        `检测到 ${importData.messageCount || importData.messages.length} 条消息。\n\n` +
                        `点击"确定"：替换当前所有聊天记录\n` +
                        `点击"取消"：追加到现有聊天记录末尾`
                    );
                    
                    if (shouldReplace) {
                        // Replace all messages
                        character.history = importData.messages.map(msg => ({
                            id: msg.id || `msg_${Date.now()}_${Math.random()}`,
                            role: msg.role,
                            content: msg.content,
                            timestamp: msg.timestamp || Date.now(),
                            parts: msg.parts || null
                        }));
                    } else {
                        // Append messages
                        const newMessages = importData.messages.map(msg => ({
                            id: msg.id || `msg_${Date.now()}_${Math.random()}`,
                            role: msg.role,
                            content: msg.content,
                            timestamp: msg.timestamp || Date.now(),
                            parts: msg.parts || null
                        }));
                        character.history.push(...newMessages);
                    }
                    
                    await saveData();
                    currentPage = 1;
                    renderMessages(false, true);
                    renderChatList();
                    
                    showToast(`成功导入 ${importData.messages.length} 条消息`);
                } catch (error) {
                    console.error('导入失败:', error);
                    showToast('导入失败：' + error.message);
                }
                
                e.target.value = '';
            });
            
            // Custom theme color button handler for private chat
            document.getElementById('apply-custom-theme-btn').addEventListener('click', async () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                const charBg = document.getElementById('setting-custom-char-bg').value;
                const charText = document.getElementById('setting-custom-char-text').value;
                const userBg = document.getElementById('setting-custom-user-bg').value;
                const userText = document.getElementById('setting-custom-user-text').value;
                
                character.customTheme = {
                    received: { bg: charBg, text: charText },
                    sent: { bg: userBg, text: userText }
                };
                
                await saveData();
                currentPage = 1;
                renderMessages(false, true);
                showToast('自定义颜色已应用！');
            });
            
            // Reset custom theme button handler for private chat
            document.getElementById('reset-custom-theme-btn').addEventListener('click', async () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                // Remove custom theme
                delete character.customTheme;
                
                // Reset color inputs to current theme defaults
                const defaultTheme = colorThemes[character.theme || 'white_pink'];
                document.getElementById('setting-custom-char-bg').value = defaultTheme.received.bg;
                document.getElementById('setting-custom-char-text').value = defaultTheme.received.text;
                document.getElementById('setting-custom-user-bg').value = defaultTheme.sent.bg;
                document.getElementById('setting-custom-user-text').value = defaultTheme.sent.text;
                
                await saveData();
                currentPage = 1;
                renderMessages(false, true);
                showToast('已重置为默认气泡！');
            });
            
            // Theme Preset Management Functions
            function refreshThemePresetDropdown(selectId) {
                const select = document.getElementById(selectId);
                if (!select) return;
                
                select.innerHTML = '<option value="">-- 选择预设 --</option>';
                db.themePresets.forEach(preset => {
                    const option = document.createElement('option');
                    option.value = preset.id;
                    option.textContent = preset.name;
                    select.appendChild(option);
                });
            }
            
            // Private Chat - Save Theme Preset
            document.getElementById('save-theme-preset-btn').addEventListener('click', async () => {
                const charBg = document.getElementById('setting-custom-char-bg').value;
                const charText = document.getElementById('setting-custom-char-text').value;
                const userBg = document.getElementById('setting-custom-user-bg').value;
                const userText = document.getElementById('setting-custom-user-text').value;
                
                const name = prompt('请输入预设名称：');
                if (!name || !name.trim()) {
                    showToast('预设名称不能为空');
                    return;
                }
                
                const preset = {
                    id: 'preset_' + Date.now(),
                    name: name.trim(),
                    colors: {
                        received: { bg: charBg, text: charText },
                        sent: { bg: userBg, text: userText }
                    }
                };
                
                db.themePresets.push(preset);
                await saveData();
                refreshThemePresetDropdown('theme-preset-select');
                refreshThemePresetDropdown('group-theme-preset-select');
                showToast('预设已保存！');
            });
            
            // Private Chat - Load Theme Preset
            document.getElementById('load-theme-preset-btn').addEventListener('click', () => {
                const select = document.getElementById('theme-preset-select');
                const presetId = select.value;
                
                if (!presetId) {
                    showToast('请先选择一个预设');
                    return;
                }
                
                const preset = db.themePresets.find(p => p.id === presetId);
                if (!preset) {
                    showToast('预设不存在');
                    return;
                }
                
                document.getElementById('setting-custom-char-bg').value = preset.colors.received.bg;
                document.getElementById('setting-custom-char-text').value = preset.colors.received.text;
                document.getElementById('setting-custom-user-bg').value = preset.colors.sent.bg;
                document.getElementById('setting-custom-user-text').value = preset.colors.sent.text;
                
                showToast('预设已加载到颜色选择器');
            });
            
            // Private Chat - Delete Theme Preset
            document.getElementById('delete-theme-preset-btn').addEventListener('click', () => {
                if (db.themePresets.length === 0) {
                    showToast('没有可删除的预设');
                    return;
                }
                
                const modal = document.getElementById('delete-theme-preset-modal');
                const list = document.getElementById('theme-preset-delete-list');
                list.innerHTML = '';
                
                db.themePresets.forEach(preset => {
                    const li = document.createElement('li');
                    li.style.cssText = 'padding: 10px; border-bottom: 1px solid #eee;';
                    li.innerHTML = `
                        <input type="checkbox" id="preset-delete-${preset.id}" value="${preset.id}" style="margin-right: 8px;">
                        <label for="preset-delete-${preset.id}" style="cursor: pointer;">${preset.name}</label>
                    `;
                    list.appendChild(li);
                });
                
                modal.classList.add('visible');
            });
            
            // Group Chat - Save Theme Preset
            document.getElementById('save-group-theme-preset-btn').addEventListener('click', async () => {
                const charBg = document.getElementById('setting-group-custom-char-bg').value;
                const charText = document.getElementById('setting-group-custom-char-text').value;
                const userBg = document.getElementById('setting-group-custom-user-bg').value;
                const userText = document.getElementById('setting-group-custom-user-text').value;
                
                const name = prompt('请输入预设名称：');
                if (!name || !name.trim()) {
                    showToast('预设名称不能为空');
                    return;
                }
                
                const preset = {
                    id: 'preset_' + Date.now(),
                    name: name.trim(),
                    colors: {
                        received: { bg: charBg, text: charText },
                        sent: { bg: userBg, text: userText }
                    }
                };
                
                db.themePresets.push(preset);
                await saveData();
                refreshThemePresetDropdown('theme-preset-select');
                refreshThemePresetDropdown('group-theme-preset-select');
                showToast('预设已保存！');
            });
            
            // Group Chat - Load Theme Preset
            document.getElementById('load-group-theme-preset-btn').addEventListener('click', () => {
                const select = document.getElementById('group-theme-preset-select');
                const presetId = select.value;
                
                if (!presetId) {
                    showToast('请先选择一个预设');
                    return;
                }
                
                const preset = db.themePresets.find(p => p.id === presetId);
                if (!preset) {
                    showToast('预设不存在');
                    return;
                }
                
                document.getElementById('setting-group-custom-char-bg').value = preset.colors.received.bg;
                document.getElementById('setting-group-custom-char-text').value = preset.colors.received.text;
                document.getElementById('setting-group-custom-user-bg').value = preset.colors.sent.bg;
                document.getElementById('setting-group-custom-user-text').value = preset.colors.sent.text;
                
                showToast('预设已加载到颜色选择器');
            });
            
            // Group Chat - Delete Theme Preset
            document.getElementById('delete-group-theme-preset-btn').addEventListener('click', () => {
                if (db.themePresets.length === 0) {
                    showToast('没有可删除的预设');
                    return;
                }
                
                const modal = document.getElementById('delete-theme-preset-modal');
                const list = document.getElementById('theme-preset-delete-list');
                list.innerHTML = '';
                
                db.themePresets.forEach(preset => {
                    const li = document.createElement('li');
                    li.style.cssText = 'padding: 10px; border-bottom: 1px solid #eee;';
                    li.innerHTML = `
                        <input type="checkbox" id="preset-delete-${preset.id}" value="${preset.id}" style="margin-right: 8px;">
                        <label for="preset-delete-${preset.id}" style="cursor: pointer;">${preset.name}</label>
                    `;
                    list.appendChild(li);
                });
                
                modal.classList.add('visible');
            });
            
            // Delete Theme Preset Modal - Select All
            document.getElementById('theme-preset-select-all').addEventListener('change', function() {
                const checkboxes = document.querySelectorAll('#theme-preset-delete-list input[type="checkbox"]');
                checkboxes.forEach(cb => cb.checked = this.checked);
            });
            
            // Delete Theme Preset Modal - Confirm Delete
            document.getElementById('confirm-delete-theme-preset-btn').addEventListener('click', async () => {
                const checkedBoxes = document.querySelectorAll('#theme-preset-delete-list input[type="checkbox"]:checked');
                const idsToDelete = Array.from(checkedBoxes).map(cb => cb.value);
                
                if (idsToDelete.length === 0) {
                    showToast('请至少选择一个预设');
                    return;
                }
                
                if (!confirm(`确定要删除选中的 ${idsToDelete.length} 个预设吗？`)) {
                    return;
                }
                
                db.themePresets = db.themePresets.filter(p => !idsToDelete.includes(p.id));
                await saveData();
                refreshThemePresetDropdown('theme-preset-select');
                refreshThemePresetDropdown('group-theme-preset-select');
                
                document.getElementById('delete-theme-preset-modal').classList.remove('visible');
                document.getElementById('theme-preset-select-all').checked = false;
                showToast(`已删除 ${idsToDelete.length} 个预设`);
            });
            
            // Delete Theme Preset Modal - Cancel
            document.getElementById('cancel-delete-theme-preset-btn').addEventListener('click', () => {
                document.getElementById('delete-theme-preset-modal').classList.remove('visible');
                document.getElementById('theme-preset-select-all').checked = false;
            });
            
            // Bubble Style Preset Management Functions
            function refreshBubbleStylePresetDropdown(selectId) {
                const select = document.getElementById(selectId);
                if (!select) return;
                
                select.innerHTML = '<option value="">-- 选择预设 --</option>';
                db.bubbleStylePresets.forEach(preset => {
                    const option = document.createElement('option');
                    option.value = preset.id;
                    option.textContent = preset.name;
                    select.appendChild(option);
                });
            }
            
            // Private Chat - Save Bubble Style Preset
            document.getElementById('save-bubble-style-preset-btn').addEventListener('click', async () => {
                const customCss = document.getElementById('setting-custom-bubble-css').value;
                
                if (!customCss || !customCss.trim()) {
                    showToast('气泡样式不能为空');
                    return;
                }
                
                const name = prompt('请输入预设名称：');
                if (!name || !name.trim()) {
                    showToast('预设名称不能为空');
                    return;
                }
                
                const preset = {
                    id: 'bubble_preset_' + Date.now(),
                    name: name.trim(),
                    css: customCss.trim()
                };
                
                db.bubbleStylePresets.push(preset);
                await saveData();
                refreshBubbleStylePresetDropdown('bubble-style-preset-select');
                refreshBubbleStylePresetDropdown('group-bubble-style-preset-select');
                showToast('气泡样式预设已保存！');
            });
            
            // Private Chat - Load Bubble Style Preset
            document.getElementById('load-bubble-style-preset-btn').addEventListener('click', () => {
                const select = document.getElementById('bubble-style-preset-select');
                const presetId = select.value;
                
                if (!presetId) {
                    showToast('请先选择一个预设');
                    return;
                }
                
                const preset = db.bubbleStylePresets.find(p => p.id === presetId);
                if (!preset) {
                    showToast('预设不存在');
                    return;
                }
                
                document.getElementById('setting-custom-bubble-css').value = preset.css;
                showToast('预设已加载');
            });
            
            // Private Chat - Delete Bubble Style Preset
            document.getElementById('delete-bubble-style-preset-btn').addEventListener('click', () => {
                if (db.bubbleStylePresets.length === 0) {
                    showToast('没有可删除的预设');
                    return;
                }
                
                const modal = document.getElementById('delete-bubble-style-preset-modal');
                const list = document.getElementById('bubble-style-preset-delete-list');
                list.innerHTML = '';
                
                db.bubbleStylePresets.forEach(preset => {
                    const li = document.createElement('li');
                    li.style.cssText = 'padding: 10px; border-bottom: 1px solid #eee;';
                    li.innerHTML = `
                        <input type="checkbox" id="bubble-preset-delete-${preset.id}" value="${preset.id}" style="margin-right: 8px;">
                        <label for="bubble-preset-delete-${preset.id}" style="cursor: pointer;">${preset.name}</label>
                    `;
                    list.appendChild(li);
                });
                
                modal.classList.add('visible');
            });
            
            // Group Chat - Save Bubble Style Preset
            document.getElementById('save-group-bubble-style-preset-btn').addEventListener('click', async () => {
                const customCss = document.getElementById('setting-group-custom-bubble-css').value;
                
                if (!customCss || !customCss.trim()) {
                    showToast('气泡样式不能为空');
                    return;
                }
                
                const name = prompt('请输入预设名称：');
                if (!name || !name.trim()) {
                    showToast('预设名称不能为空');
                    return;
                }
                
                const preset = {
                    id: 'bubble_preset_' + Date.now(),
                    name: name.trim(),
                    css: customCss.trim()
                };
                
                db.bubbleStylePresets.push(preset);
                await saveData();
                refreshBubbleStylePresetDropdown('bubble-style-preset-select');
                refreshBubbleStylePresetDropdown('group-bubble-style-preset-select');
                showToast('气泡样式预设已保存！');
            });
            
            // Group Chat - Load Bubble Style Preset
            document.getElementById('load-group-bubble-style-preset-btn').addEventListener('click', () => {
                const select = document.getElementById('group-bubble-style-preset-select');
                const presetId = select.value;
                
                if (!presetId) {
                    showToast('请先选择一个预设');
                    return;
                }
                
                const preset = db.bubbleStylePresets.find(p => p.id === presetId);
                if (!preset) {
                    showToast('预设不存在');
                    return;
                }
                
                document.getElementById('setting-group-custom-bubble-css').value = preset.css;
                showToast('预设已加载');
            });
            
            // Group Chat - Delete Bubble Style Preset
            document.getElementById('delete-group-bubble-style-preset-btn').addEventListener('click', () => {
                if (db.bubbleStylePresets.length === 0) {
                    showToast('没有可删除的预设');
                    return;
                }
                
                const modal = document.getElementById('delete-bubble-style-preset-modal');
                const list = document.getElementById('bubble-style-preset-delete-list');
                list.innerHTML = '';
                
                db.bubbleStylePresets.forEach(preset => {
                    const li = document.createElement('li');
                    li.style.cssText = 'padding: 10px; border-bottom: 1px solid #eee;';
                    li.innerHTML = `
                        <input type="checkbox" id="bubble-preset-delete-${preset.id}" value="${preset.id}" style="margin-right: 8px;">
                        <label for="bubble-preset-delete-${preset.id}" style="cursor: pointer;">${preset.name}</label>
                    `;
                    list.appendChild(li);
                });
                
                modal.classList.add('visible');
            });
            
            // Delete Bubble Style Preset Modal - Select All
            document.getElementById('bubble-style-preset-select-all').addEventListener('change', function() {
                const checkboxes = document.querySelectorAll('#bubble-style-preset-delete-list input[type="checkbox"]');
                checkboxes.forEach(cb => cb.checked = this.checked);
            });
            
            // Delete Bubble Style Preset Modal - Confirm Delete
            document.getElementById('confirm-delete-bubble-style-preset-btn').addEventListener('click', async () => {
                const checkedBoxes = document.querySelectorAll('#bubble-style-preset-delete-list input[type="checkbox"]:checked');
                const idsToDelete = Array.from(checkedBoxes).map(cb => cb.value);
                
                if (idsToDelete.length === 0) {
                    showToast('请至少选择一个预设');
                    return;
                }
                
                if (!confirm(`确定要删除选中的 ${idsToDelete.length} 个预设吗？`)) {
                    return;
                }
                
                db.bubbleStylePresets = db.bubbleStylePresets.filter(p => !idsToDelete.includes(p.id));
                await saveData();
                refreshBubbleStylePresetDropdown('bubble-style-preset-select');
                refreshBubbleStylePresetDropdown('group-bubble-style-preset-select');
                
                document.getElementById('delete-bubble-style-preset-modal').classList.remove('visible');
                document.getElementById('bubble-style-preset-select-all').checked = false;
                showToast(`已删除 ${idsToDelete.length} 个预设`);
            });
            
            // Delete Bubble Style Preset Modal - Cancel
            document.getElementById('cancel-delete-bubble-style-preset-btn').addEventListener('click', () => {
                document.getElementById('delete-bubble-style-preset-modal').classList.remove('visible');
                document.getElementById('bubble-style-preset-select-all').checked = false;
            });
            
            // ===== Persona Presets Management =====
            let currentPersonaPresetContext = null; // 'private' or 'group'
            
            // Open Persona Presets Modal for Private Chat
            document.getElementById('manage-persona-presets-btn').addEventListener('click', () => {
                currentPersonaPresetContext = 'private';
                renderPersonaPresetsList();
                document.getElementById('persona-presets-modal').classList.add('visible');
            });
            
            // Open Persona Presets Modal for Group Chat
            document.getElementById('group-manage-persona-presets-btn').addEventListener('click', () => {
                currentPersonaPresetContext = 'group';
                renderPersonaPresetsList();
                document.getElementById('persona-presets-modal').classList.add('visible');
            });
            
            // Close Persona Presets Modal
            document.getElementById('close-persona-presets-btn').addEventListener('click', () => {
                document.getElementById('persona-presets-modal').classList.remove('visible');
            });
            
            // Add New Persona Preset
            document.getElementById('add-new-persona-preset-btn').addEventListener('click', async () => {
                const choice = await showChoiceModal('选择创建方式', [
                    { text: '手动创建预设', value: 'manual' },
                    { text: 'AI生成预设', value: 'ai-generate' }
                ]);
                
                if (choice === 'manual') {
                    document.getElementById('edit-persona-preset-title').textContent = '添加人设预设';
                    document.getElementById('edit-persona-preset-id').value = '';
                    document.getElementById('persona-preset-name').value = '';
                    document.getElementById('persona-preset-description').value = '';
                    document.getElementById('persona-preset-avatar-preview').src = 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg';
                    document.getElementById('edit-persona-preset-modal').classList.add('visible');
                } else if (choice === 'ai-generate') {
                    document.getElementById('ai-generate-persona-modal').classList.add('visible');
                }
            });
            
            // Cancel Edit Persona Preset
            document.getElementById('cancel-edit-persona-preset-btn').addEventListener('click', () => {
                document.getElementById('edit-persona-preset-modal').classList.remove('visible');
            });
            
            // Persona Preset Avatar Upload
            document.getElementById('persona-preset-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {
                            quality: 0.8,
                            maxWidth: 512,
                            maxHeight: 512
                        });
                        document.getElementById('persona-preset-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        console.error('头像压缩失败:', error);
                        showToast('头像处理失败，请重试');
                    }
                }
            });
            
            // Save Persona Preset
            document.getElementById('edit-persona-preset-form').addEventListener('submit', async (e) => {
                e.preventDefault();
                const id = document.getElementById('edit-persona-preset-id').value;
                const name = document.getElementById('persona-preset-name').value.trim();
                const description = document.getElementById('persona-preset-description').value.trim();
                const avatar = document.getElementById('persona-preset-avatar-preview').src;
                
                if (!name || !description) {
                    showToast('请填写完整信息');
                    return;
                }
                
                const preset = {
                    id: id || `persona_${Date.now()}`,
                    name,
                    description,
                    avatar,
                    createdAt: id ? (db.personaPresets.find(p => p.id === id)?.createdAt || Date.now()) : Date.now()
                };
                
                if (id) {
                    const index = db.personaPresets.findIndex(p => p.id === id);
                    if (index > -1) {
                        db.personaPresets[index] = preset;
                    }
                } else {
                    db.personaPresets.push(preset);
                }
                
                await saveData();
                renderPersonaPresetsList();
                document.getElementById('edit-persona-preset-modal').classList.remove('visible');
                showToast('人设预设已保存');
            });
            
            // Import Persona JSON
            document.getElementById('import-persona-json-btn').addEventListener('click', () => {
                document.getElementById('import-persona-json-input').click();
            });
            
            let pendingPersonasToImport = []; // Store pending personas for import
            
            document.getElementById('import-persona-json-input').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const jsonData = JSON.parse(text);
                    
                    // Parse TavernAI persona format
                    if (jsonData.personas && jsonData.persona_descriptions) {
                        pendingPersonasToImport = [];
                        
                        for (const [avatarKey, name] of Object.entries(jsonData.personas)) {
                            const personaData = jsonData.persona_descriptions[avatarKey];
                            if (personaData && personaData.description) {
                                pendingPersonasToImport.push({
                                    avatarKey,
                                    name,
                                    description: personaData.description
                                });
                            }
                        }
                        
                        if (pendingPersonasToImport.length > 0) {
                            // Show selection modal
                            renderPersonaImportList();
                            document.getElementById('select-personas-import-modal').classList.add('visible');
                        } else {
                            showToast('未找到可导入的人设');
                        }
                    } else {
                        showToast('JSON格式不正确');
                    }
                } catch (error) {
                    console.error('导入失败:', error);
                    showToast('导入失败：' + error.message);
                }
                
                e.target.value = '';
            });
            
            // Render Persona Import Selection List
            function renderPersonaImportList() {
                const listEl = document.getElementById('persona-import-list');
                const selectAllCheckbox = document.getElementById('persona-import-select-all');
                const selectedCountEl = document.getElementById('persona-import-selected-count');
                
                listEl.innerHTML = '';
                
                pendingPersonasToImport.forEach((persona, index) => {
                    const item = document.createElement('div');
                    item.className = 'persona-import-item';
                    
                    const descPreview = persona.description.length > 100 
                        ? persona.description.substring(0, 100) + '...' 
                        : persona.description;
                    
                    item.innerHTML = `
                        <input type="checkbox" class="persona-import-checkbox" data-index="${index}" checked>
                        <div class="persona-import-item-content">
                            <div class="persona-import-item-name">${persona.name}</div>
                            <div class="persona-import-item-preview">${descPreview}</div>
                        </div>
                    `;
                    
                    // Click item to toggle checkbox
                    item.addEventListener('click', (e) => {
                        if (e.target.tagName !== 'INPUT') {
                            const checkbox = item.querySelector('input[type="checkbox"]');
                            checkbox.checked = !checkbox.checked;
                            updatePersonaImportCount();
                        }
                    });
                    
                    // Checkbox change
                    item.querySelector('input[type="checkbox"]').addEventListener('change', () => {
                        updatePersonaImportCount();
                    });
                    
                    listEl.appendChild(item);
                });
                
                // Select All functionality
                selectAllCheckbox.checked = true;
                selectAllCheckbox.addEventListener('change', (e) => {
                    const checkboxes = listEl.querySelectorAll('.persona-import-checkbox');
                    checkboxes.forEach(cb => cb.checked = e.target.checked);
                    updatePersonaImportCount();
                });
                
                updatePersonaImportCount();
                
                function updatePersonaImportCount() {
                    const checkboxes = listEl.querySelectorAll('.persona-import-checkbox:checked');
                    selectedCountEl.textContent = `已选择 ${checkboxes.length} 项`;
                    
                    const allCheckboxes = listEl.querySelectorAll('.persona-import-checkbox');
                    selectAllCheckbox.checked = checkboxes.length === allCheckboxes.length && allCheckboxes.length > 0;
                }
            }
            
            // Cancel Import
            document.getElementById('cancel-import-personas-btn').addEventListener('click', () => {
                document.getElementById('select-personas-import-modal').classList.remove('visible');
                pendingPersonasToImport = [];
            });
            
            // Confirm Import Selected Personas
            document.getElementById('confirm-import-personas-btn').addEventListener('click', async () => {
                const checkboxes = document.querySelectorAll('.persona-import-checkbox:checked');
                
                if (checkboxes.length === 0) {
                    showToast('请至少选择一个人设');
                    return;
                }
                
                let importCount = 0;
                checkboxes.forEach(checkbox => {
                    const index = parseInt(checkbox.dataset.index);
                    const persona = pendingPersonasToImport[index];
                    
                    const preset = {
                        id: `persona_${Date.now()}_${importCount}`,
                        name: persona.name,
                        description: persona.description,
                        avatar: 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg',
                        createdAt: Date.now()
                    };
                    
                    db.personaPresets.push(preset);
                    importCount++;
                });
                
                await saveData();
                renderPersonaPresetsList();
                document.getElementById('select-personas-import-modal').classList.remove('visible');
                showToast(`成功导入 ${importCount} 个人设预设`);
                pendingPersonasToImport = [];
            });
            
            // Render Persona Presets List
            function renderPersonaPresetsList() {
                const listEl = document.getElementById('persona-presets-list');
                
                if (db.personaPresets.length === 0) {
                    listEl.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">暂无人设预设</div>';
                    return;
                }
                
                listEl.innerHTML = '';
                db.personaPresets.forEach(preset => {
                    const item = document.createElement('div');
                    item.className = 'persona-preset-item';
                    
                    const descPreview = preset.description.length > 50 
                        ? preset.description.substring(0, 50) + '...' 
                        : preset.description;
                    
                    const needToggle = preset.description.length > 50;
                    
                    item.innerHTML = `
                        <img src="${preset.avatar}" alt="${preset.name}" class="persona-preset-avatar">
                        <div class="persona-preset-info">
                            <div class="persona-preset-name">
                                ${preset.name}
                                ${needToggle ? '<button class="persona-preset-toggle-btn">展开 ▼</button>' : ''}
                            </div>
                            <div class="persona-preset-description-preview">${descPreview}</div>
                            <div class="persona-preset-description-full">${preset.description}</div>
                        </div>
                        <div class="persona-preset-actions">
                            <button class="btn btn-primary apply-preset-btn" data-preset-id="${preset.id}">应用</button>
                            <button class="btn btn-secondary edit-preset-btn" data-preset-id="${preset.id}">编辑</button>
                            <button class="btn btn-danger delete-preset-btn" data-preset-id="${preset.id}">删除</button>
                        </div>
                    `;
                    
                    // Toggle expand/collapse
                    const toggleBtn = item.querySelector('.persona-preset-toggle-btn');
                    if (toggleBtn) {
                        toggleBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            item.classList.toggle('expanded');
                            toggleBtn.textContent = item.classList.contains('expanded') ? '收起 ▲' : '展开 ▼';
                        });
                    }
                    
                    // Apply preset
                    item.querySelector('.apply-preset-btn').addEventListener('click', async (e) => {
                        e.stopPropagation();
                        await applyPersonaPreset(preset.id);
                    });
                    
                    // Edit preset
                    item.querySelector('.edit-preset-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        editPersonaPreset(preset.id);
                    });
                    
                    // Delete preset
                    item.querySelector('.delete-preset-btn').addEventListener('click', async (e) => {
                        e.stopPropagation();
                        if (confirm(`确定要删除人设预设"${preset.name}"吗？`)) {
                            db.personaPresets = db.personaPresets.filter(p => p.id !== preset.id);
                            await saveData();
                            renderPersonaPresetsList();
                            showToast('人设预设已删除');
                        }
                    });
                    
                    listEl.appendChild(item);
                });
            }
            
            // Edit Persona Preset
            function editPersonaPreset(presetId) {
                const preset = db.personaPresets.find(p => p.id === presetId);
                if (!preset) return;
                
                document.getElementById('edit-persona-preset-title').textContent = '编辑人设预设';
                document.getElementById('edit-persona-preset-id').value = preset.id;
                document.getElementById('persona-preset-name').value = preset.name;
                document.getElementById('persona-preset-description').value = preset.description;
                document.getElementById('persona-preset-avatar-preview').src = preset.avatar;
                document.getElementById('edit-persona-preset-modal').classList.add('visible');
            }
            
            // Apply Persona Preset
            async function applyPersonaPreset(presetId) {
                const preset = db.personaPresets.find(p => p.id === presetId);
                if (!preset) return;
                
                if (currentPersonaPresetContext === 'private') {
                    const character = db.characters.find(c => c.id === currentChatId);
                    if (character) {
                        character.myName = preset.name;
                        character.myPersona = preset.description;
                        character.myAvatar = preset.avatar;
                        
                        // Update UI
                        document.getElementById('setting-my-name').value = preset.name;
                        document.getElementById('setting-my-persona').value = preset.description;
                        document.getElementById('setting-my-avatar-preview').src = preset.avatar;
                        
                        await saveData();
                        showToast(`已应用人设预设：${preset.name}`);
                        document.getElementById('persona-presets-modal').classList.remove('visible');
                    }
                } else if (currentPersonaPresetContext === 'group') {
                    const group = db.groups.find(g => g.id === currentChatId);
                    if (group) {
                        group.me.nickname = preset.name;
                        group.me.persona = preset.description;
                        group.me.avatar = preset.avatar;
                        
                        // Update UI
                        document.getElementById('setting-group-my-nickname').value = preset.name;
                        document.getElementById('setting-group-my-persona').value = preset.description;
                        document.getElementById('setting-group-my-avatar-preview').src = preset.avatar;
                        
                        await saveData();
                        showToast(`已应用人设预设：${preset.name}`);
                        document.getElementById('persona-presets-modal').classList.remove('visible');
                    }
                }
            }
            
            linkWorldBookBtn.addEventListener('click', () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                worldBookSelectionList.innerHTML = '';
                db.worldBooks.forEach(book => {
                    const li = document.createElement('li');
                    li.className = 'world-book-select-item';
                    const isChecked = (character.worldBookIds || []).includes(book.id);
                    li.innerHTML = `<input type="checkbox" id="wb-select-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="wb-select-${book.id}">${book.name}</label>`;
                    worldBookSelectionList.appendChild(li);
                });
                worldBookSelectionModal.classList.add('visible');
            });

            saveWorldBookSelectionBtn.addEventListener('click', async () => {
                const selectedIds = Array.from(worldBookSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                if (currentChatType === 'private') {
                    const character = db.characters.find(c => c.id === currentChatId);
                    if (character) character.worldBookIds = selectedIds;
                } else if (currentChatType === 'group') {
                    const group = db.groups.find(g => g.id === currentChatId);
                    if (group) group.worldBookIds = selectedIds;
                }
                await saveData();
                worldBookSelectionModal.classList.remove('visible');
                showToast('世界书关联已更新');
            });
            
            // ===== 识别USER头像功能 =====
            const recognizeUserAvatarToggle = document.getElementById('recognize-user-avatar-toggle');
            const recognizeUserAvatarInfo = document.getElementById('recognize-user-avatar-info');
            const forceRecognizeAvatarBtn = document.getElementById('force-recognize-avatar-btn');
            
            // 切换识别USER头像开关
            recognizeUserAvatarToggle.addEventListener('change', async () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                character.recognizeUserAvatarEnabled = recognizeUserAvatarToggle.checked;
                recognizeUserAvatarInfo.style.display = recognizeUserAvatarToggle.checked ? 'block' : 'none';
                
                await saveData();
                
                // 如果开启且还没有识别过，自动识别当前头像
                if (recognizeUserAvatarToggle.checked && !character.userAvatarDescription) {
                    await recognizeUserAvatar(character, character.myAvatar);
                }
            });
            
            // 立即识别按钮
            forceRecognizeAvatarBtn.addEventListener('click', async () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                await recognizeUserAvatar(character, character.myAvatar);
            });
            
            // 清除所有头像记忆按钮
            const clearAvatarMemoryBtn = document.getElementById('clear-avatar-memory-btn');
            clearAvatarMemoryBtn.addEventListener('click', async () => {
                const confirmed = await showCustomConfirm(
                    '确认清除',
                    '确定要清除所有角色的头像记忆吗？\n\n清除后，所有角色都将不再记得你的头像内容，就像从未开启过识别功能一样。\n\n此操作不可撤销！'
                );
                
                if (confirmed) {
                    await clearAllAvatarMemory();
                }
            });
            
            // 监听头像更换，自动识别新头像
            const originalAvatarUploadHandler = document.getElementById('setting-my-avatar-upload');
            originalAvatarUploadHandler.addEventListener('change', async (e) => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                // 等待头像上传完成
                setTimeout(async () => {
                    const newAvatarUrl = document.getElementById('setting-my-avatar-preview').src;
                    
                    // 如果开启了识别功能，且头像发生了变化，自动识别
                    if (character.recognizeUserAvatarEnabled && 
                        newAvatarUrl && 
                        newAvatarUrl !== character.userAvatarUrl) {
                        await recognizeUserAvatar(character, newAvatarUrl);
                    }
                }, 500);
            });
            
            // ===== 挂载聊天记录功能 =====
            const mountChatToggle = document.getElementById('mount-chat-history-toggle');
            const mountChatContainer = document.getElementById('mount-chat-history-container');
            const mountedChatsList = document.getElementById('mounted-chats-list');
            const addMountedChatBtn = document.getElementById('add-mounted-chat-btn');
            const mountChatSelectionModal = document.getElementById('mount-chat-selection-modal');
            const mountChatSelectionList = document.getElementById('mount-chat-selection-list');
            const confirmMountChatBtn = document.getElementById('confirm-mount-chat-btn');
            const cancelMountChatBtn = document.getElementById('cancel-mount-chat-btn');
            
            let selectedMountChatId = null;
            let selectedMountChatType = null;
            
            // 切换挂载聊天记录开关
            mountChatToggle.addEventListener('change', async () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                character.mountChatHistoryEnabled = mountChatToggle.checked;
                mountChatContainer.style.display = mountChatToggle.checked ? 'block' : 'none';
                
                if (!character.mountedChats) {
                    character.mountedChats = [];
                }
                
                await saveData();
                renderMountedChatsList();
            });
            
            // 打开选择聊天弹窗
            addMountedChatBtn.addEventListener('click', () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                mountChatSelectionList.innerHTML = '';
                
                // 添加私聊列表
                const privateChats = db.characters.filter(c => c.id !== currentChatId);
                if (privateChats.length > 0) {
                    const privateHeader = document.createElement('div');
                    privateHeader.style.cssText = 'font-weight: bold; color: var(--primary-color); margin: 10px 0 5px 0; font-size: 14px;';
                    privateHeader.textContent = '私聊';
                    mountChatSelectionList.appendChild(privateHeader);
                    
                    privateChats.forEach(char => {
                        const item = document.createElement('div');
                        item.className = 'list-item';
                        item.style.cssText = 'padding: 10px; cursor: pointer; border-bottom: 1px solid #f0f0f0; display: flex; align-items: center; gap: 10px;';
                        item.innerHTML = `
                            <img src="${char.avatar}" style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover;">
                            <span>${char.remarkName}</span>
                        `;
                        item.addEventListener('click', () => {
                            selectedMountChatId = char.id;
                            selectedMountChatType = 'private';
                            document.querySelectorAll('#mount-chat-selection-list .list-item').forEach(el => {
                                el.style.background = '';
                            });
                            item.style.background = '#e3f2fd';
                        });
                        mountChatSelectionList.appendChild(item);
                    });
                }
                
                // 添加群聊列表
                if (db.groups.length > 0) {
                    const groupHeader = document.createElement('div');
                    groupHeader.style.cssText = 'font-weight: bold; color: var(--primary-color); margin: 10px 0 5px 0; font-size: 14px;';
                    groupHeader.textContent = '群聊';
                    mountChatSelectionList.appendChild(groupHeader);
                    
                    db.groups.forEach(group => {
                        const item = document.createElement('div');
                        item.className = 'list-item';
                        item.style.cssText = 'padding: 10px; cursor: pointer; border-bottom: 1px solid #f0f0f0; display: flex; align-items: center; gap: 10px;';
                        item.innerHTML = `
                            <img src="${group.avatar}" style="width: 40px; height: 40px; border-radius: 10px; object-fit: cover;">
                            <span>${group.name}</span>
                        `;
                        item.addEventListener('click', () => {
                            selectedMountChatId = group.id;
                            selectedMountChatType = 'group';
                            document.querySelectorAll('#mount-chat-selection-list .list-item').forEach(el => {
                                el.style.background = '';
                            });
                            item.style.background = '#e3f2fd';
                        });
                        mountChatSelectionList.appendChild(item);
                    });
                }
                
                mountChatSelectionModal.classList.add('visible');
            });
            
            // 确认挂载聊天
            confirmMountChatBtn.addEventListener('click', async () => {
                if (!selectedMountChatId || !selectedMountChatType) {
                    showToast('请选择要挂载的聊天');
                    return;
                }
                
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                if (!character.mountedChats) {
                    character.mountedChats = [];
                }
                
                // 检查是否已经挂载
                const exists = character.mountedChats.some(m => m.chatId === selectedMountChatId && m.type === selectedMountChatType);
                if (exists) {
                    showToast('该聊天已经挂载');
                    return;
                }
                
                character.mountedChats.push({
                    chatId: selectedMountChatId,
                    type: selectedMountChatType,
                    messageCount: 0
                });
                
                await saveData();
                renderMountedChatsList();
                mountChatSelectionModal.classList.remove('visible');
                showToast('挂载成功');
                
                selectedMountChatId = null;
                selectedMountChatType = null;
            });
            
            // 取消挂载
            cancelMountChatBtn.addEventListener('click', () => {
                mountChatSelectionModal.classList.remove('visible');
                selectedMountChatId = null;
                selectedMountChatType = null;
            });
            
            // 点击遮罩关闭弹窗
            mountChatSelectionModal.addEventListener('click', (e) => {
                if (e.target === mountChatSelectionModal) {
                    mountChatSelectionModal.classList.remove('visible');
                    selectedMountChatId = null;
                    selectedMountChatType = null;
                }
            });
            
            // ===== 线下模式功能 =====
            const offlineModeToggle = document.getElementById('offline-mode-toggle');
            const offlineModeContainer = document.getElementById('offline-mode-container');
            const offlineWorldbooksList = document.getElementById('offline-worldbooks-list');
            const addOfflineWorldbookBtn = document.getElementById('add-offline-worldbook-btn');
            const offlineWordCountInput = document.getElementById('offline-word-count');
            const offlineNarrativePersonSelect = document.getElementById('offline-narrative-person');
            const offlineWorldbookSelectionModal = document.getElementById('offline-worldbook-selection-modal');
            const offlineWorldbookSelectionList = document.getElementById('offline-worldbook-selection-list');
            const saveOfflineWorldbookSelectionBtn = document.getElementById('save-offline-worldbook-selection-btn');
            
            // 切换线下模式开关
            offlineModeToggle.addEventListener('change', async () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                // 先显示容器，让用户可以输入字数
                offlineModeContainer.style.display = offlineModeToggle.checked ? 'block' : 'none';
                
                // 如果要开启线下模式，检查字数是否已填写
                if (offlineModeToggle.checked) {
                    const wordCount = offlineWordCountInput.value.trim();
                    if (!wordCount || isNaN(wordCount) || parseInt(wordCount) < 0) {
                        // 不阻止开启，只是提示用户需要填写
                        alert('请设置输出字数（建议100-5000字）');
                        // 聚焦到字数输入框
                        offlineWordCountInput.focus();
                    }
                }
                
                character.offlineModeEnabled = offlineModeToggle.checked;
                
                if (!character.offlineWorldbooks) {
                    character.offlineWorldbooks = [];
                }
                
                await saveData();
                
                // 添加系统消息通知模式切换（灰色旁白样式）
                const systemMessage = {
                    id: `msg_${Date.now()}`,
                    role: 'system',
                    content: offlineModeToggle.checked 
                        ? '你们已经在线下见面了' 
                        : '你们已经结束了这次线下见面，回到了线上聊天',
                    timestamp: Date.now()
                };
                character.history.push(systemMessage);
                addMessageBubble(systemMessage);
                await saveData();
                
                renderOfflineWorldbooksList();
            });
            
            // 打开选择世界书弹窗
            addOfflineWorldbookBtn.addEventListener('click', () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                offlineWorldbookSelectionList.innerHTML = '';
                
                if (db.worldBooks.length === 0) {
                    offlineWorldbookSelectionList.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">暂无世界书</p>';
                } else {
                    db.worldBooks.forEach(wb => {
                        const isSelected = character.offlineWorldbooks && character.offlineWorldbooks.includes(wb.id);
                        
                        const item = document.createElement('li');
                        item.style.cssText = 'padding: 10px; cursor: pointer; border-bottom: 1px solid #f0f0f0; display: flex; align-items: center; gap: 10px;';
                        if (isSelected) {
                            item.style.background = '#e3f2fd';
                        }
                        
                        item.innerHTML = `
                            <input type="checkbox" ${isSelected ? 'checked' : ''} data-wb-id="${wb.id}" style="width: auto;">
                            <span>${wb.name}</span>
                        `;
                        
                        const checkbox = item.querySelector('input[type="checkbox"]');
                        checkbox.addEventListener('change', () => {
                            item.style.background = checkbox.checked ? '#e3f2fd' : '';
                        });
                        
                        offlineWorldbookSelectionList.appendChild(item);
                    });
                }
                
                offlineWorldbookSelectionModal.classList.add('visible');
            });
            
            // 确认选择世界书
            saveOfflineWorldbookSelectionBtn.addEventListener('click', async () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                const checkboxes = offlineWorldbookSelectionList.querySelectorAll('input[type="checkbox"]:checked');
                character.offlineWorldbooks = Array.from(checkboxes).map(cb => parseInt(cb.dataset.wbId));
                
                await saveData();
                renderOfflineWorldbooksList();
                offlineWorldbookSelectionModal.classList.remove('visible');
                showToast('世界书设置已保存');
            });
            
            // 点击遮罩关闭弹窗
            offlineWorldbookSelectionModal.addEventListener('click', (e) => {
                if (e.target === offlineWorldbookSelectionModal) {
                    offlineWorldbookSelectionModal.classList.remove('visible');
                }
            });
            
            // 保存线下字数设置
            offlineWordCountInput.addEventListener('change', async () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                const wordCount = parseInt(offlineWordCountInput.value) || 800;
                character.offlineWordCount = Math.max(100, Math.min(5000, wordCount));
                offlineWordCountInput.value = character.offlineWordCount;
                
                await saveData();
            });
            
            // 保存线下人称设置
            offlineNarrativePersonSelect.addEventListener('change', async () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                character.offlineNarrativePerson = offlineNarrativePersonSelect.value || 'third';
                
                await saveData();
            });
            
            // 实时时间开关
            const offlineRealtimeToggle = document.getElementById('offline-realtime-toggle');
            offlineRealtimeToggle.addEventListener('change', async () => {
                const character = db.characters.find(c => c.id === currentChatId);
                if (!character) return;
                
                character.offlineRealtimeEnabled = offlineRealtimeToggle.checked;
                
                await saveData();
                showToast(offlineRealtimeToggle.checked ? 'CHAR现在可以感知实时时间' : 'CHAR现在无法感知时间');
            });
            
            // ===== 记忆库功能 =====
            const saveMemorySnapshotBtn = document.getElementById('save-memory-snapshot-btn');
            const saveMemorySnapshotModal = document.getElementById('save-memory-snapshot-modal');
            const memorySnapshotNameInput = document.getElementById('memory-snapshot-name');
            const confirmSaveSnapshotBtn = document.getElementById('confirm-save-snapshot-btn');
            const cancelSaveSnapshotBtn = document.getElementById('cancel-save-snapshot-btn');
            const restoreMemorySnapshotModal = document.getElementById('restore-memory-snapshot-modal');
            const restoreSnapshotInfo = document.getElementById('restore-snapshot-info');
            const confirmRestoreSnapshotBtn = document.getElementById('confirm-restore-snapshot-btn');
            const cancelRestoreSnapshotBtn = document.getElementById('cancel-restore-snapshot-btn');
            const memorySnapshotsList = document.getElementById('memory-snapshots-list');
            
            
            // 打开保存记忆快照弹窗
            saveMemorySnapshotBtn.addEventListener('click', () => {
                const now = new Date();
                const defaultName = `记忆快照 ${now.toLocaleString('zh-CN', {
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                })}`;
                memorySnapshotNameInput.value = defaultName;
                saveMemorySnapshotModal.classList.add('visible');
            });
            
            // 确认保存记忆快照
            confirmSaveSnapshotBtn.addEventListener('click', async () => {
                const name = memorySnapshotNameInput.value.trim();
                if (!name) {
                    showToast('请输入快照名称');
                    return;
                }
                
                if (!currentChatId) {
                    showToast('当前没有打开的对话');
                    return;
                }
                
                try {
                    // 获取当前对话的完整数据
                    let chatData;
                    if (currentChatType === 'private') {
                        const character = db.characters.find(c => c.id === currentChatId);
                        if (!character) {
                            showToast('找不到当前对话');
                            return;
                        }
                        chatData = JSON.parse(JSON.stringify(character)); // 深拷贝
                    } else if (currentChatType === 'group') {
                        const group = db.groups.find(g => g.id === currentChatId);
                        if (!group) {
                            showToast('找不到当前群聊');
                            return;
                        }
                        chatData = JSON.parse(JSON.stringify(group)); // 深拷贝
                    }
                    
                    // 保存到IndexedDB
                    const snapshot = {
                        id: `snapshot_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        chatId: currentChatId,
                        chatType: currentChatType,
                        name: name,
                        data: chatData, // 直接存储对象，不使用base64
                        timestamp: Date.now()
                    };
                    
                    await dataStorage.db.memorySnapshots.add(snapshot);
                    
                    saveMemorySnapshotModal.classList.remove('visible');
                    showToast('记忆快照已保存');
                    renderMemorySnapshots();
                } catch (error) {
                    console.error('保存记忆快照失败:', error);
                    showToast('保存失败：' + error.message);
                }
            });
            
            // 取消保存
            cancelSaveSnapshotBtn.addEventListener('click', () => {
                saveMemorySnapshotModal.classList.remove('visible');
            });
            
            // 确认恢复记忆快照
            confirmRestoreSnapshotBtn.addEventListener('click', async () => {
                if (!window.currentRestoreSnapshotId) return;
                
                try {
                    const snapshot = await dataStorage.db.memorySnapshots.get(window.currentRestoreSnapshotId);
                    if (!snapshot) {
                        showToast('找不到该快照');
                        return;
                    }
                    
                    // 恢复数据
                    if (currentChatType === 'private') {
                        const index = db.characters.findIndex(c => c.id === currentChatId);
                        if (index !== -1) {
                            // 保留ID，替换其他所有数据
                            const restoredData = snapshot.data;
                            restoredData.id = currentChatId; // 确保ID不变
                            db.characters[index] = restoredData;
                        }
                    } else if (currentChatType === 'group') {
                        const index = db.groups.findIndex(g => g.id === currentChatId);
                        if (index !== -1) {
                            // 保留ID，替换其他所有数据
                            const restoredData = snapshot.data;
                            restoredData.id = currentChatId; // 确保ID不变
                            db.groups[index] = restoredData;
                        }
                    }
                    
                    await saveData();
                    restoreMemorySnapshotModal.classList.remove('visible');
                    window.currentRestoreSnapshotId = null;
                    
                    // 刷新界面
                    loadSettingsToSidebar();
                    renderMessages(false, true);
                    showToast('记忆快照已恢复');
                } catch (error) {
                    console.error('恢复记忆快照失败:', error);
                    showToast('恢复失败：' + error.message);
                }
            });
            
            // 取消恢复
            cancelRestoreSnapshotBtn.addEventListener('click', () => {
                restoreMemorySnapshotModal.classList.remove('visible');
                window.currentRestoreSnapshotId = null;
            });
            
            // ===== 重命名记忆快照功能 =====
            const renameMemorySnapshotModal = document.getElementById('rename-memory-snapshot-modal');
            const renameSnapshotNameInput = document.getElementById('rename-snapshot-name');
            const confirmRenameSnapshotBtn = document.getElementById('confirm-rename-snapshot-btn');
            const cancelRenameSnapshotBtn = document.getElementById('cancel-rename-snapshot-btn');
            
            // 确认重命名
            confirmRenameSnapshotBtn.addEventListener('click', async () => {
                if (!window.currentRenameSnapshotId) return;
                
                const newName = renameSnapshotNameInput.value.trim();
                if (!newName) {
                    showToast('请输入新名称');
                    return;
                }
                
                try {
                    const snapshot = await dataStorage.db.memorySnapshots.get(window.currentRenameSnapshotId);
                    if (!snapshot) {
                        showToast('找不到该快照');
                        return;
                    }
                    
                    snapshot.name = newName;
                    await dataStorage.db.memorySnapshots.put(snapshot);
                    
                    renameMemorySnapshotModal.classList.remove('visible');
                    window.currentRenameSnapshotId = null;
                    showToast('重命名成功');
                    renderMemorySnapshots();
                } catch (error) {
                    console.error('重命名失败:', error);
                    showToast('重命名失败：' + error.message);
                }
            });
            
            // 取消重命名
            cancelRenameSnapshotBtn.addEventListener('click', () => {
                renameMemorySnapshotModal.classList.remove('visible');
                window.currentRenameSnapshotId = null;
            });
            
            // 点击遮罩关闭弹窗
            saveMemorySnapshotModal.addEventListener('click', (e) => {
                if (e.target === saveMemorySnapshotModal) {
                    saveMemorySnapshotModal.classList.remove('visible');
                }
            });
            
            restoreMemorySnapshotModal.addEventListener('click', (e) => {
                if (e.target === restoreMemorySnapshotModal) {
                    restoreMemorySnapshotModal.classList.remove('visible');
                    window.currentRestoreSnapshotId = null;
                }
            });
            
            renameMemorySnapshotModal.addEventListener('click', (e) => {
                if (e.target === renameMemorySnapshotModal) {
                    renameMemorySnapshotModal.classList.remove('visible');
                    window.currentRenameSnapshotId = null;
                }
            });
        }

        // Update message count display in settings
        function updateMessageCountDisplay() {
            if (currentChatType === 'private') {
                const character = db.characters.find(c => c.id === currentChatId);
                if (character) {
                    const count = character.history ? character.history.length : 0;
                    const countEl = document.getElementById('current-message-count');
                    if (countEl) {
                        countEl.textContent = count;
                    }
                }
            } else if (currentChatType === 'group') {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    const count = group.history ? group.history.length : 0;
                    const countEl = document.getElementById('group-current-message-count');
                    if (countEl) {
                        countEl.textContent = count;
                    }
                }
            }
        }

        function loadSettingsToSidebar() {
            const e = db.characters.find(e => e.id === currentChatId);
            if (e) {
                // 检查是否是加密角色，显示解密按钮
                if (e.isEncrypted) {
                    showDecryptButton(e.id);
                } else {
                    // 移除解密按钮（如果存在）
                    const decryptBtn = document.getElementById('decrypt-persona-btn');
                    if (decryptBtn) decryptBtn.remove();
                }
                
                document.getElementById('setting-char-avatar-preview').src = e.avatar;
                document.getElementById('setting-char-realname').value = e.realName || '';
                document.getElementById('setting-char-remark').value = e.remarkName;
                document.getElementById('setting-char-persona').value = e.persona;
                document.getElementById('setting-char-background-activity').checked = e.enableBackgroundActivity || false;
                document.getElementById('setting-char-auto-group').checked = e.enableAutoGroup || false;
                
                // 加载角色专属的主动拉群设置
                document.getElementById('setting-char-auto-group-interval').value = e.autoGroupInterval !== undefined ? e.autoGroupInterval : '';
                
                // 根据主动拉群开关显示/隐藏设置
                const autoGroupSettingsContainer = document.getElementById('char-auto-group-settings');
                if (autoGroupSettingsContainer) {
                    autoGroupSettingsContainer.style.display = e.enableAutoGroup ? 'block' : 'none';
                }
                
                // 加载角色专属的后台活动设置
                document.getElementById('setting-char-bg-check-interval').value = e.backgroundActivityInterval !== undefined ? e.backgroundActivityInterval : '';
                document.getElementById('setting-char-bg-trigger-chance').value = e.backgroundActivityProbability !== undefined ? e.backgroundActivityProbability : '';
                
                // 根据后台活动开关显示/隐藏设置
                const bgSettingsContainer = document.getElementById('char-background-activity-settings');
                if (bgSettingsContainer) {
                    bgSettingsContainer.style.display = e.enableBackgroundActivity ? 'block' : 'none';
                }
                
                document.getElementById('setting-char-block-cooldown').value = e.blockCooldownHours !== undefined ? e.blockCooldownHours : '';
                document.getElementById('setting-my-avatar-preview').src = e.myAvatar;
                document.getElementById('setting-my-name').value = e.myName;
                document.getElementById('setting-my-persona').value = e.myPersona;
                document.getElementById('setting-theme-color').value = e.theme || 'white_pink';
                document.getElementById('setting-max-memory').value = e.maxMemory;
                
                // 加载角色专属Minimax TTS设置
                const charMinimaxEnabled = e.minimaxConfig && (e.minimaxConfig.enabled === true);
                document.getElementById('setting-char-minimax-enabled').checked = charMinimaxEnabled;
                
                if (e.minimaxConfig) {
                    document.getElementById('setting-char-minimax-group-id').value = e.minimaxConfig.groupId || '';
                    document.getElementById('setting-char-minimax-api-key').value = e.minimaxConfig.apiKey || '';
                    document.getElementById('setting-char-minimax-voice-id').value = e.minimaxConfig.voiceId || '';
                    document.getElementById('setting-char-minimax-speech-model').value = e.minimaxConfig.speechModel || '';
                } else {
                    // 兼容旧数据：如果有voiceId字段，迁移到新结构
                    if (e.voiceId) {
                        document.getElementById('setting-char-minimax-voice-id').value = e.voiceId;
                    }
                    document.getElementById('setting-char-minimax-group-id').value = '';
                    document.getElementById('setting-char-minimax-api-key').value = '';
                    document.getElementById('setting-char-minimax-speech-model').value = '';
                }
                
                // 根据Minimax开关显示/隐藏设置
                const charMinimaxSettingsContainer = document.getElementById('char-minimax-settings');
                if (charMinimaxSettingsContainer) {
                    charMinimaxSettingsContainer.style.display = charMinimaxEnabled ? 'block' : 'none';
                }
                
                // Update current message count
                const currentCount = e.history ? e.history.length : 0;
                document.getElementById('current-message-count').textContent = currentCount;
                
                // Update last summary position
                const lastSummaryIndex = e.lastSummaryIndex || 0;
                const lastSummaryPositionEl = document.getElementById('last-summary-position');
                if (lastSummaryIndex > 0) {
                    lastSummaryPositionEl.textContent = `第 ${lastSummaryIndex} 条`;
                    lastSummaryPositionEl.style.color = '#2e7d32';
                    lastSummaryPositionEl.style.fontWeight = 'bold';
                } else {
                    lastSummaryPositionEl.textContent = '未总结';
                    lastSummaryPositionEl.style.color = '#999';
                    lastSummaryPositionEl.style.fontWeight = 'normal';
                }
                
                // Update current token count
                updateTokenDisplay();
                
                // Load token warning settings
                const tokenWarningEnabled = e.tokenWarningEnabled || false;
                const tokenWarningThreshold = e.tokenWarningThreshold || '';
                document.getElementById('token-warning-enabled').checked = tokenWarningEnabled;
                document.getElementById('token-warning-threshold').value = tokenWarningThreshold;
                document.getElementById('token-warning-options').style.display = tokenWarningEnabled ? 'block' : 'none';
                
                // Load message count warning settings
                const messageCountWarningEnabled = e.messageCountWarningEnabled || false;
                const messageCountWarningThreshold = e.messageCountWarningThreshold || '';
                document.getElementById('message-count-warning-enabled').checked = messageCountWarningEnabled;
                document.getElementById('message-count-warning-threshold').value = messageCountWarningThreshold;
                document.getElementById('message-count-warning-options').style.display = messageCountWarningEnabled ? 'block' : 'none';
                
                // Load auto-summary settings
                const autoSummaryEnabled = e.autoSummaryEnabled || false;
                const autoSummaryCount = e.autoSummaryCount || '';
                const customSummaryPrompt = e.customSummaryPrompt || DEFAULT_SUMMARY_PROMPT;
                document.getElementById('setting-auto-summary-enabled').checked = autoSummaryEnabled;
                document.getElementById('setting-auto-summary-count').value = autoSummaryCount;
                document.getElementById('custom-summary-prompt').value = customSummaryPrompt;
                document.getElementById('auto-summary-options').style.display = autoSummaryEnabled ? 'block' : 'none';
                
                // Load custom theme colors
                if (e.customTheme) {
                    document.getElementById('setting-custom-char-bg').value = e.customTheme.received.bg;
                    document.getElementById('setting-custom-char-text').value = e.customTheme.received.text;
                    document.getElementById('setting-custom-user-bg').value = e.customTheme.sent.bg;
                    document.getElementById('setting-custom-user-text').value = e.customTheme.sent.text;
                } else {
                    // Set default values from current theme
                    const defaultTheme = colorThemes[e.theme || 'white_pink'];
                    document.getElementById('setting-custom-char-bg').value = defaultTheme.received.bg;
                    document.getElementById('setting-custom-char-text').value = defaultTheme.received.text;
                    document.getElementById('setting-custom-user-bg').value = defaultTheme.sent.bg;
                    document.getElementById('setting-custom-user-text').value = defaultTheme.sent.text;
                }
                
                const useCustomCssCheckbox = document.getElementById('setting-use-custom-css'),
                    customCssTextarea = document.getElementById('setting-custom-bubble-css'),
                    privatePreviewBox = document.getElementById('private-bubble-css-preview');
                useCustomCssCheckbox.checked = e.useCustomBubbleCss || false;
                customCssTextarea.value = e.customBubbleCss || '';
                customCssTextarea.disabled = !useCustomCssCheckbox.checked;
                const theme = colorThemes[e.theme || 'white_pink'];
                updateBubbleCssPreview(privatePreviewBox, e.customBubbleCss, !e.useCustomBubbleCss, theme);
                
                // Refresh theme preset dropdown
                const select = document.getElementById('theme-preset-select');
                if (select) {
                    select.innerHTML = '<option value="">-- 选择预设 --</option>';
                    db.themePresets.forEach(preset => {
                        const option = document.createElement('option');
                        option.value = preset.id;
                        option.textContent = preset.name;
                        select.appendChild(option);
                    });
                }
                
                // 【全新】根据拉黑状态显示/隐藏拉黑按钮
                const blockBtn = document.getElementById('block-chat-btn');
                if (blockBtn) {
                    if (e.relationship?.status === 'blocked_by_user') {
                        // 如果已拉黑，显示"解除拉黑"按钮
                        blockBtn.textContent = '解除拉黑';
                        blockBtn.style.backgroundColor = '#28a745';
                        blockBtn.style.borderColor = '#28a745';
                    } else {
                        // 否则显示"拉黑对方"按钮
                        blockBtn.textContent = '拉黑对方';
                        blockBtn.style.backgroundColor = '#ff3b30';
                        blockBtn.style.borderColor = '#ff3b30';
                    }
                }
                
                // 加载识别USER头像设置
                const recognizeUserAvatarToggle = document.getElementById('recognize-user-avatar-toggle');
                const recognizeUserAvatarInfo = document.getElementById('recognize-user-avatar-info');
                if (recognizeUserAvatarToggle && recognizeUserAvatarInfo) {
                    recognizeUserAvatarToggle.checked = e.recognizeUserAvatarEnabled || false;
                    recognizeUserAvatarInfo.style.display = e.recognizeUserAvatarEnabled ? 'block' : 'none';
                    updateAvatarRecognitionStatus(e);
                }
                
                // 加载挂载聊天记录设置
                const mountChatToggle = document.getElementById('mount-chat-history-toggle');
                const mountChatContainer = document.getElementById('mount-chat-history-container');
                if (mountChatToggle && mountChatContainer) {
                    mountChatToggle.checked = e.mountChatHistoryEnabled || false;
                    mountChatContainer.style.display = e.mountChatHistoryEnabled ? 'block' : 'none';
                    renderMountedChatsList();
                }
                
                // 加载线下模式设置
                const offlineModeToggle = document.getElementById('offline-mode-toggle');
                const offlineModeContainer = document.getElementById('offline-mode-container');
                const offlineWordCountInput = document.getElementById('offline-word-count');
                const offlineNarrativePersonSelect = document.getElementById('offline-narrative-person');
                const offlineRealtimeToggle = document.getElementById('offline-realtime-toggle');
                if (offlineModeToggle && offlineModeContainer) {
                    offlineModeToggle.checked = e.offlineModeEnabled || false;
                    offlineModeContainer.style.display = e.offlineModeEnabled ? 'block' : 'none';
                    if (offlineWordCountInput) {
                        offlineWordCountInput.value = e.offlineWordCount || '';
                    }
                    if (offlineNarrativePersonSelect) {
                        offlineNarrativePersonSelect.value = e.offlineNarrativePerson || 'third';
                    }
                    if (offlineRealtimeToggle) {
                        offlineRealtimeToggle.checked = e.offlineRealtimeEnabled !== false; // 默认开启
                    }
                    renderOfflineWorldbooksList();
                }
                
                // 加载记忆快照列表
                renderMemorySnapshots();
                
                // 加载头像形状设置
                loadAvatarShapeSettings(e);
            }
        }

        async function saveSettingsFromSidebar() {
            const e = db.characters.find(e => e.id === currentChatId);
            if (e) {
                const oldTheme = e.theme;
                const newTheme = document.getElementById('setting-theme-color').value;
                
                e.avatar = document.getElementById('setting-char-avatar-preview').src;
                e.realName = document.getElementById('setting-char-realname').value;
                e.remarkName = document.getElementById('setting-char-remark').value;
                e.persona = document.getElementById('setting-char-persona').value;
                e.enableBackgroundActivity = document.getElementById('setting-char-background-activity').checked;
                e.enableAutoGroup = document.getElementById('setting-char-auto-group').checked;
                
                // 保存角色专属的主动拉群设置
                const autoGroupInterval = parseFloat(document.getElementById('setting-char-auto-group-interval').value);
                e.autoGroupInterval = !isNaN(autoGroupInterval) && autoGroupInterval > 0 ? autoGroupInterval : undefined;
                
                // 保存角色专属的后台活动设置
                const bgCheckInterval = parseFloat(document.getElementById('setting-char-bg-check-interval').value);
                e.backgroundActivityInterval = !isNaN(bgCheckInterval) && bgCheckInterval > 0 ? bgCheckInterval : undefined;
                
                const bgTriggerChance = parseInt(document.getElementById('setting-char-bg-trigger-chance').value);
                e.backgroundActivityProbability = !isNaN(bgTriggerChance) && bgTriggerChance >= 0 && bgTriggerChance <= 100 ? bgTriggerChance : undefined;
                
                const cooldownValue = parseFloat(document.getElementById('setting-char-block-cooldown').value);
                e.blockCooldownHours = !isNaN(cooldownValue) && cooldownValue > 0 ? cooldownValue : undefined;
                e.myAvatar = document.getElementById('setting-my-avatar-preview').src;
                e.myName = document.getElementById('setting-my-name').value;
                e.myPersona = document.getElementById('setting-my-persona').value;
                e.theme = newTheme;
                e.maxMemory = document.getElementById('setting-max-memory').value;
                
                // 保存角色专属Minimax TTS设置
                const charMinimaxEnabled = document.getElementById('setting-char-minimax-enabled').checked;
                if (!e.minimaxConfig) {
                    e.minimaxConfig = {};
                }
                e.minimaxConfig.enabled = charMinimaxEnabled;
                e.minimaxConfig.groupId = document.getElementById('setting-char-minimax-group-id').value.trim();
                e.minimaxConfig.apiKey = document.getElementById('setting-char-minimax-api-key').value.trim();
                e.minimaxConfig.voiceId = document.getElementById('setting-char-minimax-voice-id').value.trim();
                e.minimaxConfig.speechModel = document.getElementById('setting-char-minimax-speech-model').value;
                
                // 兼容性：保留旧的voiceId字段（用于数据迁移）
                if (e.voiceId !== undefined) {
                    delete e.voiceId;
                }
                
                e.autoSummaryEnabled = document.getElementById('setting-auto-summary-enabled').checked;
                e.autoSummaryCount = document.getElementById('setting-auto-summary-count').value;
                e.useCustomBubbleCss = document.getElementById('setting-use-custom-css').checked;
                e.customBubbleCss = document.getElementById('setting-custom-bubble-css').value;
                
                // If theme changed and custom theme exists, clear it and update color inputs
                if (oldTheme !== newTheme && e.customTheme) {
                    delete e.customTheme;
                    const defaultTheme = colorThemes[newTheme || 'white_pink'];
                    document.getElementById('setting-custom-char-bg').value = defaultTheme.received.bg;
                    document.getElementById('setting-custom-char-text').value = defaultTheme.received.text;
                    document.getElementById('setting-custom-user-bg').value = defaultTheme.sent.bg;
                    document.getElementById('setting-custom-user-text').value = defaultTheme.sent.text;
                }
                
                await saveData();
                
                // 【修复】保存角色设置后，检查是否需要启动后台活动
                stopBackgroundSimulation();
                const hasAnyBackgroundActivity = db.enableBackgroundActivity || db.characters.some(c => c.enableBackgroundActivity);
                if (hasAnyBackgroundActivity) {
                    startBackgroundSimulation();
                    console.log('角色后台活动设置已更新，后台模拟已重新启动');
                }
                
                showToast('设置已保存！');
                chatRoomTitle.textContent = e.remarkName;
                renderChatList();
                updateCustomBubbleStyle(currentChatId, e.customBubbleCss, e.useCustomBubbleCss);
                currentPage = 1;
                renderMessages(false, true);
            }
        }
        
        // 角色后台活动开关事件监听器
        document.getElementById('setting-char-background-activity')?.addEventListener('change', (e) => {
            const bgSettingsContainer = document.getElementById('char-background-activity-settings');
            if (bgSettingsContainer) {
                bgSettingsContainer.style.display = e.target.checked ? 'block' : 'none';
            }
        });

        // 角色主动拉群开关事件监听器
        document.getElementById('setting-char-auto-group')?.addEventListener('change', (e) => {
            const autoGroupSettingsContainer = document.getElementById('char-auto-group-settings');
            if (autoGroupSettingsContainer) {
                autoGroupSettingsContainer.style.display = e.target.checked ? 'block' : 'none';
            }
        });

        // 角色专属Minimax TTS开关事件监听器
        document.getElementById('setting-char-minimax-enabled')?.addEventListener('change', (e) => {
            const charMinimaxSettingsContainer = document.getElementById('char-minimax-settings');
            if (charMinimaxSettingsContainer) {
                charMinimaxSettingsContainer.style.display = e.target.checked ? 'block' : 'none';
            }
        });

        function setupApiSettingsApp() {
            const e = document.getElementById('api-form'), t = document.getElementById('fetch-models-btn'),
                a = document.getElementById('api-model'), n = document.getElementById('api-provider'),
                r = document.getElementById('api-url'), s = document.getElementById('api-key'), c = {
                    newapi: '',
                    deepseek: 'https://api.deepseek.com',
                    claude: 'https://api.anthropic.com',
                    gemini: 'https://generativelanguage.googleapis.com'
                };
            
            // 动态添加后台活动设置HTML
            const saveBtn = document.getElementById('save-btn');
            if (saveBtn && !document.getElementById('background-activity-switch')) {
                const backgroundHTML = `
                    <hr style="margin:20px 0; opacity:.3">
                    <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                        <label for="simple-prompt-mode-switch" style="margin-bottom: 0;">
                            简洁模式 (Prompt优化)
                            <p style="font-size: 12px; font-weight: normal; color: #4CAF50; margin-top: 5px;">
                                开启后可自定义选择功能模块，减少Token消耗，提升AI专注度
                            </p>
                        </label>
                        <input type="checkbox" id="simple-prompt-mode-switch" style="width: auto; height: 20px;">
                    </div>
                    <div id="simple-mode-features-container" style="display: none; margin-top: 15px; padding: 15px; background-color: #f0f8ff; border-radius: 8px; border: 1px solid #90caf9;">
                        <h4 style="font-size: 14px; margin: 0 0 10px 0; color: #333;">功能模块选择</h4>
                        <p style="font-size: 12px; color: #666; margin-bottom: 15px;">勾选你想要保留的功能模块（未勾选的功能将从Prompt中移除）</p>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="checkbox" id="feature-inner-thought" class="simple-mode-feature" checked>
                                <span style="font-size: 13px;">心声功能</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="checkbox" id="feature-music" class="simple-mode-feature" checked>
                                <span style="font-size: 13px;">音乐播放</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="checkbox" id="feature-avatar" class="simple-mode-feature" checked>
                                <span style="font-size: 13px;">头像管理</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="checkbox" id="feature-npc" class="simple-mode-feature" checked>
                                <span style="font-size: 13px;">NPC社交圈</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="checkbox" id="feature-offline-mode" class="simple-mode-feature" checked>
                                <span style="font-size: 13px;">线下模式</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="checkbox" id="feature-mount-chat" class="simple-mode-feature" checked>
                                <span style="font-size: 13px;">挂载聊天记录</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="checkbox" id="feature-recognize-avatar" class="simple-mode-feature" checked>
                                <span style="font-size: 13px;">识别USER头像</span>
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                                <input type="checkbox" id="feature-time-awareness" class="simple-mode-feature" checked>
                                <span style="font-size: 13px;">时间感知增强</span>
                            </label>
                        </div>
                        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd; display: flex; gap: 10px;">
                            <button type="button" id="select-all-features-btn" class="btn btn-secondary" style="flex: 1;">全选</button>
                            <button type="button" id="deselect-all-features-btn" class="btn btn-secondary" style="flex: 1;">全不选</button>
                        </div>
                    </div>
                    <div class="form-group" style="margin-top: 15px; padding: 15px; background-color: #f9f9f9; border-radius: 8px;">
                        <h4 style="font-size: 14px; margin: 0 0 10px 0; color: #333;">消息数量限制</h4>
                        <p style="font-size: 12px; color: #666; margin-bottom: 15px;">控制AI每次回复生成的消息条数范围。留空使用默认值（1-20条）</p>
                        <div style="display: flex; gap: 15px; align-items: center;">
                            <div style="flex: 1;">
                                <label for="message-count-min-input" style="font-size: 13px; display: block; margin-bottom: 5px; color: #555;">最少消息数</label>
                                <input type="number" id="message-count-min-input" min="1" max="100" placeholder="默认1条" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px; text-align: center;">
                            </div>
                            <div style="flex: 1;">
                                <label for="message-count-max-input" style="font-size: 13px; display: block; margin-bottom: 5px; color: #555;">最多消息数</label>
                                <input type="number" id="message-count-max-input" min="1" max="100" placeholder="默认20条" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px; text-align: center;">
                            </div>
                        </div>
                        <small style="font-size: 11px; color: #888; display: block; margin-top: 8px;">提示：较少的消息数可以让AI回复更精炼，较多的消息数可以让对话更连贯</small>
                    </div>
                    <hr style="margin:20px 0; opacity:.3">
                    <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                        <label for="background-activity-switch" style="margin-bottom: 0;">
                            启用后台角色活动
                            <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;">
                                警告：此功能会显著增加API调用和费用！
                            </p>
                        </label>
                        <input type="checkbox" id="background-activity-switch" style="width: auto; height: 20px;">
                    </div>
                    <div id="background-settings-container" style="display: none;">
                        <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                            <label for="background-interval-input" style="margin-bottom: 0;">
                                后台活动检测间隔 (秒)
                                <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                                    建议值 60-300。值越大，费用越低，但角色反应越慢。
                                </p>
                            </label>
                            <input type="number" id="background-interval-input" min="0.1" step="0.1" value="60" style="width: 80px; text-align: center;">
                        </div>
                        <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                            <label for="background-probability-input" style="margin-bottom: 0;">
                                角色唤醒概率 (%)
                                <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                                    每次检测时，角色被唤醒的概率。建议值 10-30。
                                </p>
                            </label>
                            <input type="number" id="background-probability-input" min="1" max="100" value="20" style="width: 80px; text-align: center;">
                        </div>
                        <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
                            <label for="block-cooldown-input" style="margin-bottom: 0;">
                                AI被拉黑后冷静期 (小时)
                                <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                                    被拉黑超过这个时间后，AI才有几率重新申请好友。
                                </p>
                            </label>
                            <input type="number" id="block-cooldown-input" min="0.1" step="0.1" value="1" style="width: 80px; text-align: center;">
                        </div>
                        <button type="button" class="btn btn-secondary" id="test-background-btn" style="width: 100%; margin-top: 10px;">
                            <span class="btn-text">立即测试后台发消息</span>
                        </button>
                        <button type="button" class="btn btn-secondary" id="test-friend-request-btn" style="width: 100%; margin-top: 10px;">
                            <span class="btn-text">立即测试发送好友申请</span>
                        </button>
                    </div>
                `;
                saveBtn.insertAdjacentHTML('beforebegin', backgroundHTML);
                
                // 加载当前设置
                const simplePromptSwitch = document.getElementById('simple-prompt-mode-switch');
                const simpleModeFeaturesContainer = document.getElementById('simple-mode-features-container');
                const messageCountMinInput = document.getElementById('message-count-min-input');
                const messageCountMaxInput = document.getElementById('message-count-max-input');
                const backgroundSwitch = document.getElementById('background-activity-switch');
                const intervalInput = document.getElementById('background-interval-input');
                const probabilityInput = document.getElementById('background-probability-input');
                const blockCooldownInput = document.getElementById('block-cooldown-input');
                const settingsContainer = document.getElementById('background-settings-container');
                
                // 加载简洁模式设置
                if (simplePromptSwitch) {
                    simplePromptSwitch.checked = db.simplePromptMode || false;
                    
                    // 根据开关状态显示/隐藏功能选择区域
                    if (simpleModeFeaturesContainer) {
                        simpleModeFeaturesContainer.style.display = simplePromptSwitch.checked ? 'block' : 'none';
                    }
                    
                    // 监听开关变化
                    simplePromptSwitch.addEventListener('change', () => {
                        if (simpleModeFeaturesContainer) {
                            simpleModeFeaturesContainer.style.display = simplePromptSwitch.checked ? 'block' : 'none';
                        }
                    });
                }
                
                // 加载功能模块选择
                if (db.simplePromptFeatures) {
                    document.getElementById('feature-inner-thought').checked = db.simplePromptFeatures.innerThought !== false;
                    document.getElementById('feature-music').checked = db.simplePromptFeatures.music !== false;
                    document.getElementById('feature-avatar').checked = db.simplePromptFeatures.avatar !== false;
                    document.getElementById('feature-npc').checked = db.simplePromptFeatures.npc !== false;
                    document.getElementById('feature-offline-mode').checked = db.simplePromptFeatures.offlineMode !== false;
                    document.getElementById('feature-mount-chat').checked = db.simplePromptFeatures.mountChat !== false;
                    document.getElementById('feature-recognize-avatar').checked = db.simplePromptFeatures.recognizeAvatar !== false;
                    document.getElementById('feature-time-awareness').checked = db.simplePromptFeatures.timeAwareness !== false;
                }
                
                // 全选/全不选按钮
                document.getElementById('select-all-features-btn').addEventListener('click', () => {
                    document.querySelectorAll('.simple-mode-feature').forEach(cb => cb.checked = true);
                });
                document.getElementById('deselect-all-features-btn').addEventListener('click', () => {
                    document.querySelectorAll('.simple-mode-feature').forEach(cb => cb.checked = false);
                });
                
                // 加载消息数量限制设置
                if (messageCountMinInput) {
                    messageCountMinInput.value = db.messageCountMin || '';
                }
                if (messageCountMaxInput) {
                    messageCountMaxInput.value = db.messageCountMax || '';
                }
                
                if (backgroundSwitch && intervalInput && probabilityInput && blockCooldownInput && settingsContainer) {
                    backgroundSwitch.checked = db.enableBackgroundActivity || false;
                    intervalInput.value = db.backgroundActivityInterval || 60;
                    probabilityInput.value = db.backgroundActivityProbability || 20;
                    blockCooldownInput.value = db.blockCooldownHours || 1;
                    
                    // 根据开关状态显示/隐藏设置项
                    settingsContainer.style.display = backgroundSwitch.checked ? 'block' : 'none';
                    
                    // 监听开关变化
                    backgroundSwitch.addEventListener('change', () => {
                        settingsContainer.style.display = backgroundSwitch.checked ? 'block' : 'none';
                    });
                    
                    // 测试后台发消息按钮
                    const testBackgroundBtn = document.getElementById('test-background-btn');
                    if (testBackgroundBtn) {
                        testBackgroundBtn.addEventListener('click', async () => {
                            // 检查是否有角色
                            if (!db.characters || db.characters.length === 0) {
                                showToast('没有可测试的角色，请先创建角色！');
                                return;
                            }
                            
                            // 检查API配置
                            if (!db.apiSettings || !db.apiSettings.url || !db.apiSettings.key || !db.apiSettings.model) {
                                showToast('请先完成API设置！');
                                return;
                            }
                            
                            // 获取非当前聊天的角色
                            const availableCharacters = db.characters.filter(c => c.id !== currentChatId);
                            if (availableCharacters.length === 0) {
                                showToast('所有角色都在当前聊天中，无法测试！');
                                return;
                            }
                            
                            // 随机选择一个角色
                            const testCharacter = availableCharacters[Math.floor(Math.random() * availableCharacters.length)];
                            const testCharacterName = testCharacter.remarkName || testCharacter.realName || '未命名角色';
                            
                            // 显示加载状态
                            testBackgroundBtn.classList.add('loading');
                            testBackgroundBtn.disabled = true;
                            showToast(`正在测试角色"${testCharacterName}"的后台发消息...`);
                            
                            try {
                                // 调用后台发消息函数
                                await triggerBackgroundAiAction(testCharacter.id);
                                showToast(`测试成功！请查看角色"${testCharacterName}"的聊天记录。`);
                            } catch (error) {
                                console.error('测试后台发消息失败:', error);
                                showToast(`测试失败: ${error.message}`);
                            } finally {
                                testBackgroundBtn.classList.remove('loading');
                                testBackgroundBtn.disabled = false;
                            }
                        });
                    }
                    
                    // 【全新】测试发送好友申请按钮
                    const testFriendRequestBtn = document.getElementById('test-friend-request-btn');
                    if (testFriendRequestBtn) {
                        testFriendRequestBtn.addEventListener('click', async () => {
                            // 检查是否有角色
                            if (!db.characters || db.characters.length === 0) {
                                showToast('没有可测试的角色，请先创建角色！');
                                return;
                            }
                            
                            // 检查API配置
                            if (!db.apiSettings || !db.apiSettings.url || !db.apiSettings.key || !db.apiSettings.model) {
                                showToast('请先完成API设置！');
                                return;
                            }
                            
                            // 获取所有被拉黑的角色
                            const blockedCharacters = db.characters.filter(c => c.relationship?.status === 'blocked_by_user');
                            if (blockedCharacters.length === 0) {
                                showToast('没有被拉黑的角色，无法测试好友申请！');
                                return;
                            }
                            
                            // 随机选择一个被拉黑的角色
                            const testCharacter = blockedCharacters[Math.floor(Math.random() * blockedCharacters.length)];
                            const testCharacterName = testCharacter.remarkName || testCharacter.realName || '未命名角色';
                            
                            // 显示加载状态
                            testFriendRequestBtn.classList.add('loading');
                            testFriendRequestBtn.disabled = true;
                            showToast(`正在测试角色"${testCharacterName}"发送好友申请...`);
                            
                            try {
                                // 调用好友申请函数
                                await triggerAiFriendApplication(testCharacter.id);
                                showToast(`测试成功！角色"${testCharacterName}"已发送好友申请，请查看聊天列表。`);
                                
                                // 刷新聊天列表
                                if (document.getElementById('chat-list-screen').classList.contains('active')) {
                                    renderChatList();
                                }
                            } catch (error) {
                                console.error('测试好友申请失败:', error);
                                showToast(`测试失败: ${error.message}`);
                            } finally {
                                testFriendRequestBtn.classList.remove('loading');
                                testFriendRequestBtn.disabled = false;
                            }
                        });
                    }
                }
            }
            // 修改"API 预设"标题为"聊天API预设"
            setTimeout(() => {
                const apiPresetHeaders = document.querySelectorAll('#api-settings-screen h3');
                apiPresetHeaders.forEach(header => {
                    if (header.textContent.trim() === 'API 预设') {
                        header.innerHTML = '聊天API预设';
                        // 添加说明文字
                        const description = document.createElement('p');
                        description.style.cssText = 'font-size: 13px; color: #666; margin: 5px 0 15px 0; font-weight: normal;';
                        description.textContent = '保存和管理不同的聊天API配置，方便快速切换';
                        header.parentNode.insertBefore(description, header.nextSibling);
                    }
                });
            }, 100);
            
            // 预设相关DOM元素
            const presetSelect = document.getElementById('api-preset-select'),
                savePresetBtn = document.getElementById('save-preset-btn'),
                deletePresetBtn = document.getElementById('delete-preset-btn'),
                presetListContainer = document.getElementById('preset-list-container'),
                presetCheckboxes = document.getElementById('preset-checkboxes'),
                selectAllCheckbox = document.getElementById('select-all-presets');

            // 加载当前API设置
            db.apiSettings && (n.value = db.apiSettings.provider || 'newapi', r.value = db.apiSettings.url || '', s.value = db.apiSettings.key || '', db.apiSettings.model && (a.innerHTML = `<option value="${db.apiSettings.model}">${db.apiSettings.model}</option>`));
            
            // 初始化预设数组
            if (!db.apiPresets) db.apiPresets = [];
            
            // 渲染预设列表
            function renderPresetList() {
                presetSelect.innerHTML = '<option value="">-- 选择一个预设 --</option>';
                presetCheckboxes.innerHTML = '';
                
                if (db.apiPresets.length === 0) {
                    presetListContainer.style.display = 'none';
                    return;
                }
                
                db.apiPresets.forEach((preset, index) => {
                    // 添加到下拉框
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = preset.name;
                    presetSelect.appendChild(option);
                    
                    // 添加到复选框列表
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 5px 0;';
                    checkboxDiv.innerHTML = `
                        <input type="checkbox" id="preset-${index}" value="${index}" style="cursor: pointer;">
                        <label for="preset-${index}" style="cursor: pointer; margin: 0; flex: 1;">${preset.name}</label>
                    `;
                    presetCheckboxes.appendChild(checkboxDiv);
                });
            }
            
            // 初始渲染
            renderPresetList();
            
            // 选择预设时加载设置
            presetSelect.addEventListener('change', () => {
                const index = presetSelect.value;
                if (index === '') return;
                
                const preset = db.apiPresets[parseInt(index)];
                if (preset) {
                    n.value = preset.provider;
                    r.value = preset.url;
                    s.value = preset.key;
                    if (preset.model) {
                        a.innerHTML = `<option value="${preset.model}">${preset.model}</option>`;
                    }
                    showToast(`已加载预设：${preset.name}`);
                }
            });
            
            // 保存预设
            savePresetBtn.addEventListener('click', async () => {
                if (!n.value || !r.value || !s.value || !a.value) {
                    return showToast('请先完整填写API设置！');
                }
                
                // 检查是否存在相同 URL 的预设
                const existingPresetIndex = db.apiPresets.findIndex(preset => preset.url === r.value);
                
                if (existingPresetIndex !== -1) {
                    const existingPreset = db.apiPresets[existingPresetIndex];
                    // 检查其他配置是否也相同
                    const isSameConfig = existingPreset.provider === n.value && 
                                        existingPreset.key === s.value && 
                                        existingPreset.model === a.value;
                    
                    if (!isSameConfig) {
                        // URL 相同但其他配置不同，询问是否覆盖
                        const shouldOverwrite = confirm(`检测到已存在相同 URL 的预设"${existingPreset.name}"，但其他配置不同。\n\n是否要覆盖该预设的内容？\n\n点击"确定"覆盖，点击"取消"创建新预设。`);
                        
                        if (shouldOverwrite) {
                            // 覆盖现有预设
                            db.apiPresets[existingPresetIndex] = {
                                name: existingPreset.name, // 保持原预设名称
                                provider: n.value,
                                url: r.value,
                                key: s.value,
                                model: a.value,
                                createdAt: existingPreset.createdAt, // 保持原创建时间
                                updatedAt: Date.now() // 添加更新时间
                            };
                            await saveData();
                            renderPresetList();
                            showToast(`预设"${existingPreset.name}"已更新！`);
                            return;
                        }
                    } else {
                        // 完全相同的配置
                        showToast(`预设"${existingPreset.name}"已存在且配置相同！`);
                        return;
                    }
                }
                
                // 创建新预设
                const presetName = prompt('请输入预设名称：', `预设${db.apiPresets.length + 1}`);
                if (!presetName) return;
                
                const newPreset = {
                    name: presetName.trim(),
                    provider: n.value,
                    url: r.value,
                    key: s.value,
                    model: a.value,
                    createdAt: Date.now()
                };
                
                db.apiPresets.push(newPreset);
                await saveData();
                renderPresetList();
                showToast(`预设"${presetName}"已保存！`);
            });
            
            // 显示/隐藏删除列表
            deletePresetBtn.addEventListener('click', () => {
                if (db.apiPresets.length === 0) {
                    return showToast('没有可删除的预设！');
                }
                
                if (presetListContainer.style.display === 'none' || presetListContainer.style.display === '') {
                    presetListContainer.style.display = 'block';
                    deletePresetBtn.textContent = '取消';
                    deletePresetBtn.classList.remove('btn-danger');
                    deletePresetBtn.classList.add('btn-secondary');
                } else {
                    // 执行删除
                    const checkedBoxes = presetCheckboxes.querySelectorAll('input[type="checkbox"]:checked');
                    if (checkedBoxes.length === 0) {
                        return showToast('请至少选择一个预设！');
                    }
                    
                    if (!confirm(`确定要删除选中的 ${checkedBoxes.length} 个预设吗？`)) {
                        return;
                    }
                    
                    const indicesToDelete = Array.from(checkedBoxes).map(cb => parseInt(cb.value)).sort((a, b) => b - a);
                    indicesToDelete.forEach(index => {
                        db.apiPresets.splice(index, 1);
                    });
                    
                    saveData();
                    renderPresetList();
                    presetListContainer.style.display = 'none';
                    deletePresetBtn.textContent = '删除预设';
                    deletePresetBtn.classList.remove('btn-secondary');
                    deletePresetBtn.classList.add('btn-danger');
                    showToast(`已删除 ${checkedBoxes.length} 个预设！`);
                    selectAllCheckbox.checked = false;
                }
            });
            
            // 全选功能
            selectAllCheckbox.addEventListener('change', (e) => {
                const checkboxes = presetCheckboxes.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(cb => {
                    cb.checked = e.target.checked;
                });
            });

            n.addEventListener('change', () => {
                r.value = c[n.value] || ''
            });
            t.addEventListener('click', async () => {
                let o = r.value.trim();
                const l = s.value.trim();
                if (!o || !l) return showToast('请先填写API地址和密钥！');
                o.endsWith('/') && (o = o.slice(0, -1));
                const i = 'gemini' === n.value ? `${o}/v1beta/models?key=${getRandomValue(l)}` : `${o}/v1/models`;
                t.classList.add('loading'), t.disabled = !0;
                try {
                    const d = 'gemini' === n.value ? {} : {Authorization: `Bearer ${l}`},
                        g = await fetch(i, {method: 'GET', headers: d});
                    if (!g.ok) throw new Error(`网络响应错误: ${g.status}`);
                    const u = await g.json();
                    let p = [];
                    'gemini' !== n.value && u.data ? p = u.data.map(e => e.id) : 'gemini' === n.value && u.models && (p = u.models.map(e => e.name.replace('models/', ''))), a.innerHTML = '', p.length > 0 ? p.forEach(e => {
                        const t = document.createElement('option');
                        t.value = e, t.textContent = e, a.appendChild(t)
                    }) : a.innerHTML = '<option value="">未找到任何模型</option>', showToast('模型列表拉取成功！')
                } catch (f) {
                    showToast(`拉取失败: ${f.message}`), a.innerHTML = '<option value="">拉取失败</option>'
                } finally {
                    t.classList.remove('loading'), t.disabled = !1
                }
            });

            // 测试连通性按钮
            const testConnectionBtn = document.getElementById('test-connection-btn');
            testConnectionBtn.addEventListener('click', async () => {
                let apiUrl = r.value.trim();
                const apiKey = s.value.trim();
                const selectedModel = a.value;
                
                if (!apiUrl || !apiKey) {
                    return showToast('请先填写API地址和密钥！');
                }
                
                if (!selectedModel) {
                    return showToast('请先拉取并选择模型！');
                }
                
                // 提示用户可能会消耗额度
                if (!confirm('测试连通性将发送一条测试消息，可能会消耗一次API额度。是否继续？')) {
                    return;
                }
                
                apiUrl.endsWith('/') && (apiUrl = apiUrl.slice(0, -1));
                
                testConnectionBtn.classList.add('loading');
                testConnectionBtn.disabled = true;
                
                try {
                    let endpoint, headers, body;
                    
                    if (n.value === 'gemini') {
                        // Gemini API
                        endpoint = `${apiUrl}/v1beta/models/${selectedModel}:generateContent?key=${getRandomValue(apiKey)}`;
                        headers = {
                            'Content-Type': 'application/json'
                        };
                        body = JSON.stringify({
                            contents: [{
                                parts: [{
                                    text: '测试连通性'
                                }]
                            }]
                        });
                    } else if (n.value === 'claude') {
                        // Claude API
                        endpoint = `${apiUrl}/v1/messages`;
                        headers = {
                            'Content-Type': 'application/json',
                            'x-api-key': apiKey,
                            'anthropic-version': '2023-06-01'
                        };
                        body = JSON.stringify({
                            model: selectedModel,
                            messages: [{
                                role: 'user',
                                content: '测试连通性'
                            }],
                            max_tokens: 10
                        });
                    } else {
                        // OpenAI 兼容 API (NewAPI, DeepSeek等)
                        endpoint = `${apiUrl}/v1/chat/completions`;
                        headers = {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        };
                        body = JSON.stringify({
                            model: selectedModel,
                            messages: [{
                                role: 'user',
                                content: '测试连通性'
                            }],
                            max_tokens: 10
                        });
                    }
                    
                    const response = await fetch(endpoint, {
                        method: 'POST',
                        headers: headers,
                        body: body
                    });
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`HTTP ${response.status}: ${errorText}`);
                    }
                    
                    const result = await response.json();
                    
                    // 检查响应是否包含有效内容
                    let hasValidResponse = false;
                    if (n.value === 'gemini' && result.candidates && result.candidates.length > 0) {
                        hasValidResponse = true;
                    } else if (n.value === 'claude' && result.content && result.content.length > 0) {
                        hasValidResponse = true;
                    } else if (result.choices && result.choices.length > 0) {
                        hasValidResponse = true;
                    }
                    
                    if (hasValidResponse) {
                        showToast('连通性测试成功！API配置正常，可以正常发送消息。');
                    } else {
                        showToast('API响应异常，请检查配置。');
                    }
                    
                } catch (error) {
                    showToast(`连通性测试失败: ${error.message}`);
                } finally {
                    testConnectionBtn.classList.remove('loading');
                    testConnectionBtn.disabled = false;
                }
            });
            e.addEventListener('submit', async (e) => {
                e.preventDefault();
                if (!a.value) return showToast('请选择模型后保存！');
                db.apiSettings = {provider: n.value, url: r.value, key: s.value, model: a.value};
                
                // 保存简洁模式设置
                const simplePromptSwitch = document.getElementById('simple-prompt-mode-switch');
                if (simplePromptSwitch) {
                    db.simplePromptMode = simplePromptSwitch.checked;
                    
                    // 保存功能模块选择
                    db.simplePromptFeatures = {
                        innerThought: document.getElementById('feature-inner-thought').checked,
                        music: document.getElementById('feature-music').checked,
                        avatar: document.getElementById('feature-avatar').checked,
                        npc: document.getElementById('feature-npc').checked,
                        offlineMode: document.getElementById('feature-offline-mode').checked,
                        mountChat: document.getElementById('feature-mount-chat').checked,
                        recognizeAvatar: document.getElementById('feature-recognize-avatar').checked,
                        timeAwareness: document.getElementById('feature-time-awareness').checked
                    };
                }
                
                // 保存消息数量限制设置
                const messageCountMinInput = document.getElementById('message-count-min-input');
                const messageCountMaxInput = document.getElementById('message-count-max-input');
                if (messageCountMinInput && messageCountMaxInput) {
                    const minValue = parseInt(messageCountMinInput.value);
                    const maxValue = parseInt(messageCountMaxInput.value);
                    
                    // 验证并保存最小值
                    if (!isNaN(minValue) && minValue >= 1) {
                        db.messageCountMin = minValue;
                    } else {
                        db.messageCountMin = 1; // 默认值
                    }
                    
                    // 验证并保存最大值
                    if (!isNaN(maxValue) && maxValue >= 1) {
                        db.messageCountMax = maxValue;
                    } else {
                        db.messageCountMax = 20; // 默认值
                    }
                    
                    // 确保最小值不大于最大值
                    if (db.messageCountMin > db.messageCountMax) {
                        const temp = db.messageCountMin;
                        db.messageCountMin = db.messageCountMax;
                        db.messageCountMax = temp;
                        showToast('已自动调整：最小值不能大于最大值');
                    }
                }
                
                // 保存后台活动设置
                const backgroundSwitch = document.getElementById('background-activity-switch');
                const intervalInput = document.getElementById('background-interval-input');
                const probabilityInput = document.getElementById('background-probability-input');
                const blockCooldownInput = document.getElementById('block-cooldown-input');
                if (backgroundSwitch && intervalInput && probabilityInput && blockCooldownInput) {
                    const newEnableState = backgroundSwitch.checked;
                    const oldEnableState = db.enableBackgroundActivity || false;
                    
                    // 如果从关闭变为开启，显示警告
                    if (!oldEnableState && newEnableState) {
                        const confirmed = confirm('警告：启用后台活动会让AI角色主动发送消息，这将显著增加API调用次数和费用！\n\n确定要启用吗？');
                        if (!confirmed) {
                            backgroundSwitch.checked = false;
                            document.getElementById('background-settings-container').style.display = 'none';
                            return;
                        }
                    }
                    
                    db.enableBackgroundActivity = newEnableState;
                    const intervalValue = parseFloat(intervalInput.value) || 60;
                    // 确保间隔大于0
                    db.backgroundActivityInterval = intervalValue > 0 ? intervalValue : 60;
                    db.backgroundActivityProbability = parseInt(probabilityInput.value) || 20;
                    db.blockCooldownHours = parseFloat(blockCooldownInput.value) || 1;
                    
                    // 动态启动或停止后台活动
                    stopBackgroundSimulation();
                    if (db.enableBackgroundActivity) {
                        startBackgroundSimulation();
                        console.log(`后台活动已启动，间隔: ${db.backgroundActivityInterval}秒，唤醒概率: ${db.backgroundActivityProbability}%`);
                    } else {
                        console.log("后台活动已停止");
                    }
                }
                
                await saveData();
                showToast('API设置已保存！')
            });
            
            // ===== 副API设置 =====
            const secondaryProvider = document.getElementById('secondary-api-provider'),
                secondaryUrl = document.getElementById('secondary-api-url'),
                secondaryKey = document.getElementById('secondary-api-key'),
                secondaryModel = document.getElementById('secondary-api-model'),
                fetchSecondaryModelsBtn = document.getElementById('fetch-secondary-models-btn'),
                saveSecondaryApiBtn = document.getElementById('save-secondary-api-btn'),
                secondaryPresetSelect = document.getElementById('secondary-api-preset-select'),
                saveSecondaryPresetBtn = document.getElementById('save-secondary-preset-btn'),
                deleteSecondaryPresetBtn = document.getElementById('delete-secondary-preset-btn'),
                secondaryPresetListContainer = document.getElementById('secondary-preset-list-container'),
                secondaryPresetCheckboxes = document.getElementById('secondary-preset-checkboxes'),
                selectAllSecondaryCheckbox = document.getElementById('select-all-secondary-presets');

            // 初始化副API设置
            if (!db.secondaryApiSettings) {
                db.secondaryApiSettings = {
                    provider: '',
                    url: '',
                    key: '',
                    model: ''
                };
            }

            // 加载副API设置
            if (db.secondaryApiSettings) {
                secondaryProvider.value = db.secondaryApiSettings.provider || '';
                secondaryUrl.value = db.secondaryApiSettings.url || '';
                secondaryKey.value = db.secondaryApiSettings.key || '';
                if (db.secondaryApiSettings.model) {
                    secondaryModel.innerHTML = `<option value="${db.secondaryApiSettings.model}">${db.secondaryApiSettings.model}</option>`;
                }
            }

            // 初始化副API预设数组
            if (!db.secondaryApiPresets) db.secondaryApiPresets = [];

            // 渲染副API预设列表
            function renderSecondaryPresetList() {
                secondaryPresetSelect.innerHTML = '<option value="">-- 选择一个预设 --</option>';
                secondaryPresetCheckboxes.innerHTML = '';
                
                if (db.secondaryApiPresets.length === 0) {
                    secondaryPresetListContainer.style.display = 'none';
                    return;
                }
                
                db.secondaryApiPresets.forEach((preset, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = preset.name;
                    secondaryPresetSelect.appendChild(option);
                    
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 5px 0;';
                    checkboxDiv.innerHTML = `
                        <input type="checkbox" id="secondary-preset-${index}" value="${index}" style="cursor: pointer;">
                        <label for="secondary-preset-${index}" style="cursor: pointer; margin: 0; flex: 1;">${preset.name}</label>
                    `;
                    secondaryPresetCheckboxes.appendChild(checkboxDiv);
                });
            }

            renderSecondaryPresetList();

            // 副API服务商切换时自动填充地址
            secondaryProvider.addEventListener('change', () => {
                if (secondaryProvider.value && c[secondaryProvider.value]) {
                    secondaryUrl.value = c[secondaryProvider.value];
                } else if (secondaryProvider.value === '') {
                    secondaryUrl.value = '';
                }
            });

            // 拉取副API模型
            fetchSecondaryModelsBtn.addEventListener('click', async () => {
                let apiUrl = secondaryUrl.value.trim();
                const apiKey = secondaryKey.value.trim();
                
                if (!secondaryProvider.value || secondaryProvider.value === '') {
                    return showToast('请先选择副API服务商！');
                }
                
                if (!apiUrl || !apiKey) {
                    return showToast('请先填写副API地址和密钥！');
                }
                
                apiUrl.endsWith('/') && (apiUrl = apiUrl.slice(0, -1));
                const endpoint = secondaryProvider.value === 'gemini' 
                    ? `${apiUrl}/v1beta/models?key=${getRandomValue(apiKey)}` 
                    : `${apiUrl}/v1/models`;
                
                fetchSecondaryModelsBtn.classList.add('loading');
                fetchSecondaryModelsBtn.disabled = true;
                
                try {
                    const headers = secondaryProvider.value === 'gemini' 
                        ? {} 
                        : {Authorization: `Bearer ${apiKey}`};
                    
                    const response = await fetch(endpoint, {method: 'GET', headers: headers});
                    
                    if (!response.ok) throw new Error(`网络响应错误: ${response.status}`);
                    
                    const data = await response.json();
                    let models = [];
                    
                    if (secondaryProvider.value !== 'gemini' && data.data) {
                        models = data.data.map(m => m.id);
                    } else if (secondaryProvider.value === 'gemini' && data.models) {
                        models = data.models.map(m => m.name.replace('models/', ''));
                    }
                    
                    secondaryModel.innerHTML = '';
                    if (models.length > 0) {
                        models.forEach(modelId => {
                            const option = document.createElement('option');
                            option.value = modelId;
                            option.textContent = modelId;
                            secondaryModel.appendChild(option);
                        });
                        showToast('副API模型列表拉取成功！');
                    } else {
                        secondaryModel.innerHTML = '<option value="">未找到任何模型</option>';
                        showToast('未找到任何模型');
                    }
                } catch (error) {
                    showToast(`拉取失败: ${error.message}`);
                    secondaryModel.innerHTML = '<option value="">拉取失败</option>';
                } finally {
                    fetchSecondaryModelsBtn.classList.remove('loading');
                    fetchSecondaryModelsBtn.disabled = false;
                }
            });

            // 保存副API设置
            saveSecondaryApiBtn.addEventListener('click', async () => {
                // 允许清空副API设置
                db.secondaryApiSettings = {
                    provider: secondaryProvider.value,
                    url: secondaryUrl.value.trim(),
                    key: secondaryKey.value.trim(),
                    model: secondaryModel.value
                };
                await saveData();
                
                if (secondaryProvider.value === '') {
                    showToast('副API设置已清空，将使用主API！');
                } else {
                    showToast('副API设置已保存！');
                }
            });

            // 选择副API预设时加载设置
            secondaryPresetSelect.addEventListener('change', () => {
                const index = secondaryPresetSelect.value;
                if (index === '') return;
                
                const preset = db.secondaryApiPresets[parseInt(index)];
                if (preset) {
                    secondaryProvider.value = preset.provider;
                    secondaryUrl.value = preset.url;
                    secondaryKey.value = preset.key;
                    if (preset.model) {
                        secondaryModel.innerHTML = `<option value="${preset.model}">${preset.model}</option>`;
                    }
                    showToast(`已加载副API预设：${preset.name}`);
                }
            });

            // 保存副API预设
            saveSecondaryPresetBtn.addEventListener('click', async () => {
                if (!secondaryProvider.value || !secondaryUrl.value || !secondaryKey.value || !secondaryModel.value) {
                    return showToast('请先完整填写副API设置！');
                }
                
                // 检查是否存在相同 URL 的预设
                const existingPresetIndex = db.secondaryApiPresets.findIndex(preset => preset.url === secondaryUrl.value);
                
                if (existingPresetIndex !== -1) {
                    const existingPreset = db.secondaryApiPresets[existingPresetIndex];
                    // 检查其他配置是否也相同
                    const isSameConfig = existingPreset.provider === secondaryProvider.value && 
                                        existingPreset.key === secondaryKey.value && 
                                        existingPreset.model === secondaryModel.value;
                    
                    if (!isSameConfig) {
                        // URL 相同但其他配置不同，询问是否覆盖
                        const shouldOverwrite = confirm(`检测到已存在相同 URL 的副API预设"${existingPreset.name}"，但其他配置不同。\n\n是否要覆盖该预设的内容？\n\n点击"确定"覆盖，点击"取消"创建新预设。`);
                        
                        if (shouldOverwrite) {
                            // 覆盖现有预设
                            db.secondaryApiPresets[existingPresetIndex] = {
                                name: existingPreset.name, // 保持原预设名称
                                provider: secondaryProvider.value,
                                url: secondaryUrl.value,
                                key: secondaryKey.value,
                                model: secondaryModel.value,
                                createdAt: existingPreset.createdAt, // 保持原创建时间
                                updatedAt: Date.now() // 添加更新时间
                            };
                            await saveData();
                            renderSecondaryPresetList();
                            showToast(`副API预设"${existingPreset.name}"已更新！`);
                            return;
                        }
                    } else {
                        // 完全相同的配置
                        showToast(`副API预设"${existingPreset.name}"已存在且配置相同！`);
                        return;
                    }
                }
                
                // 创建新预设
                const presetName = prompt('请输入副API预设名称：', `副API预设${db.secondaryApiPresets.length + 1}`);
                if (!presetName) return;
                
                const newPreset = {
                    name: presetName.trim(),
                    provider: secondaryProvider.value,
                    url: secondaryUrl.value,
                    key: secondaryKey.value,
                    model: secondaryModel.value,
                    createdAt: Date.now()
                };
                
                db.secondaryApiPresets.push(newPreset);
                await saveData();
                renderSecondaryPresetList();
                showToast(`副API预设"${presetName}"已保存！`);
            });

            // 删除副API预设
            deleteSecondaryPresetBtn.addEventListener('click', async () => {
                if (db.secondaryApiPresets.length === 0) {
                    return showToast('没有可删除的副API预设！');
                }
                
                if (secondaryPresetListContainer.style.display === 'none' || secondaryPresetListContainer.style.display === '') {
                    secondaryPresetListContainer.style.display = 'block';
                    deleteSecondaryPresetBtn.textContent = '取消';
                    deleteSecondaryPresetBtn.classList.remove('btn-danger');
                    deleteSecondaryPresetBtn.classList.add('btn-secondary');
                } else {
                    const checkedBoxes = secondaryPresetCheckboxes.querySelectorAll('input[type="checkbox"]:checked');
                    if (checkedBoxes.length === 0) {
                        return showToast('请至少选择一个副API预设！');
                    }
                    
                    if (!confirm(`确定要删除选中的 ${checkedBoxes.length} 个副API预设吗？`)) {
                        return;
                    }
                    
                    const indicesToDelete = Array.from(checkedBoxes).map(cb => parseInt(cb.value)).sort((a, b) => b - a);
                    indicesToDelete.forEach(index => {
                        db.secondaryApiPresets.splice(index, 1);
                    });
                    
                    await saveData();
                    renderSecondaryPresetList();
                    secondaryPresetListContainer.style.display = 'none';
                    deleteSecondaryPresetBtn.textContent = '删除副API预设';
                    deleteSecondaryPresetBtn.classList.remove('btn-secondary');
                    deleteSecondaryPresetBtn.classList.add('btn-danger');
                    showToast(`已删除 ${checkedBoxes.length} 个副API预设！`);
                    selectAllSecondaryCheckbox.checked = false;
                }
            });

            // 副API预设全选功能
            selectAllSecondaryCheckbox.addEventListener('change', (e) => {
                const checkboxes = secondaryPresetCheckboxes.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(cb => {
                    cb.checked = e.target.checked;
                });
            });
            
            // ===== Minimax TTS 配置 =====
            const minimaxGroupIdInput = document.getElementById('minimax-group-id');
            const minimaxApiKeyInput = document.getElementById('minimax-api-key');
            const minimaxVoiceIdInput = document.getElementById('minimax-voice-id');
            const minimaxSpeechModelSelect = document.getElementById('minimax-speech-model');
            const saveMinimaxBtn = document.getElementById('save-minimax-btn');
            
            // 初始化 Minimax 配置
            if (!db.minimaxConfig) {
                db.minimaxConfig = {
                    groupId: '',
                    apiKey: '',
                    voiceId: 'male-qn-qingse',
                    speechModel: 'speech-01'
                };
            }
            
            // 加载已保存的 Minimax 配置
            minimaxGroupIdInput.value = db.minimaxConfig.groupId || '';
            minimaxApiKeyInput.value = db.minimaxConfig.apiKey || '';
            minimaxVoiceIdInput.value = db.minimaxConfig.voiceId || 'male-qn-qingse';
            minimaxSpeechModelSelect.value = db.minimaxConfig.speechModel || 'speech-01';
            
            // 保存 Minimax 配置
            saveMinimaxBtn.addEventListener('click', async () => {
                db.minimaxConfig = {
                    groupId: minimaxGroupIdInput.value.trim(),
                    apiKey: minimaxApiKeyInput.value.trim(),
                    voiceId: minimaxVoiceIdInput.value.trim() || 'male-qn-qingse',
                    speechModel: minimaxSpeechModelSelect.value || 'speech-01'
                };
                await saveData();
                showToast('Minimax 语音设置已保存！');
            });

            // ===== Minimax 语音API预设 =====
            // 动态添加语音API预设HTML
            const minimaxSection = document.querySelector('#api-settings-screen .content');
            if (minimaxSection) {
                const minimaxPresetHTML = `
                    <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                    <div style="padding: 0 20px;">
                        <h3 style="font-size: 16px; margin-bottom: 15px; color: #333;">语音API预设 (Minimax)</h3>
                        <p style="font-size: 13px; color: #666; margin-bottom: 15px;">保存和管理不同的Minimax语音配置，方便快速切换</p>
                        
                        <div class="form-group">
                            <label for="minimax-preset-select">选择预设</label>
                            <select id="minimax-preset-select" style="margin-bottom: 10px; width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                                <option value="">-- 选择一个预设 --</option>
                            </select>
                        </div>
                        
                        <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                            <button type="button" class="btn btn-primary" id="save-minimax-preset-btn" style="flex: 1;">保存当前配置为预设</button>
                            <button type="button" class="btn btn-danger" id="delete-minimax-preset-btn" style="flex: 1;">删除预设</button>
                        </div>
                        
                        <div id="minimax-preset-list-container" style="max-height: 200px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px; display: none;">
                            <div style="margin-bottom: 10px; display: flex; align-items: center; gap: 10px;">
                                <input type="checkbox" id="select-all-minimax-presets" style="cursor: pointer; width: auto;">
                                <label for="select-all-minimax-presets" style="cursor: pointer; margin: 0;">全选</label>
                            </div>
                            <div id="minimax-preset-checkboxes"></div>
                        </div>
                    </div>
                `;
                
                // 找到Minimax配置区域后插入预设HTML
                const minimaxSaveBtn = document.getElementById('save-minimax-btn');
                if (minimaxSaveBtn && minimaxSaveBtn.parentElement) {
                    minimaxSaveBtn.parentElement.insertAdjacentHTML('afterend', minimaxPresetHTML);
                }
                
                // 初始化Minimax预设数组
                if (!db.minimaxPresets) db.minimaxPresets = [];
                
                // Minimax预设相关DOM元素
                const minimaxPresetSelect = document.getElementById('minimax-preset-select');
                const saveMinimaxPresetBtn = document.getElementById('save-minimax-preset-btn');
                const deleteMinimaxPresetBtn = document.getElementById('delete-minimax-preset-btn');
                const minimaxPresetListContainer = document.getElementById('minimax-preset-list-container');
                const minimaxPresetCheckboxes = document.getElementById('minimax-preset-checkboxes');
                const selectAllMinimaxCheckbox = document.getElementById('select-all-minimax-presets');
                
                // 渲染Minimax预设列表
                function renderMinimaxPresetList() {
                    if (!minimaxPresetSelect) return;
                    
                    minimaxPresetSelect.innerHTML = '<option value="">-- 选择一个预设 --</option>';
                    minimaxPresetCheckboxes.innerHTML = '';
                    
                    if (db.minimaxPresets.length === 0) {
                        minimaxPresetListContainer.style.display = 'none';
                        return;
                    }
                    
                    db.minimaxPresets.forEach((preset, index) => {
                        // 添加到下拉框
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = preset.name;
                        minimaxPresetSelect.appendChild(option);
                        
                        // 添加到复选框列表
                        const checkboxDiv = document.createElement('div');
                        checkboxDiv.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 5px 0;';
                        checkboxDiv.innerHTML = `
                            <input type="checkbox" id="minimax-preset-${index}" value="${index}" style="cursor: pointer; width: auto;">
                            <label for="minimax-preset-${index}" style="cursor: pointer; margin: 0; flex: 1;">${preset.name}</label>
                        `;
                        minimaxPresetCheckboxes.appendChild(checkboxDiv);
                    });
                }
                
                // 初始渲染
                renderMinimaxPresetList();
                
                // 选择预设时加载配置
                if (minimaxPresetSelect) {
                    minimaxPresetSelect.addEventListener('change', () => {
                        const index = minimaxPresetSelect.value;
                        if (index === '') return;
                        
                        const preset = db.minimaxPresets[parseInt(index)];
                        if (preset) {
                            minimaxGroupIdInput.value = preset.groupId || '';
                            minimaxApiKeyInput.value = preset.apiKey || '';
                            minimaxVoiceIdInput.value = preset.voiceId || 'male-qn-qingse';
                            minimaxSpeechModelSelect.value = preset.speechModel || 'speech-01';
                            showToast(`已加载预设：${preset.name}`);
                        }
                    });
                }
                
                // 保存Minimax预设
                if (saveMinimaxPresetBtn) {
                    saveMinimaxPresetBtn.addEventListener('click', async () => {
                        const groupId = minimaxGroupIdInput.value.trim();
                        const apiKey = minimaxApiKeyInput.value.trim();
                        
                        if (!groupId || !apiKey) {
                            return showToast('请先填写Group ID和API Key！');
                        }
                        
                        // 检查是否存在相同 Group ID 和 API Key 的预设
                        const existingPresetIndex = db.minimaxPresets.findIndex(preset => 
                            preset.groupId === groupId && preset.apiKey === apiKey
                        );
                        
                        if (existingPresetIndex !== -1) {
                            const existingPreset = db.minimaxPresets[existingPresetIndex];
                            // 检查其他配置是否也相同
                            const isSameConfig = existingPreset.voiceId === (minimaxVoiceIdInput.value.trim() || 'male-qn-qingse') && 
                                                existingPreset.speechModel === (minimaxSpeechModelSelect.value || 'speech-01');
                            
                            if (!isSameConfig) {
                                // Group ID 和 API Key 相同但其他配置不同，询问是否覆盖
                                const shouldOverwrite = confirm(`检测到已存在相同 Group ID 和 API Key 的预设"${existingPreset.name}"，但其他配置不同。\n\n是否要覆盖该预设的内容？\n\n点击"确定"覆盖，点击"取消"创建新预设。`);
                                
                                if (shouldOverwrite) {
                                    // 覆盖现有预设
                                    db.minimaxPresets[existingPresetIndex] = {
                                        name: existingPreset.name, // 保持原预设名称
                                        groupId: groupId,
                                        apiKey: apiKey,
                                        voiceId: minimaxVoiceIdInput.value.trim() || 'male-qn-qingse',
                                        speechModel: minimaxSpeechModelSelect.value || 'speech-01',
                                        createdAt: existingPreset.createdAt, // 保持原创建时间
                                        updatedAt: Date.now() // 添加更新时间
                                    };
                                    await saveData();
                                    renderMinimaxPresetList();
                                    showToast(`预设"${existingPreset.name}"已更新！`);
                                    return;
                                }
                            } else {
                                // 完全相同的配置
                                showToast(`预设"${existingPreset.name}"已存在且配置相同！`);
                                return;
                            }
                        }
                        
                        // 创建新预设
                        const presetName = prompt('请输入预设名称：', `语音预设${db.minimaxPresets.length + 1}`);
                        if (!presetName) return;
                        
                        const newPreset = {
                            name: presetName.trim(),
                            groupId: groupId,
                            apiKey: apiKey,
                            voiceId: minimaxVoiceIdInput.value.trim() || 'male-qn-qingse',
                            speechModel: minimaxSpeechModelSelect.value || 'speech-01',
                            createdAt: Date.now()
                        };
                        
                        db.minimaxPresets.push(newPreset);
                        await saveData();
                        renderMinimaxPresetList();
                        showToast(`预设"${presetName}"已保存！`);
                    });
                }
                
                // 删除Minimax预设
                if (deleteMinimaxPresetBtn) {
                    deleteMinimaxPresetBtn.addEventListener('click', async () => {
                        if (db.minimaxPresets.length === 0) {
                            return showToast('没有可删除的预设！');
                        }
                        
                        if (minimaxPresetListContainer.style.display === 'none' || minimaxPresetListContainer.style.display === '') {
                            minimaxPresetListContainer.style.display = 'block';
                            deleteMinimaxPresetBtn.textContent = '取消';
                            deleteMinimaxPresetBtn.classList.remove('btn-danger');
                            deleteMinimaxPresetBtn.classList.add('btn-secondary');
                        } else {
                            // 执行删除
                            const checkedBoxes = minimaxPresetCheckboxes.querySelectorAll('input[type="checkbox"]:checked');
                            if (checkedBoxes.length === 0) {
                                return showToast('请至少选择一个预设！');
                            }
                            
                            if (!confirm(`确定要删除选中的 ${checkedBoxes.length} 个预设吗？`)) {
                                return;
                            }
                            
                            const indicesToDelete = Array.from(checkedBoxes).map(cb => parseInt(cb.value)).sort((a, b) => b - a);
                            indicesToDelete.forEach(index => {
                                db.minimaxPresets.splice(index, 1);
                            });
                            
                            await saveData();
                            renderMinimaxPresetList();
                            minimaxPresetListContainer.style.display = 'none';
                            deleteMinimaxPresetBtn.textContent = '删除预设';
                            deleteMinimaxPresetBtn.classList.remove('btn-secondary');
                            deleteMinimaxPresetBtn.classList.add('btn-danger');
                            showToast(`已删除 ${checkedBoxes.length} 个预设！`);
                            if (selectAllMinimaxCheckbox) selectAllMinimaxCheckbox.checked = false;
                        }
                    });
                }
                
                // 全选功能
                if (selectAllMinimaxCheckbox) {
                    selectAllMinimaxCheckbox.addEventListener('change', (e) => {
                        const checkboxes = minimaxPresetCheckboxes.querySelectorAll('input[type="checkbox"]');
                        checkboxes.forEach(cb => {
                            cb.checked = e.target.checked;
                        });
                    });
                }
            }
            
            // ===== NovelAI 图像生成配置 =====
            // 动态添加NovelAI配置HTML到API设置页面
            const apiFormContent = document.querySelector('#api-settings-screen .content');
            if (apiFormContent) {
                const novelaiHTML = `
                    <hr style="border:none; border-top:1px solid #eee; margin: 20px 0;">
                    <div style="padding: 0 20px;">
                        <h3 style="font-size: 16px; margin-bottom: 15px; color: #333;">NovelAI 图像生成</h3>
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                            <div style="flex: 1;">
                                <label style="font-weight: bold; display: block; margin-bottom: 5px;">启用 NovelAI 图像生成</label>
                                <p style="font-size: 12px; color: #666; margin: 5px 0;">开启后可使用NovelAI官方API生成高质量动漫风格图像</p>
                                <p style="font-size: 11px; color: #999; margin: 3px 0;">• 双击下载图片</p>
                                <p style="font-size: 11px; color: #999; margin: 3px 0;">• 429错误：访问频繁，等待几秒重试</p>
                                <p style="font-size: 11px; color: #999; margin: 3px 0;">• 403错误：多人共号限制或未开启订阅</p>
                                <p style="font-size: 11px; color: #999; margin: 3px 0;">• 401错误：API Key无权限</p>
                            </div>
                            <label class="toggle-switch" style="margin-left: 15px;">
                                <input type="checkbox" id="novelai-switch">
                                <span class="slider"></span>
                            </label>
                        </div>
                        
                        <div id="novelai-details" style="display: none;">
                            <div class="form-group">
                                <label for="novelai-model">NovelAI 模型</label>
                                <select id="novelai-model" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                                    <option value="nai-diffusion-4-curated-preview">NAI Diffusion V4.5 Curated (精选版无nsfw)</option>
                                    <option value="nai-diffusion-4-5-full">NAI Diffusion V4.5 Full（完整版含nsfw）</option>
                                    <option value="nai-diffusion-3">NAI Diffusion Anime V3（旧版）</option>
                                    <option value="nai-diffusion-furry-3">NAI Diffusion Furry V3（旧旧版）</option>
                                </select>
                                <small style="font-size: 12px; color: #888;">💡 必须有oplus订阅的apikey才可以使用！</small>
                            </div>

                            <div class="form-group">
                                <label for="novelai-api-key">NovelAI API Key</label>
                                <div style="position: relative;">
                                    <input type="password" id="novelai-api-key" placeholder="pst-xxxxxxxxxxxxxxxx" style="width: 100%; padding: 8px 40px 8px 8px; border: 1px solid #ddd; border-radius: 5px;">
                                    <span id="novelai-key-toggle" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); cursor: pointer; user-select: none; font-size: 18px;">🧐</span>
                                </div>
                                <small style="font-size: 12px; color: #888;">💡 在 <a href="https://novelai.net" target="_blank" style="color: #007bff;">NovelAI官网</a> 获取API Key</small>
                            </div>

                            <div style="display: flex; gap: 10px; margin-top: 15px;">
                                <button type="button" id="novelai-settings-btn" class="btn btn-secondary" style="flex: 1;">生成设置</button>
                                <button type="button" id="novelai-test-btn" class="btn btn-success" style="flex: 1;">测试生成</button>
                            </div>
                        </div>
                    </div>
                `;
                apiFormContent.insertAdjacentHTML('beforeend', novelaiHTML);
                
                // 初始化NovelAI配置
                if (!db.novelaiConfig) {
                    db.novelaiConfig = {
                        enabled: false,
                        model: 'nai-diffusion-4-5-full',
                        apiKey: '',
                        resolution: '1024x1024',
                        steps: 28,
                        cfgScale: 5,
                        sampler: 'k_euler_ancestral',
                        seed: -1,
                        ucPreset: 1,
                        qualityToggle: true,
                        smea: true,
                        smeaDyn: false,
                        defaultPositive: 'masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style',
                        defaultNegative: 'lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry'
                    };
                }
                
                // 加载NovelAI配置
                document.getElementById('novelai-switch').checked = db.novelaiConfig.enabled || false;
                document.getElementById('novelai-model').value = db.novelaiConfig.model || 'nai-diffusion-4-5-full';
                document.getElementById('novelai-api-key').value = db.novelaiConfig.apiKey || '';
                document.getElementById('novelai-details').style.display = db.novelaiConfig.enabled ? 'block' : 'none';
                
                // NovelAI开关事件
                document.getElementById('novelai-switch').addEventListener('change', async (e) => {
                    const detailsDiv = document.getElementById('novelai-details');
                    detailsDiv.style.display = e.target.checked ? 'block' : 'none';
                    db.novelaiConfig.enabled = e.target.checked;
                    await saveData();
                });
                
                // API Key显示/隐藏切换
                document.getElementById('novelai-key-toggle').addEventListener('click', () => {
                    const input = document.getElementById('novelai-api-key');
                    const toggle = document.getElementById('novelai-key-toggle');
                    if (input.type === 'password') {
                        input.type = 'text';
                        toggle.textContent = '🙈';
                    } else {
                        input.type = 'password';
                        toggle.textContent = '🧐';
                    }
                });
                
                // 保存NovelAI基础配置
                document.getElementById('novelai-model').addEventListener('change', async () => {
                    db.novelaiConfig.model = document.getElementById('novelai-model').value;
                    await saveData();
                });
                
                document.getElementById('novelai-api-key').addEventListener('blur', async () => {
                    db.novelaiConfig.apiKey = document.getElementById('novelai-api-key').value.trim();
                    await saveData();
                });
                
                // 打开生成设置弹窗
                document.getElementById('novelai-settings-btn').addEventListener('click', () => {
                    // 加载设置到弹窗
                    document.getElementById('nai-resolution').value = db.novelaiConfig.resolution || '1024x1024';
                    document.getElementById('nai-steps').value = db.novelaiConfig.steps || 28;
                    document.getElementById('nai-cfg-scale').value = db.novelaiConfig.cfgScale || 5;
                    document.getElementById('nai-sampler').value = db.novelaiConfig.sampler || 'k_euler_ancestral';
                    document.getElementById('nai-seed').value = db.novelaiConfig.seed || -1;
                    document.getElementById('nai-uc-preset').value = db.novelaiConfig.ucPreset || 1;
                    document.getElementById('nai-quality-toggle').checked = db.novelaiConfig.qualityToggle !== false;
                    document.getElementById('nai-smea').checked = db.novelaiConfig.smea !== false;
                    document.getElementById('nai-smea-dyn').checked = db.novelaiConfig.smeaDyn || false;
                    document.getElementById('nai-default-positive').value = db.novelaiConfig.defaultPositive || 'masterpiece, best quality, 1girl, beautiful, detailed face, detailed eyes, long hair, anime style';
                    document.getElementById('nai-default-negative').value = db.novelaiConfig.defaultNegative || 'lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry';
                    
                    document.getElementById('novelai-settings-modal').style.display = 'flex';
                });
                
                // 打开测试生成弹窗
                document.getElementById('novelai-test-btn').addEventListener('click', () => {
                    document.getElementById('nai-test-prompt').value = '';
                    document.getElementById('nai-test-negative').value = '';
                    document.getElementById('nai-test-result').style.display = 'none';
                    document.getElementById('novelai-test-modal').style.display = 'flex';
                });
            }
        }

        function setupWallpaperApp() {
            // 主屏幕壁纸元素
            const e = document.getElementById('wallpaper-upload'), t = document.getElementById('wallpaper-preview');
            const urlInput = document.getElementById('wallpaper-url-input'), urlBtn = document.getElementById('wallpaper-url-btn');
            const resetWallpaperBtn = document.getElementById('reset-wallpaper-btn');
            
            // 锁屏壁纸元素
            const lockWallpaperUpload = document.getElementById('lock-wallpaper-upload');
            const lockWallpaperPreview = document.getElementById('lock-wallpaper-preview');
            const lockWallpaperUrlInput = document.getElementById('lock-wallpaper-url-input');
            const lockWallpaperUrlBtn = document.getElementById('lock-wallpaper-url-btn');
            const resetLockWallpaperBtn = document.getElementById('reset-lock-wallpaper-btn');
            
            // 全局聊天背景元素
            const globalChatBgUpload = document.getElementById('global-chat-bg-upload');
            const globalChatBgPreview = document.getElementById('global-chat-bg-preview');
            const globalChatBgUrlInput = document.getElementById('global-chat-bg-url-input');
            const globalChatBgUrlBtn = document.getElementById('global-chat-bg-url-btn');
            const resetGlobalChatBgBtn = document.getElementById('reset-global-chat-bg-btn');
            
            // 壁纸库元素
            const addToLibraryBtn = document.getElementById('add-to-library-btn');
            const manageLibraryBtn = document.getElementById('manage-library-btn');
            const libraryGrid = document.getElementById('wallpaper-library-grid');
            const libraryManage = document.getElementById('wallpaper-library-manage');
            const libraryCheckboxes = document.getElementById('wallpaper-library-checkboxes');
            const selectAllCheckbox = document.getElementById('select-all-wallpapers');
            const deleteWallpapersBtn = document.getElementById('delete-wallpapers-btn');
            
            // 初始化壁纸库数组
            if (!db.wallpaperLibrary) db.wallpaperLibrary = [];
            
            // 渲染壁纸库网格
            function renderLibraryGrid() {
                libraryGrid.innerHTML = '';
                
                if (db.wallpaperLibrary.length === 0) {
                    libraryGrid.innerHTML = '<p style="grid-column: 1/-1; text-align: center; color: #999; padding: 20px;">壁纸库为空，快去添加壁纸吧！</p>';
                    return;
                }
                
                db.wallpaperLibrary.forEach((wallpaper, index) => {
                    const item = document.createElement('div');
                    item.style.cssText = 'aspect-ratio: 1; border-radius: 8px; overflow: hidden; cursor: pointer; border: 2px solid #eee; transition: all 0.3s;';
                    item.innerHTML = `<img src="${wallpaper.url}" alt="壁纸${index + 1}" style="width: 100%; height: 100%; object-fit: cover;">`;
                    item.addEventListener('click', () => applyWallpaperFromLibrary(index));
                    item.addEventListener('mouseenter', () => {
                        item.style.borderColor = '#007bff';
                        item.style.transform = 'scale(1.05)';
                    });
                    item.addEventListener('mouseleave', () => {
                        item.style.borderColor = '#eee';
                        item.style.transform = 'scale(1)';
                    });
                    libraryGrid.appendChild(item);
                });
            }
            
            // 渲染管理界面
            function renderManageCheckboxes() {
                libraryCheckboxes.innerHTML = '';
                
                db.wallpaperLibrary.forEach((wallpaper, index) => {
                    const div = document.createElement('div');
                    div.style.cssText = 'display: flex; align-items: center; gap: 10px; padding: 10px; border: 1px solid #eee; border-radius: 5px; margin-bottom: 8px;';
                    div.innerHTML = `
                        <input type="checkbox" id="wp-${index}" value="${index}" style="cursor: pointer;">
                        <img src="${wallpaper.url}" style="width: 50px; height: 50px; object-fit: cover; border-radius: 5px;">
                        <label for="wp-${index}" style="cursor: pointer; margin: 0; flex: 1;">${wallpaper.name || '壁纸 ' + (index + 1)}</label>
                    `;
                    libraryCheckboxes.appendChild(div);
                });
            }
            
            // 应用壁纸库中的壁纸（带选择弹窗）
            async function applyWallpaperFromLibrary(index) {
                const wallpaper = db.wallpaperLibrary[index];
                if (!wallpaper) return;
                
                // 创建选择弹窗
                const modal = document.createElement('div');
                modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10001; display: flex; align-items: center; justify-content: center;';
                
                modal.innerHTML = `
                    <div style="background: white; padding: 30px; border-radius: 15px; max-width: 300px; width: 90%;">
                        <h3 style="margin: 0 0 20px 0; text-align: center; color: #333;">应用壁纸到...</h3>
                        <img src="${wallpaper.url}" style="width: 100%; height: 150px; object-fit: cover; border-radius: 10px; margin-bottom: 20px;">
                        <button id="apply-to-home" class="btn btn-primary" style="width: 100%; margin-bottom: 10px;">主屏幕</button>
                        <button id="apply-to-lock" class="btn btn-secondary" style="width: 100%; margin-bottom: 10px;">锁屏界面</button>
                        <button id="apply-to-chat" class="btn btn-secondary" style="width: 100%; margin-bottom: 10px;">全局聊天背景</button>
                        <button id="cancel-apply" class="btn btn-neutral" style="width: 100%;">取消</button>
                    </div>
                `;
                
                document.body.appendChild(modal);
                
                // 应用到主屏幕
                document.getElementById('apply-to-home').addEventListener('click', async () => {
                    db.wallpaper = wallpaper.url;
                    applyWallpaper(wallpaper.url);
                    t.style.backgroundImage = `url(${wallpaper.url})`;
                    await saveData();
                    showToast('已应用到主屏幕！');
                    modal.remove();
                });
                
                // 应用到锁屏
                document.getElementById('apply-to-lock').addEventListener('click', async () => {
                    db.lockScreenWallpaper = wallpaper.url;
                    applyLockScreenWallpaper(wallpaper.url);
                    // 清除可能存在的渐变背景，避免与backgroundImage冲突
                    lockWallpaperPreview.style.background = '';
                    lockWallpaperPreview.style.backgroundColor = '';
                    lockWallpaperPreview.style.backgroundImage = `url(${wallpaper.url})`;
                    lockWallpaperPreview.style.backgroundSize = 'cover';
                    lockWallpaperPreview.style.backgroundPosition = 'center';
                    lockWallpaperPreview.textContent = '';
                    await saveData();
                    showToast('已应用到锁屏界面！');
                    modal.remove();
                });
                
                // 应用到全局聊天背景
                document.getElementById('apply-to-chat').addEventListener('click', async () => {
                    db.globalChatBg = wallpaper.url;
                    applyGlobalChatBackground(wallpaper.url);
                    globalChatBgPreview.style.backgroundImage = `url(${wallpaper.url})`;
                    globalChatBgPreview.style.backgroundSize = 'cover';
                    globalChatBgPreview.style.backgroundPosition = 'center';
                    globalChatBgPreview.textContent = '';
                    await saveData();
                    showToast('已应用到全局聊天背景！');
                    modal.remove();
                });
                
                // 取消
                document.getElementById('cancel-apply').addEventListener('click', () => {
                    modal.remove();
                });
                
                // 点击背景关闭
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                });
            }
            
            // 初始化锁屏壁纸预览
            function initLockWallpaperPreview() {
                if (db.lockScreenWallpaper) {
                    if (db.lockScreenWallpaper.startsWith('linear-gradient') || db.lockScreenWallpaper.startsWith('radial-gradient')) {
                        // 清除所有背景相关样式，然后设置渐变
                        lockWallpaperPreview.style.backgroundImage = '';
                        lockWallpaperPreview.style.backgroundColor = '';
                        lockWallpaperPreview.style.background = db.lockScreenWallpaper;
                    } else {
                        // 清除渐变背景，设置图片背景
                        lockWallpaperPreview.style.background = '';
                        lockWallpaperPreview.style.backgroundColor = '';
                        lockWallpaperPreview.style.backgroundImage = `url(${db.lockScreenWallpaper})`;
                        lockWallpaperPreview.style.backgroundSize = 'cover';
                        lockWallpaperPreview.style.backgroundPosition = 'center';
                    }
                    lockWallpaperPreview.textContent = '';
                }
            }
            
            // 应用锁屏壁纸函数
            function applyLockScreenWallpaper(wallpaper) {
                const lockScreen = document.getElementById('lock-screen');
                if (lockScreen) {
                    if (wallpaper.startsWith('linear-gradient') || wallpaper.startsWith('radial-gradient')) {
                        lockScreen.style.background = wallpaper;
                        lockScreen.style.backgroundImage = '';
                    } else {
                        lockScreen.style.backgroundImage = `url(${wallpaper})`;
                        lockScreen.style.backgroundSize = 'cover';
                        lockScreen.style.backgroundPosition = 'center';
                    }
                }
            }
            
            // 应用全局聊天背景函数
            function applyGlobalChatBackground(bgUrl) {
                // 如果设置了全局聊天背景，应用到当前聊天界面
                const chatScreen = document.getElementById('chat-screen');
                if (chatScreen) {
                    if (bgUrl) {
                        chatScreen.style.backgroundImage = `url(${bgUrl})`;
                        chatScreen.style.backgroundSize = 'cover';
                        chatScreen.style.backgroundPosition = 'center';
                    } else {
                        // 如果清空了全局背景，恢复默认或角色独立背景
                        chatScreen.style.backgroundImage = '';
                        // 如果当前有打开的聊天，应用其独立背景
                        if (currentChatId && currentChatType) {
                            const chat = currentChatType === 'private' 
                                ? db.characters.find(c => c.id === currentChatId)
                                : db.groups.find(g => g.id === currentChatId);
                            if (chat && chat.chatBackground) {
                                chatScreen.style.backgroundImage = `url(${chat.chatBackground})`;
                                chatScreen.style.backgroundSize = 'cover';
                                chatScreen.style.backgroundPosition = 'center';
                            }
                        }
                    }
                }
            }
            
            // 初始渲染
            renderLibraryGrid();
            initLockWallpaperPreview();
            
            // 主屏幕壁纸预览和上传
            t.style.backgroundImage = `url(${db.wallpaper})`;
            t.textContent = '';
            e.addEventListener('change', async (a) => {
                const n = a.target.files[0];
                if (n) {
                    try {
                        const r = await compressImage(n, {quality: 0.85, maxWidth: 1080, maxHeight: 1920});
                        db.wallpaper = r;
                        applyWallpaper(r);
                        t.style.backgroundImage = `url(${r})`;
                        await saveData();
                        showToast('壁纸更换成功！');
                    } catch (s) {
                        showToast('壁纸压缩失败，请重试');
                    }
                }
            });

            // URL上传壁纸功能
            urlBtn.addEventListener('click', async () => {
                const url = urlInput.value.trim();
                if (!url) {
                    return showToast('请输入壁纸URL！');
                }
                
                // 验证URL格式
                try {
                    new URL(url);
                } catch (error) {
                    return showToast('URL格式不正确！');
                }
                
                // 显示加载状态
                urlBtn.disabled = true;
                urlBtn.textContent = '上传中...';
                
                try {
                    // 测试图片是否可以加载
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    await new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = () => reject(new Error('图片加载失败'));
                        img.src = url;
                    });
                    
                    // 直接使用URL
                    db.wallpaper = url;
                    applyWallpaper(url);
                    t.style.backgroundImage = `url(${url})`;
                    await saveData();
                    showToast('壁纸更换成功！');
                    urlInput.value = '';
                } catch (error) {
                    showToast('壁纸上传失败：' + error.message);
                } finally {
                    urlBtn.disabled = false;
                    urlBtn.textContent = '通过URL上传壁纸';
                }
            });
            
            // 支持回车键上传
            urlInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    urlBtn.click();
                }
            });
            
            // 锁屏壁纸本地上传
            lockWallpaperUpload.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (file) {
                    try {
                        const compressed = await compressImage(file, {quality: 0.85, maxWidth: 1080, maxHeight: 1920});
                        db.lockScreenWallpaper = compressed;
                        applyLockScreenWallpaper(compressed);
                        // 清除可能存在的渐变背景，避免与backgroundImage冲突
                        lockWallpaperPreview.style.background = '';
                        lockWallpaperPreview.style.backgroundColor = '';
                        lockWallpaperPreview.style.backgroundImage = `url(${compressed})`;
                        lockWallpaperPreview.style.backgroundSize = 'cover';
                        lockWallpaperPreview.style.backgroundPosition = 'center';
                        lockWallpaperPreview.textContent = '';
                        await saveData();
                        showToast('锁屏壁纸更换成功！');
                    } catch (error) {
                        showToast('锁屏壁纸压缩失败，请重试');
                    }
                }
            });
            
            // 锁屏壁纸URL上传
            lockWallpaperUrlBtn.addEventListener('click', async () => {
                const url = lockWallpaperUrlInput.value.trim();
                if (!url) {
                    return showToast('请输入锁屏壁纸URL！');
                }
                
                // 验证URL格式
                try {
                    new URL(url);
                } catch (error) {
                    return showToast('URL格式不正确！');
                }
                
                // 显示加载状态
                lockWallpaperUrlBtn.disabled = true;
                lockWallpaperUrlBtn.textContent = '上传中...';
                
                try {
                    // 测试图片是否可以加载
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    await new Promise((resolve, reject) => {
                        img.onload = resolve;
                        img.onerror = () => reject(new Error('图片加载失败'));
                        img.src = url;
                    });
                    
                    // 直接使用URL
                    db.lockScreenWallpaper = url;
                    applyLockScreenWallpaper(url);
                    // 清除可能存在的渐变背景，避免与backgroundImage冲突
                    lockWallpaperPreview.style.background = '';
                    lockWallpaperPreview.style.backgroundColor = '';
                    lockWallpaperPreview.style.backgroundImage = `url(${url})`;
                    lockWallpaperPreview.style.backgroundSize = 'cover';
                    lockWallpaperPreview.style.backgroundPosition = 'center';
                    lockWallpaperPreview.textContent = '';
                    await saveData();
                    showToast('锁屏壁纸更换成功！');
                    lockWallpaperUrlInput.value = '';
                } catch (error) {
                    showToast('锁屏壁纸上传失败：' + error.message);
                } finally {
                    lockWallpaperUrlBtn.disabled = false;
                    lockWallpaperUrlBtn.textContent = '通过URL上传锁屏壁纸';
                }
            });
            
            // 支持回车键上传锁屏壁纸
            lockWallpaperUrlInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    lockWallpaperUrlBtn.click();
                }
            });
            
            // 重置主屏幕壁纸
            resetWallpaperBtn.addEventListener('click', async () => {
                if (confirm('确定要重置主屏幕壁纸到默认壁纸吗？')) {
                    const defaultWallpaper = 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg';
                    db.wallpaper = defaultWallpaper;
                    applyWallpaper(defaultWallpaper);
                    t.style.backgroundImage = `url(${defaultWallpaper})`;
                    await saveData();
                    showToast('主屏幕壁纸已重置！');
                }
            });
            
            // 重置锁屏壁纸
            resetLockWallpaperBtn.addEventListener('click', async () => {
                if (confirm('确定要重置锁屏壁纸到默认壁纸吗？')) {
                    const defaultLockWallpaper = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                    db.lockScreenWallpaper = defaultLockWallpaper;
                    applyLockScreenWallpaper(defaultLockWallpaper);
                    // 清除所有背景相关样式，然后设置渐变
                    lockWallpaperPreview.style.backgroundImage = '';
                    lockWallpaperPreview.style.backgroundColor = '';
                    lockWallpaperPreview.style.background = defaultLockWallpaper;
                    lockWallpaperPreview.textContent = '';
                    await saveData();
                    showToast('锁屏壁纸已重置！');
                }
            });
            
            // ===== 全局聊天背景处理 =====
            
            // 初始化全局聊天背景预览
            function initGlobalChatBgPreview() {
                if (db.globalChatBg) {
                    globalChatBgPreview.style.backgroundImage = `url(${db.globalChatBg})`;
                    globalChatBgPreview.style.backgroundSize = 'cover';
                    globalChatBgPreview.style.backgroundPosition = 'center';
                    globalChatBgPreview.textContent = '';
                } else {
                    globalChatBgPreview.style.backgroundImage = '';
                    globalChatBgPreview.innerHTML = '<span>全局聊天背景预览</span>';
                }
            }
            
            // 本地上传全局聊天背景
            globalChatBgUpload.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                try {
                    const compressed = await compressImage(file, {quality: 0.85, maxWidth: 1080, maxHeight: 1920});
                    db.globalChatBg = compressed;
                    applyGlobalChatBackground(compressed);
                    globalChatBgPreview.style.backgroundImage = `url(${compressed})`;
                    globalChatBgPreview.style.backgroundSize = 'cover';
                    globalChatBgPreview.style.backgroundPosition = 'center';
                    globalChatBgPreview.textContent = '';
                    await saveData();
                    showToast('全局聊天背景更换成功！');
                } catch (error) {
                    showToast('全局聊天背景上传失败：' + error.message);
                }
                event.target.value = '';
            });
            
            // URL上传全局聊天背景
            globalChatBgUrlBtn.addEventListener('click', async () => {
                const url = globalChatBgUrlInput.value.trim();
                if (!url) {
                    return showToast('请输入图片URL');
                }
                
                globalChatBgUrlBtn.disabled = true;
                globalChatBgUrlBtn.textContent = '上传中...';
                
                try {
                    db.globalChatBg = url;
                    applyGlobalChatBackground(url);
                    globalChatBgPreview.style.backgroundImage = `url(${url})`;
                    globalChatBgPreview.style.backgroundSize = 'cover';
                    globalChatBgPreview.style.backgroundPosition = 'center';
                    globalChatBgPreview.textContent = '';
                    await saveData();
                    showToast('全局聊天背景更换成功！');
                    globalChatBgUrlInput.value = '';
                } catch (error) {
                    showToast('全局聊天背景上传失败：' + error.message);
                } finally {
                    globalChatBgUrlBtn.disabled = false;
                    globalChatBgUrlBtn.textContent = '通过URL上传聊天背景';
                }
            });
            
            // 支持回车键上传全局聊天背景
            globalChatBgUrlInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    globalChatBgUrlBtn.click();
                }
            });
            
            // 重置全局聊天背景
            resetGlobalChatBgBtn.addEventListener('click', async () => {
                if (confirm('确定要重置全局聊天背景吗？重置后将使用各角色/群聊的独立背景。')) {
                    db.globalChatBg = '';
                    applyGlobalChatBackground('');
                    globalChatBgPreview.style.backgroundImage = '';
                    globalChatBgPreview.innerHTML = '<span>全局聊天背景预览</span>';
                    await saveData();
                    showToast('全局聊天背景已重置！');
                }
            });
            
            // 初始化全局聊天背景预览
            initGlobalChatBgPreview();
            
            // ===== 全局聊天背景处理结束 =====
            
            // 添加到壁纸库
            addToLibraryBtn.addEventListener('click', async () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.multiple = true;
                
                input.addEventListener('change', async (event) => {
                    const files = Array.from(event.target.files);
                    if (files.length === 0) return;
                    
                    addToLibraryBtn.disabled = true;
                    addToLibraryBtn.textContent = `上传中... (0/${files.length})`;
                    
                    for (let i = 0; i < files.length; i++) {
                        const file = files[i];
                        try {
                            const compressed = await compressImage(file, {quality: 0.85, maxWidth: 1080, maxHeight: 1920});
                            const wallpaperName = prompt(`请输入壁纸名称（${i + 1}/${files.length}）：`, file.name.replace(/\.[^/.]+$/, ""));
                            
                            if (wallpaperName) {
                                db.wallpaperLibrary.push({
                                    name: wallpaperName.trim(),
                                    url: compressed,
                                    addedAt: Date.now()
                                });
                            }
                            
                            addToLibraryBtn.textContent = `上传中... (${i + 1}/${files.length})`;
                        } catch (error) {
                            console.error('压缩失败:', error);
                        }
                    }
                    
                    await saveData();
                    renderLibraryGrid();
                    addToLibraryBtn.disabled = false;
                    addToLibraryBtn.textContent = '添加到壁纸库';
                    showToast(`成功添加 ${files.length} 张壁纸到壁纸库！`);
                });
                
                input.click();
            });
            
            // 管理壁纸库
            manageLibraryBtn.addEventListener('click', () => {
                if (db.wallpaperLibrary.length === 0) {
                    return showToast('壁纸库为空！');
                }
                
                if (libraryManage.style.display === 'none') {
                    libraryManage.style.display = 'block';
                    libraryGrid.style.display = 'none';
                    manageLibraryBtn.textContent = '返回';
                    manageLibraryBtn.classList.remove('btn-danger');
                    manageLibraryBtn.classList.add('btn-secondary');
                    renderManageCheckboxes();
                } else {
                    libraryManage.style.display = 'none';
                    libraryGrid.style.display = 'grid';
                    manageLibraryBtn.textContent = '管理壁纸库';
                    manageLibraryBtn.classList.remove('btn-secondary');
                    manageLibraryBtn.classList.add('btn-danger');
                    selectAllCheckbox.checked = false;
                }
            });
            
            // 全选功能
            selectAllCheckbox.addEventListener('change', (e) => {
                const checkboxes = libraryCheckboxes.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(cb => {
                    cb.checked = e.target.checked;
                });
            });
            
            // 删除壁纸
            deleteWallpapersBtn.addEventListener('click', async () => {
                const checkedBoxes = libraryCheckboxes.querySelectorAll('input[type="checkbox"]:checked');
                if (checkedBoxes.length === 0) {
                    return showToast('请至少选择一张壁纸！');
                }
                
                if (!confirm(`确定要删除选中的 ${checkedBoxes.length} 张壁纸吗？`)) {
                    return;
                }
                
                const indicesToDelete = Array.from(checkedBoxes).map(cb => parseInt(cb.value)).sort((a, b) => b - a);
                indicesToDelete.forEach(index => {
                    db.wallpaperLibrary.splice(index, 1);
                });
                
                await saveData();
                renderLibraryGrid();
                renderManageCheckboxes();
                selectAllCheckbox.checked = false;
                showToast(`已删除 ${checkedBoxes.length} 张壁纸！`);
                
                if (db.wallpaperLibrary.length === 0) {
                    libraryManage.style.display = 'none';
                    libraryGrid.style.display = 'grid';
                    manageLibraryBtn.textContent = '管理壁纸库';
                    manageLibraryBtn.classList.remove('btn-secondary');
                    manageLibraryBtn.classList.add('btn-danger');
                }
            });
        }

        // --- GROUP CHAT FUNCTIONS ---
        
        // 拉回被踢出的成员
        async function handlePullBackKickedMembers(message) {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group || !message.kickedMembersData || message.kickedMembersData.length === 0) return;
            
            const kickedMembers = message.kickedMembersData;
            const memberNames = kickedMembers.map(m => m.groupNickname).join('、');
            
            // 确认拉回
            if (!confirm(`是否拉回 ${memberNames}？\n\n注意：如果被踢出的是管理员，拉回后会变成普通成员。`)) {
                return;
            }
            
            const pulledBackMembers = [];
            
            // 拉回成员
            kickedMembers.forEach(kickedMember => {
                // 恢复成员，但如果曾是管理员，现在变成普通成员
                const restoredMember = {
                    ...kickedMember,
                    isAdmin: false, // 拉回后都是普通成员
                    isOwner: false  // 确保不是群主
                };
                
                // 删除临时属性
                delete restoredMember.kickedAt;
                delete restoredMember.wasAdmin;
                
                // 添加回群组
                group.members.push(restoredMember);
                pulledBackMembers.push(restoredMember.groupNickname);
                
                // 从kickedMembers数组中移除
                if (group.kickedMembers) {
                    group.kickedMembers = group.kickedMembers.filter(m => m.id !== kickedMember.id);
                }
            });
            
            // 添加系统消息
            const systemMessage = {
                id: `msg_${Date.now()}`,
                role: 'system',
                content: `[system-display:${pulledBackMembers.join('、')} 被拉回群聊]`,
                timestamp: Date.now()
            };
            group.history.push(systemMessage);
            
            // 清除原消息的kickedMembersData，防止重复拉回
            message.kickedMembersData = [];
            
            await saveData();
            
            // 重新渲染
            if (groupSettingsSidebar.classList.contains('open')) {
                renderGroupMembersInSettings(group);
            }
            renderMessages(false, true);
            
            showToast(`已拉回 ${pulledBackMembers.length} 位成员`);
        }
        
        // @功能实现
        function setupMentionFeature() {
            const mentionSelector = document.getElementById('mention-selector');
            const mentionList = document.getElementById('mention-list');
            let mentionStartPos = -1;
            let selectedMentionIndex = 0;
            
            // 监听输入
            messageInput.addEventListener('input', (e) => {
                if (currentChatType !== 'group') return;
                
                const text = messageInput.value;
                const cursorPos = messageInput.selectionStart;
                
                // 查找最近的@符号
                const lastAtPos = text.lastIndexOf('@', cursorPos - 1);
                
                if (lastAtPos !== -1 && lastAtPos >= mentionStartPos) {
                    const searchText = text.substring(lastAtPos + 1, cursorPos);
                    
                    // 如果@后面有空格，关闭选择器
                    if (searchText.includes(' ')) {
                        closeMentionSelector();
                        return;
                    }
                    
                    mentionStartPos = lastAtPos;
                    showMentionSelector(searchText);
                } else {
                    closeMentionSelector();
                }
            });
            
            // 键盘导航
            messageInput.addEventListener('keydown', (e) => {
                if (!mentionSelector.style.display || mentionSelector.style.display === 'none') return;
                
                const items = mentionList.querySelectorAll('.mention-item');
                if (items.length === 0) return;
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedMentionIndex = (selectedMentionIndex + 1) % items.length;
                    updateMentionSelection(items);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedMentionIndex = (selectedMentionIndex - 1 + items.length) % items.length;
                    updateMentionSelection(items);
                } else if (e.key === 'Enter' || e.key === 'Tab') {
                    e.preventDefault();
                    items[selectedMentionIndex]?.click();
                } else if (e.key === 'Escape') {
                    closeMentionSelector();
                }
            });
            
            function showMentionSelector(searchText) {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                
                // 确保mentionData存在
                if (!group.mentionData) {
                    group.mentionData = {
                        userMentionCount: 0,
                        userMentionDate: new Date().toDateString(),
                        mentions: []
                    };
                }
                
                // 检查日期，重置计数
                const today = new Date().toDateString();
                if (group.mentionData.userMentionDate !== today) {
                    group.mentionData.userMentionCount = 0;
                    group.mentionData.userMentionDate = today;
                }
                
                mentionList.innerHTML = '';
                selectedMentionIndex = 0;
                
                const search = searchText.toLowerCase();
                
                // 添加@全员选项（仅群主和管理员）
                if (group.me.isOwner || group.me.isAdmin) {
                    const maxMentions = group.me.isOwner ? 20 : 10;
                    const remainingMentions = maxMentions - group.mentionData.userMentionCount;
                    
                    if (remainingMentions > 0 && ('全员'.includes(search) || search === '')) {
                        const allItem = document.createElement('div');
                        allItem.className = 'mention-item mention-all';
                        allItem.innerHTML = `
                            <img src="https://i.postimg.cc/fTLCngk1/image.jpg" alt="全员">
                            <span class="mention-name">全员 (剩余${remainingMentions}次)</span>
                        `;
                        allItem.addEventListener('click', () => insertMention('全员', true));
                        mentionList.appendChild(allItem);
                    }
                }
                
                // 添加群成员选项
                group.members.forEach(member => {
                    if (member.groupNickname.toLowerCase().includes(search) || member.realName.toLowerCase().includes(search) || search === '') {
                        const item = document.createElement('div');
                        item.className = 'mention-item';
                        
                        let badgeHTML = '';
                        if (member.isOwner) {
                            badgeHTML = '<span class="mention-badge" style="background-color: #ffd700; color: #000;">群主</span>';
                        } else if (member.isAdmin) {
                            badgeHTML = '<span class="mention-badge" style="background-color: #10b981;">管理员</span>';
                        }
                        
                        item.innerHTML = `
                            <img src="${member.avatar}" alt="${member.groupNickname}">
                            <span class="mention-name">${member.groupNickname}${badgeHTML}</span>
                        `;
                        item.addEventListener('click', () => insertMention(member.groupNickname, false, member.id));
                        mentionList.appendChild(item);
                    }
                });
                
                if (mentionList.children.length > 0) {
                    mentionSelector.style.display = 'block';
                    updateMentionSelection(mentionList.querySelectorAll('.mention-item'));
                } else {
                    closeMentionSelector();
                }
            }
            
            function updateMentionSelection(items) {
                items.forEach((item, index) => {
                    if (index === selectedMentionIndex) {
                        item.classList.add('selected');
                    } else {
                        item.classList.remove('selected');
                    }
                });
            }
            
            function insertMention(name, isAll, memberId = null) {
                const text = messageInput.value;
                const beforeMention = text.substring(0, mentionStartPos);
                const afterMention = text.substring(messageInput.selectionStart);
                
                messageInput.value = `${beforeMention}@${name} ${afterMention}`;
                messageInput.focus();
                
                const newCursorPos = beforeMention.length + name.length + 2;
                messageInput.setSelectionRange(newCursorPos, newCursorPos);
                
                closeMentionSelector();
                
                // 记录@信息（用于发送时处理）
                if (!messageInput.dataset.mentions) {
                    messageInput.dataset.mentions = JSON.stringify([]);
                }
                const mentions = JSON.parse(messageInput.dataset.mentions);
                mentions.push({ name, isAll, memberId });
                messageInput.dataset.mentions = JSON.stringify(mentions);
            }
            
            function closeMentionSelector() {
                mentionSelector.style.display = 'none';
                mentionStartPos = -1;
                selectedMentionIndex = 0;
            }
            
            // 点击外部关闭
            document.addEventListener('click', (e) => {
                if (!mentionSelector.contains(e.target) && e.target !== messageInput) {
                    closeMentionSelector();
                }
            });
        }
        
        // 格式化@标记
        function formatMentions(text) {
            // 匹配@用户名（@后面跟非空格字符）
            const mentionRegex = /@([^\s@]+)/g;
            return text.replace(mentionRegex, '<span class="mention-tag">@$1</span>');
        }
        
        // 格式化Markdown样式（加粗、斜体等）
        function formatMarkdown(text) {
            // 先转义HTML特殊字符（除了已经处理过的mention标签和strong/em标签）
            const parts = text.split(/(<span class="mention-tag">.*?<\/span>|<strong>.*?<\/strong>|<em>.*?<\/em>)/g);
            
            return parts.map(part => {
                // 如果是已处理的标签，直接返回
                if (part.startsWith('<span class="mention-tag">') || 
                    part.startsWith('<strong>') || 
                    part.startsWith('<em>')) {
                    return part;
                }
                
                // 处理加粗和斜体
                // 优先处理 **text**（加粗）
                part = part.replace(/\*\*([^*]+?)\*\*/g, '<strong>$1</strong>');
                // 然后处理单个 *text*（斜体）
                part = part.replace(/\*([^*]+?)\*/g, '<em>$1</em>');
                
                return part;
            }).join('');
        }
        
        function setupGroupChatSystem() {
            createGroupBtn.addEventListener('click', () => {
                groupTypeSelectionModal.classList.add('visible');
            });
            
            normalGroupBtn.addEventListener('click', () => {
                groupTypeSelectionModal.classList.remove('visible');
                renderMemberSelectionList();
                createGroupModal.classList.add('visible');
            });
            
            observerGroupBtn.addEventListener('click', () => {
                groupTypeSelectionModal.classList.remove('visible');
                renderObserverMemberSelectionList();
                createObserverGroupModal.classList.add('visible');
            });
            
            cancelGroupTypeBtn.addEventListener('click', () => {
                groupTypeSelectionModal.classList.remove('visible');
            });
            createGroupForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const selectedMemberIds = Array.from(memberSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                const groupName = groupNameInput.value.trim();
                if (selectedMemberIds.length < 1) return showToast('请至少选择一个群成员。');
                if (!groupName) return showToast('请输入群聊名称。');
                const firstChar = db.characters.length > 0 ? db.characters[0] : null;
                const newGroup = {
                    id: `group_${Date.now()}`,
                    name: groupName,
                    avatar: 'https://i.postimg.cc/fTLCngk1/image.jpg',
                    me: {
                        nickname: firstChar ? firstChar.myName : '我',
                        persona: firstChar ? firstChar.myPersona : '',
                        avatar: firstChar ? firstChar.myAvatar : 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg',
                        isOwner: true, // 创建群组时，用户默认是群主
                        isAdmin: false // 群主不需要管理员身份
                    },
                    members: selectedMemberIds.map((charId, index) => {
                        const char = db.characters.find(c => c.id === charId);
                        return {
                            id: `member_${char.id}`,
                            originalCharId: char.id,
                            realName: char.realName,
                            groupNickname: char.remarkName,
                            persona: char.persona,
                            avatar: char.avatar,
                            isOwner: index === 0 // 第一个成员为群主
                        };
                    }),
                    theme: 'white_pink',
                    maxMemory: 10,
                    chatBg: '',
                    history: [],
                    isPinned: false,
                    useCustomBubbleCss: false,
                    customBubbleCss: '',
                    worldBookIds: getGlobalWorldBookIds(),
                    musicData: { totalTime: 0 },
                    unreadCount: 0,
                    mentionData: {
                        userMentionCount: 0, // USER今天@的次数
                        userMentionDate: new Date().toDateString(), // 记录日期
                        mentions: [] // 存储所有@记录
                    },
                    innerThoughtEnabled: false // 群聊心声功能默认关闭
                };
                db.groups.push(newGroup);
                await saveData();
                renderChatList();
                createGroupModal.classList.remove('visible');
                showToast(`群聊“${groupName}”创建成功！`);
            });

            // 旁观者群聊创建表单提交
            createObserverGroupForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const selectedMemberIds = Array.from(observerMemberSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                const groupName = observerGroupNameInput.value.trim();
                
                if (selectedMemberIds.length < 2) return showToast('旁观者群聊请至少选择两个角色。');
                if (!groupName) return showToast('请输入群聊名称。');

                // 获取互相认识的设置
                const knowEachOtherEnabled = membersKnowEachOtherToggle.checked;
                let knownPairs = [];
                
                if (knowEachOtherEnabled) {
                    const selectedPairs = Array.from(knowEachOtherPairs.querySelectorAll('input:checked'));
                    if (selectedPairs.length > 0) {
                        // 有选择具体的认识对
                        knownPairs = selectedPairs.map(cb => cb.value.split(','));
                    } else {
                        // 开启但没选择，默认所有人互相认识
                        knownPairs = 'all';
                    }
                } else {
                    // 关闭，所有人都不认识
                    knownPairs = [];
                }

                // 获取记忆中有USER的设置
                const memoryHasUserEnabled = memoryHasUserToggle.checked;
                let membersWithUserMemory = [];
                
                if (memoryHasUserEnabled) {
                    const selectedMembers = Array.from(memoryHasUserList.querySelectorAll('input:checked'));
                    if (selectedMembers.length > 0) {
                        // 有选择具体的角色
                        membersWithUserMemory = selectedMembers.map(cb => cb.value);
                    } else {
                        // 开启但没选择，默认所有人都有USER记忆
                        membersWithUserMemory = 'all';
                    }
                } else {
                    // 关闭，所有人都没有USER记忆
                    membersWithUserMemory = [];
                }

                const newGroup = {
                    id: `group_${Date.now()}`,
                    name: groupName,
                    avatar: 'https://i.postimg.cc/fTLCngk1/image.jpg',
                    isObserverMode: true, // 标记为旁观者模式
                    me: null, // 旁观者模式没有USER
                    members: selectedMemberIds.map((charId, index) => {
                        const char = db.characters.find(c => c.id === charId);
                        
                        // 判断该角色是否有USER记忆
                        const hasUserMemory = membersWithUserMemory === 'all' || 
                                            (Array.isArray(membersWithUserMemory) && membersWithUserMemory.includes(charId));
                        
                        return {
                            id: `member_${char.id}`,
                            originalCharId: char.id,
                            realName: char.realName,
                            groupNickname: char.remarkName,
                            persona: char.persona,
                            avatar: char.avatar,
                            isOwner: false, // 旁观者模式没有群主
                            hasUserMemory: hasUserMemory, // 是否有USER记忆
                            userRelationship: hasUserMemory ? (char.relationship || '') : '', // USER关系
                            userNickname: hasUserMemory ? (char.myName || 'USER') : '' // USER昵称
                        };
                    }),
                    knownPairs: knownPairs, // 互相认识的配置
                    theme: 'white_pink',
                    maxMemory: 10,
                    chatBg: '',
                    history: [],
                    isPinned: false,
                    useCustomBubbleCss: false,
                    customBubbleCss: '',
                    worldBookIds: getGlobalWorldBookIds(),
                    musicData: { totalTime: 0 },
                    unreadCount: 0,
                    mentionData: {
                        userMentionCount: 0,
                        userMentionDate: new Date().toDateString(),
                        mentions: []
                    },
                    innerThoughtEnabled: false
                };
                
                db.groups.push(newGroup);
                await saveData();
                renderChatList();
                createObserverGroupModal.classList.remove('visible');
                
                // 重置表单
                createObserverGroupForm.reset();
                membersKnowEachOtherToggle.checked = false;
                memoryHasUserToggle.checked = false;
                knowEachOtherSelection.style.display = 'none';
                memoryHasUserSelection.style.display = 'none';
                
                showToast(`旁观者群聊"${groupName}"创建成功！`);
            });

            groupSettingsForm.addEventListener('submit', e => {
                e.preventDefault();
                saveGroupSettingsFromSidebar();
                groupSettingsSidebar.classList.remove('open');
            });
            
            // 群管理按钮事件
            const groupManagementBtn = document.getElementById('group-management-btn');
            const groupManagementModal = document.getElementById('group-management-modal');
            const closeGroupManagementBtn = document.getElementById('close-group-management-btn');
            
            groupManagementBtn?.addEventListener('click', () => {
                groupManagementModal.classList.add('visible');
            });
            
            closeGroupManagementBtn?.addEventListener('click', () => {
                groupManagementModal.classList.remove('visible');
            });
            
            groupManagementModal?.addEventListener('click', (e) => {
                if (e.target === groupManagementModal) {
                    groupManagementModal.classList.remove('visible');
                }
            });
            
            // 设置管理员功能
            const setAdminModal = document.getElementById('set-admin-modal');
            const adminSelectionList = document.getElementById('admin-selection-list');
            const confirmSetAdminBtn = document.getElementById('confirm-set-admin-btn');
            const cancelSetAdminBtn = document.getElementById('cancel-set-admin-btn');
            
            document.getElementById('set-admin-btn')?.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                
                // 确保用户有权限属性
                if (group.me.isOwner === undefined) {
                    group.me.isOwner = false;
                }
                
                // 检查权限：只有群主可以设置管理员
                if (!group.me.isOwner) {
                    showToast('只有群主可以设置管理员');
                    groupManagementModal.classList.remove('visible');
                    return;
                }
                
                // 渲染管理员选择列表
                renderAdminSelectionList(group);
                
                // 显示弹窗
                groupManagementModal.classList.remove('visible');
                setAdminModal.classList.add('visible');
            });
            
            // 渲染管理员选择列表
            function renderAdminSelectionList(group) {
                adminSelectionList.innerHTML = '';
                
                // 确保每个成员都有isAdmin属性
                group.members.forEach(member => {
                    if (member.isAdmin === undefined) {
                        member.isAdmin = false;
                    }
                    
                    const item = document.createElement('div');
                    item.className = 'admin-select-item';
                    item.innerHTML = `
                        <input type="checkbox" id="admin-check-${member.id}" ${member.isAdmin ? 'checked' : ''}>
                        <img src="${member.avatar}" alt="${member.groupNickname}">
                        <div class="member-info">
                            <div class="member-name">
                                ${member.groupNickname}
                                ${member.isAdmin ? '<span class="admin-badge">管理员</span>' : ''}
                            </div>
                        </div>
                    `;
                    
                    // 点击整个项目切换复选框
                    item.addEventListener('click', (e) => {
                        if (e.target.tagName !== 'INPUT') {
                            const checkbox = item.querySelector('input[type="checkbox"]');
                            checkbox.checked = !checkbox.checked;
                        }
                    });
                    
                    adminSelectionList.appendChild(item);
                });
            }
            
            // 确认设置管理员
            confirmSetAdminBtn?.addEventListener('click', async () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                
                // 记录变化
                const newAdmins = [];
                const removedAdmins = [];
                
                // 更新管理员状态并记录变化
                group.members.forEach(member => {
                    const checkbox = document.getElementById(`admin-check-${member.id}`);
                    const newStatus = checkbox ? checkbox.checked : false;
                    const oldStatus = member.isAdmin || false;
                    
                    if (newStatus && !oldStatus) {
                        newAdmins.push(member.groupNickname);
                    } else if (!newStatus && oldStatus) {
                        removedAdmins.push(member.groupNickname);
                    }
                    
                    member.isAdmin = newStatus;
                });
                
                // 添加系统消息通知管理员变动
                if (newAdmins.length > 0 || removedAdmins.length > 0) {
                    let notificationText = '';
                    if (newAdmins.length > 0) {
                        notificationText += `${newAdmins.join('、')} 被设置为管理员`;
                    }
                    if (removedAdmins.length > 0) {
                        if (notificationText) notificationText += '；';
                        notificationText += `${removedAdmins.join('、')} 被取消管理员`;
                    }
                    
                    const systemMessage = {
                        id: `msg_${Date.now()}`,
                        role: 'system',
                        content: `[system-display:${notificationText}]`,
                        timestamp: Date.now()
                    };
                    group.history.push(systemMessage);
                }
                
                await saveData();
                
                // 重新渲染群成员列表
                renderGroupMembersInSettings(group);
                
                // 重新渲染消息（显示系统消息）
                if (currentChatType === 'group' && currentChatId === group.id) {
                    renderMessages(false, true);
                }
                
                // 关闭弹窗
                setAdminModal.classList.remove('visible');
                
                const adminCount = group.members.filter(m => m.isAdmin).length;
                showToast(`已设置 ${adminCount} 位管理员`);
            });
            
            // 取消设置管理员
            cancelSetAdminBtn?.addEventListener('click', () => {
                setAdminModal.classList.remove('visible');
            });
            
            // 禁言管理功能
            let selectedMuteMembers = new Set();
            let selectedMuteDuration = null;
            
            document.getElementById('mute-management-btn')?.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                
                // 检查权限
                if (!group.me.isOwner && !group.me.isAdmin) {
                    showToast('只有群主和管理员可以管理禁言');
                    return;
                }
                
                document.getElementById('group-management-modal').classList.remove('visible');
                document.getElementById('mute-management-modal').classList.add('visible');
                renderMuteMemberList();
            });
            
            document.getElementById('close-mute-management-btn')?.addEventListener('click', () => {
                document.getElementById('mute-management-modal').classList.remove('visible');
                selectedMuteMembers.clear();
                selectedMuteDuration = null;
            });
            
            // 渲染禁言成员列表
            function renderMuteMemberList() {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                
                const listContainer = document.getElementById('mute-member-list');
                listContainer.innerHTML = '';
                
                // 添加全选按钮
                const selectAllDiv = document.createElement('div');
                selectAllDiv.style.cssText = 'display: flex; gap: 8px; margin-bottom: 10px;';
                selectAllDiv.innerHTML = `
                    <button type="button" class="btn btn-secondary" id="select-all-mute" style="flex: 1; padding: 8px; font-size: 13px;">全选</button>
                    <button type="button" class="btn btn-secondary" id="deselect-all-mute" style="flex: 1; padding: 8px; font-size: 13px;">取消全选</button>
                `;
                listContainer.appendChild(selectAllDiv);
                
                // 渲染成员列表
                group.members.forEach(member => {
                    // 不显示自己
                    if (member.id === 'me') return;
                    
                    // 群主不能被禁言
                    if (member.isOwner) return;
                    
                    // 如果自己是管理员，不能禁言其他管理员
                    if (group.me.isAdmin && !group.me.isOwner && member.isAdmin) return;
                    
                    const isMuted = member.isMuted && (!member.muteEndTime || member.muteEndTime > Date.now());
                    
                    const itemDiv = document.createElement('div');
                    itemDiv.className = `mute-member-item ${isMuted ? 'muted' : ''}`;
                    itemDiv.dataset.memberId = member.id;
                    
                    let statusText = '';
                    if (isMuted) {
                        if (member.muteEndTime === -1) {
                            statusText = '<span class="muted-status">已禁言 (永久)</span>';
                        } else {
                            const remainingMinutes = Math.ceil((member.muteEndTime - Date.now()) / 60000);
                            statusText = `<span class="muted-status">已禁言 (剩余${remainingMinutes}分钟)</span>`;
                        }
                    } else {
                        statusText = '<span class="mute-member-status">正常</span>';
                    }
                    
                    const roleTag = member.isAdmin ? '<span style="color: #4CAF50; font-size: 11px; margin-left: 5px;">[管理员]</span>' : '';
                    
                    itemDiv.innerHTML = `
                        <img src="${member.avatar}" class="mute-member-avatar">
                        <div class="mute-member-info">
                            <div class="mute-member-name">${member.groupNickname}${roleTag}</div>
                            <div>${statusText}</div>
                        </div>
                    `;
                    
                    itemDiv.addEventListener('click', () => {
                        if (selectedMuteMembers.has(member.id)) {
                            selectedMuteMembers.delete(member.id);
                            itemDiv.classList.remove('selected');
                        } else {
                            selectedMuteMembers.add(member.id);
                            itemDiv.classList.add('selected');
                        }
                    });
                    
                    listContainer.appendChild(itemDiv);
                });
                
                // 全选/取消全选事件
                document.getElementById('select-all-mute')?.addEventListener('click', () => {
                    document.querySelectorAll('.mute-member-item').forEach(item => {
                        const memberId = item.dataset.memberId;
                        if (memberId) {
                            selectedMuteMembers.add(memberId);
                            item.classList.add('selected');
                        }
                    });
                });
                
                document.getElementById('deselect-all-mute')?.addEventListener('click', () => {
                    selectedMuteMembers.clear();
                    document.querySelectorAll('.mute-member-item').forEach(item => {
                        item.classList.remove('selected');
                    });
                });
            }
            
            // 禁言成员按钮
            document.getElementById('mute-members-btn')?.addEventListener('click', () => {
                if (selectedMuteMembers.size === 0) {
                    showToast('请先选择要禁言的成员');
                    return;
                }
                
                document.getElementById('mute-duration-section').style.display = 'block';
                selectedMuteDuration = null;
                document.querySelectorAll('.mute-duration-btn').forEach(btn => btn.classList.remove('selected'));
            });
            
            // 解除禁言按钮
            document.getElementById('unmute-members-btn')?.addEventListener('click', async () => {
                if (selectedMuteMembers.size === 0) {
                    showToast('请先选择要解除禁言的成员');
                    return;
                }
                
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                
                const unmutedNames = [];
                selectedMuteMembers.forEach(memberId => {
                    const member = group.members.find(m => m.id === memberId);
                    if (member && member.isMuted) {
                        member.isMuted = false;
                        member.muteEndTime = null;
                        unmutedNames.push(member.groupNickname);
                    }
                });
                
                await saveData();
                
                if (unmutedNames.length > 0) {
                    const myNickname = group.me.groupNickname || group.me.nickname || (group.settings && group.settings.myNickname) || '我';
                    const message = `${myNickname} 解除了 ${unmutedNames.join('、')} 的禁言`;
                    await addSystemMessage(group.id, message);
                    showToast(`已解除 ${unmutedNames.length} 位成员的禁言`);
                }
                
                selectedMuteMembers.clear();
                renderMuteMemberList();
                document.getElementById('mute-duration-section').style.display = 'none';
            });
            
            // 全员禁言按钮
            document.getElementById('mute-all-btn')?.addEventListener('click', async () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                
                if (!group.me.isOwner && !group.me.isAdmin) {
                    showToast('只有群主和管理员可以全员禁言');
                    return;
                }
                
                const confirmed = confirm('全员禁言\n\n确定要开启全员禁言吗？开启后只有群主和管理员可以发言。');
                if (!confirmed) return;
                
                group.allMuted = !group.allMuted;
                await saveData();
                
                const myNickname = group.me.groupNickname || group.me.nickname || (group.settings && group.settings.myNickname) || '我';
                const message = group.allMuted 
                    ? `${myNickname} 开启了全员禁言` 
                    : `${myNickname} 关闭了全员禁言`;
                await addSystemMessage(group.id, message);
                
                showToast(group.allMuted ? '已开启全员禁言' : '已关闭全员禁言');
                document.getElementById('mute-all-btn').textContent = group.allMuted ? '解除全员禁言' : '全员禁言';
            });
            
            // 禁言时长选择
            document.querySelectorAll('.mute-duration-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.mute-duration-btn').forEach(b => b.classList.remove('selected'));
                    btn.classList.add('selected');
                    selectedMuteDuration = parseInt(btn.dataset.minutes);
                    document.getElementById('custom-mute-minutes').value = '';
                });
            });
            
            // 确认禁言按钮
            document.getElementById('confirm-mute-btn')?.addEventListener('click', async () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                
                // 获取禁言时长
                let duration = selectedMuteDuration;
                const customMinutes = document.getElementById('custom-mute-minutes').value;
                if (customMinutes && parseInt(customMinutes) > 0) {
                    duration = parseInt(customMinutes);
                }
                
                if (duration === null) {
                    showToast('请选择禁言时长');
                    return;
                }
                
                const mutedNames = [];
                selectedMuteMembers.forEach(memberId => {
                    const member = group.members.find(m => m.id === memberId);
                    if (member) {
                        member.isMuted = true;
                        member.muteEndTime = duration === -1 ? -1 : Date.now() + (duration * 60000);
                        mutedNames.push(member.groupNickname);
                    }
                });
                
                await saveData();
                
                if (mutedNames.length > 0) {
                    const myNickname = group.me.groupNickname || group.me.nickname || (group.settings && group.settings.myNickname) || '我';
                    const durationText = duration === -1 ? '永久' : `${duration}分钟`;
                    const message = `${myNickname} 禁言了 ${mutedNames.join('、')} (${durationText})`;
                    await addSystemMessage(group.id, message);
                    showToast(`已禁言 ${mutedNames.length} 位成员`);
                }
                
                selectedMuteMembers.clear();
                selectedMuteDuration = null;
                renderMuteMemberList();
                document.getElementById('mute-duration-section').style.display = 'none';
            });
            
            // 转让群主功能
            const transferOwnerModal = document.getElementById('transfer-owner-modal');
            const ownerSelectionList = document.getElementById('owner-selection-list');
            const confirmTransferOwnerBtn = document.getElementById('confirm-transfer-owner-btn');
            const cancelTransferOwnerBtn = document.getElementById('cancel-transfer-owner-btn');
            
            document.getElementById('transfer-owner-btn')?.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                
                // 确保用户有权限属性
                if (group.me.isOwner === undefined) {
                    group.me.isOwner = false;
                }
                
                // 检查权限：只有群主可以转让群主
                if (!group.me.isOwner) {
                    showToast('只有群主可以转让群主');
                    groupManagementModal.classList.remove('visible');
                    return;
                }
                
                // 渲染群主选择列表
                renderOwnerSelectionList(group);
                
                // 显示弹窗
                groupManagementModal.classList.remove('visible');
                transferOwnerModal.classList.add('visible');
            });
            
            // 渲染群主选择列表
            function renderOwnerSelectionList(group) {
                ownerSelectionList.innerHTML = '';
                
                // 确保每个成员都有isOwner属性
                group.members.forEach(member => {
                    if (member.isOwner === undefined) {
                        member.isOwner = false;
                    }
                    
                    const item = document.createElement('div');
                    item.className = 'owner-select-item';
                    item.innerHTML = `
                        <input type="radio" name="owner-select" id="owner-radio-${member.id}" ${member.isOwner ? 'checked' : ''} value="${member.id}">
                        <img src="${member.avatar}" alt="${member.groupNickname}">
                        <div class="member-info">
                            <div class="member-name">
                                ${member.groupNickname}
                                ${member.isOwner ? '<span class="owner-badge">群主</span>' : ''}
                            </div>
                        </div>
                    `;
                    
                    // 点击整个项目选择单选框
                    item.addEventListener('click', (e) => {
                        if (e.target.tagName !== 'INPUT') {
                            const radio = item.querySelector('input[type="radio"]');
                            radio.checked = true;
                        }
                    });
                    
                    ownerSelectionList.appendChild(item);
                });
            }
            
            // 确认转让群主
            confirmTransferOwnerBtn?.addEventListener('click', async () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                
                const selectedRadio = document.querySelector('input[name="owner-select"]:checked');
                if (!selectedRadio) {
                    showToast('请选择新群主');
                    return;
                }
                
                const newOwnerId = selectedRadio.value;
                const newOwner = group.members.find(m => m.id === newOwnerId);
                
                if (!newOwner) return;
                
                // 确认转让
                if (!confirm(`确定要将群主转让给 ${newOwner.groupNickname} 吗？此操作不可撤销！`)) {
                    return;
                }
                
                // 移除所有成员的群主身份
                group.members.forEach(member => {
                    member.isOwner = false;
                });
                
                // 设置新群主
                newOwner.isOwner = true;
                // 新群主不需要管理员身份
                newOwner.isAdmin = false;
                
                // 用户失去群主身份
                if (group.me.isOwner) {
                    group.me.isOwner = false;
                    // 可以选择是否给用户管理员身份，这里默认不给
                    // group.me.isAdmin = true;
                }
                
                // 添加系统消息（使用system-display格式以显示为旁白）
                const systemMessage = {
                    id: `msg_${Date.now()}`,
                    role: 'system',
                    content: `[system-display:群主已转让给 ${newOwner.groupNickname}]`,
                    timestamp: Date.now()
                };
                group.history.push(systemMessage);
                
                await saveData();
                
                // 重新渲染群成员列表
                renderGroupMembersInSettings(group);
                
                // 重新渲染消息（显示系统消息）
                if (currentChatType === 'group' && currentChatId === group.id) {
                    renderMessages(false, true);
                }
                
                // 关闭弹窗
                transferOwnerModal.classList.remove('visible');
                
                showToast(`已将群主转让给 ${newOwner.groupNickname}`);
            });
            
            // 取消转让群主
            cancelTransferOwnerBtn?.addEventListener('click', () => {
                transferOwnerModal.classList.remove('visible');
            });
            
            document.getElementById('toggle-group-search-btn')?.addEventListener('click', () => {
                showToast('关闭群搜索功能开发中...');
            });
            
            // 踢出成员功能
            const kickMembersModal = document.getElementById('kick-members-modal');
            const kickMembersList = document.getElementById('kick-members-list');
            const selectAllKickMembersBtn = document.getElementById('select-all-kick-members-btn');
            const kickSelectedCount = document.getElementById('kick-selected-count');
            const confirmKickMembersBtn = document.getElementById('confirm-kick-members-btn');
            const cancelKickMembersBtn = document.getElementById('cancel-kick-members-btn');
            
            document.getElementById('kick-all-members-btn')?.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                
                // 确保用户有isOwner和isAdmin属性
                if (group.me.isOwner === undefined) {
                    group.me.isOwner = false;
                }
                if (group.me.isAdmin === undefined) {
                    group.me.isAdmin = false;
                }
                
                // 检查权限：只有群主和管理员可以踢人
                if (!group.me.isOwner && !group.me.isAdmin) {
                    showToast('只有群主和管理员可以踢出成员');
                    groupManagementModal.classList.remove('visible');
                    return;
                }
                
                // 渲染踢出成员列表
                renderKickMembersList(group);
                
                // 显示弹窗
                groupManagementModal.classList.remove('visible');
                kickMembersModal.classList.add('visible');
            });
            
            // 渲染踢出成员列表
            function renderKickMembersList(group) {
                kickMembersList.innerHTML = '';
                
                // 确保用户有权限属性
                const userIsOwner = group.me.isOwner || false;
                const userIsAdmin = group.me.isAdmin || false;
                
                group.members.forEach(member => {
                    const item = document.createElement('div');
                    item.className = 'kick-member-item';
                    
                    // 判断是否可以踢出该成员
                    let canKick = false;
                    let cannotKickReason = '';
                    
                    if (userIsOwner) {
                        // 群主可以踢出任何人（除了自己，但用户不在members列表中）
                        canKick = true;
                    } else if (userIsAdmin) {
                        // 管理员只能踢出普通成员，不能踢出群主和其他管理员
                        if (member.isOwner) {
                            canKick = false;
                            cannotKickReason = '群主';
                        } else if (member.isAdmin) {
                            canKick = false;
                            cannotKickReason = '管理员';
                        } else {
                            canKick = true;
                        }
                    } else {
                        // 普通成员不能踢人
                        canKick = false;
                        cannotKickReason = '无权限';
                    }
                    
                    if (!canKick) {
                        item.classList.add('disabled');
                    }
                    
                    item.innerHTML = `
                        <input type="checkbox" class="kick-member-checkbox" value="${member.id}" ${!canKick ? 'disabled' : ''}>
                        <img src="${member.avatar}" alt="${member.groupNickname}">
                        <div class="member-info">
                            <div class="member-name">
                                ${member.groupNickname}
                                ${member.isOwner ? '<span class="owner-badge">群主</span>' : ''}
                                ${member.isAdmin && !member.isOwner ? '<span class="admin-badge">管理员</span>' : ''}
                                ${!canKick ? `<span class="cannot-kick-badge">不可踢出${cannotKickReason ? '(' + cannotKickReason + ')' : ''}</span>` : ''}
                            </div>
                        </div>
                    `;
                    
                    // 点击整个项目切换复选框（如果可以踢出）
                    if (canKick) {
                        item.addEventListener('click', (e) => {
                            if (e.target.tagName !== 'INPUT') {
                                const checkbox = item.querySelector('input[type="checkbox"]');
                                checkbox.checked = !checkbox.checked;
                                updateKickSelectedCount();
                            }
                        });
                    }
                    
                    kickMembersList.appendChild(item);
                });
                
                // 绑定复选框change事件
                document.querySelectorAll('.kick-member-checkbox').forEach(checkbox => {
                    checkbox.addEventListener('change', updateKickSelectedCount);
                });
                
                updateKickSelectedCount();
            }
            
            // 更新已选择数量
            function updateKickSelectedCount() {
                const checkedBoxes = document.querySelectorAll('.kick-member-checkbox:checked');
                kickSelectedCount.textContent = `已选择 ${checkedBoxes.length} 人`;
            }
            
            // 全选/取消全选
            selectAllKickMembersBtn?.addEventListener('click', () => {
                const checkboxes = document.querySelectorAll('.kick-member-checkbox:not([disabled])');
                const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                
                checkboxes.forEach(checkbox => {
                    checkbox.checked = !allChecked;
                });
                
                selectAllKickMembersBtn.textContent = allChecked ? '全选' : '取消全选';
                updateKickSelectedCount();
            });
            
            // 确认踢出成员
            confirmKickMembersBtn?.addEventListener('click', async () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                
                // 确保群组有kickedMembers数组
                if (!group.kickedMembers) {
                    group.kickedMembers = [];
                }
                
                const checkedBoxes = document.querySelectorAll('.kick-member-checkbox:checked');
                if (checkedBoxes.length === 0) {
                    showToast('请至少选择一个成员');
                    return;
                }
                
                // 确认操作
                if (!confirm(`确定要踢出 ${checkedBoxes.length} 位成员吗？`)) {
                    return;
                }
                
                // 收集被踢出成员的信息
                const kickedMembers = [];
                const kickedMembersData = [];
                
                checkedBoxes.forEach(checkbox => {
                    const memberId = checkbox.value;
                    const member = group.members.find(m => m.id === memberId);
                    if (member) {
                        kickedMembers.push(member.groupNickname);
                        
                        // 保存被踢成员的完整信息
                        kickedMembersData.push({
                            ...member,
                            kickedAt: Date.now(),
                            wasAdmin: member.isAdmin || false
                        });
                    }
                });
                
                // 从群组中移除成员
                checkedBoxes.forEach(checkbox => {
                    const memberId = checkbox.value;
                    group.members = group.members.filter(m => m.id !== memberId);
                });
                
                // 添加系统消息
                const systemMessage = {
                    id: `msg_${Date.now()}`,
                    role: 'system',
                    content: `[system-display:${kickedMembers.join('、')} 被移出群聊]`,
                    timestamp: Date.now(),
                    kickedMembersData: kickedMembersData // 保存被踢成员数据
                };
                group.history.push(systemMessage);
                
                // 将被踢成员添加到群组的kickedMembers数组
                group.kickedMembers.push(...kickedMembersData);
                
                await saveData();
                
                // 重新渲染群成员列表
                renderGroupMembersInSettings(group);
                
                // 重新渲染消息（显示系统消息）
                if (currentChatType === 'group' && currentChatId === group.id) {
                    renderMessages(false, true);
                }
                
                // 关闭弹窗
                kickMembersModal.classList.remove('visible');
                
                showToast(`已踢出 ${kickedMembers.length} 位成员`);
            });
            
            // 取消踢出
            cancelKickMembersBtn?.addEventListener('click', () => {
                kickMembersModal.classList.remove('visible');
            });
            
            // AI生成角色事件
            const aiGenerateCharModal = document.getElementById('ai-generate-char-modal');
            const aiGenerateCharForm = document.getElementById('ai-generate-char-form');
            const closeAiGenerateModal = document.getElementById('close-ai-generate-modal');
            
            closeAiGenerateModal?.addEventListener('click', () => {
                aiGenerateCharModal.classList.remove('visible');
                aiGenerateCharForm.reset();
                document.getElementById('ai-gen-result').style.display = 'none';
            });
            
            aiGenerateCharModal?.addEventListener('click', (e) => {
                if (e.target === aiGenerateCharModal) {
                    aiGenerateCharModal.classList.remove('visible');
                    aiGenerateCharForm.reset();
                    document.getElementById('ai-gen-result').style.display = 'none';
                }
            });
            
            // 模板文件上传按钮
            const uploadTemplateBtn = document.getElementById('upload-template-btn');
            const templateFileInput = document.getElementById('ai-gen-template-file');
            const clearTemplateBtn = document.getElementById('clear-template-btn');
            const templateTextarea = document.getElementById('ai-gen-template');
            
            uploadTemplateBtn?.addEventListener('click', () => {
                templateFileInput.click();
            });
            
            clearTemplateBtn?.addEventListener('click', () => {
                templateTextarea.value = '';
                showToast('模板已清空');
            });
            
            templateFileInput?.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    let content = '';
                    
                    if (file.name.endsWith('.txt')) {
                        // 读取TXT文件
                        content = await file.text();
                    } else if (file.name.endsWith('.docx')) {
                        // 读取DOCX文件
                        if (typeof mammoth === 'undefined') {
                            throw new Error('DOCX解析库未加载，请刷新页面重试');
                        }
                        
                        const arrayBuffer = await file.arrayBuffer();
                        const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                        content = result.value;
                        
                        if (result.messages && result.messages.length > 0) {
                            console.warn('DOCX解析警告:', result.messages);
                        }
                    } else {
                        throw new Error('不支持的文件格式，请选择TXT或DOCX文件');
                    }
                    
                    // 将内容填入文本框
                    templateTextarea.value = content.trim();
                    showToast('模板导入成功！');
                    
                } catch (error) {
                    console.error('模板文件导入失败:', error);
                    showToast(`导入失败: ${error.message}`);
                } finally {
                    // 清空文件选择，允许重复选择同一文件
                    e.target.value = '';
                }
            });
            
            // 系统词文件上传按钮（角色生成）
            const uploadSystemPromptBtn = document.getElementById('upload-system-prompt-btn');
            const systemPromptFileInput = document.getElementById('ai-gen-system-prompt-file');
            const clearSystemPromptBtn = document.getElementById('clear-system-prompt-btn');
            const systemPromptTextarea = document.getElementById('ai-gen-system-prompt');
            
            uploadSystemPromptBtn?.addEventListener('click', () => {
                systemPromptFileInput.click();
            });
            
            clearSystemPromptBtn?.addEventListener('click', () => {
                systemPromptTextarea.value = '';
                showToast('系统词已清空');
            });
            
            systemPromptFileInput?.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    let content = '';
                    
                    if (file.name.endsWith('.txt')) {
                        content = await file.text();
                    } else if (file.name.endsWith('.docx')) {
                        if (typeof mammoth === 'undefined') {
                            throw new Error('DOCX解析库未加载，请刷新页面重试');
                        }
                        
                        const arrayBuffer = await file.arrayBuffer();
                        const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                        content = result.value;
                        
                        if (result.messages && result.messages.length > 0) {
                            console.warn('DOCX解析警告:', result.messages);
                        }
                    } else {
                        throw new Error('不支持的文件格式，请选择TXT或DOCX文件');
                    }
                    
                    systemPromptTextarea.value = content.trim();
                    showToast('系统词导入成功！');
                    
                } catch (error) {
                    console.error('系统词文件导入失败:', error);
                    showToast(`导入失败: ${error.message}`);
                } finally {
                    e.target.value = '';
                }
            });
            
            // 执行AI生成角色的函数
            async function executeAiGeneration(buttonElement) {
                const originalText = buttonElement.textContent;
                buttonElement.disabled = true;
                buttonElement.textContent = '生成中...';
                
                try {
                    const formData = new FormData();
                    formData.append('mustHave', document.getElementById('ai-gen-must-have').value);
                    formData.append('mustNotHave', document.getElementById('ai-gen-must-not-have').value);
                    formData.append('wordCount', document.getElementById('ai-gen-word-count').value);
                    formData.append('template', document.getElementById('ai-gen-template').value);
                    formData.append('systemPrompt', document.getElementById('ai-gen-system-prompt').value);
                    formData.append('systemPosition', document.querySelector('input[name="ai-gen-system-position"]:checked').value);
                    formData.append('apiType', document.querySelector('input[name="ai-gen-api-type"]:checked').value);
                    formData.append('count', document.getElementById('ai-gen-count').value);
                    
                    // 保存当前表单数据，用于重新生成
                    window.lastAiGenFormData = {
                        mustHave: document.getElementById('ai-gen-must-have').value,
                        mustNotHave: document.getElementById('ai-gen-must-not-have').value,
                        wordCount: document.getElementById('ai-gen-word-count').value,
                        template: document.getElementById('ai-gen-template').value,
                        systemPrompt: document.getElementById('ai-gen-system-prompt').value,
                        systemPosition: document.querySelector('input[name="ai-gen-system-position"]:checked').value,
                        apiType: document.querySelector('input[name="ai-gen-api-type"]:checked').value,
                        count: document.getElementById('ai-gen-count').value
                    };
                    
                    const result = await handleAiGenerateCharacter(formData);
                    
                    // 显示生成结果
                    const resultDiv = document.getElementById('ai-gen-result');
                    const resultContent = document.getElementById('ai-gen-result-content');
                    resultDiv.style.display = 'block';
                    
                    let html = '<div style="margin-bottom: 15px;">';
                    html += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">`;
                    html += `<p style="color: #4CAF50; font-weight: bold; margin: 0;">✓ 成功生成 ${result.characters.length} 个角色</p>`;
                    html += `<button class="btn btn-secondary" onclick="regenerateCharacters()" style="padding: 8px 16px; font-size: 14px;">重新生成</button>`;
                    html += `</div>`;
                    
                    result.characters.forEach((char, index) => {
                        html += `<div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid var(--primary-color);">`;
                        html += `<h5 style="margin: 0 0 10px 0; color: var(--primary-color);">角色 ${index + 1}</h5>`;
                        html += `<pre style="white-space: pre-wrap; word-wrap: break-word; font-family: monospace; font-size: 13px; margin: 0; background: #f5f5f5; padding: 10px; border-radius: 4px;">${JSON.stringify(char, null, 2)}</pre>`;
                        html += `<button class="btn btn-primary" onclick="importGeneratedCharacter(${index})" style="margin-top: 10px; width: 100%;">导入此角色</button>`;
                        html += `</div>`;
                    });
                    
                    html += '</div>';
                    resultContent.innerHTML = html;
                    
                    // 保存生成结果到临时变量
                    window.generatedCharacters = result.characters;
                    
                    showToast('角色生成成功！');
                    
                } catch (error) {
                    console.error('AI生成角色失败:', error);
                    showToast(`生成失败: ${error.message}`);
                } finally {
                    buttonElement.disabled = false;
                    buttonElement.textContent = originalText;
                }
            }
            
            // 重新生成角色
            async function regenerateCharacters() {
                if (!window.lastAiGenFormData) {
                    showToast('没有可用的生成参数');
                    return;
                }
                
                // 创建一个临时按钮元素用于显示状态
                const resultContent = document.getElementById('ai-gen-result-content');
                resultContent.innerHTML = '<div style="text-align: center; padding: 40px;"><p style="color: #666;">正在重新生成...</p></div>';
                
                // 使用保存的表单数据重新生成
                const formData = new FormData();
                formData.append('mustHave', window.lastAiGenFormData.mustHave);
                formData.append('mustNotHave', window.lastAiGenFormData.mustNotHave);
                formData.append('wordCount', window.lastAiGenFormData.wordCount);
                formData.append('template', window.lastAiGenFormData.template);
                formData.append('apiType', window.lastAiGenFormData.apiType);
                formData.append('count', window.lastAiGenFormData.count);
                
                try {
                    const result = await handleAiGenerateCharacter(formData);
                    
                    // 显示生成结果
                    let html = '<div style="margin-bottom: 15px;">';
                    html += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">`;
                    html += `<p style="color: #4CAF50; font-weight: bold; margin: 0;">✓ 成功生成 ${result.characters.length} 个角色</p>`;
                    html += `<button class="btn btn-secondary" onclick="regenerateCharacters()" style="padding: 8px 16px; font-size: 14px;">重新生成</button>`;
                    html += `</div>`;
                    
                    result.characters.forEach((char, index) => {
                        html += `<div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid var(--primary-color);">`;
                        html += `<h5 style="margin: 0 0 10px 0; color: var(--primary-color);">角色 ${index + 1}</h5>`;
                        html += `<pre style="white-space: pre-wrap; word-wrap: break-word; font-family: monospace; font-size: 13px; margin: 0; background: #f5f5f5; padding: 10px; border-radius: 4px;">${JSON.stringify(char, null, 2)}</pre>`;
                        html += `<button class="btn btn-primary" onclick="importGeneratedCharacter(${index})" style="margin-top: 10px; width: 100%;">导入此角色</button>`;
                        html += `</div>`;
                    });
                    
                    html += '</div>';
                    resultContent.innerHTML = html;
                    
                    // 保存生成结果到临时变量
                    window.generatedCharacters = result.characters;
                    
                    showToast('角色重新生成成功！');
                    
                } catch (error) {
                    console.error('AI重新生成角色失败:', error);
                    showToast(`重新生成失败: ${error.message}`);
                    resultContent.innerHTML = '<div style="text-align: center; padding: 40px;"><p style="color: #e53935;">生成失败，请重试</p></div>';
                }
            }
            
            // 暴露到全局作用域
            window.regenerateCharacters = regenerateCharacters;
            
            aiGenerateCharForm?.addEventListener('submit', async (e) => {
                e.preventDefault();
                const submitBtn = e.target.querySelector('button[type="submit"]');
                await executeAiGeneration(submitBtn);
            });
            
            // AI生成人设预设事件
            const aiGeneratePersonaModal = document.getElementById('ai-generate-persona-modal');
            const aiGeneratePersonaForm = document.getElementById('ai-generate-persona-form');
            const closeAiGeneratePersonaModal = document.getElementById('close-ai-generate-persona-modal');
            
            closeAiGeneratePersonaModal?.addEventListener('click', () => {
                aiGeneratePersonaModal.classList.remove('visible');
                aiGeneratePersonaForm.reset();
                document.getElementById('ai-gen-persona-result').style.display = 'none';
            });
            
            aiGeneratePersonaModal?.addEventListener('click', (e) => {
                if (e.target === aiGeneratePersonaModal) {
                    aiGeneratePersonaModal.classList.remove('visible');
                    aiGeneratePersonaForm.reset();
                    document.getElementById('ai-gen-persona-result').style.display = 'none';
                }
            });
            
            // 人设模板文件上传
            const uploadPersonaTemplateBtn = document.getElementById('upload-persona-template-btn');
            const personaTemplateFileInput = document.getElementById('ai-gen-persona-template-file');
            const clearPersonaTemplateBtn = document.getElementById('clear-persona-template-btn');
            const personaTemplateTextarea = document.getElementById('ai-gen-persona-template');
            
            uploadPersonaTemplateBtn?.addEventListener('click', () => {
                personaTemplateFileInput.click();
            });
            
            clearPersonaTemplateBtn?.addEventListener('click', () => {
                personaTemplateTextarea.value = '';
                showToast('模板已清空');
            });
            
            personaTemplateFileInput?.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    let content = '';
                    
                    if (file.name.endsWith('.txt')) {
                        content = await file.text();
                    } else if (file.name.endsWith('.docx')) {
                        if (typeof mammoth === 'undefined') {
                            throw new Error('DOCX解析库未加载，请刷新页面重试');
                        }
                        const arrayBuffer = await file.arrayBuffer();
                        const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                        content = result.value;
                    } else {
                        throw new Error('不支持的文件格式，请选择TXT或DOCX文件');
                    }
                    
                    personaTemplateTextarea.value = content.trim();
                    showToast('模板导入成功！');
                } catch (error) {
                    console.error('模板文件导入失败:', error);
                    showToast(`导入失败: ${error.message}`);
                } finally {
                    e.target.value = '';
                }
            });
            
            // 系统词文件上传按钮（人设预设生成）
            const uploadPersonaSystemPromptBtn = document.getElementById('upload-persona-system-prompt-btn');
            const personaSystemPromptFileInput = document.getElementById('ai-gen-persona-system-prompt-file');
            const clearPersonaSystemPromptBtn = document.getElementById('clear-persona-system-prompt-btn');
            const personaSystemPromptTextarea = document.getElementById('ai-gen-persona-system-prompt');
            
            uploadPersonaSystemPromptBtn?.addEventListener('click', () => {
                personaSystemPromptFileInput.click();
            });
            
            clearPersonaSystemPromptBtn?.addEventListener('click', () => {
                personaSystemPromptTextarea.value = '';
                showToast('系统词已清空');
            });
            
            personaSystemPromptFileInput?.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    let content = '';
                    
                    if (file.name.endsWith('.txt')) {
                        content = await file.text();
                    } else if (file.name.endsWith('.docx')) {
                        if (typeof mammoth === 'undefined') {
                            throw new Error('DOCX解析库未加载，请刷新页面重试');
                        }
                        const arrayBuffer = await file.arrayBuffer();
                        const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                        content = result.value;
                    } else {
                        throw new Error('不支持的文件格式，请选择TXT或DOCX文件');
                    }
                    
                    personaSystemPromptTextarea.value = content.trim();
                    showToast('系统词导入成功！');
                } catch (error) {
                    console.error('系统词文件导入失败:', error);
                    showToast(`导入失败: ${error.message}`);
                } finally {
                    e.target.value = '';
                }
            });
            
            // AI生成人设预设表单提交
            aiGeneratePersonaForm?.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const submitBtn = e.target.querySelector('button[type="submit"]');
                const originalText = submitBtn.textContent;
                submitBtn.disabled = true;
                submitBtn.textContent = '生成中...';
                
                try {
                    const mustHave = document.getElementById('ai-gen-persona-must-have').value;
                    const mustNotHave = document.getElementById('ai-gen-persona-must-not-have').value;
                    const wordCount = document.getElementById('ai-gen-persona-word-count').value;
                    const template = document.getElementById('ai-gen-persona-template').value;
                    const systemPrompt = document.getElementById('ai-gen-persona-system-prompt').value;
                    const systemPosition = document.querySelector('input[name="ai-gen-persona-system-position"]:checked').value;
                    const apiType = document.querySelector('input[name="ai-gen-persona-api-type"]:checked').value;
                    const count = parseInt(document.getElementById('ai-gen-persona-count').value) || 1;
                    
                    // 获取API配置
                    let apiUrl, apiKey, model;
                    if (apiType === 'main') {
                        apiUrl = db.apiSettings?.url;
                        apiKey = db.apiSettings?.key;
                        model = db.apiSettings?.model;
                    } else {
                        apiUrl = db.secondaryApiSettings?.url;
                        apiKey = db.secondaryApiSettings?.key;
                        model = db.secondaryApiSettings?.model;
                    }
                    
                    if (!apiUrl || !apiKey || !model) {
                        throw new Error(`${apiType === 'main' ? '主' : '副'}API配置不完整，请先在设置中配置API`);
                    }
                    
                    // 构建提示词
                    let promptParts = {
                        before: '',
                        middle: '',
                        after: ''
                    };
                    
                    // 根据位置添加系统词
                    if (systemPrompt) {
                        promptParts[systemPosition] = systemPrompt + '\n\n';
                    }
                    
                    let mainPrompt = `你是一个专业的人设设计师。请根据以下要求生成${count}个详细的人设描述。\n\n`;
                    
                    if (mustHave) {
                        mainPrompt += `必须包含的特征：${mustHave}\n`;
                    }
                    if (mustNotHave) {
                        mainPrompt += `绝对不能包含的特征：${mustNotHave}\n`;
                    }
                    if (wordCount) {
                        mainPrompt += `每个人设字数：约${wordCount}字\n`;
                    }
                    
                    if (template) {
                        mainPrompt += `\n请按照以下模板格式生成人设：\n${template}\n\n`;
                    } else {
                        mainPrompt += `\n请生成详细的人设描述，包括：性格特点、外貌特征、背景故事、兴趣爱好、说话风格等。\n\n`;
                    }
                    
                    mainPrompt += `请生成${count}个不同的人设，每个人设用"---"分隔。确保每个人设都独特且符合要求。`;
                    
                    // 组合提示词
                    const finalPrompt = promptParts.before + mainPrompt + promptParts.middle + promptParts.after;
                    
                    // 调用API
                    const messages = [
                        { role: 'system', content: '你是一个专业的人设设计师，擅长创造生动、有趣、符合要求的人物设定。' },
                        { role: 'user', content: finalPrompt }
                    ];
                    
                    const isGemini = apiUrl.includes('generativelanguage.googleapis.com');
                    let response;
                    
                    if (isGemini) {
                        const geminiBody = {
                            contents: messages.map(msg => ({
                                role: msg.role === 'assistant' ? 'model' : 'user',
                                parts: [{ text: msg.content }]
                            }))
                        };
                        response = await fetch(`${apiUrl}/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(geminiBody)
                        });
                    } else {
                        response = await fetch(`${apiUrl}/v1/chat/completions`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`
                            },
                            body: JSON.stringify({
                                model: model,
                                messages: messages,
                                temperature: 0.9
                            })
                        });
                    }
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API请求失败: ${response.status} - ${JSON.stringify(errorData)}`);
                    }
                    
                    const data = await response.json();
                    let responseText;
                    
                    if (isGemini) {
                        responseText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    } else {
                        responseText = data.choices?.[0]?.message?.content;
                    }
                    
                    if (!responseText) {
                        throw new Error('API响应为空');
                    }
                    
                    // 分割人设
                    const personas = responseText.split('---').map(p => p.trim()).filter(p => p);
                    
                    // 显示生成结果
                    const resultDiv = document.getElementById('ai-gen-persona-result');
                    const resultContent = document.getElementById('ai-gen-persona-result-content');
                    resultDiv.style.display = 'block';
                    
                    let html = '<div style="margin-bottom: 15px;">';
                    html += `<p style="color: #4CAF50; font-weight: bold; margin-bottom: 10px;">✓ 成功生成 ${personas.length} 个人设</p>`;
                    
                    personas.forEach((persona, index) => {
                        html += `<div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid var(--primary-color);">`;
                        html += `<h5 style="margin: 0 0 10px 0; color: var(--primary-color);">人设 ${index + 1}</h5>`;
                        html += `<pre style="white-space: pre-wrap; word-wrap: break-word; font-size: 14px; margin: 0; line-height: 1.6;">${persona}</pre>`;
                        html += `<button class="btn btn-primary" onclick="importGeneratedPersona(${index})" style="margin-top: 10px; width: 100%;">导入此人设</button>`;
                        html += `</div>`;
                    });
                    
                    html += '</div>';
                    resultContent.innerHTML = html;
                    
                    // 保存生成结果到临时变量
                    window.generatedPersonas = personas;
                    
                    showToast('人设生成成功！');
                    
                } catch (error) {
                    console.error('AI生成人设失败:', error);
                    showToast(`生成失败: ${error.message}`);
                } finally {
                    submitBtn.disabled = false;
                    submitBtn.textContent = originalText;
                }
            });
            
            // 导入生成的人设到描述框
            window.importGeneratedPersona = function(index) {
                if (!window.generatedPersonas || !window.generatedPersonas[index]) {
                    showToast('人设数据不存在');
                    return;
                }
                
                const persona = window.generatedPersonas[index];
                
                // 根据当前上下文填入对应的文本框
                if (currentPersonaPresetContext === 'private') {
                    document.getElementById('setting-my-persona').value = persona;
                    showToast('人设已导入到"我的人设"框，请自行设置名称和头像');
                } else if (currentPersonaPresetContext === 'group') {
                    document.getElementById('setting-group-my-persona').value = persona;
                    showToast('人设已导入到"我的人设"框，请自行设置名称和头像');
                }
                
                // 关闭弹窗
                aiGeneratePersonaModal.classList.remove('visible');
                aiGeneratePersonaForm.reset();
                document.getElementById('ai-gen-persona-result').style.display = 'none';
            };
            
            // AI生成NPC功能
            const aiGenerateNpcModal = document.getElementById('ai-generate-npc-modal');
            const aiGenerateNpcForm = document.getElementById('ai-generate-npc-form');
            const closeAiGenerateNpcModal = document.getElementById('close-ai-generate-npc-modal');
            
            closeAiGenerateNpcModal?.addEventListener('click', () => {
                aiGenerateNpcModal.classList.remove('visible');
                aiGenerateNpcForm.reset();
                document.getElementById('ai-gen-npc-result').style.display = 'none';
            });
            
            aiGenerateNpcModal?.addEventListener('click', (e) => {
                if (e.target === aiGenerateNpcModal) {
                    aiGenerateNpcModal.classList.remove('visible');
                    aiGenerateNpcForm.reset();
                    document.getElementById('ai-gen-npc-result').style.display = 'none';
                }
            });
            
            // NPC模板文件上传按钮
            const uploadNpcTemplateBtn = document.getElementById('upload-npc-template-btn');
            const npcTemplateFileInput = document.getElementById('ai-gen-npc-template-file');
            const clearNpcTemplateBtn = document.getElementById('clear-npc-template-btn');
            const npcTemplateTextarea = document.getElementById('ai-gen-npc-template');
            
            uploadNpcTemplateBtn?.addEventListener('click', () => {
                npcTemplateFileInput.click();
            });
            
            clearNpcTemplateBtn?.addEventListener('click', () => {
                npcTemplateTextarea.value = '';
                showToast('模板已清空');
            });
            
            npcTemplateFileInput?.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    let content = '';
                    
                    if (file.name.endsWith('.txt')) {
                        content = await file.text();
                    } else if (file.name.endsWith('.docx')) {
                        if (typeof mammoth === 'undefined') {
                            throw new Error('DOCX解析库未加载，请刷新页面重试');
                        }
                        
                        const arrayBuffer = await file.arrayBuffer();
                        const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                        content = result.value;
                        
                        if (result.messages && result.messages.length > 0) {
                            console.warn('DOCX解析警告:', result.messages);
                        }
                    } else {
                        throw new Error('不支持的文件格式，请选择TXT或DOCX文件');
                    }
                    
                    npcTemplateTextarea.value = content.trim();
                    showToast('模板导入成功！');
                    
                } catch (error) {
                    console.error('模板文件导入失败:', error);
                    showToast(`导入失败: ${error.message}`);
                } finally {
                    e.target.value = '';
                }
            });
            
            // NPC系统词文件上传按钮
            const uploadNpcSystemPromptBtn = document.getElementById('upload-npc-system-prompt-btn');
            const npcSystemPromptFileInput = document.getElementById('ai-gen-npc-system-prompt-file');
            const clearNpcSystemPromptBtn = document.getElementById('clear-npc-system-prompt-btn');
            const npcSystemPromptTextarea = document.getElementById('ai-gen-npc-system-prompt');
            
            uploadNpcSystemPromptBtn?.addEventListener('click', () => {
                npcSystemPromptFileInput.click();
            });
            
            clearNpcSystemPromptBtn?.addEventListener('click', () => {
                npcSystemPromptTextarea.value = '';
                showToast('系统词已清空');
            });
            
            npcSystemPromptFileInput?.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    let content = '';
                    
                    if (file.name.endsWith('.txt')) {
                        content = await file.text();
                    } else if (file.name.endsWith('.docx')) {
                        if (typeof mammoth === 'undefined') {
                            throw new Error('DOCX解析库未加载，请刷新页面重试');
                        }
                        
                        const arrayBuffer = await file.arrayBuffer();
                        const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                        content = result.value;
                        
                        if (result.messages && result.messages.length > 0) {
                            console.warn('DOCX解析警告:', result.messages);
                        }
                    } else {
                        throw new Error('不支持的文件格式，请选择TXT或DOCX文件');
                    }
                    
                    npcSystemPromptTextarea.value = content.trim();
                    showToast('系统词导入成功！');
                    
                } catch (error) {
                    console.error('系统词文件导入失败:', error);
                    showToast(`导入失败: ${error.message}`);
                } finally {
                    e.target.value = '';
                }
            });
            
            // AI生成NPC表单提交
            aiGenerateNpcForm?.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const submitBtn = e.target.querySelector('button[type="submit"]');
                const originalText = submitBtn.textContent;
                submitBtn.disabled = true;
                submitBtn.textContent = '生成中...';
                
                try {
                    const mustHave = document.getElementById('ai-gen-npc-must-have').value;
                    const mustNotHave = document.getElementById('ai-gen-npc-must-not-have').value;
                    const wordCount = document.getElementById('ai-gen-npc-word-count').value;
                    const template = document.getElementById('ai-gen-npc-template').value;
                    const systemPrompt = document.getElementById('ai-gen-npc-system-prompt').value;
                    const systemPosition = document.querySelector('input[name="ai-gen-npc-system-position"]:checked').value;
                    const apiType = document.querySelector('input[name="ai-gen-npc-api-type"]:checked').value;
                    const count = parseInt(document.getElementById('ai-gen-npc-count').value) || 1;
                    
                    // 获取API配置
                    let apiUrl, apiKey, model;
                    if (apiType === 'main') {
                        apiUrl = db.apiSettings?.url;
                        apiKey = db.apiSettings?.key;
                        model = db.apiSettings?.model;
                    } else {
                        apiUrl = db.secondaryApiSettings?.url;
                        apiKey = db.secondaryApiSettings?.key;
                        model = db.secondaryApiSettings?.model;
                    }
                    
                    if (!apiUrl || !apiKey || !model) {
                        throw new Error(`${apiType === 'main' ? '主' : '副'}API配置不完整，请先在设置中配置API`);
                    }
                    
                    // 构建提示词
                    let promptParts = {
                        before: '',
                        middle: '',
                        after: ''
                    };
                    
                    // 根据位置添加系统词
                    if (systemPrompt) {
                        promptParts[systemPosition] = systemPrompt + '\n\n';
                    }
                    
                    let mainPrompt = `你是一个专业的NPC角色设计师。请根据以下要求生成${count}个NPC角色的详细人设。\n\n`;
                    
                    if (mustHave) {
                        mainPrompt += `必须包含的特征：${mustHave}\n`;
                    }
                    if (mustNotHave) {
                        mainPrompt += `绝对不能包含的特征：${mustNotHave}\n`;
                    }
                    if (wordCount) {
                        mainPrompt += `每个NPC人设字数：约${wordCount}字\n`;
                    }
                    
                    if (template) {
                        mainPrompt += `\n请严格按照以下模板格式生成NPC：\n${template}\n\n`;
                    } else {
                        mainPrompt += `\n请生成详细的NPC人设描述，包括：性格特点、外貌特征、背景故事、职业或身份等。\n\n`;
                    }
                    
                    mainPrompt += `请生成${count}个不同的NPC，每个NPC用"---"分隔。确保每个NPC都独特且符合要求。`;
                    
                    // 组合提示词
                    const finalPrompt = promptParts.before + mainPrompt + promptParts.middle + promptParts.after;
                    
                    // 调用API
                    const messages = [
                        { role: 'system', content: '你是一个专业的NPC角色设计师，擅长创造生动、有趣、符合要求的NPC角色。' },
                        { role: 'user', content: finalPrompt }
                    ];
                    
                    const isGemini = apiUrl.includes('generativelanguage.googleapis.com');
                    let response;
                    
                    if (isGemini) {
                        const geminiBody = {
                            contents: messages.map(msg => ({
                                role: msg.role === 'assistant' ? 'model' : 'user',
                                parts: [{ text: msg.content }]
                            }))
                        };
                        response = await fetch(`${apiUrl}/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(geminiBody)
                        });
                    } else {
                        response = await fetch(`${apiUrl}/v1/chat/completions`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${apiKey}`
                            },
                            body: JSON.stringify({
                                model: model,
                                messages: messages,
                                temperature: 0.9
                            })
                        });
                    }
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`API请求失败: ${response.status} - ${JSON.stringify(errorData)}`);
                    }
                    
                    const data = await response.json();
                    let responseText;
                    
                    if (isGemini) {
                        responseText = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    } else {
                        responseText = data.choices?.[0]?.message?.content;
                    }
                    
                    if (!responseText) {
                        throw new Error('API响应为空');
                    }
                    
                    // 分割NPC
                    const npcs = responseText.split('---').map(p => p.trim()).filter(p => p);
                    
                    // 显示生成结果
                    const resultDiv = document.getElementById('ai-gen-npc-result');
                    const resultContent = document.getElementById('ai-gen-npc-result-content');
                    resultDiv.style.display = 'block';
                    
                    let html = '<div style="margin-bottom: 15px;">';
                    html += `<p style="color: #4CAF50; font-weight: bold; margin-bottom: 10px;">✓ 成功生成 ${npcs.length} 个NPC</p>`;
                    
                    npcs.forEach((npc, index) => {
                        html += `<div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid var(--primary-color);">`;
                        html += `<h5 style="margin: 0 0 10px 0; color: var(--primary-color);">NPC ${index + 1}</h5>`;
                        html += `<pre style="white-space: pre-wrap; word-wrap: break-word; font-size: 14px; margin: 0; line-height: 1.6;">${npc}</pre>`;
                        html += `<button class="btn btn-primary" onclick="importGeneratedNpc(${index})" style="margin-top: 10px; width: 100%;">导入此NPC</button>`;
                        html += `</div>`;
                    });
                    
                    html += '</div>';
                    resultContent.innerHTML = html;
                    
                    // 保存生成结果到临时变量
                    window.generatedNpcs = npcs;
                    
                    showToast('NPC生成成功！');
                    
                } catch (error) {
                    console.error('AI生成NPC失败:', error);
                    showToast(`生成失败: ${error.message}`);
                } finally {
                    submitBtn.disabled = false;
                    submitBtn.textContent = originalText;
                }
            });
            
            // 导入生成的NPC
            window.importGeneratedNpc = function(index) {
                if (!window.generatedNpcs || !window.generatedNpcs[index]) {
                    showToast('NPC数据不存在');
                    return;
                }
                
                const npcDescription = window.generatedNpcs[index];
                
                // 填入NPC描述框
                document.getElementById('edit-npc-title').textContent = '添加NPC';
                document.getElementById('edit-npc-id').value = '';
                document.getElementById('npc-name').value = '';
                document.getElementById('npc-description').value = npcDescription;
                document.getElementById('npc-relation-to-char').value = '';
                document.getElementById('npc-relation-to-user').value = '';
                document.getElementById('npc-avatar-preview').src = 'https://i.postimg.cc/GtbTnxhP/o-o-1.jpg';
                
                // 重置全局NPC和选择角色开关
                document.getElementById('npc-global-toggle').checked = false;
                document.getElementById('npc-select-chars-toggle').checked = false;
                document.getElementById('npc-chars-selection').style.display = 'none';
                
                // 显示两个开关的form-group（添加模式）
                document.getElementById('npc-global-toggle-group').style.display = 'block';
                document.getElementById('npc-select-chars-group').style.display = 'block';
                
                // 生成角色列表
                renderNpcCharSelection();
                
                // 关闭AI生成弹窗，打开编辑弹窗
                aiGenerateNpcModal.classList.remove('visible');
                aiGenerateNpcForm.reset();
                document.getElementById('ai-gen-npc-result').style.display = 'none';
                document.getElementById('edit-npc-modal').classList.add('visible');
                
                showToast('NPC已导入，请设置名称、头像和关系');
            };
            const useGroupCustomCssCheckbox = document.getElementById('setting-group-use-custom-css'),
                groupCustomCssTextarea = document.getElementById('setting-group-custom-bubble-css'),
                resetGroupCustomCssBtn = document.getElementById('reset-group-custom-bubble-css-btn'),
                groupPreviewBox = document.getElementById('group-bubble-css-preview');
            useGroupCustomCssCheckbox.addEventListener('change', (e) => {
                groupCustomCssTextarea.disabled = !e.target.checked;
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, groupCustomCssTextarea.value, !e.target.checked, theme);
                }
            });
            groupCustomCssTextarea.addEventListener('input', (e) => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group && useGroupCustomCssCheckbox.checked) {
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, e.target.value, false, theme);
                }
            });
            resetGroupCustomCssBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    groupCustomCssTextarea.value = '';
                    useGroupCustomCssCheckbox.checked = false;
                    groupCustomCssTextarea.disabled = true;
                    const theme = colorThemes[group.theme || 'white_pink'];
                    updateBubbleCssPreview(groupPreviewBox, '', true, theme);
                    showToast('样式已重置为默认');
                }
            });
            document.getElementById('setting-group-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        const group = db.groups.find(g => g.id === currentChatId);
                        if (group) {
                            group.avatar = compressedUrl;
                            document.getElementById('setting-group-avatar-preview').src = compressedUrl;
                        }
                    } catch (error) {
                        showToast('群头像压缩失败，请重试');
                    }
                }
            });
            document.getElementById('setting-group-chat-bg-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {
                            quality: 0.85,
                            maxWidth: 1080,
                            maxHeight: 1920
                        });
                        const group = db.groups.find(g => g.id === currentChatId);
                        if (group) {
                            group.chatBg = compressedUrl;
                            chatRoomScreen.style.backgroundImage = `url(${compressedUrl})`;
                            await saveData();
                            showToast('聊天背景已更换');
                        }
                    } catch (error) {
                        showToast('群聊背景压缩失败，请重试');
                    }
                }
            });
            document.getElementById('clear-group-chat-history-btn').addEventListener('click', async () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                if (confirm(`你确定要清空群聊“${group.name}”的所有聊天记录吗？这个操作是不可恢复的！`)) {
                    group.history = [];
                    group.autoSummarizedFloors = []; // 清空已总结记录
                    // 重置所有群成员的在线状态为默认值
                    if (group.members) {
                        group.members.forEach(member => {
                            const char = db.characters.find(c => c.id === member.id);
                            if (char) {
                                char.status = '在线';
                            }
                        });
                    }
                    await dataStorage.clearChatMessages(group.id, 'group');
                    await saveData();
                    renderMessages(false, true);
                    renderChatList();
                    groupSettingsSidebar.classList.remove('open');
                    showToast('聊天记录已清空，所有成员状态已重置');
                }
            });
            
            // Export Group Chat History
            exportGroupChatHistoryBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                
                if (!group.history || group.history.length === 0) {
                    showToast('当前没有聊天记录可导出');
                    return;
                }
                
                // Prepare export data
                const exportData = {
                    exportTime: new Date().toISOString(),
                    chatType: 'group',
                    group: {
                        name: group.name,
                        members: group.members.map(m => ({
                            id: m.id,
                            realName: m.realName,
                            groupNickname: m.groupNickname,
                            persona: m.persona
                        }))
                    },
                    user: {
                        nickname: group.me.nickname,
                        persona: group.me.persona
                    },
                    messageCount: group.history.length,
                    messages: group.history.map(msg => {
                        const sender = msg.senderId ? group.members.find(m => m.id === msg.senderId) : null;
                        return {
                            id: msg.id,
                            role: msg.role,
                            content: msg.content,
                            timestamp: msg.timestamp,
                            time: new Date(msg.timestamp).toLocaleString('zh-CN'),
                            sender: sender ? {
                                id: sender.id,
                                realName: sender.realName,
                                groupNickname: sender.groupNickname
                            } : null,
                            parts: msg.parts
                        };
                    })
                };
                
                // Create download link
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `群聊记录_${group.name}_${new Date().toLocaleDateString('zh-CN').replace(/\//g, '-')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showToast('聊天记录已导出');
            });
            
            // Import Group Chat History
            importGroupChatHistoryBtn.addEventListener('click', () => {
                importGroupChatHistoryInput.click();
            });
            
            importGroupChatHistoryInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const text = await file.text();
                    const importData = JSON.parse(text);
                    
                    // Validate import data
                    if (!importData.messages || !Array.isArray(importData.messages)) {
                        showToast('导入失败：文件格式不正确');
                        return;
                    }
                    
                    const group = db.groups.find(g => g.id === currentChatId);
                    if (!group) {
                        showToast('导入失败：未找到当前群聊');
                        return;
                    }
                    
                    // Ask user: replace or append
                    const shouldReplace = confirm(
                        `检测到 ${importData.messageCount || importData.messages.length} 条消息。\n\n` +
                        `点击"确定"：替换当前所有聊天记录\n` +
                        `点击"取消"：追加到现有聊天记录末尾`
                    );
                    
                    if (shouldReplace) {
                        // Replace all messages
                        group.history = importData.messages.map(msg => ({
                            id: msg.id || `msg_${Date.now()}_${Math.random()}`,
                            role: msg.role,
                            content: msg.content,
                            timestamp: msg.timestamp || Date.now(),
                            senderId: msg.sender?.id || msg.senderId || null,
                            parts: msg.parts || null
                        }));
                    } else {
                        // Append messages
                        const newMessages = importData.messages.map(msg => ({
                            id: msg.id || `msg_${Date.now()}_${Math.random()}`,
                            role: msg.role,
                            content: msg.content,
                            timestamp: msg.timestamp || Date.now(),
                            senderId: msg.sender?.id || msg.senderId || null,
                            parts: msg.parts || null
                        }));
                        group.history.push(...newMessages);
                    }
                    
                    await saveData();
                    currentPage = 1;
                    renderMessages(false, true);
                    renderChatList();
                    
                    showToast(`成功导入 ${importData.messages.length} 条消息`);
                } catch (error) {
                    console.error('导入失败:', error);
                    showToast('导入失败：' + error.message);
                }
                
                e.target.value = '';
            });
            
            groupMembersListContainer.addEventListener('click', e => {
                const memberDiv = e.target.closest('.group-member');
                const addBtn = e.target.closest('.add-member-btn');
                if (memberDiv) {
                    openGroupMemberEditModal(memberDiv.dataset.id);
                } else if (addBtn) {
                    addMemberActionSheet.classList.add('visible');
                }
            });
            document.getElementById('edit-member-avatar-preview').addEventListener('click', () => {
                document.getElementById('edit-member-avatar-upload').click();
            });
            document.getElementById('edit-member-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('edit-member-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('成员头像压缩失败，请重试');
                    }
                }
            });
            editGroupMemberForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const memberId = document.getElementById('editing-member-id').value;
                const group = db.groups.find(g => g.id === currentChatId);
                const member = group.members.find(m => m.id === memberId);
                if (member) {
                    member.avatar = document.getElementById('edit-member-avatar-preview').src;
                    member.groupNickname = document.getElementById('edit-member-group-nickname').value;
                    member.realName = document.getElementById('edit-member-real-name').value;
                    member.persona = document.getElementById('edit-member-persona').value;
                    
                    // 保存成员专属Minimax TTS设置
                    const memberMinimaxEnabled = document.getElementById('edit-member-minimax-enabled').checked;
                    if (!member.minimaxConfig) {
                        member.minimaxConfig = {};
                    }
                    member.minimaxConfig.enabled = memberMinimaxEnabled;
                    member.minimaxConfig.groupId = document.getElementById('edit-member-minimax-group-id').value.trim();
                    member.minimaxConfig.apiKey = document.getElementById('edit-member-minimax-api-key').value.trim();
                    member.minimaxConfig.voiceId = document.getElementById('edit-member-minimax-voice-id').value.trim();
                    member.minimaxConfig.speechModel = document.getElementById('edit-member-minimax-speech-model').value;
                    
                    // 兼容性：保留旧的voiceId字段（用于数据迁移）
                    if (member.voiceId !== undefined) {
                        delete member.voiceId;
                    }
                    
                    await saveData();
                    renderGroupMembersInSettings(group);
                    document.querySelectorAll(`.message-wrapper[data-sender-id="${member.id}"] .group-nickname`).forEach(el => {
                        el.textContent = member.groupNickname;
                    });
                    showToast('成员信息已更新');
                }
                editGroupMemberModal.classList.remove('visible');
            });
            
            // 群成员专属Minimax TTS开关事件监听器
            document.getElementById('edit-member-minimax-enabled')?.addEventListener('change', (e) => {
                const memberMinimaxSettingsContainer = document.getElementById('member-minimax-settings');
                if (memberMinimaxSettingsContainer) {
                    memberMinimaxSettingsContainer.style.display = e.target.checked ? 'block' : 'none';
                }
            });
            
            inviteExistingMemberBtn.addEventListener('click', () => {
                renderInviteSelectionList();
                inviteMemberModal.classList.add('visible');
                addMemberActionSheet.classList.remove('visible');
            });
            createNewMemberBtn.addEventListener('click', () => {
                createMemberForGroupForm.reset();
                document.getElementById('create-group-member-avatar-preview').src = 'https://i.postimg.cc/Y96LPskq/o-o-2.jpg';
                createMemberForGroupModal.classList.add('visible');
                addMemberActionSheet.classList.remove('visible');
            });
            
            // AI生成群成员按钮
            const aiGenerateGroupMemberBtn = document.getElementById('ai-generate-group-member-btn');
            const aiGenerateGroupMemberModal = document.getElementById('ai-generate-group-member-modal');
            const aiGenerateGroupMemberForm = document.getElementById('ai-generate-group-member-form');
            const closeAiGenerateGmModal = document.getElementById('close-ai-generate-gm-modal');
            
            aiGenerateGroupMemberBtn?.addEventListener('click', () => {
                aiGenerateGroupMemberModal.classList.add('visible');
                addMemberActionSheet.classList.remove('visible');
            });
            
            closeAiGenerateGmModal?.addEventListener('click', () => {
                aiGenerateGroupMemberModal.classList.remove('visible');
                aiGenerateGroupMemberForm.reset();
                document.getElementById('ai-gen-gm-result').style.display = 'none';
            });
            
            aiGenerateGroupMemberModal?.addEventListener('click', (e) => {
                if (e.target === aiGenerateGroupMemberModal) {
                    aiGenerateGroupMemberModal.classList.remove('visible');
                    aiGenerateGroupMemberForm.reset();
                    document.getElementById('ai-gen-gm-result').style.display = 'none';
                }
            });
            
            // 群成员模板文件上传
            const uploadGmTemplateBtn = document.getElementById('upload-gm-template-btn');
            const gmTemplateFileInput = document.getElementById('ai-gen-gm-template-file');
            const clearGmTemplateBtn = document.getElementById('clear-gm-template-btn');
            const gmTemplateTextarea = document.getElementById('ai-gen-gm-template');
            
            uploadGmTemplateBtn?.addEventListener('click', () => {
                gmTemplateFileInput.click();
            });
            
            clearGmTemplateBtn?.addEventListener('click', () => {
                gmTemplateTextarea.value = '';
                showToast('模板已清空');
            });
            
            gmTemplateFileInput?.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    let content = '';
                    
                    if (file.name.endsWith('.txt')) {
                        content = await file.text();
                    } else if (file.name.endsWith('.docx')) {
                        if (typeof mammoth === 'undefined') {
                            throw new Error('DOCX解析库未加载，请刷新页面重试');
                        }
                        const arrayBuffer = await file.arrayBuffer();
                        const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                        content = result.value;
                    } else {
                        throw new Error('不支持的文件格式，请选择TXT或DOCX文件');
                    }
                    
                    gmTemplateTextarea.value = content.trim();
                    showToast('模板导入成功！');
                } catch (error) {
                    console.error('模板文件导入失败:', error);
                    showToast(`导入失败: ${error.message}`);
                } finally {
                    e.target.value = '';
                }
            });
            
            // 群成员系统词文件上传
            const uploadGmSystemPromptBtn = document.getElementById('upload-gm-system-prompt-btn');
            const gmSystemPromptFileInput = document.getElementById('ai-gen-gm-system-prompt-file');
            const clearGmSystemPromptBtn = document.getElementById('clear-gm-system-prompt-btn');
            const gmSystemPromptTextarea = document.getElementById('ai-gen-gm-system-prompt');
            
            uploadGmSystemPromptBtn?.addEventListener('click', () => {
                gmSystemPromptFileInput.click();
            });
            
            clearGmSystemPromptBtn?.addEventListener('click', () => {
                gmSystemPromptTextarea.value = '';
                showToast('系统词已清空');
            });
            
            gmSystemPromptFileInput?.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    let content = '';
                    
                    if (file.name.endsWith('.txt')) {
                        content = await file.text();
                    } else if (file.name.endsWith('.docx')) {
                        if (typeof mammoth === 'undefined') {
                            throw new Error('DOCX解析库未加载，请刷新页面重试');
                        }
                        const arrayBuffer = await file.arrayBuffer();
                        const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                        content = result.value;
                    } else {
                        throw new Error('不支持的文件格式，请选择TXT或DOCX文件');
                    }
                    
                    gmSystemPromptTextarea.value = content.trim();
                    showToast('系统词导入成功！');
                } catch (error) {
                    console.error('系统词文件导入失败:', error);
                    showToast(`导入失败: ${error.message}`);
                } finally {
                    e.target.value = '';
                }
            });
            
            // AI生成群成员表单提交
            aiGenerateGroupMemberForm?.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const submitBtn = e.target.querySelector('button[type="submit"]');
                const originalText = submitBtn.textContent;
                submitBtn.disabled = true;
                submitBtn.textContent = '生成中...';
                
                try {
                    const formData = new FormData();
                    formData.append('mustHave', document.getElementById('ai-gen-gm-must-have').value);
                    formData.append('mustNotHave', document.getElementById('ai-gen-gm-must-not-have').value);
                    formData.append('wordCount', document.getElementById('ai-gen-gm-word-count').value);
                    formData.append('template', document.getElementById('ai-gen-gm-template').value);
                    formData.append('systemPrompt', document.getElementById('ai-gen-gm-system-prompt').value);
                    formData.append('systemPosition', document.querySelector('input[name="ai-gen-gm-system-position"]:checked').value);
                    formData.append('apiType', document.querySelector('input[name="ai-gen-gm-api-type"]:checked').value);
                    formData.append('count', document.getElementById('ai-gen-gm-count').value);
                    
                    const result = await handleAiGenerateCharacter(formData);
                    
                    // 显示生成结果
                    const resultDiv = document.getElementById('ai-gen-gm-result');
                    const resultContent = document.getElementById('ai-gen-gm-result-content');
                    resultDiv.style.display = 'block';
                    
                    let html = '<div style="margin-bottom: 15px;">';
                    html += `<p style="color: #4CAF50; font-weight: bold; margin-bottom: 15px;">✓ 成功生成 ${result.characters.length} 个群成员</p>`;
                    
                    result.characters.forEach((char, index) => {
                        html += `<div style="background: white; padding: 15px; border-radius: 10px; margin-bottom: 15px; border: 2px solid #e0e0e0;">`;
                        html += `<h4 style="margin: 0 0 10px 0; color: var(--primary-color);">群成员 ${index + 1}</h4>`;
                        html += `<pre style="white-space: pre-wrap; word-wrap: break-word; font-family: inherit; margin: 0 0 10px 0;">${JSON.stringify(char, null, 2)}</pre>`;
                        html += `<button class="btn btn-primary" onclick="addGeneratedGroupMember(${index})" style="width: 100%; padding: 10px;">添加到群聊</button>`;
                        html += `</div>`;
                    });
                    
                    html += '</div>';
                    resultContent.innerHTML = html;
                    
                    // 保存生成的角色数据供添加使用
                    window.generatedGroupMembers = result.characters;
                    
                    showToast('生成成功！');
                    
                } catch (error) {
                    console.error('AI生成群成员失败:', error);
                    showToast(`生成失败: ${error.message}`);
                } finally {
                    submitBtn.disabled = false;
                    submitBtn.textContent = originalText;
                }
            });
            document.getElementById('create-group-member-avatar-preview').addEventListener('click', () => {
                document.getElementById('create-group-member-avatar-upload').click();
            });
            document.getElementById('create-group-member-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('create-group-member-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('新成员头像压缩失败，请重试');
                    }
                }
            });
            confirmInviteBtn.addEventListener('click', async () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                const selectedCharIds = Array.from(inviteMemberSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                selectedCharIds.forEach(charId => {
                    const char = db.characters.find(c => c.id === charId);
                    if (char) {
                        const newMember = {
                            id: `member_${char.id}`,
                            originalCharId: char.id,
                            realName: char.realName,
                            groupNickname: char.remarkName,
                            persona: char.persona,
                            avatar: char.avatar
                        };
                        group.members.push(newMember);
                        sendInviteNotification(group, newMember.realName);
                    }
                });
                if (selectedCharIds.length > 0) {
                    await saveData();
                    renderGroupMembersInSettings(group);
                    renderMessages(false, true);
                    showToast('已邀请新成员');
                }
                inviteMemberModal.classList.remove('visible');
            });
            createMemberForGroupForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                const newMember = {
                    id: `member_group_only_${Date.now()}`,
                    originalCharId: null,
                    realName: document.getElementById('create-group-member-realname').value,
                    groupNickname: document.getElementById('create-group-member-nickname').value,
                    persona: document.getElementById('create-group-member-persona').value,
                    avatar: document.getElementById('create-group-member-avatar-preview').src,
                };
                group.members.push(newMember);
                sendInviteNotification(group, newMember.realName);
                await saveData();
                renderGroupMembersInSettings(group);
                renderMessages(false, true);
                showToast(`新成员 ${newMember.groupNickname} 已加入`);
                createMemberForGroupModal.classList.remove('visible');
            });
            document.getElementById('setting-group-my-avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const compressedUrl = await compressImage(file, {quality: 0.8, maxWidth: 400, maxHeight: 400});
                        document.getElementById('setting-group-my-avatar-preview').src = compressedUrl;
                    } catch (error) {
                        showToast('头像压缩失败')
                    }
                }
            });
            confirmGroupRecipientBtn.addEventListener('click', () => {
                const selectedRecipientIds = Array.from(groupRecipientSelectionList.querySelectorAll('input:checked')).map(input => input.value);
                if (selectedRecipientIds.length === 0) {
                    return showToast('请至少选择一个收件人。');
                }
                currentGroupAction.recipients = selectedRecipientIds;
                groupRecipientSelectionModal.classList.remove('visible');

                if (currentGroupAction.type === 'transfer') {
                    sendTransferForm.reset();
                    sendTransferModal.classList.add('visible');
                } else if (currentGroupAction.type === 'gift') {
                    sendGiftForm.reset();
                    sendGiftModal.classList.add('visible');
                }
            });
            // Custom theme color button handler for group chat
            document.getElementById('apply-group-custom-theme-btn').addEventListener('click', async () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                
                const charBg = document.getElementById('setting-group-custom-char-bg').value;
                const charText = document.getElementById('setting-group-custom-char-text').value;
                const userBg = document.getElementById('setting-group-custom-user-bg').value;
                const userText = document.getElementById('setting-group-custom-user-text').value;
                
                group.customTheme = {
                    received: { bg: charBg, text: charText },
                    sent: { bg: userBg, text: userText }
                };
                
                await saveData();
                currentPage = 1;
                renderMessages(false, true);
                showToast('自定义颜色已应用！');
            });
            
            // Reset custom theme button handler for group chat
            document.getElementById('reset-group-custom-theme-btn').addEventListener('click', async () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                
                // Remove custom theme
                delete group.customTheme;
                
                // Reset color inputs to current theme defaults
                const defaultTheme = colorThemes[group.theme || 'white_pink'];
                document.getElementById('setting-group-custom-char-bg').value = defaultTheme.received.bg;
                document.getElementById('setting-group-custom-char-text').value = defaultTheme.received.text;
                document.getElementById('setting-group-custom-user-bg').value = defaultTheme.sent.bg;
                document.getElementById('setting-group-custom-user-text').value = defaultTheme.sent.text;
                
                await saveData();
                currentPage = 1;
                renderMessages(false, true);
                showToast('已重置为默认气泡！');
            });
            linkGroupWorldBookBtn.addEventListener('click', () => {
                const group = db.groups.find(g => g.id === currentChatId);
                if (!group) return;
                worldBookSelectionList.innerHTML = '';
                db.worldBooks.forEach(book => {
                    const li = document.createElement('li');
                    li.className = 'world-book-select-item';
                    const isChecked = (group.worldBookIds || []).includes(book.id);
                    li.innerHTML = `<input type="checkbox" id="wb-select-group-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="wb-select-group-${book.id}">${book.name}</label>`;
                    worldBookSelectionList.appendChild(li);
                });
                worldBookSelectionModal.classList.add('visible');
            });
        }

        function renderMemberSelectionList() {
            memberSelectionList.innerHTML = '';
            // 过滤掉NPC角色
            const normalCharacters = db.characters.filter(c => !c.isNPC);
            if (normalCharacters.length === 0) {
                memberSelectionList.innerHTML = '<li style="color:#aaa; text-align:center; padding: 10px 0;">没有可选择的人设。</li>';
                return;
            }
            normalCharacters.forEach(char => {
                const li = document.createElement('li');
                li.className = 'member-selection-item';
                li.innerHTML = `<input type="checkbox" id="select-${char.id}" value="${char.id}"><img src="${char.avatar}" alt="${char.remarkName}"><label for="select-${char.id}">${char.remarkName}</label>`;
                memberSelectionList.appendChild(li);
            });
        }

        function renderObserverMemberSelectionList() {
            observerMemberSelectionList.innerHTML = '';
            // 过滤掉NPC角色
            const normalCharacters = db.characters.filter(c => !c.isNPC);
            if (normalCharacters.length === 0) {
                observerMemberSelectionList.innerHTML = '<li style="color:#aaa; text-align:center; padding: 10px 0;">没有可选择的人设。</li>';
                return;
            }
            normalCharacters.forEach(char => {
                const li = document.createElement('li');
                li.className = 'member-selection-item';
                li.innerHTML = `<input type="checkbox" id="observer-select-${char.id}" value="${char.id}" data-char-name="${char.remarkName}"><img src="${char.avatar}" alt="${char.remarkName}"><label for="observer-select-${char.id}">${char.remarkName}</label>`;
                observerMemberSelectionList.appendChild(li);
                
                // 监听选择变化，更新互相认识和记忆选项
                li.querySelector('input').addEventListener('change', updateObserverGroupOptions);
            });
        }

        function updateObserverGroupOptions() {
            const selectedCheckboxes = Array.from(observerMemberSelectionList.querySelectorAll('input:checked'));
            const selectedMembers = selectedCheckboxes.map(cb => ({
                id: cb.value,
                name: cb.dataset.charName
            }));

            // 更新互相认识的角色对选择
            knowEachOtherPairs.innerHTML = '';
            if (selectedMembers.length >= 2) {
                for (let i = 0; i < selectedMembers.length; i++) {
                    for (let j = i + 1; j < selectedMembers.length; j++) {
                        const pairDiv = document.createElement('div');
                        pairDiv.style.cssText = 'display: flex; align-items: center; padding: 5px 0;';
                        pairDiv.innerHTML = `
                            <input type="checkbox" id="pair-${selectedMembers[i].id}-${selectedMembers[j].id}" 
                                   value="${selectedMembers[i].id},${selectedMembers[j].id}" 
                                   style="width: auto; margin-right: 10px;">
                            <label for="pair-${selectedMembers[i].id}-${selectedMembers[j].id}">
                                ${selectedMembers[i].name} ⇄ ${selectedMembers[j].name}
                            </label>
                        `;
                        knowEachOtherPairs.appendChild(pairDiv);
                    }
                }
            } else {
                knowEachOtherPairs.innerHTML = '<p style="color: #aaa; text-align: center;">请至少选择2个角色</p>';
            }

            // 更新记忆中有USER的角色选择
            memoryHasUserList.innerHTML = '';
            if (selectedMembers.length > 0) {
                selectedMembers.forEach(member => {
                    const li = document.createElement('li');
                    li.className = 'member-selection-item';
                    li.innerHTML = `
                        <input type="checkbox" id="memory-user-${member.id}" value="${member.id}" style="width: auto;">
                        <label for="memory-user-${member.id}">${member.name}</label>
                    `;
                    memoryHasUserList.appendChild(li);
                });
            } else {
                memoryHasUserList.innerHTML = '<li style="color:#aaa; text-align:center; padding: 10px 0;">请先选择角色</li>';
            }
        }

        // 互相认识开关监听
        membersKnowEachOtherToggle.addEventListener('change', (e) => {
            if (e.target.checked) {
                knowEachOtherSelection.style.display = 'block';
            } else {
                knowEachOtherSelection.style.display = 'none';
            }
        });

        // 记忆中有USER开关监听
        memoryHasUserToggle.addEventListener('change', (e) => {
            if (e.target.checked) {
                memoryHasUserSelection.style.display = 'block';
            } else {
                memoryHasUserSelection.style.display = 'none';
            }
        });

        function loadGroupSettingsToSidebar() {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const themeSelect = document.getElementById('setting-group-theme-color');
            if (themeSelect.options.length === 0) {
                Object.keys(colorThemes).forEach(key => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = colorThemes[key].name;
                    themeSelect.appendChild(option);
                });
            }
            document.getElementById('setting-group-avatar-preview').src = group.avatar;
            document.getElementById('setting-group-name').value = group.name;
            document.getElementById('setting-group-my-avatar-preview').src = group.me.avatar;
            document.getElementById('setting-group-my-nickname').value = group.me.nickname;
            document.getElementById('setting-group-my-persona').value = group.me.persona;
            themeSelect.value = group.theme || 'white_pink';
            document.getElementById('setting-group-max-memory').value = group.maxMemory;
            
            // Update current message count for group
            const groupCurrentCount = group.history ? group.history.length : 0;
            document.getElementById('group-current-message-count').textContent = groupCurrentCount;
            
            // Update last summary position for group
            const groupLastSummaryIndex = group.lastSummaryIndex || 0;
            const groupLastSummaryPositionEl = document.getElementById('group-last-summary-position');
            if (groupLastSummaryIndex > 0) {
                groupLastSummaryPositionEl.textContent = `第 ${groupLastSummaryIndex} 条`;
                groupLastSummaryPositionEl.style.color = '#2e7d32';
                groupLastSummaryPositionEl.style.fontWeight = 'bold';
            } else {
                groupLastSummaryPositionEl.textContent = '未总结';
                groupLastSummaryPositionEl.style.color = '#999';
                groupLastSummaryPositionEl.style.fontWeight = 'normal';
            }
            
            // Update current token count for group
            updateTokenDisplay();
            
            // Load token warning settings for group
            const groupTokenWarningEnabled = group.tokenWarningEnabled || false;
            const groupTokenWarningThreshold = group.tokenWarningThreshold || '';
            document.getElementById('group-token-warning-enabled').checked = groupTokenWarningEnabled;
            document.getElementById('group-token-warning-threshold').value = groupTokenWarningThreshold;
            document.getElementById('group-token-warning-options').style.display = groupTokenWarningEnabled ? 'block' : 'none';
            
            // Load message count warning settings for group
            const groupMessageCountWarningEnabled = group.messageCountWarningEnabled || false;
            const groupMessageCountWarningThreshold = group.messageCountWarningThreshold || '';
            document.getElementById('group-message-count-warning-enabled').checked = groupMessageCountWarningEnabled;
            document.getElementById('group-message-count-warning-threshold').value = groupMessageCountWarningThreshold;
            document.getElementById('group-message-count-warning-options').style.display = groupMessageCountWarningEnabled ? 'block' : 'none';
            
            // Load auto-summary settings for group
            const groupAutoSummaryEnabled = group.autoSummaryEnabled || false;
            const groupAutoSummaryCount = group.autoSummaryCount || '';
            const groupCustomSummaryPrompt = group.customSummaryPrompt || DEFAULT_SUMMARY_PROMPT;
            document.getElementById('setting-group-auto-summary-enabled').checked = groupAutoSummaryEnabled;
            document.getElementById('setting-group-auto-summary-count').value = groupAutoSummaryCount;
            document.getElementById('group-custom-summary-prompt').value = groupCustomSummaryPrompt;
            document.getElementById('group-auto-summary-options').style.display = groupAutoSummaryEnabled ? 'block' : 'none';
            
            // Load custom theme colors for group
            if (group.customTheme) {
                document.getElementById('setting-group-custom-char-bg').value = group.customTheme.received.bg;
                document.getElementById('setting-group-custom-char-text').value = group.customTheme.received.text;
                document.getElementById('setting-group-custom-user-bg').value = group.customTheme.sent.bg;
                document.getElementById('setting-group-custom-user-text').value = group.customTheme.sent.text;
            } else {
                // Set default values from current theme
                const defaultTheme = colorThemes[group.theme || 'white_pink'];
                document.getElementById('setting-group-custom-char-bg').value = defaultTheme.received.bg;
                document.getElementById('setting-group-custom-char-text').value = defaultTheme.received.text;
                document.getElementById('setting-group-custom-user-bg').value = defaultTheme.sent.bg;
                document.getElementById('setting-group-custom-user-text').value = defaultTheme.sent.text;
            }
            
            // Load group inner thought setting (默认关闭)
            const groupInnerThoughtEnabled = group.innerThoughtEnabled !== undefined ? group.innerThoughtEnabled : false;
            document.getElementById('setting-group-inner-thought-enabled').checked = groupInnerThoughtEnabled;
            
            renderGroupMembersInSettings(group);
            const useGroupCustomCssCheckbox = document.getElementById('setting-group-use-custom-css'),
                groupCustomCssTextarea = document.getElementById('setting-group-custom-bubble-css'),
                groupPreviewBox = document.getElementById('group-bubble-css-preview');
            useGroupCustomCssCheckbox.checked = group.useCustomBubbleCss || false;
            groupCustomCssTextarea.value = group.customBubbleCss || '';
            groupCustomCssTextarea.disabled = !useGroupCustomCssCheckbox.checked;
            const theme = colorThemes[group.theme || 'white_pink'];
            updateBubbleCssPreview(groupPreviewBox, group.customBubbleCss, !group.useCustomBubbleCss, theme);
            
            // Refresh theme preset dropdown for group
            const groupSelect = document.getElementById('group-theme-preset-select');
            if (groupSelect) {
                groupSelect.innerHTML = '<option value="">-- 选择预设 --</option>';
                db.themePresets.forEach(preset => {
                    const option = document.createElement('option');
                    option.value = preset.id;
                    option.textContent = preset.name;
                    groupSelect.appendChild(option);
                });
            }
        }

        function renderGroupMembersInSettings(group) {
            groupMembersListContainer.innerHTML = '';
            group.members.forEach(member => {
                const memberDiv = document.createElement('div');
                memberDiv.className = 'group-member';
                
                // 群主优先级最高
                if (member.isOwner) {
                    memberDiv.classList.add('is-owner');
                } else if (member.isAdmin) {
                    memberDiv.classList.add('is-admin');
                }
                
                memberDiv.dataset.id = member.id;
                memberDiv.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><span>${member.groupNickname}</span>`;
                groupMembersListContainer.appendChild(memberDiv);
            });
            const addBtn = document.createElement('div');
            addBtn.className = 'add-member-btn';
            addBtn.innerHTML = `<div class="add-icon">+</div><span>添加</span>`;
            groupMembersListContainer.appendChild(addBtn);
            
            // 渲染群公告
            renderGroupAnnouncement(group);
        }
        
        // 渲染群公告列表
        function renderGroupAnnouncement(group) {
            const announcementsList = document.getElementById('group-announcements-list');
            const addBtn = document.getElementById('add-group-announcement-btn');
            const deleteBtn = document.getElementById('delete-group-announcements-btn');
            
            // 初始化公告数组
            if (!group.announcements) {
                group.announcements = [];
            }
            
            // 清空列表
            announcementsList.innerHTML = '';
            
            // 检查权限
            const canEdit = group.me.isOwner || group.me.isAdmin;
            
            // 显示/隐藏按钮
            if (canEdit) {
                addBtn.style.display = 'block';
                deleteBtn.style.display = 'block';
            } else {
                addBtn.style.display = 'none';
                deleteBtn.style.display = 'none';
            }
            
            // 渲染每个公告
            group.announcements.forEach((announcement, index) => {
                const item = document.createElement('div');
                item.className = 'announcement-item';
                item.dataset.index = index;
                
                let html = '';
                
                // 只有管理员才显示复选框
                if (canEdit) {
                    html += `<input type="checkbox" class="announcement-checkbox" data-index="${index}">`;
                }
                
                html += `
                    <div class="announcement-content" data-index="${index}">${announcement.content}</div>
                    <div class="announcement-edit-area" data-index="${index}">
                        <textarea class="announcement-textarea">${announcement.content}</textarea>
                        <div class="announcement-actions">
                            <button class="btn btn-primary save-announcement-btn" data-index="${index}">保存</button>
                            <button class="btn btn-secondary cancel-announcement-btn" data-index="${index}">取消</button>
                        </div>
                    </div>
                `;
                
                if (announcement.updatedAt) {
                    const date = new Date(announcement.updatedAt);
                    const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
                    const editor = announcement.updatedBy || announcement.createdBy || '未知';
                    html += `<div class="announcement-meta">最后编辑: ${dateStr} (${editor})</div>`;
                }
                
                // 只有管理员才显示编辑按钮
                if (canEdit) {
                    html += `<div class="announcement-actions"><button class="btn btn-secondary edit-announcement-btn" data-index="${index}">编辑</button></div>`;
                }
                
                item.innerHTML = html;
                announcementsList.appendChild(item);
            });
            
            // 绑定事件
            bindAnnouncementEvents();
        }
        
        // 绑定公告事件
        function bindAnnouncementEvents() {
            // 复选框事件
            document.querySelectorAll('.announcement-checkbox').forEach(checkbox => {
                checkbox.addEventListener('change', (e) => {
                    const item = e.target.closest('.announcement-item');
                    if (e.target.checked) {
                        item.classList.add('selected');
                    } else {
                        item.classList.remove('selected');
                    }
                });
            });
            
            // 编辑按钮事件
            document.querySelectorAll('.edit-announcement-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = e.target.dataset.index;
                    const item = document.querySelector(`.announcement-item[data-index="${index}"]`);
                    const content = item.querySelector('.announcement-content');
                    const editArea = item.querySelector('.announcement-edit-area');
                    const actions = item.querySelector('.announcement-actions');
                    
                    content.style.display = 'none';
                    editArea.style.display = 'block';
                    actions.style.display = 'none';
                });
            });
            
            // 保存按钮事件
            document.querySelectorAll('.save-announcement-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const index = parseInt(e.target.dataset.index);
                    const group = db.groups.find(g => g.id === currentChatId);
                    if (!group) return;
                    
                    const item = document.querySelector(`.announcement-item[data-index="${index}"]`);
                    const textarea = item.querySelector('.announcement-textarea');
                    const newContent = textarea.value.trim();
                    
                    if (!newContent) {
                        showToast('公告内容不能为空');
                        return;
                    }
                    
                    // 获取编辑者信息
                    const myNickname = group.me.groupNickname || group.me.nickname || (group.settings && group.settings.myNickname) || '我';
                    
                    // 更新公告
                    group.announcements[index].content = newContent;
                    group.announcements[index].updatedAt = Date.now();
                    group.announcements[index].updatedBy = myNickname;
                    
                    // 添加系统消息通知所有成员
                    await addSystemMessage(group.id, `${myNickname} 编辑了群公告`);
                    
                    await saveData();
                    renderGroupAnnouncement(group);
                    
                    // 如果当前正在查看这个群聊，刷新消息显示
                    if (currentChatType === 'group' && currentChatId === group.id) {
                        renderMessages(false, true);
                    }
                    
                    showToast('公告已更新');
                });
            });
            
            // 取消按钮事件
            document.querySelectorAll('.cancel-announcement-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = e.target.dataset.index;
                    const item = document.querySelector(`.announcement-item[data-index="${index}"]`);
                    const content = item.querySelector('.announcement-content');
                    const editArea = item.querySelector('.announcement-edit-area');
                    const actions = item.querySelector('.announcement-actions');
                    
                    content.style.display = 'block';
                    editArea.style.display = 'none';
                    actions.style.display = 'flex';
                });
            });
        }
        
        // 新增公告按钮
        document.getElementById('add-group-announcement-btn')?.addEventListener('click', async () => {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            
            // 检查权限
            if (!group.me.isOwner && !group.me.isAdmin) {
                showToast('只有群主和管理员可以新增公告');
                return;
            }
            
            const content = prompt('新增群公告\n请输入公告内容：');
            if (content === null || !content.trim()) return;
            
            // 初始化公告数组
            if (!group.announcements) {
                group.announcements = [];
            }
            
            // 获取创建者信息
            const myNickname = group.me.groupNickname || group.me.nickname || (group.settings && group.settings.myNickname) || '我';
            
            // 添加新公告
            group.announcements.push({
                content: content.trim(),
                createdAt: Date.now(),
                updatedAt: Date.now(),
                createdBy: myNickname,
                updatedBy: myNickname
            });
            
            // 添加系统消息通知所有成员
            await addSystemMessage(group.id, `${myNickname} 发布了新的群公告`);
            
            await saveData();
            renderGroupAnnouncement(group);
            
            // 如果当前正在查看这个群聊，刷新消息显示
            if (currentChatType === 'group' && currentChatId === group.id) {
                renderMessages(false, true);
            }
            
            showToast('公告已添加');
        });
        
        // 删除选中的公告
        document.getElementById('delete-group-announcements-btn')?.addEventListener('click', async () => {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            
            // 检查权限
            if (!group.me.isOwner && !group.me.isAdmin) {
                showToast('只有群主和管理员可以删除公告');
                return;
            }
            
            // 获取选中的公告
            const selectedCheckboxes = document.querySelectorAll('.announcement-checkbox:checked');
            if (selectedCheckboxes.length === 0) {
                showToast('请先选择要删除的公告');
                return;
            }
            
            const confirmed = confirm(`删除公告\n\n确定要删除选中的 ${selectedCheckboxes.length} 条公告吗？`);
            if (!confirmed) return;
            
            // 收集要删除的索引（从大到小排序，避免删除时索引错乱）
            const indicesToDelete = Array.from(selectedCheckboxes)
                .map(cb => parseInt(cb.dataset.index))
                .sort((a, b) => b - a);
            
            // 获取操作者信息
            const myNickname = group.me.groupNickname || group.me.nickname || (group.settings && group.settings.myNickname) || '我';
            
            // 删除公告
            indicesToDelete.forEach(index => {
                group.announcements.splice(index, 1);
            });
            
            // 添加系统消息通知所有成员
            await addSystemMessage(group.id, `${myNickname} 删除了 ${indicesToDelete.length} 条群公告`);
            
            await saveData();
            renderGroupAnnouncement(group);
            
            // 如果当前正在查看这个群聊，刷新消息显示
            if (currentChatType === 'group' && currentChatId === group.id) {
                renderMessages(false, true);
            }
            
            showToast(`已删除 ${indicesToDelete.length} 条公告`);
        });

        function renderGroupRecipientSelectionList(actionText) {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            groupRecipientSelectionTitle.textContent = actionText;
            groupRecipientSelectionList.innerHTML = '';
            group.members.forEach(member => {
                const li = document.createElement('li');
                li.className = 'group-recipient-select-item';
                li.innerHTML = `
                        <input type="checkbox" id="recipient-select-${member.id}" value="${member.id}">
                        <label for="recipient-select-${member.id}">
                            <img src="${member.avatar}" alt="${member.groupNickname}">
                            <span>${member.groupNickname}</span>
                        </label>`;
                groupRecipientSelectionList.appendChild(li);
            });
        }

        async function saveGroupSettingsFromSidebar() {
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const oldName = group.name;
            const newName = document.getElementById('setting-group-name').value;
            if (oldName !== newName) {
                group.name = newName;
                sendRenameNotification(group, newName);
            }
            
            const oldTheme = group.theme;
            const newTheme = document.getElementById('setting-group-theme-color').value;
            
            group.avatar = document.getElementById('setting-group-avatar-preview').src;
            group.me.avatar = document.getElementById('setting-group-my-avatar-preview').src;
            group.me.nickname = document.getElementById('setting-group-my-nickname').value;
            group.me.persona = document.getElementById('setting-group-my-persona').value;
            group.theme = newTheme;
            group.maxMemory = document.getElementById('setting-group-max-memory').value;
            group.autoSummaryEnabled = document.getElementById('setting-group-auto-summary-enabled').checked;
            group.autoSummaryCount = document.getElementById('setting-group-auto-summary-count').value;
            group.useCustomBubbleCss = document.getElementById('setting-group-use-custom-css').checked;
            group.customBubbleCss = document.getElementById('setting-group-custom-bubble-css').value;
            group.innerThoughtEnabled = document.getElementById('setting-group-inner-thought-enabled').checked;
            
            // If theme changed and custom theme exists, clear it and update color inputs
            if (oldTheme !== newTheme && group.customTheme) {
                delete group.customTheme;
                const defaultTheme = colorThemes[newTheme || 'white_pink'];
                document.getElementById('setting-group-custom-char-bg').value = defaultTheme.received.bg;
                document.getElementById('setting-group-custom-char-text').value = defaultTheme.received.text;
                document.getElementById('setting-group-custom-user-bg').value = defaultTheme.sent.bg;
                document.getElementById('setting-group-custom-user-text').value = defaultTheme.sent.text;
            }
            
            updateCustomBubbleStyle(currentChatId, group.customBubbleCss, group.useCustomBubbleCss);
            await saveData();
            showToast('群聊设置已保存！');
            chatRoomTitle.textContent = group.name;
            renderChatList();
            renderMessages(false, true);
        }

        function openGroupMemberEditModal(memberId) {
            const group = db.groups.find(g => g.id === currentChatId);
            const member = group.members.find(m => m.id === memberId);
            if (!member) return;
            document.getElementById('edit-group-member-title').textContent = `编辑 ${member.groupNickname}`;
            document.getElementById('editing-member-id').value = member.id;
            document.getElementById('edit-member-avatar-preview').src = member.avatar;
            document.getElementById('edit-member-group-nickname').value = member.groupNickname;
            document.getElementById('edit-member-real-name').value = member.realName;
            document.getElementById('edit-member-persona').value = member.persona;
            
            // 加载成员专属Minimax TTS设置
            const memberMinimaxEnabled = member.minimaxConfig && (member.minimaxConfig.enabled === true);
            document.getElementById('edit-member-minimax-enabled').checked = memberMinimaxEnabled;
            
            if (member.minimaxConfig) {
                document.getElementById('edit-member-minimax-group-id').value = member.minimaxConfig.groupId || '';
                document.getElementById('edit-member-minimax-api-key').value = member.minimaxConfig.apiKey || '';
                document.getElementById('edit-member-minimax-voice-id').value = member.minimaxConfig.voiceId || '';
                document.getElementById('edit-member-minimax-speech-model').value = member.minimaxConfig.speechModel || '';
            } else {
                // 兼容旧数据：如果有voiceId字段，迁移到新结构
                if (member.voiceId) {
                    document.getElementById('edit-member-minimax-voice-id').value = member.voiceId;
                }
                document.getElementById('edit-member-minimax-group-id').value = '';
                document.getElementById('edit-member-minimax-api-key').value = '';
                document.getElementById('edit-member-minimax-speech-model').value = '';
            }
            
            // 根据Minimax开关显示/隐藏设置
            const memberMinimaxSettingsContainer = document.getElementById('member-minimax-settings');
            if (memberMinimaxSettingsContainer) {
                memberMinimaxSettingsContainer.style.display = memberMinimaxEnabled ? 'block' : 'none';
            }
            
            editGroupMemberModal.classList.add('visible');
        }

        function renderInviteSelectionList() {
            inviteMemberSelectionList.innerHTML = '';
            const group = db.groups.find(g => g.id === currentChatId);
            if (!group) return;
            const currentMemberCharIds = new Set(group.members.map(m => m.originalCharId));
            // 过滤掉NPC角色和已在群中的角色
            const availableChars = db.characters.filter(c => !c.isNPC && !currentMemberCharIds.has(c.id));
            if (availableChars.length === 0) {
                inviteMemberSelectionList.innerHTML = '<li style="color:#aaa; text-align:center; padding: 10px 0;">没有可邀请的新成员了。</li>';
                confirmInviteBtn.disabled = true;
                return;
            }
            confirmInviteBtn.disabled = false;
            availableChars.forEach(char => {
                const li = document.createElement('li');
                li.className = 'invite-member-select-item';
                li.innerHTML = `<input type="checkbox" id="invite-select-${char.id}" value="${char.id}"><label for="invite-select-${char.id}"><img src="${char.avatar}" alt="${char.remarkName}"><span>${char.remarkName}</span></label>`;
                inviteMemberSelectionList.appendChild(li);
            });
        }

        function sendInviteNotification(group, newMemberRealName) {
            const messageContent = `[${group.me.nickname}邀请${newMemberRealName}加入了群聊]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContent,
                parts: [{type: 'text', text: messageContent}],
                timestamp: Date.now(),
                senderId: 'user_me'
            };
            group.history.push(message);
        }

        function sendRenameNotification(group, newName) {
            const myName = group.me.nickname;
            const messageContent = `[${myName}修改群名为：${newName}]`;
            const message = {
                id: `msg_${Date.now()}`,
                role: 'user',
                content: messageContent,
                parts: [{type: 'text', text: messageContent}],
                timestamp: Date.now()
            };
            group.history.push(message);
        }


        // 优化的消息保存操作
        async function saveMessageToStorage(chatId, chatType, message) {
            try {
                await dataStorage.addMessage(chatId, chatType, message);
                return true;
            } catch (error) {
                console.error('保存消息失败:', error);
                return false;
            }
        }

        // 优化的消息删除操作
        async function deleteMessageFromStorage(chatId, chatType, messageId) {
            try {
                await dataStorage.deleteMessage(chatId, chatType, messageId);
                return true;
            } catch (error) {
                console.error('删除消息失败:', error);
                return false;
            }
        }

        // 优化的消息更新操作
        async function updateMessageInStorage(chatId, chatType, messageId, updatedMessage) {
            try {
                await dataStorage.updateMessage(chatId, chatType, messageId, updatedMessage);
                return true;
            } catch (error) {
                console.error('更新消息失败:', error);
                return false;
            }
        }

        // 创建完整的备份数据（包含所有消息历史）
        async function createFullBackupData() {
            const startTime = Date.now();

            try {
                console.log('🔄 开始创建完整备份数据...');
                
                // 获取基础数据
                const baseData = await dataStorage.getData('章鱼喷墨机') || {};
                console.log('📦 基础数据:', baseData);

                // 重建完整的数据结构
                const fullData = {
                    ...baseData,
                    ...db,
                    characters: [],
                    groups: [],
                    // 确保 personaPresets 被包含（修复：user人设预设无法跟随导出的问题）
                    personaPresets: db.personaPresets || [],
                    // 添加版本信息用于兼容性检测
                    _exportVersion: '2.0',
                    _exportTimestamp: Date.now(),
                    _optimizedStorage: true
                };

                console.log(`📊 当前内存中有 ${db.characters.length} 个角色, ${db.groups.length} 个群组`);

                // 重建角色数据（包含完整消息历史）
                for (const char of db.characters) {
                    const fullHistory = await dataStorage.getChatMessages(char.id, 'private');
                    const charData = await dataStorage.getData(`character_${char.id}`) || char;

                    console.log(`👤 角色 ${charData.remarkName || charData.name}: ${fullHistory.length} 条消息`);

                    // 修复：确保 worldBookIds 被包含（角色关联世界书无法跟随导出的问题）
                    fullData.characters.push({
                        ...charData,
                        worldBookIds: charData.worldBookIds || char.worldBookIds || [],
                        history: fullHistory || []
                    });
                }

                // 重建群组数据（包含完整消息历史）
                for (const group of db.groups) {
                    const fullHistory = await dataStorage.getChatMessages(group.id, 'group');
                    const groupData = await dataStorage.getData(`group_${group.id}`) || group;

                    console.log(`👥 群组 ${groupData.name}: ${fullHistory.length} 条消息`);

                    // 修复：确保 worldBookIds 被包含（群组关联世界书无法跟随导出的问题）
                    fullData.groups.push({
                        ...groupData,
                        worldBookIds: groupData.worldBookIds || group.worldBookIds || [],
                        history: fullHistory || []
                    });
                }

                console.log(`✅ 完整备份数据创建完成，耗时: ${Date.now() - startTime}ms`);
                console.log(`📊 导出统计: ${fullData.characters.length}个角色, ${fullData.groups.length}个群组, ${fullData.personaPresets.length}个人设预设`);
                return fullData;

            } catch (error) {
                console.error('❌ 创建备份数据失败:', error);
                throw new Error(`备份数据创建失败: ${error.message}`);
            }
        }

        // 导入备份数据（兼容新旧格式）
        async function importBackupData(data) {
            const startTime = Date.now();

            try {
                // 检测数据格式版本
                const isOptimizedFormat = data._optimizedStorage === true;
                const exportVersion = data._exportVersion || '1.0';

                console.log(`检测到数据格式版本: ${exportVersion}, 优化存储: ${isOptimizedFormat}`);

                // 清空现有数据
                await dataStorage.clearAll();

                // 重建数据库结构（修复：确保 personaPresets 被导入）
                db = {
                    apiSettings: data.apiSettings || {},
                    wallpaper: data.wallpaper || 'https://i.postimg.cc/W4Z9R9x4/ins-1.jpg',
                    // characters: [],
                    // groups: [],
                    myStickers: data.myStickers || [],
                    homeScreenMode: data.homeScreenMode || 'night',
                    worldBooks: data.worldBooks || [],
                    fontUrl: data.fontUrl || '',
                    customIcons: data.customIcons || {},
                    personaPresets: data.personaPresets || []
                };

                let importStats = {
                    charactersCount: 0,
                    groupsCount: 0,
                    messagesCount: 0,
                    personaPresetsCount: 0
                };

                // 导入角色数据
                if (data.characters && Array.isArray(data.characters)) {
                    console.log(`开始导入 ${data.characters.length} 个角色`);
                    for (const char of data.characters) {
                        // 保存角色基础信息
                        const { history, ...charData } = char;
                        charData.history = []; // 保持兼容性

                        // 设置默认值
                        if (charData.isPinned === undefined) charData.isPinned = false;
                        if (charData.status === undefined) charData.status = '在线';
                        if (!charData.worldBookIds) charData.worldBookIds = [];
                        if (charData.customBubbleCss === undefined) charData.customBubbleCss = '';
                        if (charData.useCustomBubbleCss === undefined) charData.useCustomBubbleCss = false;

                        // db.characters.push(charData);
                        await dataStorage.saveData(`character_${char.id}`, charData);

                        // 保存消息历史
                        if (history && Array.isArray(history) && history.length > 0) {
                            console.log(`角色 ${charData.remarkName || charData.name} 有 ${history.length} 条消息`);
                            await dataStorage.saveChatMessages(char.id, 'private', history);
                            importStats.messagesCount += history.length;
                        } else {
                            console.log(`角色 ${charData.remarkName || charData.name} 没有消息历史`);
                        }

                        importStats.charactersCount++;
                    }
                } else {
                    console.log('没有找到角色数据或格式不正确');
                }

                // 导入群组数据
                if (data.groups && Array.isArray(data.groups)) {
                    console.log(`开始导入 ${data.groups.length} 个群组`);
                    for (const group of data.groups) {
                        // 保存群组基础信息
                        const { history, ...groupData } = group;
                        groupData.history = []; // 保持兼容性

                        // 设置默认值
                        if (groupData.isPinned === undefined) groupData.isPinned = false;
                        if (!groupData.worldBookIds) groupData.worldBookIds = [];
                        if (groupData.customBubbleCss === undefined) groupData.customBubbleCss = '';
                        if (groupData.useCustomBubbleCss === undefined) groupData.useCustomBubbleCss = false;

                        // db.groups.push(groupData);
                        await dataStorage.saveData(`group_${group.id}`, groupData);

                        // 保存消息历史
                        if (history && Array.isArray(history) && history.length > 0) {
                            console.log(`群组 ${groupData.name} 有 ${history.length} 条消息`);
                            await dataStorage.saveChatMessages(group.id, 'group', history);
                            importStats.messagesCount += history.length;
                        } else {
                            console.log(`群组 ${groupData.name} 没有消息历史`);
                        }

                        importStats.groupsCount++;
                    }
                } else {
                    console.log('没有找到群组数据或格式不正确');
                }

                for (const key in db){
                    await dataStorage.saveData(key, db[key]);
                }

                // if(data.apiSettings){
                //     await dataStorage.saveData('apiSettings', data.apiSettings);
                // }
                // if(data.customIcons){
                //     await dataStorage.saveData('customIcons', data.customIcons);
                // }
                // if(data.fontUrl){
                //     await dataStorage.saveData('fontUrl', data.fontUrl);
                // }
                // if(data.homeScreenMode){
                //     await dataStorage.saveData('homeScreenMode', data.homeScreenMode);
                // }
                // if(data.wallpaper){
                //     await dataStorage.saveData('wallpaper', data.wallpaper);
                // }

                // console.log(data)
                // console.log(db)

                // 保存基础数据
                await dataStorage.saveData('章鱼喷墨机', db);

                // 【修复】重新加载角色和群组数据，确保history被正确加载
                db.characters = [];
                db.groups = [];

                // 获取所有存储的键，找出角色和群组数据
                const allKeys = await dataStorage.getAllKeys();
                const characterKeys = allKeys.filter(key => key.startsWith('character_'));
                const groupKeys = allKeys.filter(key => key.startsWith('group_'));

                // 加载角色数据（包含消息历史）
                const characterPromises = characterKeys.map(async (key) => {
                    const charId = key.replace('character_', '');
                    const charData = await dataStorage.getData(key);
                    if (charData) {
                        // 加载消息历史
                        charData.history = await dataStorage.getChatMessages(charId, 'private');
                        return charData;
                    }
                    return null;
                });

                // 加载群组数据（包含消息历史）
                const groupPromises = groupKeys.map(async (key) => {
                    const groupId = key.replace('group_', '');
                    const groupData = await dataStorage.getData(key);
                    if (groupData) {
                        // 加载消息历史
                        groupData.history = await dataStorage.getChatMessages(groupId, 'group');
                        return groupData;
                    }
                    return null;
                });

                // 等待所有数据加载完成
                const [loadedCharacters, loadedGroups] = await Promise.all([
                    Promise.all(characterPromises),
                    Promise.all(groupPromises)
                ]);

                // 过滤掉null值并赋值给db
                db.characters = loadedCharacters.filter(char => char !== null);
                db.groups = loadedGroups.filter(group => group !== null);

                // 统计人设预设数量
                importStats.personaPresetsCount = db.personaPresets ? db.personaPresets.length : 0;

                const duration = Date.now() - startTime;
                const message = `导入完成: ${importStats.charactersCount}个角色, ${importStats.groupsCount}个群组, ${importStats.messagesCount}条消息, ${importStats.personaPresetsCount}个人设预设 (耗时${duration}ms)`;



                return {
                    success: true,
                    message: message,
                    stats: importStats,
                    duration: duration
                };

            } catch (error) {
                console.error('导入数据失败:', error);
                return {
                    success: false,
                    error: error.message,
                    duration: Date.now() - startTime
                };
            }
        }

        // 数据完整性验证
        async function validateDataIntegrity() {
            try {
                const issues = [];

                // 检查角色数据完整性
                for (const char of db.characters) {
                    const charData = await dataStorage.getData(`character_${char.id}`);
                    const messages = await dataStorage.getChatMessages(char.id, 'private');

                    if (!charData) {
                        issues.push(`角色 ${char.remarkName} 的基础数据缺失`);
                    }

                    if (char.history && char.history.length > 0 && messages.length === 0) {
                        issues.push(`角色 ${char.remarkName} 的消息历史未正确迁移`);
                    }
                }

                // 检查群组数据完整性
                for (const group of db.groups) {
                    const groupData = await dataStorage.getData(`group_${group.id}`);
                    const messages = await dataStorage.getChatMessages(group.id, 'group');

                    if (!groupData) {
                        issues.push(`群组 ${group.name} 的基础数据缺失`);
                    }

                    if (group.history && group.history.length > 0 && messages.length === 0) {
                        issues.push(`群组 ${group.name} 的消息历史未正确迁移`);
                    }
                }

                return {
                    isValid: issues.length === 0,
                    issues: issues
                };

            } catch (error) {
                return {
                    isValid: false,
                    issues: [`数据完整性验证失败: ${error.message}`]
                };
            }
        }

        // 重写原有的消息操作函数以使用优化存储
        const originalSaveData = saveData;
        window.saveData = async (data) => {
            // 对于频繁的消息操作，使用优化的存储方法
            if (currentChatId && (currentChatType === 'private' || currentChatType === 'group')) {
                const chat = currentChatType === 'private'
                    ? db.characters.find(c => c.id === currentChatId)
                    : db.groups.find(g => g.id === currentChatId);

                if (chat && chat.history) {
                    // 保存消息到优化存储
                    await dataStorage.saveChatMessages(currentChatId, currentChatType, chat.history);
                }
            }

            // 保存其他数据
            return originalSaveData(data);
        };

        // ===== Auto-Summary Functionality =====

        // Default summary prompt
        const DEFAULT_SUMMARY_PROMPT = '请总结以下对话内容，提取关键信息和重要细节：';

        // Token warning toggle event listeners
        document.getElementById('token-warning-enabled').addEventListener('change', async function() {
            document.getElementById('token-warning-options').style.display = this.checked ? 'block' : 'none';
            // Auto-save when toggle changes
            if (currentChatId && currentChatType === 'private') {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    char.tokenWarningEnabled = this.checked;
                    await saveData();
                }
            }
        });
        
        document.getElementById('group-token-warning-enabled').addEventListener('change', async function() {
            document.getElementById('group-token-warning-options').style.display = this.checked ? 'block' : 'none';
            // Auto-save when toggle changes
            if (currentChatId && currentChatType === 'group') {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    group.tokenWarningEnabled = this.checked;
                    await saveData();
                }
            }
        });
        
        // Message count warning toggle event listeners
        document.getElementById('message-count-warning-enabled').addEventListener('change', async function() {
            document.getElementById('message-count-warning-options').style.display = this.checked ? 'block' : 'none';
            // Auto-save when toggle changes
            if (currentChatId && currentChatType === 'private') {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    char.messageCountWarningEnabled = this.checked;
                    await saveData();
                }
            }
        });
        
        document.getElementById('group-message-count-warning-enabled').addEventListener('change', async function() {
            document.getElementById('group-message-count-warning-options').style.display = this.checked ? 'block' : 'none';
            // Auto-save when toggle changes
            if (currentChatId && currentChatType === 'group') {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    group.messageCountWarningEnabled = this.checked;
                    await saveData();
                }
            }
        });
        
        // Token warning threshold change event listeners
        document.getElementById('token-warning-threshold').addEventListener('change', async function() {
            if (currentChatId && currentChatType === 'private') {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    const newThreshold = parseInt(this.value) || 0;
                    // 如果阈值改变，重置已提示记录
                    if (char.tokenWarningThreshold !== newThreshold) {
                        char.lastTokenWarningThreshold = 0;
                    }
                    char.tokenWarningThreshold = newThreshold;
                    await saveData();
                }
            }
        });
        
        document.getElementById('group-token-warning-threshold').addEventListener('change', async function() {
            if (currentChatId && currentChatType === 'group') {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    const newThreshold = parseInt(this.value) || 0;
                    // 如果阈值改变，重置已提示记录
                    if (group.tokenWarningThreshold !== newThreshold) {
                        group.lastTokenWarningThreshold = 0;
                    }
                    group.tokenWarningThreshold = newThreshold;
                    await saveData();
                }
            }
        });
        
        // Message count warning threshold change event listeners
        document.getElementById('message-count-warning-threshold').addEventListener('change', async function() {
            if (currentChatId && currentChatType === 'private') {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    const newThreshold = parseInt(this.value) || 0;
                    // 如果阈值改变，重置已提示记录
                    if (char.messageCountWarningThreshold !== newThreshold) {
                        char.lastMessageCountWarningThreshold = 0;
                    }
                    char.messageCountWarningThreshold = newThreshold;
                    await saveData();
                }
            }
        });
        
        document.getElementById('group-message-count-warning-threshold').addEventListener('change', async function() {
            if (currentChatId && currentChatType === 'group') {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    const newThreshold = parseInt(this.value) || 0;
                    // 如果阈值改变，重置已提示记录
                    if (group.messageCountWarningThreshold !== newThreshold) {
                        group.lastMessageCountWarningThreshold = 0;
                    }
                    group.messageCountWarningThreshold = newThreshold;
                    await saveData();
                }
            }
        });

        // Token详细信息按钮事件监听器
        document.getElementById('view-token-details-btn').addEventListener('click', function() {
            showTokenDetails('private');
        });
        
        document.getElementById('view-group-token-details-btn').addEventListener('click', function() {
            showTokenDetails('group');
        });
        
        document.getElementById('close-token-details-btn').addEventListener('click', function() {
            document.getElementById('token-details-modal').classList.remove('visible');
        });

        // Toggle switch event listeners with auto-save
        document.getElementById('setting-auto-summary-enabled').addEventListener('change', async function() {
            document.getElementById('auto-summary-options').style.display = this.checked ? 'block' : 'none';
            // Auto-save when toggle changes
            if (currentChatId && currentChatType === 'private') {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    char.autoSummaryEnabled = this.checked;
                    await saveData();
                }
            }
        });

        document.getElementById('setting-group-auto-summary-enabled').addEventListener('change', async function() {
            document.getElementById('group-auto-summary-options').style.display = this.checked ? 'block' : 'none';
            // Auto-save when toggle changes
            if (currentChatId && currentChatType === 'group') {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    group.autoSummaryEnabled = this.checked;
                    await saveData();
                }
            }
        });
        
        // Auto-save when count changes
        document.getElementById('setting-auto-summary-count').addEventListener('change', async function() {
            if (currentChatId && currentChatType === 'private') {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    char.autoSummaryCount = this.value;
                    await saveData();
                }
            }
        });
        
        document.getElementById('setting-group-auto-summary-count').addEventListener('change', async function() {
            if (currentChatId && currentChatType === 'group') {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    group.autoSummaryCount = this.value;
                    await saveData();
                }
            }
        });
        
        // Auto-save custom summary prompt
        document.getElementById('custom-summary-prompt').addEventListener('blur', async function() {
            if (currentChatId && currentChatType === 'private') {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    char.customSummaryPrompt = this.value.trim();
                    await saveData();
                }
            }
        });
        
        document.getElementById('group-custom-summary-prompt').addEventListener('blur', async function() {
            if (currentChatId && currentChatType === 'group') {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    group.customSummaryPrompt = this.value.trim();
                    await saveData();
                }
            }
        });
        
        // Reset prompt buttons
        document.getElementById('reset-summary-prompt-btn').addEventListener('click', async function() {
            document.getElementById('custom-summary-prompt').value = DEFAULT_SUMMARY_PROMPT;
            if (currentChatId && currentChatType === 'private') {
                const char = db.characters.find(c => c.id === currentChatId);
                if (char) {
                    char.customSummaryPrompt = DEFAULT_SUMMARY_PROMPT;
                    await saveData();
                    showToast('已重置为默认提示词');
                }
            }
        });
        
        document.getElementById('group-reset-summary-prompt-btn').addEventListener('click', async function() {
            document.getElementById('group-custom-summary-prompt').value = DEFAULT_SUMMARY_PROMPT;
            if (currentChatId && currentChatType === 'group') {
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    group.customSummaryPrompt = DEFAULT_SUMMARY_PROMPT;
                    await saveData();
                    showToast('已重置为默认提示词');
                }
            }
        });
                // Create summary as world book
        async function createMemorySummary(chatId, chatType, messages) {
            if (!messages || messages.length === 0) return;

            const chat = chatType === 'private'
                ? db.characters.find(c => c.id === chatId)
                : db.groups.find(g => g.id === chatId);
            
            if (!chat) return;

            // 检查是否已有关联的总结世界书
            let summaryWorldBookId = chat.summaryWorldBookId;
            let existingWorldBook = summaryWorldBookId ? db.worldBooks.find(wb => wb.id === summaryWorldBookId) : null;
            
            // 如果世界书被删除了，清除引用
            if (summaryWorldBookId && !existingWorldBook) {
                chat.summaryWorldBookId = null;
                summaryWorldBookId = null;
            }

            // 如果是第一次总结，需要让用户命名
            let worldBookName = '';
            if (!summaryWorldBookId) {
                const modal = document.getElementById('memory-summary-name-modal');
                const form = document.getElementById('memory-summary-name-form');
                const input = document.getElementById('memory-summary-name-input');

                input.value = '';
                modal.classList.add('visible');

                const name = await new Promise((resolve) => {
                    const submitHandler = (e) => {
                        e.preventDefault();
                        let name = input.value.trim();
                        if (!name) {
                            const now = new Date();
                            const chatName = chatType === 'private' ? (chat.remarkName || chat.realName) : chat.name;
                            name = `${chatName}的聊天总结`;
                        }
                        modal.classList.remove('visible');
                        form.removeEventListener('submit', submitHandler);
                        document.getElementById('cancel-memory-name-btn').removeEventListener('click', cancelHandler);
                        resolve(name);
                    };

                    const cancelHandler = () => {
                        modal.classList.remove('visible');
                        form.removeEventListener('submit', submitHandler);
                        document.getElementById('cancel-memory-name-btn').removeEventListener('click', cancelHandler);
                        resolve(null);
                    };

                    form.addEventListener('submit', submitHandler);
                    document.getElementById('cancel-memory-name-btn').addEventListener('click', cancelHandler);
                });

                if (!name) return null;
                worldBookName = name;
            }

            // 显示加载提示
            showToast('正在生成总结...');

            // Get custom prompt
            let summaryPrompt = DEFAULT_SUMMARY_PROMPT;
            if (chat && chat.customSummaryPrompt && chat.customSummaryPrompt.trim()) {
                summaryPrompt = chat.customSummaryPrompt.trim();
            }
            
            // 【线下模式】添加场景说明
            if (chat && chat.offlineModeEnabled) {
                summaryPrompt += '\n\n注意：以下内容发生在线下真实场景中，不是网上聊天记录。请按照线下场景的叙事文本方式进行总结。';
            }

            // 获取角色名称
            let userName = '用户';
            let charName = 'AI';
            
            if (chatType === 'private') {
                userName = chat.myName || '用户';
                charName = chat.remarkName || chat.realName || 'AI';
            } else if (chatType === 'group') {
                userName = chat.me ? (chat.me.nickname || '我') : '用户';
                charName = '群成员';
            }

            // 从消息对象中提取实际内容，使用真实名字
            const messageText = messages.map(msg => {
                let senderName = '系统';
                
                if (msg.role === 'user') {
                    senderName = userName;
                } else if (msg.role === 'assistant') {
                    senderName = charName;
                } else if (msg.senderId && chatType === 'group') {
                    // 群聊中查找发送者名字
                    const member = chat.members?.find(m => m.id === msg.senderId);
                    if (member) {
                        senderName = member.nickname || member.name;
                    }
                }
                
                const content = msg.content || '';
                return `[${senderName}]: ${content}`;
            }).join('\n');

            // 调用AI生成总结
            let summaryContent = '';
            try {
                const apiUrl = db.apiSettings?.url;
                const apiKey = db.apiSettings?.key;
                const model = db.apiSettings?.model;
                
                if (!apiUrl || !apiKey || !model) {
                    throw new Error('未找到可用的API配置，请先在设置中配置API');
                }
                
                const systemPrompt = `你是一个专业的对话总结助手。你的任务是总结对话内容，提取关键信息和重要细节。

要求：
1. 用简洁的文字叙述对话中发生的重要事情
2. 保留关键信息、人物关系、情感变化等重要细节
3. 不要简单列出消息，而是用连贯的叙述方式总结
4. 总结中必须使用对话者的真实名字（${userName}、${charName}等），不要用"用户"、"AI"等代称
5. 总结应该让角色能够快速了解之前发生了什么
6. 字数控制在200-500字之间

${summaryPrompt}`;

                const userPrompt = `请总结以下对话内容：\n\n${messageText}`;

                const response = await fetch(`${apiUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: model,
                        messages: [
                            { role: 'system', content: systemPrompt },
                            { role: 'user', content: userPrompt }
                        ],
                        temperature: 0.7
                    })
                });

                if (!response.ok) {
                    throw new Error(`API请求失败: ${response.status}`);
                }

                const data = await response.json();
                summaryContent = data.choices[0].message.content.trim();

            } catch (error) {
                console.error('生成总结失败:', error);
                
                let errorMessage = error.message || '未知错误';
                
                await showCustomAlert(
                    '总结生成失败', 
                    `无法生成总结，请检查API配置。\n\n错误详情：${errorMessage}\n\n建议：\n1. 检查API设置是否正确\n2. 确认API密钥是否有效\n3. 检查网络连接\n4. 确认API服务是否正常`
                );
                
                return null;
            }

            // 检查总结内容是否为空
            if (!summaryContent || summaryContent.trim() === '') {
                await showCustomAlert(
                    '总结生成失败', 
                    `API返回了空的总结内容。\n\n可能的原因：\n1. API响应格式不正确\n2. 模型无法处理该请求\n3. 消息内容过长或过短\n\n请检查API配置或尝试减少消息数量。`
                );
                
                return null;
            }

            // 创建或更新世界书
            try {
                const now = new Date();
                const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')} ${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}`;
                
                if (summaryWorldBookId && existingWorldBook) {
                    // 更新现有世界书，追加新总结
                    existingWorldBook.content += `\n\n---\n## 总结更新 (${timestamp})\n${summaryContent}`;
                    await saveData();
                    showToast('总结已更新到世界书');
                } else {
                    // 创建新世界书
                    const bookId = `wb_summary_${Date.now()}`;
                    const newWorldBook = {
                        id: bookId,
                        name: worldBookName,
                        content: `## 聊天总结 (${timestamp})\n${summaryContent}`,
                        position: 'after',
                        isGlobal: false,
                        groupId: '',
                        isSummaryBook: true // 标记为总结世界书
                    };
                    
                    db.worldBooks.push(newWorldBook);
                    
                    // 关联到角色/群聊
                    chat.summaryWorldBookId = bookId;
                    if (!chat.worldBookIds) chat.worldBookIds = [];
                    if (!chat.worldBookIds.includes(bookId)) {
                        chat.worldBookIds.push(bookId);
                    }
                    
                    await saveData();
                    showToast('总结已保存为世界书');
                }
                
                return { success: true };
            } catch (error) {
                console.error('保存世界书失败:', error);
                showToast('保存失败');
                return null;
            }
        }

        // View memory summary in modal
        function viewMemorySummary(summary) {
            const modal = document.getElementById('memory-summary-view-modal');
            const titleEl = document.getElementById('memory-summary-view-title');
            const timeEl = document.getElementById('memory-summary-view-time');
            const countEl = document.getElementById('memory-summary-view-count');
            const contentEl = document.getElementById('memory-summary-view-content');

            const date = new Date(summary.timestamp);
            const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}:${String(date.getSeconds()).padStart(2, '0')}`;

            titleEl.textContent = summary.name;
            timeEl.textContent = dateStr;
            countEl.textContent = summary.messageCount + ' 条';
            contentEl.value = summary.content;

            modal.classList.add('visible');

            // Set up save button
            const saveBtn = document.getElementById('save-memory-summary-btn');
            saveBtn.onclick = async () => {
                try {
                    const updatedContent = contentEl.value.trim();
                    if (!updatedContent) {
                        showToast('记忆内容不能为空');
                        return;
                    }
                    
                    await dataStorage.db.memorySummaries.update(summary.id, {
                        content: updatedContent
                    });
                    showToast('记忆已更新');
                    
                    // Reload compress memory list if modal is open
                    if (document.getElementById('compress-memory-modal').classList.contains('visible')) {
                        await loadCompressMemoryList(currentCompressChatId, currentCompressChatType);
                    }
                    // Reload delete selection list if modal is open
                    if (document.getElementById('delete-memory-select-modal').classList.contains('visible')) {
                        await loadDeleteSelectionList(currentDeleteSelectChatId, currentDeleteSelectChatType);
                    }
                } catch (error) {
                    console.error('更新记忆失败:', error);
                    showToast('更新失败');
                }
            };

            // Set up delete button
            const deleteBtn = document.getElementById('delete-memory-summary-btn');
            deleteBtn.onclick = async () => {
                if (confirm('确定要删除这条记忆吗？')) {
                    try {
                        await dataStorage.db.memorySummaries.delete(summary.id);
                        modal.classList.remove('visible');
                        showToast('记忆已删除');
                        
                        // Reload compress memory list if modal is open
                        if (document.getElementById('compress-memory-modal').classList.contains('visible')) {
                            await loadCompressMemoryList(currentCompressChatId, currentCompressChatType);
                        }
                        // Reload delete selection list if modal is open
                        if (document.getElementById('delete-memory-select-modal').classList.contains('visible')) {
                            await loadDeleteSelectionList(currentDeleteSelectChatId, currentDeleteSelectChatType);
                        }
                    } catch (error) {
                        console.error('删除记忆失败:', error);
                        showToast('删除失败');
                    }
                }
            };
        }

        // Close memory view modal
        document.getElementById('close-memory-view-btn').addEventListener('click', () => {
            document.getElementById('memory-summary-view-modal').classList.remove('visible');
        });

        // Close modals when clicking overlay
        document.getElementById('memory-summary-name-modal').addEventListener('click', (e) => {
            if (e.target.id === 'memory-summary-name-modal') {
                e.target.classList.remove('visible');
            }
        });

        document.getElementById('memory-summary-view-modal').addEventListener('click', (e) => {
            if (e.target.id === 'memory-summary-view-modal') {
                e.target.classList.remove('visible');
            }
        });
        
        // Manual Summary Functionality
        let currentManualSummaryChatId = null;
        let currentManualSummaryChatType = null;
        
        // Open manual summary modal (for private chat)
        document.getElementById('manual-summary-btn').addEventListener('click', () => {
            currentManualSummaryChatId = currentChatId;
            currentManualSummaryChatType = 'private';
            document.getElementById('manual-summary-modal').classList.add('visible');
        });
        
        // Open manual summary modal (for group chat)
        document.getElementById('group-manual-summary-btn').addEventListener('click', () => {
            currentManualSummaryChatId = currentChatId;
            currentManualSummaryChatType = 'group';
            document.getElementById('manual-summary-modal').classList.add('visible');
        });
        
        // Quick summary (from start to set count)
        document.getElementById('quick-summary-btn').addEventListener('click', async () => {
            let chat = currentManualSummaryChatType === 'private'
                ? db.characters.find(c => c.id === currentManualSummaryChatId)
                : db.groups.find(g => g.id === currentManualSummaryChatId);
            
            if (!chat) {
                showToast('无法找到聊天');
                return;
            }
            
            const count = parseInt(chat.autoSummaryCount);
            if (!count || count <= 0) {
                showToast('请先设置自动总结条数');
                return;
            }
            
            const messages = await dataStorage.getChatMessages(currentManualSummaryChatId, currentManualSummaryChatType);
            if (messages.length === 0) {
                showToast('没有消息可以总结');
                return;
            }
            
            const messagesToSummarize = messages.slice(0, Math.min(count, messages.length));
            document.getElementById('manual-summary-modal').classList.remove('visible');
            
            await createMemorySummary(currentManualSummaryChatId, currentManualSummaryChatType, messagesToSummarize);
            
            // Update last summary index (reuse chat variable)
            chat = currentManualSummaryChatType === 'private'
                ? db.characters.find(c => c.id === currentManualSummaryChatId)
                : db.groups.find(g => g.id === currentManualSummaryChatId);
            if (chat) {
                chat.lastSummaryIndex = messagesToSummarize.length;
                await saveData();
            }
            
            // Remove summarized messages
            const remainingMessages = messages.slice(messagesToSummarize.length);
            await dataStorage.saveChatMessages(currentManualSummaryChatId, currentManualSummaryChatType, remainingMessages);
            
            // Refresh display
            currentPage = 1;
            renderMessages(false, true);
            showToast(`已总结 ${messagesToSummarize.length} 条消息`);
        });
        
        // Custom range summary
        document.getElementById('custom-range-summary-btn').addEventListener('click', () => {
            document.getElementById('manual-summary-modal').classList.remove('visible');
            document.getElementById('custom-range-summary-modal').classList.add('visible');
            document.getElementById('summary-range-input').value = '';
        });
        
        // Handle custom range form submission
        document.getElementById('custom-range-summary-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const rangeInput = document.getElementById('summary-range-input').value.trim();
            const match = rangeInput.match(/^(\d+)-(\d+)$/);
            
            if (!match) {
                showToast('格式错误，请使用"起始-结束"格式，例如：1-20');
                return;
            }
            
            const start = parseInt(match[1]);
            const end = parseInt(match[2]);
            
            if (start < 1 || end < start) {
                showToast('范围无效，起始必须≥1，结束必须≥起始');
                return;
            }
            
            const messages = await dataStorage.getChatMessages(currentManualSummaryChatId, currentManualSummaryChatType);
            
            if (start > messages.length) {
                showToast(`只有 ${messages.length} 条消息，无法从第 ${start} 条开始`);
                return;
            }
            
            const actualEnd = Math.min(end, messages.length);
            const messagesToSummarize = messages.slice(start - 1, actualEnd);
            
            document.getElementById('custom-range-summary-modal').classList.remove('visible');
            
            await createMemorySummary(currentManualSummaryChatId, currentManualSummaryChatType, messagesToSummarize);
            
            // Update last summary index
            const chat = currentManualSummaryChatType === 'private'
                ? db.characters.find(c => c.id === currentManualSummaryChatId)
                : db.groups.find(g => g.id === currentManualSummaryChatId);
            if (chat) {
                chat.lastSummaryIndex = actualEnd;
                await saveData();
            }
            
            // Remove summarized messages
            const remainingMessages = [...messages.slice(0, start - 1), ...messages.slice(actualEnd)];
            await dataStorage.saveChatMessages(currentManualSummaryChatId, currentManualSummaryChatType, remainingMessages);
            
            // Refresh display
            currentPage = 1;
            renderMessages(false, true);
            showToast(`已总结第 ${start}-${actualEnd} 条消息`);
        });
        
        // Cancel buttons
        document.getElementById('cancel-manual-summary-btn').addEventListener('click', () => {
            document.getElementById('manual-summary-modal').classList.remove('visible');
        });
        
        document.getElementById('cancel-range-summary-btn').addEventListener('click', () => {
            document.getElementById('custom-range-summary-modal').classList.remove('visible');
        });
        
        // Close modals when clicking overlay
        document.getElementById('manual-summary-modal').addEventListener('click', (e) => {
            if (e.target.id === 'manual-summary-modal') {
                e.target.classList.remove('visible');
            }
        });
        
        document.getElementById('custom-range-summary-modal').addEventListener('click', (e) => {
            if (e.target.id === 'custom-range-summary-modal') {
                e.target.classList.remove('visible');
            }
        });

        // Memory Library Content Management
        let currentLibraryChatId = null;
        let currentLibraryChatType = null;
        
        // Open memory library modal (private chat)
        document.getElementById('open-memory-library-btn').addEventListener('click', async () => {
            if (!currentChatId) return;
            currentLibraryChatId = currentChatId;
            currentLibraryChatType = 'private';
            await loadMemoryLibraryList(currentChatId, 'private');
            document.getElementById('memory-library-modal').classList.add('visible');
        });
        
        // Open memory library modal (group chat)
        document.getElementById('group-open-memory-library-btn').addEventListener('click', async () => {
            if (!currentChatId) return;
            currentLibraryChatId = currentChatId;
            currentLibraryChatType = 'group';
            await loadMemoryLibraryList(currentChatId, 'group');
            document.getElementById('memory-library-modal').classList.add('visible');
        });
        
        // Load memory library list
        async function loadMemoryLibraryList(chatId, chatType) {
            const listEl = document.getElementById('memory-library-list');
            
            try {
                const summaries = await dataStorage.db.memorySummaries
                    .where('chatId').equals(chatId)
                    .and(s => s.chatType === chatType)
                    .reverse()
                    .sortBy('timestamp');
                
                if (!summaries || summaries.length === 0) {
                    listEl.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">暂无记忆</div>';
                    return;
                }
                
                listEl.innerHTML = '';
                summaries.forEach(summary => {
                    const item = document.createElement('div');
                    item.className = 'memory-summary-item';
                    item.setAttribute('data-summary-id', summary.id);
                    
                    const date = new Date(summary.timestamp);
                    const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
                    
                    item.innerHTML = `
                        <div class="memory-summary-info">
                            <div class="memory-summary-name">${summary.name}</div>
                            <div class="memory-summary-date">${dateStr} · ${summary.messageCount}条消息</div>
                        </div>
                    `;
                    
                    item.addEventListener('click', () => {
                        document.getElementById('memory-library-modal').classList.remove('visible');
                        viewMemorySummary(summary);
                    });
                    listEl.appendChild(item);
                });
            } catch (error) {
                console.error('加载记忆列表失败:', error);
                listEl.innerHTML = '<div style="color: #f44; text-align: center; padding: 20px;">加载失败</div>';
            }
        }
        
        // Close memory library modal
        document.getElementById('close-memory-library-btn').addEventListener('click', () => {
            document.getElementById('memory-library-modal').classList.remove('visible');
        });
        
        // Close modal when clicking overlay
        document.getElementById('memory-library-modal').addEventListener('click', (e) => {
            if (e.target.id === 'memory-library-modal') {
                e.target.classList.remove('visible');
            }
        });
        
        // Memory Delete Management Feature
        let currentDeleteSelectChatId = null;
        let currentDeleteSelectChatType = null;

        // Open delete memory selection modal
        document.getElementById('manage-memory-delete-btn-new').addEventListener('click', async () => {
            if (!currentLibraryChatId || !currentLibraryChatType) return;
            currentDeleteSelectChatId = currentLibraryChatId;
            currentDeleteSelectChatType = currentLibraryChatType;
            await loadDeleteSelectionList(currentDeleteSelectChatId, currentDeleteSelectChatType);
            document.getElementById('delete-memory-select-modal').classList.add('visible');
        });

        // Load memory list for deletion selection
        async function loadDeleteSelectionList(chatId, chatType) {
            const listEl = document.getElementById('delete-memory-list');
            const selectedCountEl = document.getElementById('delete-selected-count');
            
            try {
                const summaries = await dataStorage.db.memorySummaries
                    .where('chatId').equals(chatId)
                    .and(s => s.chatType === chatType)
                    .reverse()
                    .sortBy('timestamp');
                
                if (!summaries || summaries.length === 0) {
                    listEl.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">暂无记忆</div>';
                    return;
                }
                
                listEl.innerHTML = '';
                selectedCountEl.textContent = '0';
                
                summaries.forEach(summary => {
                    const item = document.createElement('div');
                    item.className = 'memory-summary-item';
                    item.style.display = 'flex';
                    item.style.alignItems = 'center';
                    item.style.gap = '10px';
                    item.setAttribute('data-memory-id', summary.id);
                    
                    const date = new Date(summary.timestamp);
                    const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'delete-memory-checkbox';
                    checkbox.setAttribute('data-memory-id', summary.id);
                    checkbox.style.cursor = 'pointer';
                    
                    const info = document.createElement('div');
                    info.className = 'memory-summary-info';
                    info.style.flex = '1';
                    info.style.cursor = 'pointer';
                    info.innerHTML = `
                        <div class="memory-summary-name">${summary.name}</div>
                        <div class="memory-summary-date">${dateStr} · ${summary.messageCount}条消息</div>
                    `;
                    
                    item.appendChild(checkbox);
                    item.appendChild(info);
                    
                    info.addEventListener('click', () => {
                        document.getElementById('delete-memory-select-modal').classList.remove('visible');
                        viewMemorySummary(summary);
                    });
                    
                    checkbox.addEventListener('change', updateDeleteSelectedCount);
                    
                    listEl.appendChild(item);
                });
            } catch (error) {
                console.error('加载记忆列表失败:', error);
                listEl.innerHTML = '<div style="color: #f44; text-align: center; padding: 20px;">加载失败</div>';
            }
        }

        function updateDeleteSelectedCount() {
            const checkboxes = document.querySelectorAll('.delete-memory-checkbox:checked');
            document.getElementById('delete-selected-count').textContent = checkboxes.length;
        }

        document.getElementById('delete-select-all-btn').addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('.delete-memory-checkbox');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            checkboxes.forEach(cb => cb.checked = !allChecked);
            updateDeleteSelectedCount();
        });

        document.getElementById('cancel-delete-btn').addEventListener('click', () => {
            document.getElementById('delete-memory-select-modal').classList.remove('visible');
        });

        document.getElementById('confirm-delete-btn').addEventListener('click', async () => {
            const selectedCheckboxes = document.querySelectorAll('.delete-memory-checkbox:checked');
            if (selectedCheckboxes.length === 0) {
                showToast('请先选择要删除的记忆');
                return;
            }
            if (!confirm(`确定要删除选中的 ${selectedCheckboxes.length} 条记忆吗？此操作不可恢复。`)) {
                return;
            }
            const deleteBtn = document.getElementById('confirm-delete-btn');
            try {
                deleteBtn.disabled = true;
                deleteBtn.textContent = '删除中...';
                const idsToDelete = Array.from(selectedCheckboxes).map(cb => cb.getAttribute('data-memory-id'));
                await dataStorage.db.memorySummaries.bulkDelete(idsToDelete);
                showToast(`已删除 ${idsToDelete.length} 条记忆`);
                await loadDeleteSelectionList(currentDeleteSelectChatId, currentDeleteSelectChatType);
                if (document.getElementById('memory-library-modal').classList.contains('visible')) {
                    await loadMemoryLibraryList(currentDeleteSelectChatId, currentDeleteSelectChatType);
                }
            } catch (error) {
                console.error('删除记忆失败:', error);
                showToast(`删除失败: ${error.message}`);
            } finally {
                deleteBtn.disabled = false;
                deleteBtn.textContent = '删除选中记忆';
            }
        });

        document.getElementById('delete-memory-select-modal').addEventListener('click', (e) => {
            if (e.target.id === 'delete-memory-select-modal') {
                e.target.classList.remove('visible');
            }
        });

        // Memory Compression Feature
        let currentCompressChatId = null;
        let currentCompressChatType = null;
        
        // Open compress memory modal
        document.getElementById('compress-memory-btn').addEventListener('click', async () => {
            if (!currentLibraryChatId || !currentLibraryChatType) return;
            currentCompressChatId = currentLibraryChatId;
            currentCompressChatType = currentLibraryChatType;
            await loadCompressMemoryList(currentCompressChatId, currentCompressChatType);
            document.getElementById('compress-memory-modal').classList.add('visible');
        });
        
        // Load memory list for compression
        async function loadCompressMemoryList(chatId, chatType) {
            const listEl = document.getElementById('compress-memory-list');
            const selectedCountEl = document.getElementById('compress-selected-count');
            
            try {
                const summaries = await dataStorage.db.memorySummaries
                    .where('chatId').equals(chatId)
                    .and(s => s.chatType === chatType)
                    .reverse()
                    .sortBy('timestamp');
                
                if (!summaries || summaries.length === 0) {
                    listEl.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">暂无记忆</div>';
                    return;
                }
                
                if (summaries.length < 2) {
                    listEl.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">至少需要2条记忆才能进行压缩</div>';
                    return;
                }
                
                listEl.innerHTML = '';
                selectedCountEl.textContent = '0';
                
                summaries.forEach(summary => {
                    const item = document.createElement('div');
                    item.className = 'memory-summary-item';
                    item.style.display = 'flex';
                    item.style.alignItems = 'center';
                    item.style.gap = '10px';
                    item.setAttribute('data-memory-id', summary.id);
                    
                    const date = new Date(summary.timestamp);
                    const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'compress-memory-checkbox';
                    checkbox.setAttribute('data-memory-id', summary.id);
                    checkbox.style.cursor = 'pointer';
                    
                    const info = document.createElement('div');
                    info.className = 'memory-summary-info';
                    info.style.flex = '1';
                    info.style.cursor = 'pointer';
                    info.innerHTML = `
                        <div class="memory-summary-name">${summary.name}</div>
                        <div class="memory-summary-date">${dateStr} · ${summary.messageCount}条消息</div>
                    `;
                    
                    item.appendChild(checkbox);
                    item.appendChild(info);
                    
                    // Click on info area to view/edit memory
                    info.addEventListener('click', () => {
                        document.getElementById('compress-memory-modal').classList.remove('visible');
                        viewMemorySummary(summary);
                    });
                    
                    // Checkbox change event
                    checkbox.addEventListener('change', updateCompressSelectedCount);
                    
                    listEl.appendChild(item);
                });
            } catch (error) {
                console.error('加载记忆列表失败:', error);
                listEl.innerHTML = '<div style="color: #f44; text-align: center; padding: 20px;">加载失败</div>';
            }
        }
        
        // Update selected count
        function updateCompressSelectedCount() {
            const checkboxes = document.querySelectorAll('.compress-memory-checkbox:checked');
            document.getElementById('compress-selected-count').textContent = checkboxes.length;
        }
        
        // Select all memories
        document.getElementById('compress-select-all-btn').addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('.compress-memory-checkbox');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            checkboxes.forEach(cb => cb.checked = !allChecked);
            updateCompressSelectedCount();
        });
        
        // Cancel compress
        document.getElementById('cancel-compress-btn').addEventListener('click', () => {
            document.getElementById('compress-memory-modal').classList.remove('visible');
        });
        
        // Close modal when clicking overlay
        document.getElementById('compress-memory-modal').addEventListener('click', (e) => {
            if (e.target.id === 'compress-memory-modal') {
                e.target.classList.remove('visible');
            }
        });
        
        // Confirm compress memories
        document.getElementById('confirm-compress-btn').addEventListener('click', async () => {
            const selectedCheckboxes = document.querySelectorAll('.compress-memory-checkbox:checked');
            
            if (selectedCheckboxes.length < 2) {
                showToast('请至少选择2条记忆进行压缩');
                return;
            }
            
            const keepOriginal = document.getElementById('keep-original-memories').checked;
            const confirmBtn = document.getElementById('confirm-compress-btn');
            
            try {
                confirmBtn.disabled = true;
                confirmBtn.textContent = '压缩中...';
                
                // Get selected memories
                const selectedIds = Array.from(selectedCheckboxes).map(cb => cb.getAttribute('data-memory-id'));
                const selectedMemories = [];
                
                for (const id of selectedIds) {
                    const memory = await dataStorage.db.memorySummaries.get(id);
                    if (memory) selectedMemories.push(memory);
                }
                
                // Compress memories using AI
                const compressedMemory = await compressMemoriesWithAI(selectedMemories);
                
                if (compressedMemory) {
                    // Save compressed memory
                    await dataStorage.db.memorySummaries.add({
                        id: Date.now().toString(),
                        chatId: currentCompressChatId,
                        chatType: currentCompressChatType,
                        name: compressedMemory.name,
                        content: compressedMemory.content,
                        messageCount: selectedMemories.reduce((sum, m) => sum + (m.messageCount || 0), 0),
                        timestamp: Date.now()
                    });
                    
                    // Delete original memories if not keeping
                    if (!keepOriginal) {
                        await dataStorage.db.memorySummaries.bulkDelete(selectedIds);
                    }
                    
                    document.getElementById('compress-memory-modal').classList.remove('visible');
                    showToast(keepOriginal ? '记忆已压缩并保留原记忆' : '记忆已压缩并删除原记忆');
                    
                    // Reload memory library if still open
                    if (document.getElementById('memory-library-modal').classList.contains('visible')) {
                        await loadMemoryLibraryList(currentCompressChatId, currentCompressChatType);
                    }
                }
            } catch (error) {
                console.error('压缩记忆失败:', error);
                showToast(`压缩失败: ${error.message}`);
            } finally {
                confirmBtn.disabled = false;
                confirmBtn.textContent = '开始压缩';
            }
        });
        
        // Compress memories using AI
        async function compressMemoriesWithAI(memories) {
            try {
                // 优先使用副API，如果未配置则使用主API
                let provider, url, key, model;
                
                if (db.secondaryApiSettings && db.secondaryApiSettings.provider && db.secondaryApiSettings.url && db.secondaryApiSettings.key && db.secondaryApiSettings.model) {
                    // 使用副API
                    provider = db.secondaryApiSettings.provider;
                    url = db.secondaryApiSettings.url.trim();
                    key = db.secondaryApiSettings.key.trim();
                    model = db.secondaryApiSettings.model.trim();
                    console.log('使用副API进行记忆压缩');
                } else {
                    // 使用主API
                    provider = db.apiSettings?.provider || document.getElementById('api-provider')?.value;
                    url = db.apiSettings?.url || document.getElementById('api-url')?.value.trim();
                    key = db.apiSettings?.key || document.getElementById('api-key')?.value.trim();
                    model = db.apiSettings?.model || document.getElementById('api-model')?.value.trim();
                    console.log('使用主API进行记忆压缩');
                }
                
                if (!url || !key || !model) {
                    throw new Error('请先配置API设置');
                }
                
                // Build prompt for compression
                const memoriesText = memories.map((m, idx) => {
                    return `### 记忆 ${idx + 1}: ${m.name}\n${m.content}`;
                }).join('\n\n');
                
                const systemPrompt = `你是一个专业的记忆整理助手。你的任务是将多条记忆压缩整合成一条新的记忆。

要求：
1. 保留所有重要信息，不要遗漏关键细节
2. 去除重复内容，合并相似信息
3. 按时间顺序或逻辑关系组织内容
4. 使用简洁清晰的语言
5. 保持客观，不添加不存在的信息

请将以下 ${memories.length} 条记忆整合成一条新记忆：

${memoriesText}

请以JSON格式返回，格式如下：
{
  "name": "压缩记忆的标题（简短概括）",
  "content": "整合后的记忆内容"
}`;

                const requestBody = provider === 'gemini' 
                    ? {
                        contents: [{
                            role: 'user',
                            parts: [{text: systemPrompt}]
                        }],
                        generationConfig: {
                            temperature: 0.7,
                            maxOutputTokens: 4096
                        }
                    }
                    : {
                        model: model,
                        messages: [
                            {role: 'system', content: '你是一个专业的记忆整理助手。'},
                            {role: 'user', content: systemPrompt}
                        ],
                        temperature: 0.7
                    };
                
                const endpoint = provider === 'gemini' 
                    ? `${url}/v1beta/models/${model}:generateContent?key=${getRandomValue(key)}`
                    : `${url}/v1/chat/completions`;
                
                const headers = provider === 'gemini'
                    ? {'Content-Type': 'application/json'}
                    : {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${key}`
                    };
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(requestBody)
                });
                
                if (!response.ok) {
                    throw new Error(`API请求失败: ${response.status}`);
                }
                
                const data = await response.json();
                let resultText = '';
                
                if (provider === 'gemini') {
                    resultText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
                } else {
                    resultText = data.choices?.[0]?.message?.content || '';
                }
                
                if (!resultText) {
                    throw new Error('AI返回内容为空');
                }
                
                // Parse JSON response
                const jsonMatch = resultText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const result = JSON.parse(jsonMatch[0]);
                    return {
                        name: result.name || '压缩记忆',
                        content: result.content || resultText
                    };
                } else {
                    // Fallback if not JSON
                    return {
                        name: '压缩记忆',
                        content: resultText
                    };
                }
            } catch (error) {
                console.error('AI压缩记忆失败:', error);
                throw error;
            }
        }
        
        // Memory Delete Management
        let currentDeleteChatId = null;
        let currentDeleteChatType = null;
        
        // Open delete modal (private chat)
        document.getElementById('manage-memory-delete-btn').addEventListener('click', async () => {
            if (!currentChatId) return;
            currentDeleteChatId = currentChatId;
            currentDeleteChatType = 'private';
            await loadMemoryDeleteList(currentChatId, 'private');
            document.getElementById('delete-memory-summaries-modal').classList.add('visible');
        });
        
        // Open delete modal (group chat)
        document.getElementById('group-manage-memory-delete-btn').addEventListener('click', async () => {
            if (!currentChatId) return;
            currentDeleteChatId = currentChatId;
            currentDeleteChatType = 'group';
            await loadMemoryDeleteList(currentChatId, 'group');
            document.getElementById('delete-memory-summaries-modal').classList.add('visible');
        });
        
        // Load memory list for deletion
        async function loadMemoryDeleteList(chatId, chatType) {
            const listEl = document.getElementById('memory-delete-list');
            const selectAllCheckbox = document.getElementById('memory-select-all');
            const selectedCountEl = document.getElementById('memory-selected-count');
            
            try {
                const summaries = await dataStorage.db.memorySummaries
                    .where('chatId').equals(chatId)
                    .and(s => s.chatType === chatType)
                    .reverse()
                    .sortBy('timestamp');
                
                if (!summaries || summaries.length === 0) {
                    listEl.innerHTML = '<div style="color: #999; text-align: center; padding: 20px;">暂无记忆</div>';
                    selectAllCheckbox.checked = false;
                    selectedCountEl.textContent = '已选择 0 项';
                    return;
                }
                
                listEl.innerHTML = '';
                summaries.forEach(summary => {
                    const date = new Date(summary.timestamp);
                    const dateStr = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
                    
                    const item = document.createElement('div');
                    item.style.cssText = 'padding: 10px; border-bottom: 1px solid #eee; display: flex; align-items: center;';
                    item.innerHTML = `
                        <input type="checkbox" class="memory-delete-checkbox" data-memory-id="${summary.id}" style="margin-right: 10px; width: 18px; height: 18px; cursor: pointer;">
                        <div style="flex: 1;">
                            <div style="font-weight: 500; margin-bottom: 4px;">${summary.name}</div>
                            <div style="font-size: 12px; color: #888;">${dateStr} · ${summary.messageCount}条消息</div>
                        </div>
                    `;
                    listEl.appendChild(item);
                });
                
                // Update count when checkboxes change
                const updateCount = () => {
                    const checked = listEl.querySelectorAll('.memory-delete-checkbox:checked').length;
                    const total = listEl.querySelectorAll('.memory-delete-checkbox').length;
                    selectedCountEl.textContent = `已选择 ${checked} 项`;
                    selectAllCheckbox.checked = checked === total && total > 0;
                };
                
                listEl.querySelectorAll('.memory-delete-checkbox').forEach(cb => {
                    cb.addEventListener('change', updateCount);
                });
                
                selectAllCheckbox.checked = false;
                selectedCountEl.textContent = '已选择 0 项';
            } catch (error) {
                console.error('加载记忆列表失败:', error);
                listEl.innerHTML = '<div style="color: #f44; text-align: center; padding: 20px;">加载失败</div>';
            }
        }
        
        // Select all checkbox
        document.getElementById('memory-select-all').addEventListener('change', function() {
            const checkboxes = document.querySelectorAll('.memory-delete-checkbox');
            checkboxes.forEach(cb => cb.checked = this.checked);
            const count = this.checked ? checkboxes.length : 0;
            document.getElementById('memory-selected-count').textContent = `已选择 ${count} 项`;
        });
        
        // Confirm delete selected memories
        document.getElementById('confirm-delete-memories-btn').addEventListener('click', async () => {
            const selectedCheckboxes = document.querySelectorAll('.memory-delete-checkbox:checked');
            if (selectedCheckboxes.length === 0) {
                showToast('请至少选择一项');
                return;
            }
            
            if (!confirm(`确定要删除 ${selectedCheckboxes.length} 条记忆吗？`)) {
                return;
            }
            
            try {
                const idsToDelete = Array.from(selectedCheckboxes).map(cb => cb.getAttribute('data-memory-id'));
                await dataStorage.db.memorySummaries.bulkDelete(idsToDelete);
                
                document.getElementById('delete-memory-summaries-modal').classList.remove('visible');
                showToast(`已删除 ${idsToDelete.length} 条记忆`);
            } catch (error) {
                console.error('删除记忆失败:', error);
                showToast('删除失败');
            }
        });
        
        // Cancel delete
        document.getElementById('cancel-delete-memories-btn').addEventListener('click', () => {
            document.getElementById('delete-memory-summaries-modal').classList.remove('visible');
        });
        
        // Close delete modal when clicking overlay
        document.getElementById('delete-memory-summaries-modal').addEventListener('click', (e) => {
            if (e.target.id === 'delete-memory-summaries-modal') {
                e.target.classList.remove('visible');
            }
        });

        // Check and trigger auto-summary when sending messages
        async function checkAutoSummary(chatId, chatType) {
            const chat = chatType === 'private'
                ? db.characters.find(c => c.id === chatId)
                : db.groups.find(g => g.id === chatId);

            if (!chat || !chat.autoSummaryEnabled) return;
            
            const messages = await dataStorage.getChatMessages(chatId, chatType);
            const triggerCount = parseInt(chat.autoSummaryCount);
            
            if (!triggerCount || triggerCount <= 0) return;

            // 检查是否达到触发点（100、200、300...）
            // 只有当消息数量正好是triggerCount的整数倍时才触发
            if (messages.length % triggerCount === 0 && messages.length > 0) {
                // 初始化已总结记录
                if (!chat.autoSummarizedFloors) {
                    chat.autoSummarizedFloors = [];
                }
                
                // 检查当前楼层是否已经总结过
                const currentFloor = messages.length;
                if (chat.autoSummarizedFloors.includes(currentFloor)) {
                    // 已经总结过这个楼层，不再提示
                    return;
                }
                
                // 计算这是第几次总结
                const summaryRound = messages.length / triggerCount;
                
                // 如果是第二次及以后的总结，询问用户是否要包含之前的总结
                let startIndex = 0;
                if (summaryRound > 1) {
                    const includePrevious = await showCustomConfirm(
                        '自动总结',
                        `当前已有 ${messages.length} 条消息。\n\n是否要包含之前已总结的 ${(summaryRound - 1) * triggerCount} 条消息一起总结？\n\n点击"确定"：总结全部 ${messages.length} 条消息\n点击"取消"：只总结最近的 ${triggerCount} 条消息（第 ${(summaryRound - 1) * triggerCount + 1}-${messages.length} 楼）`
                    );
                    
                    if (!includePrevious) {
                        // 只总结最近的triggerCount条消息
                        startIndex = messages.length - triggerCount;
                    }
                }
                
                const messagesToSummarize = messages.slice(startIndex);
                
                // 创建总结（这会弹出命名窗口）
                const summary = await createMemorySummary(chatId, chatType, messagesToSummarize);
                
                // 只有在用户确认创建总结后才显示提示和记录
                if (summary) {
                    // 记录已总结的楼层
                    chat.autoSummarizedFloors.push(currentFloor);
                    
                    // Update last summary index
                    chat.lastSummaryIndex = messages.length;
                    
                    await saveData();
                    
                    const summarizedCount = messagesToSummarize.length;
                    if (startIndex > 0) {
                        showToast(`已自动总结第 ${startIndex + 1}-${messages.length} 楼（共 ${summarizedCount} 条消息）`);
                    } else {
                        showToast(`已自动总结前 ${summarizedCount} 条消息`);
                    }
                }
            }
        }


        // ============ 页面动态效果功能 ============
        let currentEffect = null;
        let effectInterval = null;
        
        // 创建雪花效果
        function createSnowEffect(duration, speed, color) {
            stopPageEffect();
            const container = document.getElementById('page-effect-container');
            container.innerHTML = '';
            
            const snowflakeCount = 50;
            const snowflakes = [];
            
            for (let i = 0; i < snowflakeCount; i++) {
                const snowflake = document.createElement('div');
                snowflake.className = 'snowflake';
                snowflake.textContent = '❄';
                snowflake.style.left = Math.random() * 100 + '%';
                snowflake.style.fontSize = (Math.random() * 0.5 + 0.5) + 'em';
                snowflake.style.animationDuration = speed + 's';
                snowflake.style.animationDelay = Math.random() * speed + 's';
                snowflake.style.color = color;
                container.appendChild(snowflake);
                snowflakes.push(snowflake);
            }
            
            currentEffect = 'snow';
            
            if (duration > 0) {
                effectInterval = setTimeout(() => {
                    stopPageEffect();
                }, duration * 1000);
            }
        }
        
        // 创建自定义效果
        function createCustomEffect(code, duration, speed) {
            stopPageEffect();
            const container = document.getElementById('page-effect-container');
            container.innerHTML = '';
            
            try {
                // 在代码中可以使用 container 和 speed 变量
                eval(code);
                currentEffect = 'custom';
                
                if (duration > 0) {
                    effectInterval = setTimeout(() => {
                        stopPageEffect();
                    }, duration * 1000);
                }
            } catch (error) {
                console.error('自定义效果执行失败:', error);
                showToast('自定义效果执行失败');
            }
        }
        
        // 停止页面效果
        function stopPageEffect() {
            const container = document.getElementById('page-effect-container');
            container.innerHTML = '';
            currentEffect = null;
            if (effectInterval) {
                clearTimeout(effectInterval);
                effectInterval = null;
            }
        }
        
        // 加载页面动态效果设置
        function loadPageEffectSettings() {
            const effects = db.pageEffects || {};
            
            // 加载时间显示设置
            document.getElementById('show-seconds-toggle').checked = db.showSecondsInTime || false;
            document.getElementById('custom-time-format-input').value = db.customTimeFormat || '{HH}:{MM}:{SS}';
            // 根据开关状态显示/隐藏自定义格式输入框
            document.getElementById('custom-time-format-section').style.display = db.showSecondsInTime ? 'block' : 'none';
            
            // 加载总开关状态
            document.getElementById('page-effect-master-toggle').checked = effects.masterEnabled || false;
            document.getElementById('page-effect-details').style.display = effects.masterEnabled ? 'block' : 'none';
            
            document.getElementById('snow-effect-toggle').checked = effects.snowEnabled || false;
            document.getElementById('snow-auto-trigger-toggle').checked = effects.snowAutoTrigger || false;
            document.getElementById('snow-duration-input').value = effects.snowDuration || 30;
            document.getElementById('snow-speed-input').value = effects.snowSpeed || 3;
            document.getElementById('snow-color-input').value = effects.snowColor || '#ffffff';
            document.getElementById('snow-color-picker').value = effects.snowColor || '#ffffff';
            
            document.getElementById('custom-effect-input').value = effects.customEffect || '';
            document.getElementById('custom-auto-trigger-toggle').checked = effects.customAutoTrigger || false;
            document.getElementById('custom-duration-input').value = effects.customDuration || 30;
            document.getElementById('custom-speed-input').value = effects.customSpeed || 3;
            
            // 控制设置区域显示
            document.getElementById('snow-effect-settings').style.display = effects.snowEnabled ? 'block' : 'none';
            
            // 渲染预设列表
            renderEffectPresets();
        }
        
        // 渲染动态预设列表
        function renderEffectPresets() {
            const select = document.getElementById('effect-preset-select');
            select.innerHTML = '<option value="">选择预设...</option>';
            
            if (db.effectPresets && db.effectPresets.length > 0) {
                db.effectPresets.forEach(preset => {
                    const option = document.createElement('option');
                    option.value = preset.id;
                    option.textContent = preset.name;
                    select.appendChild(option);
                });
            }
        }
        
        // 保存页面动态效果设置
        async function savePageEffectSettings() {
            db.pageEffects = {
                masterEnabled: document.getElementById('page-effect-master-toggle').checked,
                snowEnabled: document.getElementById('snow-effect-toggle').checked,
                snowAutoTrigger: document.getElementById('snow-auto-trigger-toggle').checked,
                snowDuration: parseInt(document.getElementById('snow-duration-input').value) || 30,
                snowSpeed: parseFloat(document.getElementById('snow-speed-input').value) || 3,
                snowColor: document.getElementById('snow-color-input').value || '#ffffff',
                customEffect: document.getElementById('custom-effect-input').value || '',
                customAutoTrigger: document.getElementById('custom-auto-trigger-toggle').checked,
                customDuration: parseInt(document.getElementById('custom-duration-input').value) || 30,
                customSpeed: parseFloat(document.getElementById('custom-speed-input').value) || 3
            };
            
            await saveData();
        }
        
        // 时间显示设置事件监听器
        document.getElementById('show-seconds-toggle').addEventListener('change', async (e) => {
            db.showSecondsInTime = e.target.checked;
            // 显示或隐藏自定义格式输入框
            document.getElementById('custom-time-format-section').style.display = e.target.checked ? 'block' : 'none';
            await saveData();
            // 重新渲染消息以更新时间显示
            if (currentChatId) {
                renderMessages(false, false);
            }
            showToast(e.target.checked ? '已开启时分秒显示' : '已关闭时分秒显示');
        });
        
        // 自定义时间格式输入框事件监听器
        document.getElementById('custom-time-format-input').addEventListener('input', async (e) => {
            db.customTimeFormat = e.target.value || '{HH}:{MM}:{SS}';
            await saveData();
            // 重新渲染消息以更新时间显示
            if (currentChatId && db.showSecondsInTime) {
                renderMessages(false, false);
            }
        });
        
        // 重置时间格式按钮
        document.getElementById('reset-time-format-btn').addEventListener('click', async () => {
            const defaultFormat = '{HH}:{MM}:{SS}';
            document.getElementById('custom-time-format-input').value = defaultFormat;
            db.customTimeFormat = defaultFormat;
            await saveData();
            // 重新渲染消息以更新时间显示
            if (currentChatId && db.showSecondsInTime) {
                renderMessages(false, false);
            }
            showToast('已重置为默认格式');
        });
        
        // 页面动态效果事件监听器
        
        // 总开关
        document.getElementById('page-effect-master-toggle').addEventListener('change', (e) => {
            document.getElementById('page-effect-details').style.display = e.target.checked ? 'block' : 'none';
        });
        
        // 下雪效果开关
        document.getElementById('snow-effect-toggle').addEventListener('change', (e) => {
            document.getElementById('snow-effect-settings').style.display = e.target.checked ? 'block' : 'none';
        });
        
        // 雪花颜色选择器同步
        document.getElementById('snow-color-picker').addEventListener('input', (e) => {
            document.getElementById('snow-color-input').value = e.target.value;
        });
        
        document.getElementById('snow-color-input').addEventListener('input', (e) => {
            const color = e.target.value;
            if (/^#[0-9A-Fa-f]{6}$/.test(color)) {
                document.getElementById('snow-color-picker').value = color;
            }
        });
        
        // 预设颜色点击
        document.querySelectorAll('.snow-color-preset').forEach(preset => {
            preset.addEventListener('click', () => {
                const color = preset.dataset.color;
                document.getElementById('snow-color-input').value = color;
                document.getElementById('snow-color-picker').value = color;
                
                // 更新选中状态
                document.querySelectorAll('.snow-color-preset').forEach(p => p.classList.remove('selected'));
                preset.classList.add('selected');
            });
        });
        
        // 应用页面动态效果
        document.getElementById('apply-page-effect-btn').addEventListener('click', async () => {
            await savePageEffectSettings();
            
            stopPageEffect();
            
            const effects = db.pageEffects;
            
            if (effects.snowEnabled) {
                createSnowEffect(effects.snowDuration, effects.snowSpeed, effects.snowColor);
                showToast('已应用下雪效果');
            } else if (effects.customEffect) {
                createCustomEffect(effects.customEffect, effects.customDuration, effects.customSpeed);
                showToast('已应用自定义效果');
            } else {
                showToast('请先开启一个效果');
            }
        });
        
        // 重置页面动态效果
        document.getElementById('reset-page-effect-btn').addEventListener('click', async () => {
            stopPageEffect();
            
            db.pageEffects = {
                masterEnabled: false,
                snowEnabled: false,
                snowAutoTrigger: false,
                snowDuration: 30,
                snowSpeed: 3,
                snowColor: '#ffffff',
                customEffect: '',
                customAutoTrigger: false,
                customDuration: 30,
                customSpeed: 3
            };
            
            await saveData();
            loadPageEffectSettings();
            showToast('页面动态效果已重置');
        });
        
        // 预览页面动态效果
        document.getElementById('preview-page-effect-btn').addEventListener('click', () => {
            const snowEnabled = document.getElementById('snow-effect-toggle').checked;
            const customEffect = document.getElementById('custom-effect-input').value;
            
            if (snowEnabled) {
                const duration = parseInt(document.getElementById('snow-duration-input').value) || 30;
                const speed = parseFloat(document.getElementById('snow-speed-input').value) || 3;
                const color = document.getElementById('snow-color-input').value || '#ffffff';
                createSnowEffect(duration, speed, color);
                showToast('预览下雪效果中...');
            } else if (customEffect) {
                const duration = parseInt(document.getElementById('custom-duration-input').value) || 30;
                const speed = parseFloat(document.getElementById('custom-speed-input').value) || 3;
                createCustomEffect(customEffect, duration, speed);
                showToast('预览自定义效果中...');
            } else {
                showToast('请先开启一个效果或输入自定义代码');
            }
        });
        
        // 保存动态预设
        document.getElementById('save-effect-preset-btn').addEventListener('click', async () => {
            const name = prompt('请输入预设名称:');
            if (!name) return;
            
            const preset = {
                id: Date.now().toString(),
                name: name,
                snowEnabled: document.getElementById('snow-effect-toggle').checked,
                snowAutoTrigger: document.getElementById('snow-auto-trigger-toggle').checked,
                snowDuration: parseInt(document.getElementById('snow-duration-input').value) || 30,
                snowSpeed: parseFloat(document.getElementById('snow-speed-input').value) || 3,
                snowColor: document.getElementById('snow-color-input').value || '#ffffff',
                customEffect: document.getElementById('custom-effect-input').value || '',
                customAutoTrigger: document.getElementById('custom-auto-trigger-toggle').checked,
                customDuration: parseInt(document.getElementById('custom-duration-input').value) || 30,
                customSpeed: parseFloat(document.getElementById('custom-speed-input').value) || 3
            };
            
            if (!db.effectPresets) {
                db.effectPresets = [];
            }
            
            db.effectPresets.push(preset);
            await saveData();
            renderEffectPresets();
            showToast('预设已保存');
        });
        
        // 删除动态预设
        document.getElementById('delete-effect-preset-btn').addEventListener('click', async () => {
            const select = document.getElementById('effect-preset-select');
            const presetId = select.value;
            
            if (!presetId) {
                showToast('请先选择一个预设');
                return;
            }
            
            if (!confirm('确定要删除这个预设吗？')) {
                return;
            }
            
            db.effectPresets = db.effectPresets.filter(p => p.id !== presetId);
            await saveData();
            renderEffectPresets();
            showToast('预设已删除');
        });
        
        // 选择动态预设
        document.getElementById('effect-preset-select').addEventListener('change', (e) => {
            const presetId = e.target.value;
            if (!presetId) return;
            
            const preset = db.effectPresets.find(p => p.id === presetId);
            if (!preset) return;
            
            document.getElementById('snow-effect-toggle').checked = preset.snowEnabled;
            document.getElementById('snow-auto-trigger-toggle').checked = preset.snowAutoTrigger;
            document.getElementById('snow-duration-input').value = preset.snowDuration;
            document.getElementById('snow-speed-input').value = preset.snowSpeed;
            document.getElementById('snow-color-input').value = preset.snowColor;
            document.getElementById('snow-color-picker').value = preset.snowColor;
            
            document.getElementById('custom-effect-input').value = preset.customEffect;
            document.getElementById('custom-auto-trigger-toggle').checked = preset.customAutoTrigger;
            document.getElementById('custom-duration-input').value = preset.customDuration;
            document.getElementById('custom-speed-input').value = preset.customSpeed;
            
            document.getElementById('snow-effect-settings').style.display = preset.snowEnabled ? 'block' : 'none';
            
            showToast(`已加载预设：${preset.name}`);
        });
        
        // 页面加载时自动触发效果
        function autoTriggerPageEffects() {
            const effects = db.pageEffects || {};
            
            if (effects.snowEnabled && effects.snowAutoTrigger) {
                createSnowEffect(effects.snowDuration, effects.snowSpeed, effects.snowColor);
            } else if (effects.customEffect && effects.customAutoTrigger) {
                createCustomEffect(effects.customEffect, effects.customDuration, effects.customSpeed);
            }
        }
        
        // 在init函数中调用加载设置和自动触发
        setTimeout(() => {
            loadPageEffectSettings();
            autoTriggerPageEffects();
        }, 1000);
        
        // === 心声功能事件监听器 ===
        document.getElementById('inner-thought-btn').addEventListener('click', showInnerThoughtModal);
        document.getElementById('close-inner-thought-btn').addEventListener('click', () => {
            document.getElementById('inner-thought-modal').classList.remove('visible');
        });
        document.getElementById('inner-thought-history-btn').addEventListener('click', toggleInnerThoughtHistory);
        document.getElementById('inner-thought-edit-btn').addEventListener('click', enterInnerThoughtEditMode);
        document.getElementById('save-inner-thought-btn').addEventListener('click', saveInnerThoughtEdits);
        document.getElementById('cancel-inner-thought-edit-btn').addEventListener('click', cancelInnerThoughtEdit);
        document.getElementById('inner-thought-delete-mode-btn').addEventListener('click', enterInnerThoughtDeleteMode);
        document.getElementById('inner-thought-select-all-btn').addEventListener('click', toggleSelectAll);
        document.getElementById('confirm-delete-inner-thought-btn').addEventListener('click', confirmDeleteInnerThoughts);
        document.getElementById('cancel-delete-inner-thought-btn').addEventListener('click', exitInnerThoughtDeleteMode);
        
        // === 音乐播放器事件监听器 ===
        document.getElementById('listen-together-btn').addEventListener('click', handleListenTogetherClick);
        document.getElementById('music-exit-btn').addEventListener('click', () => endListenTogetherSession(true));
        document.getElementById('music-return-btn').addEventListener('click', returnToChat);
        document.getElementById('music-play-pause-btn').addEventListener('click', togglePlayPause);
        document.getElementById('music-prev-btn').addEventListener('click', playPrev);
        document.getElementById('music-next-btn').addEventListener('click', playNext);
        document.getElementById('music-mode-btn').addEventListener('click', changePlayMode);
        document.getElementById('music-playlist-btn').addEventListener('click', () => {
            // 同步数据库中的播放列表到musicState
            if (db.musicPlaylist && db.musicPlaylist.length > 0) {
                musicState.playlist = db.musicPlaylist;
            }
            updatePlaylistUI();
            document.getElementById('music-playlist-panel').classList.add('visible');
        });
        document.getElementById('close-playlist-btn').addEventListener('click', () => {
            document.getElementById('music-playlist-panel').classList.remove('visible');
            // 退出管理模式
            if (playlistManageMode) {
                togglePlaylistManageMode();
            }
        });
        
        // 管理按钮 - 打开管理弹窗
        document.getElementById('manage-playlist-btn').addEventListener('click', () => {
            // 进入管理模式
            if (!playlistManageMode) {
                playlistManageMode = true;
                updatePlaylistUI();
            }
            // 更新选中计数显示
            updateManageSelectedCount();
            // 打开弹窗
            document.getElementById('playlist-manage-modal').classList.add('show');
        });
        
        // 关闭管理弹窗
        document.getElementById('close-manage-modal').addEventListener('click', () => {
            document.getElementById('playlist-manage-modal').classList.remove('show');
            // 退出管理模式
            if (playlistManageMode) {
                playlistManageMode = false;
                selectedPlaylistItems.clear();
                updatePlaylistUI();
            }
        });
        
        // 管理弹窗背景点击关闭
        document.getElementById('playlist-manage-modal').addEventListener('click', (e) => {
            if (e.target.id === 'playlist-manage-modal') {
                document.getElementById('close-manage-modal').click();
            }
        });
        
        // 播放列表管理弹窗拖动功能
        (() => {
            const modal = document.getElementById('playlist-manage-modal');
            const modalContent = modal.querySelector('.modal-content-wrapper');
            const dragHandle = modal.querySelector('.modal-header-drag-handle');
            
            let isDragging = false;
            let startX, startY;
            let initialX, initialY;
            
            // 获取当前位置
            function getCurrentPosition() {
                const rect = modalContent.getBoundingClientRect();
                return {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };
            }
            
            // 设置位置
            function setPosition(x, y) {
                const rect = modalContent.getBoundingClientRect();
                const modalRect = modal.getBoundingClientRect();
                
                // 限制在视口内
                const minX = rect.width / 2;
                const maxX = modalRect.width - rect.width / 2;
                const minY = rect.height / 2;
                const maxY = modalRect.height - rect.height / 2;
                
                x = Math.max(minX, Math.min(maxX, x));
                y = Math.max(minY, Math.min(maxY, y));
                
                modalContent.style.left = x + 'px';
                modalContent.style.top = y + 'px';
                modalContent.style.transform = 'translate(-50%, -50%)';
            }
            
            // 鼠标/触摸开始
            function handleStart(e) {
                const target = e.target;
                // 只允许从拖动手柄开始拖动
                if (!dragHandle.contains(target)) return;
                
                isDragging = true;
                modalContent.classList.add('dragging');
                
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                
                startX = clientX;
                startY = clientY;
                
                const pos = getCurrentPosition();
                initialX = pos.x;
                initialY = pos.y;
                
                e.preventDefault();
            }
            
            // 鼠标/触摸移动
            function handleMove(e) {
                if (!isDragging) return;
                
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                
                const deltaX = clientX - startX;
                const deltaY = clientY - startY;
                
                setPosition(initialX + deltaX, initialY + deltaY);
                
                e.preventDefault();
            }
            
            // 鼠标/触摸结束
            function handleEnd(e) {
                if (!isDragging) return;
                
                isDragging = false;
                modalContent.classList.remove('dragging');
                
                e.preventDefault();
            }
            
            // 添加事件监听器
            // 鼠标事件
            dragHandle.addEventListener('mousedown', handleStart);
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('mouseup', handleEnd);
            
            // 触摸事件
            dragHandle.addEventListener('touchstart', handleStart, { passive: false });
            document.addEventListener('touchmove', handleMove, { passive: false });
            document.addEventListener('touchend', handleEnd, { passive: false });
            
            // 弹窗打开时重置位置
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                        if (modal.classList.contains('show')) {
                            // 重置到中心位置
                            modalContent.style.left = '50%';
                            modalContent.style.top = '50%';
                            modalContent.style.transform = 'translate(-50%, -50%)';
                        }
                    }
                });
            });
            
            observer.observe(modal, { attributes: true });
        })();
        
        // 时长设置弹窗拖动功能
        (() => {
            const modal = document.getElementById('time-settings-modal');
            const modalContent = modal.querySelector('.modal-content-wrapper');
            const dragHandle = modal.querySelector('.modal-header-drag-handle');
            
            let isDragging = false;
            let startX, startY;
            let initialX, initialY;
            
            // 获取当前位置
            function getCurrentPosition() {
                const rect = modalContent.getBoundingClientRect();
                return {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };
            }
            
            // 设置位置
            function setPosition(x, y) {
                const rect = modalContent.getBoundingClientRect();
                const modalRect = modal.getBoundingClientRect();
                
                // 限制在视口内
                const minX = rect.width / 2;
                const maxX = modalRect.width - rect.width / 2;
                const minY = rect.height / 2;
                const maxY = modalRect.height - rect.height / 2;
                
                x = Math.max(minX, Math.min(maxX, x));
                y = Math.max(minY, Math.min(maxY, y));
                
                modalContent.style.left = x + 'px';
                modalContent.style.top = y + 'px';
                modalContent.style.transform = 'translate(-50%, -50%)';
            }
            
            // 鼠标/触摸开始
            function handleStart(e) {
                const target = e.target;
                // 只允许从拖动手柄开始拖动
                if (!dragHandle.contains(target)) return;
                
                isDragging = true;
                modalContent.classList.add('dragging');
                
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                
                startX = clientX;
                startY = clientY;
                
                const pos = getCurrentPosition();
                initialX = pos.x;
                initialY = pos.y;
                
                e.preventDefault();
            }
            
            // 鼠标/触摸移动
            function handleMove(e) {
                if (!isDragging) return;
                
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                
                const deltaX = clientX - startX;
                const deltaY = clientY - startY;
                
                setPosition(initialX + deltaX, initialY + deltaY);
                
                e.preventDefault();
            }
            
            // 鼠标/触摸结束
            function handleEnd(e) {
                if (!isDragging) return;
                
                isDragging = false;
                modalContent.classList.remove('dragging');
                
                e.preventDefault();
            }
            
            // 添加事件监听器
            // 鼠标事件
            dragHandle.addEventListener('mousedown', handleStart);
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('mouseup', handleEnd);
            
            // 触摸事件
            dragHandle.addEventListener('touchstart', handleStart, { passive: false });
            document.addEventListener('touchmove', handleMove, { passive: false });
            document.addEventListener('touchend', handleEnd, { passive: false });
            
            // 弹窗打开时重置位置
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                        if (modal.classList.contains('show')) {
                            // 重置到中心位置
                            modalContent.style.left = '50%';
                            modalContent.style.top = '50%';
                            modalContent.style.transform = 'translate(-50%, -50%)';
                        }
                    }
                });
            });
            
            observer.observe(modal, { attributes: true });
        })();
        
        // 全选按钮
        document.getElementById('select-all-playlist-btn').addEventListener('click', () => {
            const allSelected = selectedPlaylistItems.size === musicState.playlist.length;
            if (allSelected) {
                // 取消全选
                selectedPlaylistItems.clear();
            } else {
                // 全选
                selectedPlaylistItems.clear();
                musicState.playlist.forEach((_, index) => {
                    selectedPlaylistItems.add(index);
                });
            }
            updatePlaylistUI();
        });
        
        // 删除选中按钮
        document.getElementById('delete-selected-playlist-btn').addEventListener('click', async () => {
            if (selectedPlaylistItems.size === 0) {
                showToast('请先选择要删除的歌曲');
                return;
            }
            
            const confirmed = confirm(`确定要删除选中的 ${selectedPlaylistItems.size} 首歌曲吗？`);
            if (!confirmed) return;
            
            // 将索引转为数组并从大到小排序，避免删除时索引错乱
            const indicesToDelete = Array.from(selectedPlaylistItems).sort((a, b) => b - a);
            
            // 记录当前播放的歌曲信息
            const wasPlaying = musicState.isPlaying;
            const currentTrack = musicState.playlist[musicState.currentIndex];
            
            // 删除歌曲
            for (const index of indicesToDelete) {
                if (index < 0 || index >= musicState.playlist.length) continue;
                
                const track = musicState.playlist[index];
                
                // 如果是本地歌曲，释放 blob URL
                if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) {
                    URL.revokeObjectURL(audioPlayer.src);
                }
                
                musicState.playlist.splice(index, 1);
            }
            
            // 更新数据库
            db.musicPlaylist = musicState.playlist;
            await saveData();
            
            // 处理播放状态
            if (musicState.playlist.length === 0) {
                if (wasPlaying) audioPlayer.pause();
                audioPlayer.src = '';
                musicState.currentIndex = -1;
                musicState.isPlaying = false;
            } else if (currentTrack) {
                // 尝试找到原来播放的歌曲的新索引
                const newIndex = musicState.playlist.findIndex(t => t.id === currentTrack.id);
                if (newIndex !== -1) {
                    musicState.currentIndex = newIndex;
                } else {
                    // 原歌曲被删除，播放第一首
                    musicState.currentIndex = 0;
                    if (wasPlaying) {
                        playSong(0);
                    } else {
                        updatePlayerUI();
                    }
                }
            }
            
            // 清空选择并更新UI
            selectedPlaylistItems.clear();
            updatePlaylistUI();
            updatePlayerUI();
            
            showToast(`已删除 ${indicesToDelete.length} 首歌曲`);
        });
        
        // 管理弹窗功能按钮
        document.querySelectorAll('.manage-modal-option').forEach(option => {
            option.addEventListener('click', async (e) => {
                const action = e.currentTarget.getAttribute('data-action');
                
                if (action === 'time-settings') {
                    // 显示时长设置弹窗
                    const modal = document.getElementById('time-settings-modal');
                    const unitHint = document.getElementById('current-unit-hint');
                    unitHint.textContent = musicState.timeDisplayUnit === 'minutes' ? '当前显示：分钟' : '当前显示：小时';
                    modal.classList.add('show');
                    return;
                }
                
                if (action === 'select-all') {
                    // 全选/取消全选
                    const allSelected = selectedPlaylistItems.size === musicState.playlist.length;
                    if (allSelected) {
                        selectedPlaylistItems.clear();
                    } else {
                        selectedPlaylistItems.clear();
                        musicState.playlist.forEach((_, index) => {
                            selectedPlaylistItems.add(index);
                        });
                    }
                    updatePlaylistUI();
                    return;
                }
                
                if (selectedPlaylistItems.size === 0) {
                    showToast('请先选择要操作的歌曲');
                    return;
                }
                
                if (action === 'delete') {
                    // 删除选中
                    const confirmed = confirm(`确定要删除选中的 ${selectedPlaylistItems.size} 首歌曲吗？`);
                    if (!confirmed) return;
                    
                    // 将索引转为数组并从大到小排序
                    const indicesToDelete = Array.from(selectedPlaylistItems).sort((a, b) => b - a);
                    const wasPlaying = musicState.isPlaying;
                    const currentTrack = musicState.playlist[musicState.currentIndex];
                    
                    for (const index of indicesToDelete) {
                        if (index < 0 || index >= musicState.playlist.length) continue;
                        const track = musicState.playlist[index];
                        if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) {
                            URL.revokeObjectURL(audioPlayer.src);
                        }
                        musicState.playlist.splice(index, 1);
                    }
                    
                    db.musicPlaylist = musicState.playlist;
                    await saveData();
                    
                    if (musicState.playlist.length === 0) {
                        if (wasPlaying) audioPlayer.pause();
                        audioPlayer.src = '';
                        musicState.currentIndex = -1;
                        musicState.isPlaying = false;
                    } else if (currentTrack) {
                        const newIndex = musicState.playlist.findIndex(t => t.id === currentTrack.id);
                        if (newIndex !== -1) {
                            musicState.currentIndex = newIndex;
                        } else {
                            musicState.currentIndex = 0;
                            if (wasPlaying) {
                                playSong(0);
                            } else {
                                updatePlayerUI();
                            }
                        }
                    }
                    
                    selectedPlaylistItems.clear();
                    updatePlaylistUI();
                    updatePlayerUI();
                    showToast(`已删除 ${indicesToDelete.length} 首歌曲`);
                    
                } else if (action === 'move-up') {
                    // 上移选中歌曲
                    const selectedArray = Array.from(selectedPlaylistItems).sort((a, b) => a - b);
                    
                    // 检查是否可以上移
                    if (selectedArray[0] === 0) {
                        showToast('已经在最前面了');
                        return;
                    }
                    
                    // 保存当前播放歌曲的ID
                    const currentId = musicState.currentIndex >= 0 ? musicState.playlist[musicState.currentIndex]?.id : null;
                    
                    // 从前往后移动，避免索引错乱
                    for (const index of selectedArray) {
                        if (index > 0) {
                            // 交换位置
                            [musicState.playlist[index], musicState.playlist[index - 1]] = 
                            [musicState.playlist[index - 1], musicState.playlist[index]];
                        }
                    }
                    
                    // 更新选中项的索引
                    selectedPlaylistItems.clear();
                    selectedArray.forEach(index => {
                        if (index > 0) selectedPlaylistItems.add(index - 1);
                    });
                    
                    // 更新当前播放索引
                    if (currentId) {
                        const newIndex = musicState.playlist.findIndex(t => t.id === currentId);
                        if (newIndex !== -1) musicState.currentIndex = newIndex;
                    }
                    
                    db.musicPlaylist = musicState.playlist;
                    await saveData();
                    updatePlaylistUI();
                    updatePlayerUI();
                    showToast('已上移选中歌曲');
                    
                } else if (action === 'move-down') {
                    // 下移选中歌曲
                    const selectedArray = Array.from(selectedPlaylistItems).sort((a, b) => b - a);
                    
                    // 检查是否可以下移
                    if (selectedArray[0] === musicState.playlist.length - 1) {
                        showToast('已经在最后面了');
                        return;
                    }
                    
                    // 保存当前播放歌曲的ID
                    const currentId = musicState.currentIndex >= 0 ? musicState.playlist[musicState.currentIndex]?.id : null;
                    
                    // 从后往前移动，避免索引错乱
                    for (const index of selectedArray) {
                        if (index < musicState.playlist.length - 1) {
                            // 交换位置
                            [musicState.playlist[index], musicState.playlist[index + 1]] = 
                            [musicState.playlist[index + 1], musicState.playlist[index]];
                        }
                    }
                    
                    // 更新选中项的索引
                    selectedPlaylistItems.clear();
                    selectedArray.forEach(index => {
                        if (index < musicState.playlist.length - 1) selectedPlaylistItems.add(index + 1);
                    });
                    
                    // 更新当前播放索引
                    if (currentId) {
                        const newIndex = musicState.playlist.findIndex(t => t.id === currentId);
                        if (newIndex !== -1) musicState.currentIndex = newIndex;
                    }
                    
                    db.musicPlaylist = musicState.playlist;
                    await saveData();
                    updatePlaylistUI();
                    updatePlayerUI();
                    showToast('已下移选中歌曲');
                }
            });
        });
        
        // 上传按钮 - 显示上传选项弹窗
        document.getElementById('add-song-upload-btn').addEventListener('click', () => {
            document.getElementById('upload-options-modal').classList.add('show');
        });
        
        // 关闭上传选项弹窗
        document.getElementById('close-upload-modal').addEventListener('click', () => {
            document.getElementById('upload-options-modal').classList.remove('show');
        });
        
        // 点击背景关闭上传弹窗
        document.getElementById('upload-options-modal').addEventListener('click', (e) => {
            if (e.target.id === 'upload-options-modal') {
                e.target.classList.remove('show');
            }
        });
        
        // 上传选项按钮点击事件
        document.querySelectorAll('.upload-modal-option').forEach(option => {
            option.addEventListener('click', (e) => {
                const type = e.currentTarget.getAttribute('data-type');
                document.getElementById('upload-options-modal').classList.remove('show');
                
                if (type === 'local') {
                    document.getElementById('local-song-upload-input').click();
                } else if (type === 'url') {
                    addSongFromURL();
                }
            });
        });
        
        document.getElementById('local-song-upload-input').addEventListener('change', addSongFromLocal);
        document.getElementById('add-song-search-btn').addEventListener('click', openMusicSearchModal);
        document.getElementById('clean-invalid-songs-btn').addEventListener('click', cleanInvalidSongs);
        
        // 清理结果弹窗事件监听
        document.getElementById('close-clean-result').addEventListener('click', () => {
            document.getElementById('clean-result-modal').style.display = 'none';
        });
        
        document.getElementById('select-all-invalid').addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('.invalid-song-checkbox');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            const selectAllBtn = document.getElementById('select-all-invalid');
            
            checkboxes.forEach(cb => cb.checked = !allChecked);
            selectAllBtn.textContent = allChecked ? '全选' : '取消全选';
        });
        
        document.getElementById('research-selected-songs').addEventListener('click', researchSelectedSongs);
        
        // 点击背景关闭清理结果弹窗
        document.getElementById('clean-result-modal').addEventListener('click', function(e) {
            if (e.target.id === 'clean-result-modal') {
                e.target.style.display = 'none';
            }
        });
        
        // 时长设置弹窗事件监听
        document.getElementById('close-time-settings').addEventListener('click', () => {
            document.getElementById('time-settings-modal').classList.remove('show');
        });
        
        // 点击背景关闭时长设置弹窗
        document.getElementById('time-settings-modal').addEventListener('click', function(e) {
            if (e.target.id === 'time-settings-modal') {
                document.getElementById('close-time-settings').click();
            }
        });
        
        // 时长设置选项按钮
        document.querySelectorAll('.time-settings-option').forEach(option => {
            option.addEventListener('click', async (e) => {
                const action = e.currentTarget.getAttribute('data-action');
                
                if (action === 'toggle-unit') {
                    // 切换显示单位
                    musicState.timeDisplayUnit = musicState.timeDisplayUnit === 'hours' ? 'minutes' : 'hours';
                    
                    // 更新显示
                    updateElapsedTimeDisplay();
                    
                    // 更新提示文字
                    const unitHint = document.getElementById('current-unit-hint');
                    unitHint.textContent = musicState.timeDisplayUnit === 'minutes' ? '当前显示：分钟' : '当前显示：小时';
                    
                    showToast(musicState.timeDisplayUnit === 'minutes' ? '已切换为分钟显示' : '已切换为小时显示');
                } else if (action === 'reset-time') {
                    // 重置时长
                    const confirmed = confirm('确定要重置一起听听歌的时长吗？当前时长将被清零。');
                    if (!confirmed) return;
                    
                    // 重置内存中的时长
                    musicState.totalElapsedTime = 0;
                    
                    // 更新显示
                    updateElapsedTimeDisplay();
                    
                    // 保存到数据库
                    if (musicState.activeChatId) {
                        const chat = db.characters.find(c => c.id === musicState.activeChatId) ||
                                    db.groups.find(g => g.id === musicState.activeChatId);
                        if (chat) {
                            if (!chat.musicData) chat.musicData = {totalTime: 0};
                            chat.musicData.totalTime = 0;
                            await saveData();
                        }
                    }
                    
                    showToast('已重置一起听听歌时长');
                    
                    // 关闭弹窗
                    document.getElementById('time-settings-modal').classList.remove('show');
                }
            });
        });
        
        // 音乐搜索弹窗按钮监听
        document.getElementById('close-music-search-modal').addEventListener('click', closeMusicSearchModal);
        document.getElementById('music-search-btn').addEventListener('click', searchMusic);
        document.getElementById('music-search-history-btn').addEventListener('click', showSearchHistory);
        
        // API选择弹窗按钮监听
        document.getElementById('select-old-api').addEventListener('click', () => {
            selectedApiType = 'old';
            document.getElementById('api-selector-modal').style.display = 'none';
            performSearch();
        });
        
        document.getElementById('select-new-api').addEventListener('click', () => {
            selectedApiType = 'new';
            document.getElementById('api-selector-modal').style.display = 'none';
            performSearch();
        });
        
        document.getElementById('cancel-api-selector').addEventListener('click', () => {
            document.getElementById('api-selector-modal').style.display = 'none';
        });
        
        // 点击背景关闭API选择弹窗
        document.getElementById('api-selector-modal').addEventListener('click', function(e) {
            if (e.target.id === 'api-selector-modal') {
                this.style.display = 'none';
            }
        });
        
        // 平台标签切换事件
        document.querySelectorAll('.platform-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                // 移除所有active类
                document.querySelectorAll('.platform-tab').forEach(t => t.classList.remove('active'));
                // 添加active类到当前标签
                this.classList.add('active');
                // 过滤并显示结果
                const filter = this.getAttribute('data-filter');
                filterAndDisplayResults(filter);
            });
        });
        
        // 搜索历史弹窗按钮监听
        document.getElementById('close-search-history').addEventListener('click', () => {
            document.getElementById('search-history-modal').style.display = 'none';
        });
        
        document.getElementById('clear-search-history').addEventListener('click', () => {
            if (confirm('确定要清空所有搜索历史吗？')) {
                musicSearchHistory = [];
                saveSearchHistory();
                showSearchHistory();
                showToast('已清空搜索历史');
            }
        });
        
        // 切换删除模式
        document.getElementById('toggle-delete-mode').addEventListener('click', () => {
            isDeleteMode = !isDeleteMode;
            const toggleBtn = document.getElementById('toggle-delete-mode');
            const selectAllBtn = document.getElementById('select-all-history');
            const deleteSelectedBtn = document.getElementById('delete-selected-history');
            const clearHistoryBtn = document.getElementById('clear-search-history');
            const historyItems = document.querySelectorAll('.history-item');
            
            if (isDeleteMode) {
                // 进入删除模式
                toggleBtn.classList.add('active');
                toggleBtn.textContent = '取消';
                selectAllBtn.style.display = 'flex';
                deleteSelectedBtn.style.display = 'flex';
                clearHistoryBtn.style.display = 'none';
                historyItems.forEach(item => item.classList.add('delete-mode'));
            } else {
                // 退出删除模式
                toggleBtn.classList.remove('active');
                toggleBtn.textContent = '删除';
                selectAllBtn.style.display = 'none';
                deleteSelectedBtn.style.display = 'none';
                clearHistoryBtn.style.display = 'flex';
                historyItems.forEach(item => {
                    item.classList.remove('delete-mode');
                    item.querySelector('.history-item-checkbox').checked = false;
                });
            }
        });
        
        // 全选/取消全选
        document.getElementById('select-all-history').addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('.history-item-checkbox');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            const selectAllBtn = document.getElementById('select-all-history');
            
            checkboxes.forEach(cb => cb.checked = !allChecked);
            selectAllBtn.textContent = allChecked ? '全选' : '取消全选';
        });
        
        // 删除选中项
        document.getElementById('delete-selected-history').addEventListener('click', () => {
            const checkboxes = document.querySelectorAll('.history-item-checkbox:checked');
            
            if (checkboxes.length === 0) {
                showToast('请至少选择一项');
                return;
            }
            
            if (confirm(`确定要删除选中的 ${checkboxes.length} 项搜索历史吗？`)) {
                // 收集要删除的索引（从大到小排序，避免删除时索引错乱）
                const indicesToDelete = Array.from(checkboxes)
                    .map(cb => parseInt(cb.dataset.index))
                    .sort((a, b) => b - a);
                
                // 删除选中的历史记录
                indicesToDelete.forEach(index => {
                    musicSearchHistory.splice(index, 1);
                });
                
                saveSearchHistory();
                showSearchHistory();
                showToast(`已删除 ${checkboxes.length} 项搜索历史`);
            }
        });
        
        // 点击背景关闭历史弹窗
        document.getElementById('search-history-modal').addEventListener('click', function(e) {
            if (e.target.id === 'search-history-modal') {
                e.target.style.display = 'none';
            }
        });
        
        // 点击背景关闭弹窗
        document.getElementById('music-search-modal').addEventListener('click', function(e) {
            if (e.target.id === 'music-search-modal') {
                closeMusicSearchModal();
            }
        });
        
        // 歌词导入弹窗事件处理
        document.getElementById('close-lyrics-modal').addEventListener('click', () => {
            document.getElementById('lyrics-import-modal').classList.remove('show');
        });
        
        // 点击背景关闭歌词导入弹窗
        document.getElementById('lyrics-import-modal').addEventListener('click', (e) => {
            if (e.target.id === 'lyrics-import-modal') {
                e.target.classList.remove('show');
            }
        });
        
        // 歌词导入选项按钮点击事件
        document.querySelectorAll('.lyrics-modal-option').forEach(option => {
            option.addEventListener('click', async (e) => {
                const type = e.currentTarget.getAttribute('data-type');
                const index = window.currentLyricsImportIndex;
                
                document.getElementById('lyrics-import-modal').classList.remove('show');
                
                let lrcContent = null;
                
                if (type === 'file') {
                    // 文件导入
                    lrcContent = await new Promise(resolve => {
                        const lrcInput = document.getElementById('lrc-upload-input');
                        const handler = (event) => {
                            const file = event.target.files[0];
                            if (file) {
                                const reader = new FileReader();
                                reader.onload = (re) => resolve(re.target.result);
                                reader.readAsText(file);
                            } else {
                                resolve(null);
                            }
                            lrcInput.removeEventListener('change', handler);
                            lrcInput.value = '';
                        };
                        lrcInput.addEventListener('change', handler);
                        lrcInput.click();
                    });
                } else if (type === 'url') {
                    // URL导入
                    const url = prompt('请输入歌词文件的网址（.lrc格式）：');
                    if (url) {
                        try {
                            showToast('正在获取歌词...');
                            const response = await fetch(url);
                            if (response.ok) {
                                lrcContent = await response.text();
                            } else {
                                showToast('无法获取歌词文件');
                            }
                        } catch (error) {
                            console.error('获取歌词失败:', error);
                            showToast('获取歌词失败');
                        }
                    }
                }
                
                if (lrcContent !== null && lrcContent.trim()) {
                    musicState.playlist[index].lrcContent = lrcContent;
                    musicState.playlist[index].lyrics = lrcContent;
                    db.musicPlaylist = musicState.playlist;
                    await saveData();
                    showToast('歌词导入成功');
                    if (musicState.currentIndex === index) {
                        loadLyrics(lrcContent);
                    }
                }
            });
        });
        
        // 封面上传弹窗事件处理
        document.getElementById('close-cover-modal').addEventListener('click', () => {
            document.getElementById('cover-import-modal').classList.remove('show');
        });
        
        // 点击背景关闭封面上传弹窗
        document.getElementById('cover-import-modal').addEventListener('click', (e) => {
            if (e.target.id === 'cover-import-modal') {
                e.target.classList.remove('show');
            }
        });
        
        // 封面上传选项按钮点击事件
        document.querySelectorAll('.cover-modal-option').forEach(option => {
            option.addEventListener('click', async (e) => {
                const type = e.currentTarget.getAttribute('data-type');
                const index = window.currentCoverImportIndex;
                
                document.getElementById('cover-import-modal').classList.remove('show');
                
                let coverUrl = null;
                let shouldUpdate = false;
                
                if (type === 'file') {
                    // 本地文件上传
                    coverUrl = await new Promise(resolve => {
                        const input = document.createElement('input');
                        input.type = 'file';
                        input.accept = 'image/*';
                        input.onchange = (event) => {
                            const file = event.target.files[0];
                            if (file) {
                                const reader = new FileReader();
                                reader.onload = (re) => resolve(re.target.result);
                                reader.readAsDataURL(file);
                            } else {
                                resolve(null);
                            }
                        };
                        input.click();
                    });
                    shouldUpdate = coverUrl !== null;
                } else if (type === 'url') {
                    // URL上传
                    const url = prompt('请输入封面图片的网址：');
                    if (url && url.trim()) {
                        coverUrl = url.trim();
                        shouldUpdate = true;
                    }
                } else if (type === 'reset') {
                    // 重置为默认封面
                    delete musicState.playlist[index].cover;
                    db.musicPlaylist = musicState.playlist;
                    await saveData();
                    showToast('已重置为默认封面');
                    
                    // 如果是当前播放的歌曲，立即更新封面显示
                    if (musicState.currentIndex === index) {
                        const coverImg = document.getElementById('music-player-cover');
                        if (coverImg) {
                            coverImg.src = 'https://via.placeholder.com/300x300/f0f0f0/999999?text=No+Cover';
                        }
                    }
                    return;
                }
                
                if (shouldUpdate && coverUrl) {
                    musicState.playlist[index].cover = coverUrl;
                    db.musicPlaylist = musicState.playlist;
                    await saveData();
                    showToast('封面上传成功');
                    
                    // 如果是当前播放的歌曲，立即更新封面显示
                    if (musicState.currentIndex === index) {
                        const coverImg = document.getElementById('music-player-cover');
                        if (coverImg) {
                            coverImg.src = coverUrl;
                        }
                    }
                }
            });
        });
        
        // 音乐搜索结果过滤交互
        document.querySelectorAll('.platform-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                document.querySelectorAll('.platform-tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                const filter = this.dataset.filter;
                if (allSearchResults.length > 0) {
                    filterAndDisplayResults(filter);
                }
            });
        });
        
        // 搜索框回车触发搜索
        document.getElementById('music-search-keyword').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchMusic();
            }
        });
        
        // 播放列表按钮监听
        document.getElementById('playlist-body').addEventListener('click', async (e) => {
            const target = e.target;
            if (target.classList.contains('delete-track-btn')) {
                const index = parseInt(target.dataset.index);
                const track = musicState.playlist[index];
                const confirmed = confirm(`确定要从播放列表中删除《${track.name}》吗？`);
                if (confirmed) {
                    deleteTrack(index);
                }
                return;
            }
            if (target.classList.contains('cover-btn')) {
                const index = parseInt(target.dataset.index);
                if (isNaN(index)) return;
                
                // 显示封面上传弹窗
                window.currentCoverImportIndex = index;
                document.getElementById('cover-import-modal').classList.add('show');
                return;
            }
            if (target.classList.contains('lyrics-btn')) {
                const index = parseInt(target.dataset.index);
                if (isNaN(index)) return;
                
                const track = musicState.playlist[index];
                
                // 检查是否已有歌词
                if (track.lyrics || track.lrcContent) {
                    const hasLyrics = track.lyrics || track.lrcContent;
                    const choice = confirm(`该歌曲已有歌词，是否重新导入？\n\n点击"确定"重新导入\n点击"取消"查看当前歌词`);
                    
                    if (!choice) {
                        // 查看当前歌词
                        if (musicState.currentIndex !== index) {
                            playSong(index);
                        }
                        return;
                    }
                }
                
                // 显示歌词导入弹窗
                window.currentLyricsImportIndex = index;
                document.getElementById('lyrics-import-modal').classList.add('show');
            }
        });
        
        // 进度条点击监听
        document.querySelector('.progress-bar').addEventListener('click', (e) => {
            if (!audioPlayer.duration) return;
            const progressBar = e.currentTarget;
            const barWidth = progressBar.clientWidth;
            const clickX = e.offsetX;
            audioPlayer.currentTime = (clickX / barWidth) * audioPlayer.duration;
        });
        
        // 用于跟踪音频是否真正播放过
        let hasPlayedSignificantTime = false;
        let lastValidTime = 0;
        let audioLoadedDuration = 0; // 记录音频加载完成时的真实时长
        
        // 音频播放器事件
        audioPlayer.addEventListener('loadedmetadata', () => {
            // 当音频元数据加载完成时，记录真实的时长
            if (audioPlayer.duration && !isNaN(audioPlayer.duration) && isFinite(audioPlayer.duration)) {
                audioLoadedDuration = audioPlayer.duration;
                console.log('音频元数据已加载，时长:', audioLoadedDuration);
            }
        });
        
        audioPlayer.addEventListener('durationchange', () => {
            // 当duration改变时，更新记录的时长
            if (audioPlayer.duration && !isNaN(audioPlayer.duration) && isFinite(audioPlayer.duration)) {
                audioLoadedDuration = audioPlayer.duration;
                console.log('音频时长已更新:', audioLoadedDuration);
            }
        });
        
        audioPlayer.addEventListener('timeupdate', () => {
            updateMusicProgressBar();
            
            // 记录播放进度，用于判断是否真正播放过
            if (audioPlayer.currentTime > 3) {
                hasPlayedSignificantTime = true;
                lastValidTime = audioPlayer.currentTime;
            }
        });
        
        audioPlayer.addEventListener('pause', () => {
            if(musicState.isActive) {
                musicState.isPlaying = false;
                updatePlayerUI();
                // 音乐暂停时，移除胶片旋转样式
                document.getElementById('vinyl-view').classList.remove('spinning');
            }
        });
        
        audioPlayer.addEventListener('play', () => {
            if(musicState.isActive) {
                musicState.isPlaying = true;
                updatePlayerUI();
                // 音乐开始播放时，添加胶片旋转样式
                document.getElementById('vinyl-view').classList.add('spinning');
            }
        });
        
        audioPlayer.addEventListener('loadstart', () => {
            // 每次开始加载新音频时重置标记
            hasPlayedSignificantTime = false;
            lastValidTime = 0;
            audioLoadedDuration = 0;
        });
        
        audioPlayer.addEventListener('ended', () => {
            if(musicState.isActive) {
                const duration = audioLoadedDuration || audioPlayer.duration;
                const currentTime = audioPlayer.currentTime;
                
                // 更严格的检查：
                // 1. duration必须有效且大于10秒（排除异常短的音频）
                // 2. 必须播放过至少5秒
                // 3. currentTime必须接近duration（允许3秒误差）
                // 4. currentTime必须大于duration的80%（防止误判）
                const isValidDuration = duration && !isNaN(duration) && isFinite(duration) && duration > 10;
                const hasPlayedEnough = hasPlayedSignificantTime && lastValidTime > 5;
                const isNearEnd = currentTime >= duration - 3;
                const isOverEightyPercent = currentTime >= duration * 0.8;
                
                if (isValidDuration && hasPlayedEnough && isNearEnd && isOverEightyPercent) {
                    console.log('歌曲正常播放结束，切换下一首', {
                        duration, 
                        currentTime, 
                        lastValidTime,
                        percentage: ((currentTime / duration) * 100).toFixed(1) + '%'
                    });
                    // 歌曲播放结束时，移除胶片旋转样式
                    document.getElementById('vinyl-view').classList.remove('spinning');
                    playNext();
                } else {
                    console.warn('检测到异常的ended事件，忽略切歌', {
                        duration, 
                        currentTime, 
                        hasPlayedSignificantTime,
                        lastValidTime,
                        isValidDuration,
                        hasPlayedEnough,
                        isNearEnd,
                        isOverEightyPercent,
                        percentage: duration > 0 ? ((currentTime / duration) * 100).toFixed(1) + '%' : 'N/A'
                    });
                    // 如果是误触发，尝试恢复播放
                    if (hasPlayedSignificantTime && currentTime < duration - 5) {
                        console.log('尝试恢复播放...');
                        audioPlayer.play().catch(err => console.error('恢复播放失败:', err));
                    }
                }
            }
        });
        
        // 添加错误处理
        audioPlayer.addEventListener('error', (e) => {
            console.error('音频播放错误:', e);
            if (musicState.isActive && audioPlayer.error) {
                const errorCode = audioPlayer.error.code;
                const errorMessages = {
                    1: '音频加载被中止',
                    2: '网络错误',
                    3: '音频解码失败',
                    4: '音频格式不支持或音频源无效'
                };
                console.error('错误代码:', errorCode, errorMessages[errorCode] || '未知错误');
                showToast(errorMessages[errorCode] || '播放出错，尝试下一首');
                // 出错时自动跳到下一首
                setTimeout(() => playNext(), 1000);
            }
        });
        
        // 添加stalled事件处理（网络卡顿）
        audioPlayer.addEventListener('stalled', () => {
            console.warn('音频加载停滞');
        });
        
        // 添加waiting事件处理（缓冲中）
        audioPlayer.addEventListener('waiting', () => {
            console.log('音频缓冲中...', {currentTime: audioPlayer.currentTime, duration: audioPlayer.duration});
        });
        
        // 胶片/歌词切换功能
        const musicVisualContainer = document.getElementById('music-visual-container');
        if (musicVisualContainer) {
            musicVisualContainer.addEventListener('click', () => {
                musicVisualContainer.classList.toggle('lyrics-active');
            });
        }
        
        // === 悬浮歌词功能 ===
        const floatingLyricsContainer = document.getElementById('floating-lyrics-container');
        const closeFloatingLyricsBtn = document.getElementById('close-floating-lyrics');
        
        // 关闭悬浮歌词
        closeFloatingLyricsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            floatingLyricsContainer.classList.remove('visible');
        });
        
        // 悬浮歌词拖动功能
        (() => {
            let isDragging = false;
            let startX, startY;
            let initialX, initialY;
            
            // 获取当前位置（相对于视口）
            function getCurrentPosition() {
                const rect = floatingLyricsContainer.getBoundingClientRect();
                return {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };
            }
            
            // 设置位置
            function setPosition(x, y) {
                const rect = floatingLyricsContainer.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                // 限制在视口内
                const minX = rect.width / 2;
                const maxX = viewportWidth - rect.width / 2;
                const minY = rect.height / 2;
                const maxY = viewportHeight - rect.height / 2;
                
                x = Math.max(minX, Math.min(maxX, x));
                y = Math.max(minY, Math.min(maxY, y));
                
                floatingLyricsContainer.style.left = x + 'px';
                floatingLyricsContainer.style.top = y + 'px';
                floatingLyricsContainer.style.transform = 'translate(-50%, -50%)';
            }
            
            // 鼠标/触摸开始
            function handleStart(e) {
                // 如果点击的是关闭按钮，不触发拖动
                if (e.target.closest('.floating-lyrics-close')) return;
                
                isDragging = true;
                floatingLyricsContainer.classList.add('dragging');
                
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                
                startX = clientX;
                startY = clientY;
                
                const pos = getCurrentPosition();
                initialX = pos.x;
                initialY = pos.y;
                
                e.preventDefault();
            }
            
            // 鼠标/触摸移动
            function handleMove(e) {
                if (!isDragging) return;
                
                const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                
                const deltaX = clientX - startX;
                const deltaY = clientY - startY;
                
                setPosition(initialX + deltaX, initialY + deltaY);
                
                e.preventDefault();
            }
            
            // 鼠标/触摸结束
            function handleEnd(e) {
                if (!isDragging) return;
                
                isDragging = false;
                floatingLyricsContainer.classList.remove('dragging');
                
                e.preventDefault();
            }
            
            // 添加事件监听器
            // 鼠标事件
            floatingLyricsContainer.addEventListener('mousedown', handleStart);
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('mouseup', handleEnd);
            
            // 触摸事件
            floatingLyricsContainer.addEventListener('touchstart', handleStart, { passive: false });
            document.addEventListener('touchmove', handleMove, { passive: false });
            document.addEventListener('touchend', handleEnd, { passive: false });
        })();
        
        // 音乐播放时自动显示悬浮歌词（只要一起听会话是活跃的）
        audioPlayer.addEventListener('play', () => {
            if (musicState.isActive && musicState.parsedLyrics && musicState.parsedLyrics.length > 0) {
                floatingLyricsContainer.classList.add('visible');
            }
        });
        
        // 注意：不在暂停和结束时隐藏悬浮歌词
        // 悬浮歌词只在以下情况隐藏：
        // 1. 用户手动点击关闭按钮
        // 2. 结束一起听会话（endListenTogetherSession）
        
        // === 音乐播放器事件监听器结束 ===

        // ▼▼▼ 外卖代付功能函数 ▼▼▼
        function startWaimaiCountdown(element, endTime) {
            const timerId = setInterval(() => {
                const now = Date.now();
                const distance = endTime - now;

                if (distance < 0) {
                    clearInterval(timerId);
                    element.innerHTML = '<span>已</span><span>超</span><span>时</span>';
                    return;
                }

                const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);
                
                const minStr = String(minutes).padStart(2, '0');
                const secStr = String(seconds).padStart(2, '0');

                element.innerHTML = `<span>${minStr.charAt(0)}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(0)}</span><span>${secStr.charAt(1)}</span>`;
            }, 1000);
            return timerId;
        }

        function cleanupWaimaiTimers() {
            for (const timestamp in waimaiTimers) {
                clearInterval(waimaiTimers[timestamp]);
            }
            waimaiTimers = {};
        }

        async function handleWaimaiResponse(originalTimestamp, choice) {
            const chat = (currentChatType === 'private') ? db.characters.find(c => c.id === currentChatId) : db.groups.find(g => g.id === currentChatId);
            if (!chat) return;

            const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
            if (messageIndex === -1) return;

            // 更新原始消息的状态
            const originalMessage = chat.history[messageIndex];
            originalMessage.status = choice;
            
            // 记录支付者
            let systemContent;
            const myNickname = (currentChatType === 'group') ? (chat.me ? (chat.me.groupNickname || '我') : '我') : (chat.myName || '我');
            
            if (choice === 'paid') {
                originalMessage.paidBy = myNickname;
                systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName || '对方'} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
            } else {
                systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName || '对方'} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
            }

            // 创建系统消息
            const systemNote = {
                id: `msg_${Date.now()}`,
                role: 'system',
                content: systemContent,
                timestamp: Date.now(),
                isHidden: true
            };
            chat.history.push(systemNote);

            // 保存并刷新UI
            await saveToLocalStorage();
            currentPage = 1;
            renderMessages(false, true);
        }

        function showCustomAlert(title, message) {
            const alertHtml = `
                <div class="modal-overlay visible" id="custom-alert-overlay">
                    <div class="modal-window">
                        <h3>${title}</h3>
                        <div style="margin: 15px 0; line-height: 1.6;">${message}</div>
                        <button class="btn btn-primary" onclick="document.getElementById('custom-alert-overlay').remove()" style="width: 100%;">确定</button>
                    </div>
                </div>`;
            document.body.insertAdjacentHTML('beforeend', alertHtml);
        }
        // ▲▲▲ 外卖代付功能函数结束 ▲▲▲

        // ===== Minimax TTS 语音播放功能 =====
        let isTtsPlaying = false; // 全局锁，true表示有语音正在播放
        let currentTtsAudioBubble = null; // 记录当前正在播放的气泡元素
        let isIntentionalStop = false; // 标记是否为主动停止

        /**
         * 停止当前正在播放的Minimax TTS语音
         */
        function stopMinimaxAudio() {
            const ttsPlayer = document.getElementById('tts-audio-player');
            if (!ttsPlayer) return;
            
            isIntentionalStop = true;
            ttsPlayer.pause();
            ttsPlayer.currentTime = 0;
            ttsPlayer.src = '';
            
            // 移除播放动画
            if (currentTtsAudioBubble) {
                currentTtsAudioBubble.classList.remove('playing');
            }
            
            isTtsPlaying = false;
            currentTtsAudioBubble = null;
            
            setTimeout(() => {
                isIntentionalStop = false;
            }, 100);
        }

        /**
         * 调用 Minimax TTS API 生成语音并播放
         * @param {string} text - 要转换为语音的文本
         * @param {HTMLElement} bubbleElement - 需要播放动画的语音气泡元素
         * @param {string} senderId - 发送者ID（用于群聊中获取成员的voiceId）
         */
        async function playMinimaxAudio(text, bubbleElement, senderId = null) {
            // 停止当前播放
            stopMinimaxAudio();
            await new Promise(resolve => setTimeout(resolve, 50));

            const ttsPlayer = document.getElementById('tts-audio-player');
            if (!ttsPlayer) {
                console.error('TTS播放器元素未找到');
                return;
            }

            isTtsPlaying = true;
            currentTtsAudioBubble = bubbleElement;
            bubbleElement.classList.add('playing');

            // 获取配置（优先级：角色/成员专属 > 全局）
            let groupId, apiKey, voiceId, speechModel;
            
            // 获取全局配置作为默认值
            const globalConfig = db.minimaxConfig || {};
            
            if (currentChatType === 'private' && currentChatId) {
                // 私聊：检查角色是否有专属Minimax配置
                const character = db.characters.find(c => c.id === currentChatId);
                
                if (character && character.minimaxConfig && character.minimaxConfig.enabled) {
                    // 使用角色专属配置（优先级最高）
                    groupId = character.minimaxConfig.groupId || globalConfig.groupId;
                    apiKey = character.minimaxConfig.apiKey || globalConfig.apiKey;
                    voiceId = character.minimaxConfig.voiceId || globalConfig.voiceId || 'male-qn-qingse';
                    speechModel = character.minimaxConfig.speechModel || globalConfig.speechModel || 'speech-01';
                    console.log(`[私聊] 使用角色专属Minimax配置`);
                } else {
                    // 兼容旧数据：检查是否有旧的voiceId字段
                    if (character && character.voiceId && character.voiceId.trim()) {
                        groupId = globalConfig.groupId;
                        apiKey = globalConfig.apiKey;
                        voiceId = character.voiceId.trim();
                        speechModel = globalConfig.speechModel || 'speech-01';
                        console.log(`[私聊] 使用角色专属语音ID（旧格式）: ${voiceId}`);
                    } else {
                        // 使用全局配置
                        groupId = globalConfig.groupId;
                        apiKey = globalConfig.apiKey;
                        voiceId = globalConfig.voiceId || 'male-qn-qingse';
                        speechModel = globalConfig.speechModel || 'speech-01';
                        console.log(`[私聊] 使用全局Minimax配置`);
                    }
                }
            } else if (currentChatType === 'group' && currentChatId && senderId) {
                // 群聊：检查成员是否有专属Minimax配置
                const group = db.groups.find(g => g.id === currentChatId);
                if (group) {
                    const member = group.members.find(m => m.id === senderId);
                    
                    if (member && member.minimaxConfig && member.minimaxConfig.enabled) {
                        // 使用成员专属配置（优先级最高）
                        groupId = member.minimaxConfig.groupId || globalConfig.groupId;
                        apiKey = member.minimaxConfig.apiKey || globalConfig.apiKey;
                        voiceId = member.minimaxConfig.voiceId || globalConfig.voiceId || 'male-qn-qingse';
                        speechModel = member.minimaxConfig.speechModel || globalConfig.speechModel || 'speech-01';
                        console.log(`[群聊] 使用成员 ${member.groupNickname} 的专属Minimax配置`);
                    } else {
                        // 兼容旧数据：检查是否有旧的voiceId字段
                        if (member && member.voiceId && member.voiceId.trim()) {
                            groupId = globalConfig.groupId;
                            apiKey = globalConfig.apiKey;
                            voiceId = member.voiceId.trim();
                            speechModel = globalConfig.speechModel || 'speech-01';
                            console.log(`[群聊] 使用成员 ${member.groupNickname} 的专属语音ID（旧格式）: ${voiceId}`);
                        } else {
                            // 使用全局配置
                            groupId = globalConfig.groupId;
                            apiKey = globalConfig.apiKey;
                            voiceId = globalConfig.voiceId || 'male-qn-qingse';
                            speechModel = globalConfig.speechModel || 'speech-01';
                            console.log(`[群聊] 成员 ${member ? member.groupNickname : '未知'} 未配置Minimax，使用全局配置`);
                        }
                    }
                }
            } else {
                // 其他情况：使用全局配置
                groupId = globalConfig.groupId;
                apiKey = globalConfig.apiKey;
                voiceId = globalConfig.voiceId || 'male-qn-qingse';
                speechModel = globalConfig.speechModel || 'speech-01';
            }

            // 检查配置是否完整
            if (!groupId || !apiKey) {
                showToast('Minimax配置不完整，请检查设置');
                stopMinimaxAudio();
                return;
            }

            try {
                const response = await fetch(`https://api.minimax.chat/v1/text_to_speech?GroupId=${groupId}`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: text,
                        voice_id: voiceId,
                        model: speechModel,
                        speed: 1.0,
                        pitch: 0,
                        timber_list: []
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Minimax API 错误: ${errorData.base_resp?.status_msg || response.statusText}`);
                }

                const contentType = response.headers.get('Content-Type');
                if (!contentType || !contentType.startsWith('audio/')) {
                    const errorData = await response.json().catch(() => response.text());
                    throw new Error(`Minimax API 未返回有效的音频文件`);
                }

                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);

                ttsPlayer.src = audioUrl;

                const cleanupAndReset = () => {
                    if (isTtsPlaying) {
                        isTtsPlaying = false;
                        URL.revokeObjectURL(audioUrl);
                        if (currentTtsAudioBubble) {
                            currentTtsAudioBubble.classList.remove('playing');
                        }
                        currentTtsAudioBubble = null;
                    }
                };

                ttsPlayer.onended = cleanupAndReset;

                ttsPlayer.onerror = (e) => {
                    if (!isIntentionalStop) {
                        console.error("TTS音频播放时发生错误:", e);
                        showToast('语音播放失败');
                    }
                    cleanupAndReset();
                };

                await ttsPlayer.play();

            } catch (error) {
                console.error("Minimax TTS 调用失败:", error);
                showToast(`语音合成失败: ${error.message}`);
                stopMinimaxAudio();
            }
        }

        /**
         * 处理语音气泡点击事件
         * @param {HTMLElement} voiceBubble - 被点击的语音气泡元素
         */
        function handleVoiceBubbleClick(voiceBubble) {
            const messageWrapper = voiceBubble.closest('.message-wrapper');
            if (!messageWrapper) return;

            const transcript = messageWrapper.querySelector('.voice-transcript');
            if (!transcript) return;

            // 如果是用户发送的语音，只切换文字显示
            if (messageWrapper.classList.contains('sent')) {
                transcript.classList.toggle('active');
                return;
            }

            // AI发送的语音消息
            const isTranscriptActive = transcript.classList.contains('active');
            const isCurrentlyPlaying = (isTtsPlaying && currentTtsAudioBubble === voiceBubble);

            // 如果正在播放当前语音，停止播放并收起文字
            if (isCurrentlyPlaying) {
                stopMinimaxAudio();
                transcript.classList.remove('active');
                return;
            }

            // 切换文字显示状态
            transcript.classList.toggle('active');

            // 如果文字被展开，尝试播放语音（如果配置了Minimax）
            if (transcript.classList.contains('active')) {
                const config = db.minimaxConfig || {};
                if (config.groupId && config.apiKey) {
                    // 有配置，播放语音
                    const voiceText = transcript.textContent.trim();
                    if (voiceText) {
                        // 获取发送者ID（用于群聊）
                        const senderId = messageWrapper.dataset.senderId || null;
                        playMinimaxAudio(voiceText, voiceBubble, senderId);
                    }
                }
                // 如果没有配置，只显示文字，不播放
            }
        }
        // ===== Minimax TTS 功能结束 =====

        // ===== NovelAI 图像生成功能 =====
        // NovelAI设置弹窗事件
        document.getElementById('close-novelai-settings').addEventListener('click', () => {
            document.getElementById('novelai-settings-modal').style.display = 'none';
        });
        
        document.getElementById('save-nai-settings-btn').addEventListener('click', async () => {
            db.novelaiConfig.resolution = document.getElementById('nai-resolution').value;
            db.novelaiConfig.steps = parseInt(document.getElementById('nai-steps').value);
            db.novelaiConfig.cfgScale = parseFloat(document.getElementById('nai-cfg-scale').value);
            db.novelaiConfig.sampler = document.getElementById('nai-sampler').value;
            db.novelaiConfig.seed = parseInt(document.getElementById('nai-seed').value);
            db.novelaiConfig.ucPreset = parseInt(document.getElementById('nai-uc-preset').value);
            db.novelaiConfig.qualityToggle = document.getElementById('nai-quality-toggle').checked;
            db.novelaiConfig.smea = document.getElementById('nai-smea').checked;
            db.novelaiConfig.smeaDyn = document.getElementById('nai-smea-dyn').checked;
            db.novelaiConfig.defaultPositive = document.getElementById('nai-default-positive').value;
            db.novelaiConfig.defaultNegative = document.getElementById('nai-default-negative').value;
            
            await saveData();
            showToast('NovelAI设置已保存！');
            document.getElementById('novelai-settings-modal').style.display = 'none';
        });
        
        // NovelAI测试弹窗事件
        document.getElementById('close-novelai-test').addEventListener('click', () => {
            document.getElementById('novelai-test-modal').style.display = 'none';
        });
        
        document.getElementById('nai-generate-btn').addEventListener('click', async () => {
            await generateNovelAIImage();
        });
        
        /**
         * 检测消息内容中是否包含NovelAI图片请求
         * @param {string} content - 消息内容
         * @returns {Object|null} 如果包含naiimag请求，返回{prompt, negative}，否则返回null
         */
        function detectNovelAIRequest(content) {
            // 检测格式：{"type": "naiimag", "prompt": "..."}
            const naiRegex = /\{"type"\s*:\s*"naiimag"\s*,\s*"prompt"\s*:\s*"([^"]+)"\s*(?:,\s*"negative"\s*:\s*"([^"]+)")?\}/;
            const match = content.match(naiRegex);
            if (match) {
                return {
                    prompt: match[1],
                    negative: match[2] || ''
                };
            }
            return null;
        }

        /**
         * 生成NovelAI图片
         * @param {string} customPrompt - 自定义提示词（可选）
         * @param {string} customNegative - 自定义负面提示词（可选）
         * @returns {Promise<string>} 返回生成的图像Base64数据URL
         */
        async function generateNovelAIImage(customPrompt = '', customNegative = '') {
            const apiKey = db.novelaiConfig.apiKey;
            const model = db.novelaiConfig.model;
            
            if (!apiKey) {
                showToast('请先配置NovelAI API Key');
                return null;
            }
            
            // 获取提示词
            let prompt = customPrompt || document.getElementById('nai-test-prompt')?.value || db.novelaiConfig.defaultPositive;
            let negativePrompt = customNegative || document.getElementById('nai-test-negative')?.value || db.novelaiConfig.defaultNegative;
            
            if (!prompt.trim()) {
                showToast('请输入提示词');
                return null;
            }
            
            // 显示加载状态
            const loadingEl = document.getElementById('nai-test-loading');
            const resultEl = document.getElementById('nai-test-result');
            if (loadingEl) {
                loadingEl.style.display = 'block';
                resultEl.style.display = 'none';
            }
            
            try {
                // 解析分辨率
                const [width, height] = db.novelaiConfig.resolution.split('x').map(Number);
                
                // 构建请求参数
                const params = {
                    input: prompt,
                    model: model,
                    action: 'generate',
                    parameters: {
                        width: width,
                        height: height,
                        scale: db.novelaiConfig.cfgScale,
                        sampler: db.novelaiConfig.sampler,
                        steps: db.novelaiConfig.steps,
                        seed: db.novelaiConfig.seed === -1 ? Math.floor(Math.random() * 9999999999) : db.novelaiConfig.seed,
                        n_samples: 1,
                        ucPreset: db.novelaiConfig.ucPreset,
                        qualityToggle: db.novelaiConfig.qualityToggle,
                        sm: db.novelaiConfig.smea,
                        sm_dyn: db.novelaiConfig.smeaDyn,
                        dynamic_thresholding: false,
                        controlnet_strength: 1,
                        legacy: false,
                        add_original_image: false,
                        cfg_rescale: 0,
                        noise_schedule: 'native',
                        legacy_v3_extend: false,
                        skip_cfg_above_sigma: null,
                        negative_prompt: negativePrompt
                    }
                };
                
                console.log('NovelAI请求参数:', params);
                
                // 调用NovelAI API
                const response = await fetch('https://image.novelai.net/ai/generate-image', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(params)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`NovelAI API错误 (${response.status}): ${errorText}`);
                }
                
                // 获取图片数据
                const blob = await response.blob();
                const imageDataUrl = await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.readAsDataURL(blob);
                });
                
                // 显示结果
                if (loadingEl) {
                    loadingEl.style.display = 'none';
                    resultEl.style.display = 'block';
                    document.getElementById('nai-test-image').src = imageDataUrl;
                }
                
                console.log('NovelAI图片生成成功！');
                return imageDataUrl;
                
            } catch (error) {
                console.error('NovelAI生成失败:', error);
                if (loadingEl) {
                    loadingEl.style.display = 'none';
                }
                showToast(`生成失败: ${error.message}`);
                return null;
            }
        }
        
        // 双击下载NovelAI图片功能（测试弹窗和聊天中的图片）
        document.addEventListener('dblclick', (e) => {
            // 检查是否是NovelAI图片（测试弹窗或聊天中的naiimag-image）
            if (e.target.tagName === 'IMG' && 
                (e.target.id === 'nai-test-image' || e.target.classList.contains('naiimag-image'))) {
                const link = document.createElement('a');
                link.href = e.target.src;
                link.download = `novelai_${Date.now()}.png`;
                link.click();
                showToast('图片已下载');
            }
        });
        // ===== NovelAI 功能结束 =====

        init();
        
        // 【修复】页面加载后，检查是否需要启动后台活动
        // 等待 init() 完成后再检查
        (async () => {
            // 等待一小段时间确保 loadData 完成
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const hasAnyBackgroundActivity = db.enableBackgroundActivity || (db.characters && db.characters.some(c => c.enableBackgroundActivity));
            if (hasAnyBackgroundActivity) {
                startBackgroundSimulation();
                console.log('页面加载完成，后台活动已自动启动');
            } else {
                console.log('页面加载完成，无需启动后台活动');
            }
        })();

        // ===== PWA Service Worker 注册已在前面完成 =====
        
        // ========== 导出/导入小手机加密角色卡功能 ==========

        // 导出角色功能
        document.getElementById('export-character-btn')?.addEventListener('click', async () => {
            if (!currentChatId || currentChatType !== 'private') {
                showToast('请先打开一个角色聊天');
                return;
            }
            
            const character = db.characters.find(c => c.id === currentChatId);
            if (!character) {
                showToast('角色不存在');
                return;
            }
            
            const modal = document.getElementById('export-character-modal');
            const form = document.getElementById('export-character-form');
            
            // 重置表单
            form.reset();
            document.querySelectorAll('.export-format-btn').forEach(btn => {
                btn.style.borderColor = '#ddd';
                btn.style.background = 'white';
            });
            document.querySelector('.export-format-btn[data-format="json"]').style.borderColor = 'var(--primary-color)';
            document.querySelector('.export-format-btn[data-format="json"]').style.background = '#f0f8ff';
            
            // 显示关联的世界书
            const worldbookList = document.getElementById('export-worldbook-list');
            if (character.worldBookIds && character.worldBookIds.length > 0) {
                let html = '';
                character.worldBookIds.forEach(wbId => {
                    const wb = db.worldBooks.find(w => w.id === wbId);
                    if (wb) {
                        html += `
                            <label style="display: flex; align-items: center; padding: 8px; margin-bottom: 5px; background: white; border-radius: 6px; cursor: pointer;">
                                <input type="checkbox" class="export-wb-checkbox" data-wb-id="${wbId}" checked style="margin-right: 10px;">
                                <span style="flex: 1;">${wb.name}</span>
                            </label>
                        `;
                    }
                });
                worldbookList.innerHTML = html;
            } else {
                worldbookList.innerHTML = '<p style="text-align: center; color: #999; margin: 0;">该角色未绑定世界书</p>';
            }
            
            // 检查是否有NPC库
            const hasNpc = character.npcLibrary && character.npcLibrary.length > 0;
            const npcSection = document.getElementById('export-npc-section');
            npcSection.style.display = hasNpc ? 'block' : 'none';
            if (hasNpc) {
                npcSection.dataset.selected = 'no';
                document.getElementById('export-npc-yes').style.background = '';
                document.getElementById('export-npc-no').style.background = 'var(--primary-color)';
                document.getElementById('export-npc-no').style.color = 'white';
            }
            
            // 检查是否有头像库
            const hasAvatar = character.avatarLibrary && character.avatarLibrary.length > 0;
            const avatarSection = document.getElementById('export-avatar-section');
            avatarSection.style.display = hasAvatar ? 'block' : 'none';
            if (hasAvatar) {
                avatarSection.dataset.selected = 'no';
                document.getElementById('export-avatar-yes').style.background = '';
                document.getElementById('export-avatar-no').style.background = 'var(--primary-color)';
                document.getElementById('export-avatar-no').style.color = 'white';
            }
            
            modal.classList.add('visible');
        });

        // 导出格式选择
        document.querySelectorAll('.export-format-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.export-format-btn').forEach(b => {
                    b.style.borderColor = '#ddd';
                    b.style.background = 'white';
                });
                this.style.borderColor = 'var(--primary-color)';
                this.style.background = '#f0f8ff';
            });
        });

        // NPC库选择
        document.getElementById('export-npc-yes')?.addEventListener('click', function() {
            const section = document.getElementById('export-npc-section');
            section.dataset.selected = 'yes';
            this.style.background = 'var(--primary-color)';
            this.style.color = 'white';
            document.getElementById('export-npc-no').style.background = '';
            document.getElementById('export-npc-no').style.color = '';
        });

        document.getElementById('export-npc-no')?.addEventListener('click', function() {
            const section = document.getElementById('export-npc-section');
            section.dataset.selected = 'no';
            this.style.background = 'var(--primary-color)';
            this.style.color = 'white';
            document.getElementById('export-npc-yes').style.background = '';
            document.getElementById('export-npc-yes').style.color = '';
        });

        // 头像库选择
        document.getElementById('export-avatar-yes')?.addEventListener('click', function() {
            const section = document.getElementById('export-avatar-section');
            section.dataset.selected = 'yes';
            this.style.background = 'var(--primary-color)';
            this.style.color = 'white';
            document.getElementById('export-avatar-no').style.background = '';
            document.getElementById('export-avatar-no').style.color = '';
        });

        document.getElementById('export-avatar-no')?.addEventListener('click', function() {
            const section = document.getElementById('export-avatar-section');
            section.dataset.selected = 'no';
            this.style.background = 'var(--primary-color)';
            this.style.color = 'white';
            document.getElementById('export-avatar-yes').style.background = '';
            document.getElementById('export-avatar-yes').style.color = '';
        });

        // 加密类型选择
        document.getElementById('export-encryption-type')?.addEventListener('change', function() {
            const customSection = document.getElementById('custom-fake-content-section');
            const passwordSection = document.getElementById('encryption-password-section');
            const methodSection = document.getElementById('encryption-method-section');
            
            if (this.value === 'custom') {
                customSection.style.display = 'block';
                passwordSection.style.display = 'block';
                methodSection.style.display = 'block';
            } else if (this.value === 'none') {
                customSection.style.display = 'none';
                passwordSection.style.display = 'none';
                methodSection.style.display = 'none';
            } else {
                customSection.style.display = 'none';
                passwordSection.style.display = 'block';
                methodSection.style.display = 'block';
            }
        });

        // 取消导出
        document.getElementById('cancel-export-character-btn')?.addEventListener('click', () => {
            document.getElementById('export-character-modal').classList.remove('visible');
        });

        // ===== 高级加密系统 =====
        // AES-256-GCM 加密函数
        async function encryptDataAES(data, password, method = 'aes-gcm') {
            try {
                const encoder = new TextEncoder();
                const dataBytes = encoder.encode(JSON.stringify(data));
                
                // 生成随机盐值（用于密钥派生）
                const salt = crypto.getRandomValues(new Uint8Array(16));
                
                // 使用PBKDF2从密码派生密钥
                const passwordKey = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(password),
                    'PBKDF2',
                    false,
                    ['deriveBits', 'deriveKey']
                );
                
                // 派生AES-256密钥
                const key = await crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: salt,
                        iterations: method === 'aes-gcm-ultra' ? 600000 : 100000, // 超高难度使用更多迭代
                        hash: 'SHA-256'
                    },
                    passwordKey,
                    { name: 'AES-GCM', length: 256 },
                    false,
                    ['encrypt']
                );
                
                // 生成随机初始化向量
                const iv = crypto.getRandomValues(new Uint8Array(12));
                
                // 加密数据
                const encryptedData = await crypto.subtle.encrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv,
                        tagLength: 128
                    },
                    key,
                    dataBytes
                );
                
                // 组合：盐值 + IV + 加密数据
                const combined = new Uint8Array(salt.length + iv.length + encryptedData.byteLength);
                combined.set(salt, 0);
                combined.set(iv, salt.length);
                combined.set(new Uint8Array(encryptedData), salt.length + iv.length);
                
                // 转换为Base64
                return btoa(String.fromCharCode(...combined));
            } catch (error) {
                console.error('加密失败:', error);
                throw new Error('加密失败');
            }
        }
        
        // AES-256-GCM 解密函数
        async function decryptDataAES(encryptedBase64, password, method = 'aes-gcm') {
            try {
                const encoder = new TextEncoder();
                const decoder = new TextDecoder();
                
                // 从Base64解码
                const combined = Uint8Array.from(atob(encryptedBase64), c => c.charCodeAt(0));
                
                // 提取盐值、IV和加密数据
                const salt = combined.slice(0, 16);
                const iv = combined.slice(16, 28);
                const encryptedData = combined.slice(28);
                
                // 使用PBKDF2从密码派生密钥
                const passwordKey = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(password),
                    'PBKDF2',
                    false,
                    ['deriveBits', 'deriveKey']
                );
                
                // 派生AES-256密钥
                const key = await crypto.subtle.deriveKey(
                    {
                        name: 'PBKDF2',
                        salt: salt,
                        iterations: method === 'aes-gcm-ultra' ? 600000 : 100000,
                        hash: 'SHA-256'
                    },
                    passwordKey,
                    { name: 'AES-GCM', length: 256 },
                    false,
                    ['decrypt']
                );
                
                // 解密数据
                const decryptedData = await crypto.subtle.decrypt(
                    {
                        name: 'AES-GCM',
                        iv: iv,
                        tagLength: 128
                    },
                    key,
                    encryptedData
                );
                
                // 转换为JSON对象
                return JSON.parse(decoder.decode(decryptedData));
            } catch (error) {
                console.error('解密失败:', error);
                throw new Error('密码错误或数据损坏');
            }
        }

        // 确认导出
        document.getElementById('export-character-form')?.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const character = db.characters.find(c => c.id === currentChatId);
            if (!character) {
                showToast('角色不存在');
                return;
            }
            
            // 获取导出格式
            const format = document.querySelector('.export-format-btn[style*="rgb(255, 128, 171)"], .export-format-btn[style*="240, 248, 255"]')?.dataset.format || 'json';
            
            // 获取选中的世界书
            const selectedWorldBooks = [];
            document.querySelectorAll('.export-wb-checkbox:checked').forEach(checkbox => {
                const wbId = checkbox.dataset.wbId;
                const wb = db.worldBooks.find(w => w.id === wbId);
                if (wb) {
                    selectedWorldBooks.push(wb);
                }
            });
            
            // 获取NPC库和头像库选择
            const exportNpc = document.getElementById('export-npc-section').dataset.selected === 'yes';
            const exportAvatar = document.getElementById('export-avatar-section').dataset.selected === 'yes';
            
            // 获取加密设置
            const encryptionType = document.getElementById('export-encryption-type').value;
            const encryptionMethod = document.getElementById('export-encryption-method')?.value || 'aes-gcm';
            const decryptPassword = document.getElementById('export-decrypt-password').value;
            const customFakePersona = document.getElementById('custom-fake-persona').value;
            
            // 验证加密设置
            if (encryptionType !== 'none' && !decryptPassword) {
                showToast('请设置解密口令');
                return;
            }
            
            if (encryptionType === 'custom' && !customFakePersona) {
                showToast('请输入自定义假内容');
                return;
            }
            
            // 密码强度检查
            if (encryptionType !== 'none' && decryptPassword.length < 8) {
                if (!confirm('密码长度少于8位，安全性较低。是否继续？')) {
                    return;
                }
            }
            
            // 构建导出数据
            const exportData = {
                type: 'phone-character-card',
                version: '2.0', // 升级版本号
                encrypted: encryptionType !== 'none',
                encryptionType: encryptionType,
                encryptionMethod: encryptionMethod, // 新增：加密方法
                character: {
                    realName: character.realName,
                    remarkName: character.remarkName,
                    persona: character.persona,
                    avatar: character.avatar,
                    myName: character.myName,
                    myAvatar: character.myAvatar,
                    myPersona: character.myPersona,
                    greetings: character.greetings || []
                },
                worldBooks: selectedWorldBooks,
                npcLibrary: exportNpc ? (character.npcLibrary || []) : [],
                avatarLibrary: exportAvatar ? (character.avatarLibrary || []) : [],
                myAvatarLibrary: exportAvatar ? (character.myAvatarLibrary || []) : []
            };
            
            // 如果需要加密
            if (encryptionType !== 'none') {
                showToast('正在加密数据，请稍候...');
                
                try {
                    // 保存真实数据（加密）
                    const realData = {
                        persona: character.persona,
                        worldBooks: selectedWorldBooks,
                        npcLibrary: exportNpc ? (character.npcLibrary || []) : [],
                        avatarLibrary: exportAvatar ? (character.avatarLibrary || []) : [],
                        myAvatarLibrary: exportAvatar ? (character.myAvatarLibrary || []) : []
                    };
                    
                    // 使用选择的加密方法
                    exportData.encryptedData = await encryptDataAES(realData, decryptPassword, encryptionMethod);
                    
                    // 不再保存密码哈希，只有作者知道密码
                    // exportData.passwordHash = ''; // 移除密码哈希
                    
                    // 设置假数据（用户看到的）
                    if (encryptionType === 'blank') {
                        exportData.character.persona = '';
                        exportData.worldBooks = selectedWorldBooks.map(wb => ({
                            name: wb.name,
                            content: '',
                            group: wb.group,
                            position: wb.position
                        }));
                        exportData.npcLibrary = [];
                        exportData.avatarLibrary = [];
                        exportData.myAvatarLibrary = [];
                    } else if (encryptionType === 'fake') {
                        exportData.character.persona = '这是一个神秘的角色，具体信息需要解密后才能查看。';
                        exportData.worldBooks = selectedWorldBooks.map(wb => ({
                            name: wb.name,
                            content: '这是加密的世界书内容，需要解密后才能查看。',
                            group: wb.group,
                            position: wb.position
                        }));
                        exportData.npcLibrary = [];
                        exportData.avatarLibrary = [];
                        exportData.myAvatarLibrary = [];
                    } else if (encryptionType === 'custom') {
                        exportData.character.persona = customFakePersona;
                        exportData.worldBooks = selectedWorldBooks.map(wb => ({
                            name: wb.name,
                            content: '这是自定义的假世界书内容。',
                            group: wb.group,
                            position: wb.position
                        }));
                        exportData.npcLibrary = [];
                        exportData.avatarLibrary = [];
                        exportData.myAvatarLibrary = [];
                    }
                } catch (error) {
                    showToast('加密失败: ' + error.message);
                    return;
                }
            }
            
            // 导出文件
            const fileName = `${character.remarkName}_小手机角色卡_${Date.now()}`;
            
            if (format === 'json') {
                // 导出为JSON
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${fileName}.json`;
                a.click();
                URL.revokeObjectURL(url);
            } else {
                // 导出为PNG（将JSON数据嵌入PNG图片）
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // 创建一个带有角色头像的PNG
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    canvas.width = img.width || 512;
                    canvas.height = img.height || 512;
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    
                    // 将JSON数据嵌入PNG
                    canvas.toBlob(async (blob) => {
                        // 读取blob为ArrayBuffer
                        const arrayBuffer = await blob.arrayBuffer();
                        const uint8Array = new Uint8Array(arrayBuffer);
                        
                        // 将JSON数据转换为字节
                        const jsonStr = JSON.stringify(exportData);
                        const jsonBytes = new TextEncoder().encode(jsonStr);
                        
                        // 创建标记：使用特殊的分隔符
                        const separator = new TextEncoder().encode('<<<PHONE_CARD_DATA>>>');
                        
                        // 创建新的数组：PNG + 分隔符 + JSON数据
                        const newArray = new Uint8Array(uint8Array.length + separator.length + jsonBytes.length);
                        newArray.set(uint8Array, 0);
                        newArray.set(separator, uint8Array.length);
                        newArray.set(jsonBytes, uint8Array.length + separator.length);
                        
                        const newBlob = new Blob([newArray], { type: 'image/png' });
                        const url = URL.createObjectURL(newBlob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${fileName}.png`;
                        a.click();
                        URL.revokeObjectURL(url);
                        
                        showToast('角色卡导出成功');
                        document.getElementById('export-character-modal').classList.remove('visible');
                    }, 'image/png');
                };
                img.onerror = () => {
                    showToast('头像加载失败，改为导出JSON格式');
                    // 降级为JSON导出
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${fileName}.json`;
                    a.click();
                    URL.revokeObjectURL(url);
                    document.getElementById('export-character-modal').classList.remove('visible');
                };
                img.src = character.avatar || 'https://i.postimg.cc/KYr2qRCK/1.jpg';
            }
            
            if (format === 'json') {
                showToast('角色卡导出成功');
                document.getElementById('export-character-modal').classList.remove('visible');
            }
        });

        // 导入小手机角色卡
        document.getElementById('import-phone-character-input')?.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            try {
                let cardData;
                
                if (file.name.endsWith('.json')) {
                    // 读取JSON文件
                    const text = await file.text();
                    cardData = JSON.parse(text);
                } else if (file.name.endsWith('.png')) {
                    // 从PNG中提取JSON数据
                    const arrayBuffer = await file.arrayBuffer();
                    const uint8Array = new Uint8Array(arrayBuffer);
                    
                    // 查找分隔符
                    const separator = new TextEncoder().encode('<<<PHONE_CARD_DATA>>>');
                    let separatorIndex = -1;
                    
                    // 从后往前查找分隔符
                    for (let i = uint8Array.length - separator.length; i >= 0; i--) {
                        let match = true;
                        for (let j = 0; j < separator.length; j++) {
                            if (uint8Array[i + j] !== separator[j]) {
                                match = false;
                                break;
                            }
                        }
                        if (match) {
                            separatorIndex = i;
                            break;
                        }
                    }
                    
                    if (separatorIndex === -1) {
                        throw new Error('无法从PNG中提取角色卡数据，未找到数据分隔符');
                    }
                    
                    // 提取JSON数据
                    const jsonBytes = uint8Array.slice(separatorIndex + separator.length);
                    const decoder = new TextDecoder();
                    const jsonStr = decoder.decode(jsonBytes);
                    
                    try {
                        cardData = JSON.parse(jsonStr);
                    } catch (e) {
                        throw new Error('角色卡数据格式错误: ' + e.message);
                    }
                } else {
                    throw new Error('不支持的文件格式');
                }
                
                // 验证数据格式
                if (cardData.type !== 'phone-character-card') {
                    throw new Error('不是有效的小手机角色卡');
                }
                
                // 如果是加密的，先显示为加密状态
                if (cardData.encrypted) {
                    // 存储待解密的数据
                    window.pendingEncryptedCard = cardData;
                    
                    // 先导入假数据
                    await importPhoneCharacter(cardData, true);
                    
                    showToast('已导入加密角色卡，可在角色人设处解密');
                } else {
                    // 直接导入
                    await importPhoneCharacter(cardData, false);
                    showToast('角色卡导入成功');
                }
                
                document.getElementById('import-phone-character-modal').classList.remove('visible');
                e.target.value = '';
                
            } catch (error) {
                console.error('导入失败:', error);
                showToast(`导入失败: ${error.message}`);
            }
        });

        // 导入角色卡函数
        async function importPhoneCharacter(cardData, isEncrypted) {
            const character = cardData.character;
            
            // 创建新角色
            const newChar = {
                id: `char_${Date.now()}`,
                realName: character.realName,
                remarkName: character.remarkName,
                persona: character.persona,
                avatar: character.avatar,
                myName: character.myName,
                myAvatar: character.myAvatar,
                myPersona: character.myPersona,
                greetings: character.greetings || [],
                history: [],
                worldBookIds: [],
                npcLibrary: cardData.npcLibrary || [],
                avatarLibrary: cardData.avatarLibrary || [],
                myAvatarLibrary: cardData.myAvatarLibrary || [],
                themeColor: 'white_pink',
                isPinned: false,
                status: '在线',
                unreadCount: 0,
                isEncrypted: isEncrypted,
                encryptedData: isEncrypted ? cardData.encryptedData : null,
                passwordHash: isEncrypted ? cardData.passwordHash : null,
                encryptionType: isEncrypted ? cardData.encryptionType : null
            };
            
            // 导入世界书（加密的也要导入，但内容是假的，真实内容在encryptedData中）
            if (cardData.worldBooks && cardData.worldBooks.length > 0) {
                for (const wb of cardData.worldBooks) {
                    const newWb = {
                        id: `wb_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                        name: wb.name,
                        content: wb.content,  // 如果是加密的，这里是假内容
                        group: wb.group || '',
                        isGlobal: false,
                        position: wb.position || 'before',
                        // 如果是加密的角色卡，标记世界书也是加密的
                        isEncrypted: isEncrypted,
                        encryptedContent: isEncrypted ? wb.encryptedContent : null
                    };
                    db.worldBooks.push(newWb);
                    newChar.worldBookIds.push(newWb.id);
                }
            }
            
            // 添加角色到数据库
            db.characters.push(newChar);
            await saveData();
            renderChatList();
        }
        
        // 辅助函数：获取世界书的真实内容（AI使用）
        function getWorldBookRealContent(worldBook) {
            if (!worldBook) return '';
            
            // 如果世界书是加密的，返回解密后的真实内容供AI使用
            if (worldBook.isEncrypted && worldBook.encryptedContent) {
                try {
                    return decodeURIComponent(atob(worldBook.encryptedContent));
                } catch (e) {
                    console.error('世界书解密失败:', e);
                    return worldBook.content;  // 解密失败则返回假内容
                }
            }
            
            // 如果不是加密的，直接返回内容
            return worldBook.content;
        }

        // 取消导入
        document.getElementById('cancel-import-phone-character-btn')?.addEventListener('click', () => {
            document.getElementById('import-phone-character-modal').classList.remove('visible');
        });

        // 在角色人设区域添加解密按钮（需要在loadSettingsToSidebar函数中添加）
        // 这部分需要修改现有的loadSettingsToSidebar函数，在角色人设textarea上方添加解密按钮

        // 解密功能
        let currentDecryptCharacterId = null;

        function showDecryptButton(characterId) {
            const character = db.characters.find(c => c.id === characterId);
            if (!character || !character.isEncrypted) return;
            
            const personaTextarea = document.getElementById('setting-char-persona');
            if (!personaTextarea) return;
            
            // 检查是否已经有解密按钮
            let decryptBtn = document.getElementById('decrypt-persona-btn');
            if (!decryptBtn) {
                decryptBtn = document.createElement('button');
                decryptBtn.id = 'decrypt-persona-btn';
                decryptBtn.type = 'button';
                decryptBtn.className = 'btn btn-primary';
                decryptBtn.textContent = '解密角色卡';
                decryptBtn.style.width = '100%';
                decryptBtn.style.marginBottom = '10px';
                
                decryptBtn.addEventListener('click', () => {
                    currentDecryptCharacterId = characterId;
                    document.getElementById('decrypt-character-modal').classList.add('visible');
                });
                
                personaTextarea.parentNode.insertBefore(decryptBtn, personaTextarea);
            }
        }

        // 确认解密
        document.getElementById('confirm-decrypt-btn')?.addEventListener('click', async () => {
            const password = document.getElementById('decrypt-password-input').value;
            if (!password) {
                showToast('请输入解密口令');
                return;
            }
            
            const character = db.characters.find(c => c.id === currentDecryptCharacterId);
            if (!character || !character.isEncrypted) {
                showToast('角色不存在或未加密');
                return;
            }
            
            try {
                let realData;
                
                // 检测加密版本
                if (character.version === '2.0' || character.encryptionMethod) {
                    // 新版AES加密
                    showToast('正在解密，请稍候...');
                    const method = character.encryptionMethod || 'aes-gcm';
                    realData = await decryptDataAES(character.encryptedData, password, method);
                } else {
                    // 旧版Base64加密（兼容性）
                    const correctPasswordHash = character.passwordHash;
                    const inputPasswordHash = btoa(encodeURIComponent(password));
                    
                    if (inputPasswordHash !== correctPasswordHash) {
                        showToast('解密口令错误');
                        return;
                    }
                    
                    const decryptedStr = decodeURIComponent(atob(character.encryptedData));
                    realData = JSON.parse(decryptedStr);
                }
                
                // 恢复真实数据
                character.persona = realData.persona;
                character.isEncrypted = false;
                character.encryptedData = null;
                character.passwordHash = null;
                character.encryptionType = null;
                character.encryptionMethod = null;
                character.version = null;
                
                // 删除旧的加密世界书
                if (character.worldBookIds && character.worldBookIds.length > 0) {
                    const oldWorldBookIds = [...character.worldBookIds];
                    oldWorldBookIds.forEach(wbId => {
                        const wbIndex = db.worldBooks.findIndex(wb => wb.id === wbId);
                        if (wbIndex !== -1) {
                            db.worldBooks.splice(wbIndex, 1);
                        }
                    });
                    character.worldBookIds = [];
                }
                
                // 恢复世界书（真实内容）
                if (realData.worldBooks && realData.worldBooks.length > 0) {
                    for (let i = 0; i < realData.worldBooks.length; i++) {
                        const wb = realData.worldBooks[i];
                        // 添加延迟以确保ID唯一
                        await new Promise(resolve => setTimeout(resolve, 10));
                        const newWb = {
                            id: `wb_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                            name: wb.name,
                            content: wb.content,
                            group: wb.group || '',
                            isGlobal: false,
                            position: wb.position || 'before',
                            isEncrypted: false,
                            encryptedContent: null
                        };
                        db.worldBooks.push(newWb);
                        character.worldBookIds.push(newWb.id);
                    }
                }
                
                // 恢复NPC库和头像库
                if (realData.npcLibrary) character.npcLibrary = realData.npcLibrary;
                if (realData.avatarLibrary) character.avatarLibrary = realData.avatarLibrary;
                if (realData.myAvatarLibrary) character.myAvatarLibrary = realData.myAvatarLibrary;
                
                await saveData();
                
                // 刷新设置界面
                loadSettingsToSidebar();
                
                // 移除解密按钮
                const decryptBtn = document.getElementById('decrypt-persona-btn');
                if (decryptBtn) decryptBtn.remove();
                
                showToast('解密成功！');
                document.getElementById('decrypt-character-modal').classList.remove('visible');
                document.getElementById('decrypt-password-input').value = '';
                
            } catch (error) {
                console.error('解密失败:', error);
                showToast('解密失败：密码错误或数据损坏');
            }
        });

        // 取消解密
        document.getElementById('cancel-decrypt-btn')?.addEventListener('click', () => {
            document.getElementById('decrypt-character-modal').classList.remove('visible');
            document.getElementById('decrypt-password-input').value = '';
        });

        // 将showDecryptButton函数暴露给loadSettingsToSidebar使用
        window.showDecryptButton = showDecryptButton;

        console.log('✅ 小手机加密角色卡功能已加载');
    });

